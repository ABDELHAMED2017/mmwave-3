diff -Naru a/bindings/callbacks_list.py b/bindings/callbacks_list.py
--- a/bindings/callbacks_list.py	2017-10-05 11:46:52.034493329 +0200
+++ b/bindings/callbacks_list.py	2017-10-05 11:47:22.290601698 +0200
@@ -3,11 +3,21 @@
     ['void', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<const ns3::Packet>', 'unsigned short', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<const ns3::Packet>', 'unsigned short', 'const ns3::Address &', 'const ns3::Address &', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<ns3::Socket>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['bool', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<ns3::Socket>', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<const ns3::Packet>', 'unsigned short', 'const ns3::Address &', 'const ns3::Address &', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::Ptr<ns3::NetDevice>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'ns3::Ptr<const ns3::MobilityModel>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['bool', 'ns3::Ptr<ns3::Packet>', 'const ns3::Address &', 'const ns3::Address &', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::Ptr<const ns3::Packet>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::Ptr<ns3::Packet>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::EpcUeNas::State', 'ns3::EpcUeNas::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'unsigned int', 'unsigned long', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'const ns3::SpectrumValue &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'unsigned char', 'unsigned short', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<const ns3::MobilityModel>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > >', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned short', 'ns3::Ptr<ns3::SpectrumValue>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::DlInfoListElement_s', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
@@ -16,26 +26,24 @@
     ['void', 'ns3::PhyReceptionStatParameters', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned short', 'unsigned short', 'double', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'ns3::PhyTransmissionStatParameters', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'unsigned short', 'unsigned short', 'double', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'unsigned short', 'unsigned short', 'ns3::LteUePhy::State', 'ns3::LteUePhy::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'unsigned short', 'unsigned short', 'double', 'double', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'unsigned short', 'unsigned short', 'double', 'double', 'bool', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'ns3::Ptr<ns3::Socket>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['bool', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'ns3::Ptr<ns3::Socket>', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['bool', 'ns3::Ptr<ns3::Packet>', 'const ns3::Address &', 'const ns3::Address &', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'ns3::EpcUeNas::State', 'ns3::EpcUeNas::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'const ns3::SpectrumValue &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned short', 'unsigned char', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned long', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Time', 'ns3::Time', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'const char *', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'bool', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::UeManager::State', 'ns3::UeManager::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::LteRrcSap::MeasurementReport', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'ns3::DlSchedulingCallbackInfo', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
-    ['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned long', 'unsigned short', 'long double', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'double', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'ns3::LteUePhy::State', 'ns3::LteUePhy::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'double', 'double', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
+    ['void', 'unsigned short', 'unsigned short', 'double', 'double', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'unsigned short', 'ns3::LteUeRrc::State', 'ns3::LteUeRrc::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
     ['void', 'unsigned long', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
 ]
diff -Naru a/bindings/modulegen_customizations.py b/bindings/modulegen_customizations.py
--- a/bindings/modulegen_customizations.py	2017-10-05 11:46:52.038493344 +0200
+++ b/bindings/modulegen_customizations.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-import os
-
-def post_register_types(root_module):
-    enabled_features = os.environ['NS3_ENABLED_FEATURES'].split(',')
-
-    if 'EmuFdNetDevice' not in enabled_features:
-        if 'ns3::EmuEpcHelper'in root_module:
-            root_module.classes.remove(root_module['ns3::EmuEpcHelper'])
-
diff -Naru a/bindings/modulegen__gcc_ILP32.py b/bindings/modulegen__gcc_ILP32.py
--- a/bindings/modulegen__gcc_ILP32.py	2017-10-05 11:46:52.038493344 +0200
+++ b/bindings/modulegen__gcc_ILP32.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,24858 +0,0 @@
-from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers
-
-
-import pybindgen.settings
-import warnings
-
-class ErrorHandler(pybindgen.settings.ErrorHandler):
-    def handle_error(self, wrapper, exception, traceback_):
-        warnings.warn("exception %r in wrapper %s" % (exception, wrapper))
-        return True
-pybindgen.settings.error_handler = ErrorHandler()
-
-
-import sys
-
-def module_init():
-    root_module = Module('ns.lte', cpp_namespace='::ns3')
-    return root_module
-
-def register_types(module):
-    root_module = module.get_root()
-    
-    ## log.h (module 'core'): ns3::LogLevel [enumeration]
-    module.add_enum('LogLevel', ['LOG_NONE', 'LOG_ERROR', 'LOG_LEVEL_ERROR', 'LOG_WARN', 'LOG_LEVEL_WARN', 'LOG_DEBUG', 'LOG_LEVEL_DEBUG', 'LOG_INFO', 'LOG_LEVEL_INFO', 'LOG_FUNCTION', 'LOG_LEVEL_FUNCTION', 'LOG_LOGIC', 'LOG_LEVEL_LOGIC', 'LOG_ALL', 'LOG_LEVEL_ALL', 'LOG_PREFIX_FUNC', 'LOG_PREFIX_TIME', 'LOG_PREFIX_NODE', 'LOG_PREFIX_LEVEL', 'LOG_PREFIX_ALL'], import_from_module='ns.core')
-    ## ff-mac-common.h (module 'lte'): ns3::Result_e [enumeration]
-    module.add_enum('Result_e', ['SUCCESS', 'FAILURE'])
-    ## ff-mac-common.h (module 'lte'): ns3::SetupRelease_e [enumeration]
-    module.add_enum('SetupRelease_e', ['setup', 'release'])
-    ## ff-mac-common.h (module 'lte'): ns3::CeBitmap_e [enumeration]
-    module.add_enum('CeBitmap_e', ['TA', 'DRX', 'CR'])
-    ## ff-mac-common.h (module 'lte'): ns3::NormalExtended_e [enumeration]
-    module.add_enum('NormalExtended_e', ['normal', 'extended'])
-    ## address.h (module 'network'): ns3::Address [class]
-    module.add_class('Address', import_from_module='ns.network')
-    ## address.h (module 'network'): ns3::Address::MaxSize_e [enumeration]
-    module.add_enum('MaxSize_e', ['MAX_SIZE'], outer_class=root_module['ns3::Address'], import_from_module='ns.network')
-    ## eps-bearer.h (module 'lte'): ns3::AllocationRetentionPriority [struct]
-    module.add_class('AllocationRetentionPriority')
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList [class]
-    module.add_class('AttributeConstructionList', import_from_module='ns.core')
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item [struct]
-    module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])
-    ## spectrum-model.h (module 'spectrum'): ns3::BandInfo [struct]
-    module.add_class('BandInfo', import_from_module='ns.spectrum')
-    ## buffer.h (module 'network'): ns3::Buffer [class]
-    module.add_class('Buffer', import_from_module='ns.network')
-    ## buffer.h (module 'network'): ns3::Buffer::Iterator [class]
-    module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::Buffer'])
-    ## lte-common.h (module 'lte'): ns3::BufferSizeLevelBsr [class]
-    module.add_class('BufferSizeLevelBsr')
-    ## ff-mac-common.h (module 'lte'): ns3::BuildBroadcastListElement_s [struct]
-    module.add_class('BuildBroadcastListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::BuildBroadcastListElement_s::Type_e [enumeration]
-    module.add_enum('Type_e', ['BCCH', 'PCCH'], outer_class=root_module['ns3::BuildBroadcastListElement_s'])
-    ## ff-mac-common.h (module 'lte'): ns3::BuildDataListElement_s [struct]
-    module.add_class('BuildDataListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::BuildRarListElement_s [struct]
-    module.add_class('BuildRarListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::BwPart_s [struct]
-    module.add_class('BwPart_s')
-    ## packet.h (module 'network'): ns3::ByteTagIterator [class]
-    module.add_class('ByteTagIterator', import_from_module='ns.network')
-    ## packet.h (module 'network'): ns3::ByteTagIterator::Item [class]
-    module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagIterator'])
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList [class]
-    module.add_class('ByteTagList', import_from_module='ns.network')
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator [class]
-    module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList'])
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item [struct]
-    module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList::Iterator'])
-    ## callback.h (module 'core'): ns3::CallbackBase [class]
-    module.add_class('CallbackBase', import_from_module='ns.core')
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t [struct]
-    module.add_class('CqasFlowPerf_t')
-    ## ff-mac-common.h (module 'lte'): ns3::CqiConfig_s [struct]
-    module.add_class('CqiConfig_s')
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s [struct]
-    module.add_class('CqiListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::CqiType_e [enumeration]
-    module.add_enum('CqiType_e', ['P10', 'P11', 'P20', 'P21', 'A12', 'A22', 'A20', 'A30', 'A31'], outer_class=root_module['ns3::CqiListElement_s'])
-    ## data-output-interface.h (module 'stats'): ns3::DataOutputCallback [class]
-    module.add_class('DataOutputCallback', allow_subclassing=True, import_from_module='ns.stats')
-    ## data-rate.h (module 'network'): ns3::DataRate [class]
-    module.add_class('DataRate', import_from_module='ns.network')
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeAccessor> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::AttributeAccessor'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeChecker> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::AttributeChecker'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeValue> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::AttributeValue'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::CallbackImplBase> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::CallbackImplBase'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::EpcTft> [struct]
-    module.add_class('DefaultDeleter', template_parameters=['ns3::EpcTft'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::EventImpl> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::EventImpl'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Hash::Implementation> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::Hash::Implementation'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteChunkProcessor> [struct]
-    module.add_class('DefaultDeleter', template_parameters=['ns3::LteChunkProcessor'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteControlMessage> [struct]
-    module.add_class('DefaultDeleter', template_parameters=['ns3::LteControlMessage'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteHarqPhy> [struct]
-    module.add_class('DefaultDeleter', template_parameters=['ns3::LteHarqPhy'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::NixVector> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::NixVector'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Packet> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::Packet'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumModel> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::SpectrumModel'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumValue> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::SpectrumValue'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::TraceSourceAccessor> [struct]
-    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::TraceSourceAccessor'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::VendorSpecificValue> [struct]
-    module.add_class('DefaultDeleter', template_parameters=['ns3::VendorSpecificValue'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::X2CellInfo> [struct]
-    module.add_class('DefaultDeleter', template_parameters=['ns3::X2CellInfo'])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::X2IfaceInfo> [struct]
-    module.add_class('DefaultDeleter', template_parameters=['ns3::X2IfaceInfo'])
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s [struct]
-    module.add_class('DlDciListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::Format_e [enumeration]
-    module.add_enum('Format_e', ['ONE', 'ONE_A', 'ONE_B', 'ONE_C', 'ONE_D', 'TWO', 'TWO_A', 'TWO_B'], outer_class=root_module['ns3::DlDciListElement_s'])
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::VrbFormat_e [enumeration]
-    module.add_enum('VrbFormat_e', ['VRB_DISTRIBUTED', 'VRB_LOCALIZED'], outer_class=root_module['ns3::DlDciListElement_s'])
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::Ngap_e [enumeration]
-    module.add_enum('Ngap_e', ['GAP1', 'GAP2'], outer_class=root_module['ns3::DlDciListElement_s'])
-    ## ff-mac-common.h (module 'lte'): ns3::DlInfoListElement_s [struct]
-    module.add_class('DlInfoListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::DlInfoListElement_s::HarqStatus_e [enumeration]
-    module.add_enum('HarqStatus_e', ['ACK', 'NACK', 'DTX'], outer_class=root_module['ns3::DlInfoListElement_s'])
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo [struct]
-    module.add_class('DlSchedulingCallbackInfo')
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s [struct]
-    module.add_class('DrxConfig_s')
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider [class]
-    module.add_class('EpcEnbS1SapProvider', allow_subclassing=True)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::BearerToBeSwitched [struct]
-    module.add_class('BearerToBeSwitched', outer_class=root_module['ns3::EpcEnbS1SapProvider'])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters [struct]
-    module.add_class('PathSwitchRequestParameters', outer_class=root_module['ns3::EpcEnbS1SapProvider'])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser [class]
-    module.add_class('EpcEnbS1SapUser', allow_subclassing=True)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters [struct]
-    module.add_class('DataRadioBearerSetupRequestParameters', outer_class=root_module['ns3::EpcEnbS1SapUser'])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters [struct]
-    module.add_class('PathSwitchRequestAcknowledgeParameters', outer_class=root_module['ns3::EpcEnbS1SapUser'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap [class]
-    module.add_class('EpcS11Sap')
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Fteid [struct]
-    module.add_class('Fteid', outer_class=root_module['ns3::EpcS11Sap'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::GtpcMessage [struct]
-    module.add_class('GtpcMessage', outer_class=root_module['ns3::EpcS11Sap'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Uli [struct]
-    module.add_class('Uli', outer_class=root_module['ns3::EpcS11Sap'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme [class]
-    module.add_class('EpcS11SapMme', parent=root_module['ns3::EpcS11Sap'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextCreated [struct]
-    module.add_class('BearerContextCreated', outer_class=root_module['ns3::EpcS11SapMme'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextRemoved [struct]
-    module.add_class('BearerContextRemoved', outer_class=root_module['ns3::EpcS11SapMme'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::CreateSessionResponseMessage [struct]
-    module.add_class('CreateSessionResponseMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapMme'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::DeleteBearerRequestMessage [struct]
-    module.add_class('DeleteBearerRequestMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapMme'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::ModifyBearerResponseMessage [struct]
-    module.add_class('ModifyBearerResponseMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapMme'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::ModifyBearerResponseMessage::Cause [enumeration]
-    module.add_enum('Cause', ['REQUEST_ACCEPTED', 'REQUEST_ACCEPTED_PARTIALLY', 'REQUEST_REJECTED', 'CONTEXT_NOT_FOUND'], outer_class=root_module['ns3::EpcS11SapMme::ModifyBearerResponseMessage'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw [class]
-    module.add_class('EpcS11SapSgw', parent=root_module['ns3::EpcS11Sap'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw [struct]
-    module.add_class('BearerContextRemovedSgwPgw', outer_class=root_module['ns3::EpcS11SapSgw'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeCreated [struct]
-    module.add_class('BearerContextToBeCreated', outer_class=root_module['ns3::EpcS11SapSgw'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeRemoved [struct]
-    module.add_class('BearerContextToBeRemoved', outer_class=root_module['ns3::EpcS11SapSgw'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::CreateSessionRequestMessage [struct]
-    module.add_class('CreateSessionRequestMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapSgw'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerCommandMessage [struct]
-    module.add_class('DeleteBearerCommandMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapSgw'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerResponseMessage [struct]
-    module.add_class('DeleteBearerResponseMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapSgw'])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::ModifyBearerRequestMessage [struct]
-    module.add_class('ModifyBearerRequestMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapSgw'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap [class]
-    module.add_class('EpcS1apSap')
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb [class]
-    module.add_class('EpcS1apSapEnb', parent=root_module['ns3::EpcS1apSap'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem [struct]
-    module.add_class('ErabSwitchedInUplinkItem', outer_class=root_module['ns3::EpcS1apSapEnb'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem [struct]
-    module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcS1apSapEnb'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme [class]
-    module.add_class('EpcS1apSapMme', parent=root_module['ns3::EpcS1apSap'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem [struct]
-    module.add_class('ErabSetupItem', outer_class=root_module['ns3::EpcS1apSapMme'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem [struct]
-    module.add_class('ErabSwitchedInDownlinkItem', outer_class=root_module['ns3::EpcS1apSapMme'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication [struct]
-    module.add_class('ErabToBeReleasedIndication', outer_class=root_module['ns3::EpcS1apSapMme'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap [class]
-    module.add_class('EpcX2Sap')
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem [enumeration]
-    module.add_enum('UlInterferenceOverloadIndicationItem', ['HighInterference', 'MediumInterference', 'LowInterference'], outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::LoadIndicator [enumeration]
-    module.add_enum('LoadIndicator', ['LowLoad', 'MediumLoad', 'HighLoad', 'Overload'], outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::IdCause [enumeration]
-    module.add_enum('IdCause', ['HandoverDesirableForRadioReason', 'TimeCriticalHandover'], outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellInformationItem [struct]
-    module.add_class('CellInformationItem', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem [struct]
-    module.add_class('CellMeasurementResultItem', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CompositeAvailCapacity [struct]
-    module.add_class('CompositeAvailCapacity', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabAdmittedItem [struct]
-    module.add_class('ErabAdmittedItem', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabNotAdmittedItem [struct]
-    module.add_class('ErabNotAdmittedItem', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem [struct]
-    module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem [struct]
-    module.add_class('ErabsSubjectToStatusTransferItem', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams [struct]
-    module.add_class('HandoverPreparationFailureParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams [struct]
-    module.add_class('HandoverRequestAckParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams [struct]
-    module.add_class('HandoverRequestParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::LoadInformationParams [struct]
-    module.add_class('LoadInformationParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand [struct]
-    module.add_class('RelativeNarrowbandTxBand', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams [struct]
-    module.add_class('ResourceStatusUpdateParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams [struct]
-    module.add_class('SnStatusTransferParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams [struct]
-    module.add_class('UeContextReleaseParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams [struct]
-    module.add_class('UeDataParams', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem [struct]
-    module.add_class('UlHighInterferenceInformationItem', outer_class=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapProvider [class]
-    module.add_class('EpcX2SapProvider', parent=root_module['ns3::EpcX2Sap'])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapUser [class]
-    module.add_class('EpcX2SapUser', parent=root_module['ns3::EpcX2Sap'])
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer [struct]
-    module.add_class('EpsBearer')
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::Qci [enumeration]
-    module.add_enum('Qci', ['GBR_CONV_VOICE', 'GBR_CONV_VIDEO', 'GBR_GAMING', 'GBR_NON_CONV_VIDEO', 'NGBR_IMS', 'NGBR_VIDEO_TCP_OPERATOR', 'NGBR_VOICE_VIDEO_GAMING', 'NGBR_VIDEO_TCP_PREMIUM', 'NGBR_VIDEO_TCP_DEFAULT'], outer_class=root_module['ns3::EpsBearer'])
-    ## lte-common.h (module 'lte'): ns3::EutranMeasurementMapping [class]
-    module.add_class('EutranMeasurementMapping')
-    ## event-id.h (module 'core'): ns3::EventId [class]
-    module.add_class('EventId', import_from_module='ns.core')
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider [class]
-    module.add_class('FfMacCschedSapProvider', allow_subclassing=True)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters [struct]
-    module.add_class('CschedCellConfigReqParameters', outer_class=root_module['ns3::FfMacCschedSapProvider'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::HoppingMode_e [enumeration]
-    module.add_enum('HoppingMode_e', ['inter', 'interintra'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::PhichResource_e [enumeration]
-    module.add_enum('PhichResource_e', ['PHICH_R_ONE_SIXTH', 'PHICH_R_HALF', 'PHICH_R_ONE', 'PHICH_R_TWO'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::DuplexMode_e [enumeration]
-    module.add_enum('DuplexMode_e', ['DM_TDD', 'DM_FDD'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::Enable64Qam_e [enumeration]
-    module.add_enum('Enable64Qam_e', ['MOD_16QAM', 'MOD_64QAM'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters [struct]
-    module.add_class('CschedLcConfigReqParameters', outer_class=root_module['ns3::FfMacCschedSapProvider'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters [struct]
-    module.add_class('CschedLcReleaseReqParameters', outer_class=root_module['ns3::FfMacCschedSapProvider'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters [struct]
-    module.add_class('CschedUeConfigReqParameters', outer_class=root_module['ns3::FfMacCschedSapProvider'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::MeasGapConfigPattern_e [enumeration]
-    module.add_enum('MeasGapConfigPattern_e', ['MGP_GP1', 'MGP_GP2', 'OFF'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::OpenClosedLoop_e [enumeration]
-    module.add_enum('OpenClosedLoop_e', ['noneloop', 'openloop', 'closedloop'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::RepMode_e [enumeration]
-    module.add_enum('RepMode_e', ['rm12', 'rm20', 'rm22', 'rm30', 'rm31', 'nonemode'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::FeedbackMode_e [enumeration]
-    module.add_enum('FeedbackMode_e', ['bundling', 'multiplexing'], outer_class=root_module['ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters [struct]
-    module.add_class('CschedUeReleaseReqParameters', outer_class=root_module['ns3::FfMacCschedSapProvider'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser [class]
-    module.add_class('FfMacCschedSapUser', allow_subclassing=True)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters [struct]
-    module.add_class('CschedCellConfigCnfParameters', outer_class=root_module['ns3::FfMacCschedSapUser'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters [struct]
-    module.add_class('CschedCellConfigUpdateIndParameters', outer_class=root_module['ns3::FfMacCschedSapUser'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters [struct]
-    module.add_class('CschedLcConfigCnfParameters', outer_class=root_module['ns3::FfMacCschedSapUser'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters [struct]
-    module.add_class('CschedLcReleaseCnfParameters', outer_class=root_module['ns3::FfMacCschedSapUser'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters [struct]
-    module.add_class('CschedUeConfigCnfParameters', outer_class=root_module['ns3::FfMacCschedSapUser'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters [struct]
-    module.add_class('CschedUeConfigUpdateIndParameters', outer_class=root_module['ns3::FfMacCschedSapUser'])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters [struct]
-    module.add_class('CschedUeReleaseCnfParameters', outer_class=root_module['ns3::FfMacCschedSapUser'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider [class]
-    module.add_class('FfMacSchedSapProvider', allow_subclassing=True)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters [struct]
-    module.add_class('SchedDlCqiInfoReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters [struct]
-    module.add_class('SchedDlMacBufferReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters [struct]
-    module.add_class('SchedDlPagingBufferReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters [struct]
-    module.add_class('SchedDlRachInfoReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters [struct]
-    module.add_class('SchedDlRlcBufferReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters [struct]
-    module.add_class('SchedDlTriggerReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters [struct]
-    module.add_class('SchedUlCqiInfoReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters [struct]
-    module.add_class('SchedUlMacCtrlInfoReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters [struct]
-    module.add_class('SchedUlNoiseInterferenceReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters [struct]
-    module.add_class('SchedUlSrInfoReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters [struct]
-    module.add_class('SchedUlTriggerReqParameters', outer_class=root_module['ns3::FfMacSchedSapProvider'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser [class]
-    module.add_class('FfMacSchedSapUser', allow_subclassing=True)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters [struct]
-    module.add_class('SchedDlConfigIndParameters', outer_class=root_module['ns3::FfMacSchedSapUser'])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedUlConfigIndParameters [struct]
-    module.add_class('SchedUlConfigIndParameters', outer_class=root_module['ns3::FfMacSchedSapUser'])
-    ## eps-bearer.h (module 'lte'): ns3::GbrQosInformation [struct]
-    module.add_class('GbrQosInformation')
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoElement_t [struct]
-    module.add_class('HarqProcessInfoElement_t')
-    ## hash.h (module 'core'): ns3::Hasher [class]
-    module.add_class('Hasher', import_from_module='ns.core')
-    ## ff-mac-common.h (module 'lte'): ns3::HigherLayerSelected_s [struct]
-    module.add_class('HigherLayerSelected_s')
-    ## lte-common.h (module 'lte'): ns3::ImsiLcidPair_t [struct]
-    module.add_class('ImsiLcidPair_t')
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress [class]
-    module.add_class('Inet6SocketAddress', import_from_module='ns.network')
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress [class]
-    root_module['ns3::Inet6SocketAddress'].implicitly_converts_to(root_module['ns3::Address'])
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress [class]
-    module.add_class('InetSocketAddress', import_from_module='ns.network')
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress [class]
-    root_module['ns3::InetSocketAddress'].implicitly_converts_to(root_module['ns3::Address'])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address [class]
-    module.add_class('Ipv4Address', import_from_module='ns.network')
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address [class]
-    root_module['ns3::Ipv4Address'].implicitly_converts_to(root_module['ns3::Address'])
-    ## ipv4-address-helper.h (module 'internet'): ns3::Ipv4AddressHelper [class]
-    module.add_class('Ipv4AddressHelper', import_from_module='ns.internet')
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4InterfaceAddress [class]
-    module.add_class('Ipv4InterfaceAddress', import_from_module='ns.internet')
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e [enumeration]
-    module.add_enum('InterfaceAddressScope_e', ['HOST', 'LINK', 'GLOBAL'], outer_class=root_module['ns3::Ipv4InterfaceAddress'], import_from_module='ns.internet')
-    ## ipv4-interface-container.h (module 'internet'): ns3::Ipv4InterfaceContainer [class]
-    module.add_class('Ipv4InterfaceContainer', import_from_module='ns.internet')
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Mask [class]
-    module.add_class('Ipv4Mask', import_from_module='ns.network')
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address [class]
-    module.add_class('Ipv6Address', import_from_module='ns.network')
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address [class]
-    root_module['ns3::Ipv6Address'].implicitly_converts_to(root_module['ns3::Address'])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix [class]
-    module.add_class('Ipv6Prefix', import_from_module='ns.network')
-    ## log.h (module 'core'): ns3::LogComponent [class]
-    module.add_class('LogComponent', import_from_module='ns.core')
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s [struct]
-    module.add_class('LogicalChannelConfigListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::Direction_e [enumeration]
-    module.add_enum('Direction_e', ['DIR_UL', 'DIR_DL', 'DIR_BOTH'], outer_class=root_module['ns3::LogicalChannelConfigListElement_s'])
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::QosBearerType_e [enumeration]
-    module.add_enum('QosBearerType_e', ['QBT_NON_GBR', 'QBT_GBR'], outer_class=root_module['ns3::LogicalChannelConfigListElement_s'])
-    ## lte-anr-sap.h (module 'lte'): ns3::LteAnrSapProvider [class]
-    module.add_class('LteAnrSapProvider', allow_subclassing=True)
-    ## lte-anr-sap.h (module 'lte'): ns3::LteAnrSapUser [class]
-    module.add_class('LteAnrSapUser', allow_subclassing=True)
-    ## lte-as-sap.h (module 'lte'): ns3::LteAsSapProvider [class]
-    module.add_class('LteAsSapProvider', allow_subclassing=True)
-    ## lte-as-sap.h (module 'lte'): ns3::LteAsSapUser [class]
-    module.add_class('LteAsSapUser', allow_subclassing=True)
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapProvider [class]
-    module.add_class('LteCcmMacSapProvider', allow_subclassing=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider [class]
-    module.add_class('LteCcmRrcSapProvider', allow_subclassing=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig [struct]
-    module.add_class('LcsConfig', outer_class=root_module['ns3::LteCcmRrcSapProvider'])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapUser [class]
-    module.add_class('LteCcmRrcSapUser', allow_subclassing=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider [class]
-    module.add_class('LteEnbCmacSapProvider', allow_subclassing=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue [struct]
-    module.add_class('AllocateNcRaPreambleReturnValue', outer_class=root_module['ns3::LteEnbCmacSapProvider'])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo [struct]
-    module.add_class('LcInfo', outer_class=root_module['ns3::LteEnbCmacSapProvider'])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::RachConfig [struct]
-    module.add_class('RachConfig', outer_class=root_module['ns3::LteEnbCmacSapProvider'])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::UeConfig [struct]
-    module.add_class('UeConfig', outer_class=root_module['ns3::LteEnbCmacSapProvider'])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser [class]
-    module.add_class('LteEnbCmacSapUser', allow_subclassing=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser::UeConfig [struct]
-    module.add_class('UeConfig', outer_class=root_module['ns3::LteEnbCmacSapUser'])
-    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapProvider [class]
-    module.add_class('LteEnbCphySapProvider', allow_subclassing=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser [class]
-    module.add_class('LteEnbCphySapUser')
-    ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapProvider [class]
-    module.add_class('LteEnbPhySapProvider', allow_subclassing=True)
-    ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapUser [class]
-    module.add_class('LteEnbPhySapUser', allow_subclassing=True)
-    ## lte-common.h (module 'lte'): ns3::LteFfConverter [class]
-    module.add_class('LteFfConverter')
-    ## lte-ffr-rrc-sap.h (module 'lte'): ns3::LteFfrRrcSapProvider [class]
-    module.add_class('LteFfrRrcSapProvider', allow_subclassing=True)
-    ## lte-ffr-rrc-sap.h (module 'lte'): ns3::LteFfrRrcSapUser [class]
-    module.add_class('LteFfrRrcSapUser', allow_subclassing=True)
-    ## lte-ffr-sap.h (module 'lte'): ns3::LteFfrSapProvider [class]
-    module.add_class('LteFfrSapProvider', allow_subclassing=True)
-    ## lte-ffr-sap.h (module 'lte'): ns3::LteFfrSapUser [class]
-    module.add_class('LteFfrSapUser')
-    ## lte-common.h (module 'lte'): ns3::LteFlowId_t [struct]
-    module.add_class('LteFlowId_t')
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::LteGlobalPathlossDatabase [class]
-    module.add_class('LteGlobalPathlossDatabase', allow_subclassing=True)
-    ## lte-handover-management-sap.h (module 'lte'): ns3::LteHandoverManagementSapProvider [class]
-    module.add_class('LteHandoverManagementSapProvider', allow_subclassing=True)
-    ## lte-handover-management-sap.h (module 'lte'): ns3::LteHandoverManagementSapUser [class]
-    module.add_class('LteHandoverManagementSapUser', allow_subclassing=True)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider [class]
-    module.add_class('LteMacSapProvider', allow_subclassing=True)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters [struct]
-    module.add_class('ReportBufferStatusParameters', outer_class=root_module['ns3::LteMacSapProvider'])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters [struct]
-    module.add_class('TransmitPduParameters', outer_class=root_module['ns3::LteMacSapProvider'])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapUser [class]
-    module.add_class('LteMacSapUser', allow_subclassing=True)
-    ## lte-mi-error-model.h (module 'lte'): ns3::LteMiErrorModel [class]
-    module.add_class('LteMiErrorModel')
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider [class]
-    module.add_class('LtePdcpSapProvider', allow_subclassing=True)
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::TransmitPdcpSduParameters [struct]
-    module.add_class('TransmitPdcpSduParameters', outer_class=root_module['ns3::LtePdcpSapProvider'])
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser [class]
-    module.add_class('LtePdcpSapUser', allow_subclassing=True)
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::ReceivePdcpSduParameters [struct]
-    module.add_class('ReceivePdcpSduParameters', outer_class=root_module['ns3::LtePdcpSapUser'])
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider [class]
-    module.add_class('LteRlcSapProvider', allow_subclassing=True)
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::TransmitPdcpPduParameters [struct]
-    module.add_class('TransmitPdcpPduParameters', outer_class=root_module['ns3::LteRlcSapProvider'])
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapUser [class]
-    module.add_class('LteRlcSapUser', allow_subclassing=True)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap [class]
-    module.add_class('LteRrcSap')
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestablishmentCause [enumeration]
-    module.add_enum('ReestablishmentCause', ['RECONFIGURATION_FAILURE', 'HANDOVER_FAILURE', 'OTHER_FAILURE'], outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon [struct]
-    module.add_class('AntennaInfoCommon', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoDedicated [struct]
-    module.add_class('AntennaInfoDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl [struct]
-    module.add_class('AntennaInfoUl', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig [struct]
-    module.add_class('AsConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::BlackCellsToAddMod [struct]
-    module.add_class('BlackCellsToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierBandwidthEutra [struct]
-    module.add_class('CarrierBandwidthEutra', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra [struct]
-    module.add_class('CarrierFreqEutra', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo [struct]
-    module.add_class('CellAccessRelatedInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification [struct]
-    module.add_class('CellIdentification', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellSelectionInfo [struct]
-    module.add_class('CellSelectionInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellsToAddMod [struct]
-    module.add_class('CellsToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CgiInfo [struct]
-    module.add_class('CgiInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod [struct]
-    module.add_class('DrbToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::FreqInfo [struct]
-    module.add_class('FreqInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::HandoverPreparationInfo [struct]
-    module.add_class('HandoverPreparationInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig [struct]
-    module.add_class('LogicalChannelConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MasterInformationBlock [struct]
-    module.add_class('MasterInformationBlock', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig [struct]
-    module.add_class('MeasConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig [struct]
-    module.add_class('MeasGapConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::MeasGapConfig'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::gap [enumeration]
-    module.add_enum('gap', ['GP0', 'GP1'], outer_class=root_module['ns3::LteRrcSap::MeasGapConfig'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasIdToAddMod [struct]
-    module.add_class('MeasIdToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra [struct]
-    module.add_class('MeasObjectEutra', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectToAddMod [struct]
-    module.add_class('MeasObjectToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell [struct]
-    module.add_class('MeasResultBestNeighCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra [struct]
-    module.add_class('MeasResultEutra', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell [struct]
-    module.add_class('MeasResultScell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList [struct]
-    module.add_class('MeasResultServFreqList', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults [struct]
-    module.add_class('MeasResults', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasurementReport [struct]
-    module.add_class('MeasurementReport', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo [struct]
-    module.add_class('MobilityControlInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters [struct]
-    module.add_class('MobilityStateParameters', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration [struct]
-    module.add_class('NonCriticalExtensionConfiguration', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration [struct]
-    module.add_class('NonUlConfiguration', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigCommon [struct]
-    module.add_class('PdschConfigCommon', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated [struct]
-    module.add_class('PdschConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated::db [enumeration]
-    module.add_enum('db', ['dB_6', 'dB_4dot77', 'dB_3', 'dB_1dot77', 'dB0', 'dB1', 'dB2', 'dB3'], outer_class=root_module['ns3::LteRrcSap::PdschConfigDedicated'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysCellIdRange [struct]
-    module.add_class('PhysCellIdRange', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated [struct]
-    module.add_class('PhysicalConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell [struct]
-    module.add_class('PhysicalConfigDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PlmnIdentityInfo [struct]
-    module.add_class('PlmnIdentityInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell [struct]
-    module.add_class('PrachConfigSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PreambleInfo [struct]
-    module.add_class('PreambleInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell [struct]
-    module.add_class('PuschConfigDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::QuantityConfig [struct]
-    module.add_class('QuantityConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RaSupervisionInfo [struct]
-    module.add_class('RaSupervisionInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigCommon [struct]
-    module.add_class('RachConfigCommon', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigDedicated [struct]
-    module.add_class('RachConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommon [struct]
-    module.add_class('RadioResourceConfigCommon', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell [struct]
-    module.add_class('RadioResourceConfigCommonSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSib [struct]
-    module.add_class('RadioResourceConfigCommonSib', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated [struct]
-    module.add_class('RadioResourceConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell [struct]
-    module.add_class('RadioResourceConfigDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity [struct]
-    module.add_class('ReestabUeIdentity', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [struct]
-    module.add_class('ReportConfigEutra', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
-    module.add_enum('', ['EVENT', 'PERIODICAL'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
-    module.add_enum('', ['EVENT_A1', 'EVENT_A2', 'EVENT_A3', 'EVENT_A4', 'EVENT_A5'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::report [enumeration]
-    module.add_enum('report', ['REPORT_STRONGEST_CELLS', 'REPORT_CGI'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
-    module.add_enum('', ['RSRP', 'RSRQ'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
-    module.add_enum('', ['SAME_AS_TRIGGER_QUANTITY', 'BOTH'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
-    module.add_enum('', ['MS120', 'MS240', 'MS480', 'MS640', 'MS1024', 'MS2048', 'MS5120', 'MS10240', 'MIN1', 'MIN6', 'MIN12', 'MIN30', 'MIN60', 'SPARE3', 'SPARE2', 'SPARE1'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigToAddMod [struct]
-    module.add_class('ReportConfigToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig [struct]
-    module.add_class('RlcConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::direction [enumeration]
-    module.add_enum('direction', ['AM', 'UM_BI_DIRECTIONAL', 'UM_UNI_DIRECTIONAL_UL', 'UM_UNI_DIRECTIONAL_DL'], outer_class=root_module['ns3::LteRrcSap::RlcConfig'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration [struct]
-    module.add_class('RrcConnectionReconfiguration', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfigurationCompleted [struct]
-    module.add_class('RrcConnectionReconfigurationCompleted', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishment [struct]
-    module.add_class('RrcConnectionReestablishment', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentComplete [struct]
-    module.add_class('RrcConnectionReestablishmentComplete', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentReject [struct]
-    module.add_class('RrcConnectionReestablishmentReject', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentRequest [struct]
-    module.add_class('RrcConnectionReestablishmentRequest', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReject [struct]
-    module.add_class('RrcConnectionReject', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRelease [struct]
-    module.add_class('RrcConnectionRelease', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest [struct]
-    module.add_class('RrcConnectionRequest', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetup [struct]
-    module.add_class('RrcConnectionSetup', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetupCompleted [struct]
-    module.add_class('RrcConnectionSetupCompleted', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod [struct]
-    module.add_class('SCellToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon [struct]
-    module.add_class('SoundingRsUlConfigCommon', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SoundingRsUlConfigCommon'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated [struct]
-    module.add_class('SoundingRsUlConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SoundingRsUlConfigDedicated'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars [struct]
-    module.add_class('SpeedStatePars', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SpeedStatePars'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStateScaleFactors [struct]
-    module.add_class('SpeedStateScaleFactors', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SrbToAddMod [struct]
-    module.add_class('SrbToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformation [struct]
-    module.add_class('SystemInformation', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType1 [struct]
-    module.add_class('SystemInformationBlockType1', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType2 [struct]
-    module.add_class('SystemInformationBlockType2', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ThresholdEutra [struct]
-    module.add_class('ThresholdEutra', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ThresholdEutra [enumeration]
-    module.add_enum('', ['THRESHOLD_RSRP', 'THRESHOLD_RSRQ'], outer_class=root_module['ns3::LteRrcSap::ThresholdEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration [struct]
-    module.add_class('UlConfiguration', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell [struct]
-    module.add_class('UlPowerControlCommonSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell [struct]
-    module.add_class('UlPowerControlDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-chunk-processor.h (module 'lte'): ns3::LteSpectrumValueCatcher [class]
-    module.add_class('LteSpectrumValueCatcher')
-    ## lte-spectrum-value-helper.h (module 'lte'): ns3::LteSpectrumValueHelper [class]
-    module.add_class('LteSpectrumValueHelper')
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider [class]
-    module.add_class('LteUeCcmRrcSapProvider', allow_subclassing=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig [struct]
-    module.add_class('LcsConfig', outer_class=root_module['ns3::LteUeCcmRrcSapProvider'])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapUser [class]
-    module.add_class('LteUeCcmRrcSapUser', allow_subclassing=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider [class]
-    module.add_class('LteUeCmacSapProvider', allow_subclassing=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig [struct]
-    module.add_class('LogicalChannelConfig', outer_class=root_module['ns3::LteUeCmacSapProvider'])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::RachConfig [struct]
-    module.add_class('RachConfig', outer_class=root_module['ns3::LteUeCmacSapProvider'])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapUser [class]
-    module.add_class('LteUeCmacSapUser', allow_subclassing=True)
-    ## lte-common.h (module 'lte'): ns3::LteUeConfig_t [struct]
-    module.add_class('LteUeConfig_t')
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapProvider [class]
-    module.add_class('LteUeCphySapProvider', allow_subclassing=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser [class]
-    module.add_class('LteUeCphySapUser', allow_subclassing=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsElement [struct]
-    module.add_class('UeMeasurementsElement', outer_class=root_module['ns3::LteUeCphySapUser'])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters [struct]
-    module.add_class('UeMeasurementsParameters', outer_class=root_module['ns3::LteUeCphySapUser'])
-    ## lte-ue-phy-sap.h (module 'lte'): ns3::LteUePhySapProvider [class]
-    module.add_class('LteUePhySapProvider', allow_subclassing=True)
-    ## lte-ue-phy-sap.h (module 'lte'): ns3::LteUePhySapUser [class]
-    module.add_class('LteUePhySapUser', allow_subclassing=True)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider [class]
-    module.add_class('LteUeRrcSapProvider', parent=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider::CompleteSetupParameters [struct]
-    module.add_class('CompleteSetupParameters', outer_class=root_module['ns3::LteUeRrcSapProvider'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser [class]
-    module.add_class('LteUeRrcSapUser', parent=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser::SetupParameters [struct]
-    module.add_class('SetupParameters', outer_class=root_module['ns3::LteUeRrcSapUser'])
-    ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
-    module.add_class('Mac48Address', import_from_module='ns.network')
-    ## mac48-address.h (module 'network'): ns3::Mac48Address [class]
-    root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeListElement_s [struct]
-    module.add_class('MacCeListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeListElement_s::MacCeType_e [enumeration]
-    module.add_enum('MacCeType_e', ['BSR', 'PHR', 'CRNTI'], outer_class=root_module['ns3::MacCeListElement_s'])
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeValue_u [struct]
-    module.add_class('MacCeValue_u')
-    ## names.h (module 'core'): ns3::Names [class]
-    module.add_class('Names', import_from_module='ns.core')
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer [class]
-    module.add_class('NetDeviceContainer', import_from_module='ns.network')
-    ## node-container.h (module 'network'): ns3::NodeContainer [class]
-    module.add_class('NodeContainer', import_from_module='ns.network')
-    ## object-base.h (module 'core'): ns3::ObjectBase [class]
-    module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')
-    ## object.h (module 'core'): ns3::ObjectDeleter [struct]
-    module.add_class('ObjectDeleter', import_from_module='ns.core')
-    ## object-factory.h (module 'core'): ns3::ObjectFactory [class]
-    module.add_class('ObjectFactory', import_from_module='ns.core')
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata [class]
-    module.add_class('PacketMetadata', import_from_module='ns.network')
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item [struct]
-    module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::ItemType [enumeration]
-    module.add_enum('ItemType', ['PAYLOAD', 'HEADER', 'TRAILER'], outer_class=root_module['ns3::PacketMetadata::Item'], import_from_module='ns.network')
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::ItemIterator [class]
-    module.add_class('ItemIterator', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])
-    ## packet.h (module 'network'): ns3::PacketTagIterator [class]
-    module.add_class('PacketTagIterator', import_from_module='ns.network')
-    ## packet.h (module 'network'): ns3::PacketTagIterator::Item [class]
-    module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagIterator'])
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList [class]
-    module.add_class('PacketTagList', import_from_module='ns.network')
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData [struct]
-    module.add_class('TagData', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagList'])
-    ## ff-mac-common.h (module 'lte'): ns3::PagingInfoListElement_s [struct]
-    module.add_class('PagingInfoListElement_s')
-    ## log.h (module 'core'): ns3::ParameterLogger [class]
-    module.add_class('ParameterLogger', import_from_module='ns.core')
-    ## ff-mac-common.h (module 'lte'): ns3::PhichListElement_s [struct]
-    module.add_class('PhichListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::PhichListElement_s::Phich_e [enumeration]
-    module.add_enum('Phich_e', ['ACK', 'NACK'], outer_class=root_module['ns3::PhichListElement_s'])
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters [struct]
-    module.add_class('PhyReceptionStatParameters')
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters [struct]
-    module.add_class('PhyTransmissionStatParameters')
-    ## ff-mac-common.h (module 'lte'): ns3::RachListElement_s [struct]
-    module.add_class('RachListElement_s')
-    ## radio-bearer-stats-connector.h (module 'lte'): ns3::RadioBearerStatsConnector [class]
-    module.add_class('RadioBearerStatsConnector')
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::RealProtocolRlcSapUser [class]
-    module.add_class('RealProtocolRlcSapUser', parent=root_module['ns3::LteRlcSapUser'])
-    ## ff-mac-common.h (module 'lte'): ns3::RlcPduListElement_s [struct]
-    module.add_class('RlcPduListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::SbMeasResult_s [struct]
-    module.add_class('SbMeasResult_s')
-    ## lte-rlc-sequence-number.h (module 'lte'): ns3::SequenceNumber10 [class]
-    module.add_class('SequenceNumber10')
-    ## ff-mac-common.h (module 'lte'): ns3::SiConfiguration_s [struct]
-    module.add_class('SiConfiguration_s')
-    ## ff-mac-common.h (module 'lte'): ns3::SiMessageListElement_s [struct]
-    module.add_class('SiMessageListElement_s')
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter> [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Object', 'ns3::ObjectBase', 'ns3::ObjectDeleter'], parent=root_module['ns3::ObjectBase'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simulator.h (module 'core'): ns3::Simulator [class]
-    module.add_class('Simulator', destructor_visibility='private', import_from_module='ns.core')
-    ## simulator.h (module 'core'): ns3::Simulator [enumeration]
-    module.add_enum('', ['NO_CONTEXT'], outer_class=root_module['ns3::Simulator'], import_from_module='ns.core')
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s [struct]
-    module.add_class('SpsConfig_s')
-    ## ff-mac-common.h (module 'lte'): ns3::SrConfig_s [struct]
-    module.add_class('SrConfig_s')
-    ## ff-mac-common.h (module 'lte'): ns3::SrListElement_s [struct]
-    module.add_class('SrListElement_s')
-    ## data-calculator.h (module 'stats'): ns3::StatisticalSummary [class]
-    module.add_class('StatisticalSummary', allow_subclassing=True, import_from_module='ns.stats')
-    ## tag.h (module 'network'): ns3::Tag [class]
-    module.add_class('Tag', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
-    ## tag-buffer.h (module 'network'): ns3::TagBuffer [class]
-    module.add_class('TagBuffer', import_from_module='ns.network')
-    ## lte-spectrum-phy.h (module 'lte'): ns3::TbId_t [struct]
-    module.add_class('TbId_t')
-    ## lte-mi-error-model.h (module 'lte'): ns3::TbStats_t [struct]
-    module.add_class('TbStats_t')
-    ## nstime.h (module 'core'): ns3::TimeWithUnit [class]
-    module.add_class('TimeWithUnit', import_from_module='ns.core')
-    ## lte-common.h (module 'lte'): ns3::TransmissionModesLayers [class]
-    module.add_class('TransmissionModesLayers')
-    ## type-id.h (module 'core'): ns3::TypeId [class]
-    module.add_class('TypeId', import_from_module='ns.core')
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeFlag [enumeration]
-    module.add_enum('AttributeFlag', ['ATTR_GET', 'ATTR_SET', 'ATTR_CONSTRUCT', 'ATTR_SGC'], outer_class=root_module['ns3::TypeId'], import_from_module='ns.core')
-    ## type-id.h (module 'core'): ns3::TypeId::SupportLevel [enumeration]
-    module.add_enum('SupportLevel', ['SUPPORTED', 'DEPRECATED', 'OBSOLETE'], outer_class=root_module['ns3::TypeId'], import_from_module='ns.core')
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation [struct]
-    module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation [struct]
-    module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s [struct]
-    module.add_class('UeCapabilities_s')
-    ## ff-mac-common.h (module 'lte'): ns3::UeSelected_s [struct]
-    module.add_class('UeSelected_s')
-    ## ff-mac-common.h (module 'lte'): ns3::UlCqi_s [struct]
-    module.add_class('UlCqi_s')
-    ## ff-mac-common.h (module 'lte'): ns3::UlCqi_s::Type_e [enumeration]
-    module.add_enum('Type_e', ['SRS', 'PUSCH', 'PUCCH_1', 'PUCCH_2', 'PRACH'], outer_class=root_module['ns3::UlCqi_s'])
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s [struct]
-    module.add_class('UlDciListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s [struct]
-    module.add_class('UlGrant_s')
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s [struct]
-    module.add_class('UlInfoListElement_s')
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s::ReceptionStatus_e [enumeration]
-    module.add_enum('ReceptionStatus_e', ['Ok', 'NotOk', 'NotValid'], outer_class=root_module['ns3::UlInfoListElement_s'])
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::UplinkLteGlobalPathlossDatabase [class]
-    module.add_class('UplinkLteGlobalPathlossDatabase', parent=root_module['ns3::LteGlobalPathlossDatabase'])
-    ## vector.h (module 'core'): ns3::Vector2D [class]
-    module.add_class('Vector2D', import_from_module='ns.core')
-    ## vector.h (module 'core'): ns3::Vector3D [class]
-    module.add_class('Vector3D', import_from_module='ns.core')
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificListElement_s [struct]
-    module.add_class('VendorSpecificListElement_s')
-    ## empty.h (module 'core'): ns3::empty [class]
-    module.add_class('empty', import_from_module='ns.core')
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::fdbetsFlowPerf_t [struct]
-    module.add_class('fdbetsFlowPerf_t')
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t [struct]
-    module.add_class('fdtbfqsFlowPerf_t')
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t [class]
-    module.add_class('int64x64_t', import_from_module='ns.core')
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::impl_type [enumeration]
-    module.add_enum('impl_type', ['int128_impl', 'cairo_impl', 'ld_impl'], outer_class=root_module['ns3::int64x64_t'], import_from_module='ns.core')
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::pfsFlowPerf_t [struct]
-    module.add_class('pfsFlowPerf_t')
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t [struct]
-    module.add_class('pssFlowPerf_t')
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t [struct]
-    module.add_class('tbInfo_t')
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::tdbetsFlowPerf_t [struct]
-    module.add_class('tdbetsFlowPerf_t')
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t [struct]
-    module.add_class('tdtbfqsFlowPerf_t')
-    ## chunk.h (module 'network'): ns3::Chunk [class]
-    module.add_class('Chunk', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::DownlinkLteGlobalPathlossDatabase [class]
-    module.add_class('DownlinkLteGlobalPathlossDatabase', parent=root_module['ns3::LteGlobalPathlossDatabase'])
-    ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag [class]
-    module.add_class('EpsBearerTag', parent=root_module['ns3::Tag'])
-    ## header.h (module 'network'): ns3::Header [class]
-    module.add_class('Header', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Header [class]
-    module.add_class('Ipv4Header', import_from_module='ns.internet', parent=root_module['ns3::Header'])
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Header::DscpType [enumeration]
-    module.add_enum('DscpType', ['DscpDefault', 'DSCP_CS1', 'DSCP_AF11', 'DSCP_AF12', 'DSCP_AF13', 'DSCP_CS2', 'DSCP_AF21', 'DSCP_AF22', 'DSCP_AF23', 'DSCP_CS3', 'DSCP_AF31', 'DSCP_AF32', 'DSCP_AF33', 'DSCP_CS4', 'DSCP_AF41', 'DSCP_AF42', 'DSCP_AF43', 'DSCP_CS5', 'DSCP_EF', 'DSCP_CS6', 'DSCP_CS7'], outer_class=root_module['ns3::Ipv4Header'], import_from_module='ns.internet')
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Header::EcnType [enumeration]
-    module.add_enum('EcnType', ['ECN_NotECT', 'ECN_ECT1', 'ECN_ECT0', 'ECN_CE'], outer_class=root_module['ns3::Ipv4Header'], import_from_module='ns.internet')
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapUser [class]
-    module.add_class('LteCcmMacSapUser', parent=root_module['ns3::LteMacSapUser'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider [class]
-    module.add_class('LteEnbRrcSapProvider', parent=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters [struct]
-    module.add_class('CompleteSetupUeParameters', outer_class=root_module['ns3::LteEnbRrcSapProvider'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser [class]
-    module.add_class('LteEnbRrcSapUser', parent=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser::SetupUeParameters [struct]
-    module.add_class('SetupUeParameters', outer_class=root_module['ns3::LteEnbRrcSapUser'])
-    ## lte-pdcp-header.h (module 'lte'): ns3::LtePdcpHeader [class]
-    module.add_class('LtePdcpHeader', parent=root_module['ns3::Header'])
-    ## lte-pdcp-header.h (module 'lte'): ns3::LtePdcpHeader [enumeration]
-    module.add_enum('', ['CONTROL_PDU', 'DATA_PDU'], outer_class=root_module['ns3::LtePdcpHeader'])
-    ## lte-phy-tag.h (module 'lte'): ns3::LtePhyTag [class]
-    module.add_class('LtePhyTag', parent=root_module['ns3::Tag'])
-    ## lte-radio-bearer-tag.h (module 'lte'): ns3::LteRadioBearerTag [class]
-    module.add_class('LteRadioBearerTag', parent=root_module['ns3::Tag'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader [class]
-    module.add_class('LteRlcAmHeader', parent=root_module['ns3::Header'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::DataControlPdu_t [enumeration]
-    module.add_enum('DataControlPdu_t', ['CONTROL_PDU', 'DATA_PDU'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::ControPduType_t [enumeration]
-    module.add_enum('ControPduType_t', ['STATUS_PDU'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::FramingInfoFirstByte_t [enumeration]
-    module.add_enum('FramingInfoFirstByte_t', ['FIRST_BYTE', 'NO_FIRST_BYTE'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::FramingInfoLastByte_t [enumeration]
-    module.add_enum('FramingInfoLastByte_t', ['LAST_BYTE', 'NO_LAST_BYTE'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::ExtensionBit_t [enumeration]
-    module.add_enum('ExtensionBit_t', ['DATA_FIELD_FOLLOWS', 'E_LI_FIELDS_FOLLOWS'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::ResegmentationFlag_t [enumeration]
-    module.add_enum('ResegmentationFlag_t', ['PDU', 'SEGMENT'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::PollingBit_t [enumeration]
-    module.add_enum('PollingBit_t', ['STATUS_REPORT_NOT_REQUESTED', 'STATUS_REPORT_IS_REQUESTED'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::LastSegmentFlag_t [enumeration]
-    module.add_enum('LastSegmentFlag_t', ['NO_LAST_PDU_SEGMENT', 'LAST_PDU_SEGMENT'], outer_class=root_module['ns3::LteRlcAmHeader'])
-    ## lte-rlc-header.h (module 'lte'): ns3::LteRlcHeader [class]
-    module.add_class('LteRlcHeader', parent=root_module['ns3::Header'])
-    ## lte-rlc-header.h (module 'lte'): ns3::LteRlcHeader::ExtensionBit_t [enumeration]
-    module.add_enum('ExtensionBit_t', ['DATA_FIELD_FOLLOWS', 'E_LI_FIELDS_FOLLOWS'], outer_class=root_module['ns3::LteRlcHeader'])
-    ## lte-rlc-header.h (module 'lte'): ns3::LteRlcHeader::FramingInfoFirstByte_t [enumeration]
-    module.add_enum('FramingInfoFirstByte_t', ['FIRST_BYTE', 'NO_FIRST_BYTE'], outer_class=root_module['ns3::LteRlcHeader'])
-    ## lte-rlc-header.h (module 'lte'): ns3::LteRlcHeader::FramingInfoLastByte_t [enumeration]
-    module.add_enum('FramingInfoLastByte_t', ['LAST_BYTE', 'NO_LAST_BYTE'], outer_class=root_module['ns3::LteRlcHeader'])
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): ns3::LteRlcSduStatusTag [class]
-    module.add_class('LteRlcSduStatusTag', parent=root_module['ns3::Tag'])
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): ns3::LteRlcSduStatusTag::SduStatus_t [enumeration]
-    module.add_enum('SduStatus_t', ['FULL_SDU', 'FIRST_SEGMENT', 'MIDDLE_SEGMENT', 'LAST_SEGMENT', 'ANY_SEGMENT'], outer_class=root_module['ns3::LteRlcSduStatusTag'])
-    ## object.h (module 'core'): ns3::Object [class]
-    module.add_class('Object', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])
-    ## object.h (module 'core'): ns3::Object::AggregateIterator [class]
-    module.add_class('AggregateIterator', import_from_module='ns.core', outer_class=root_module['ns3::Object'])
-    ## packet-burst.h (module 'network'): ns3::PacketBurst [class]
-    module.add_class('PacketBurst', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag [class]
-    module.add_class('PdcpTag', parent=root_module['ns3::Tag'])
-    ## radio-environment-map-helper.h (module 'lte'): ns3::RadioEnvironmentMapHelper [class]
-    module.add_class('RadioEnvironmentMapHelper', parent=root_module['ns3::Object'])
-    ## random-variable-stream.h (module 'core'): ns3::RandomVariableStream [class]
-    module.add_class('RandomVariableStream', import_from_module='ns.core', parent=root_module['ns3::Object'])
-    ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag [class]
-    module.add_class('RlcTag', parent=root_module['ns3::Tag'])
-    ## random-variable-stream.h (module 'core'): ns3::SequentialRandomVariable [class]
-    module.add_class('SequentialRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeChecker', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeChecker>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeValue', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeValue>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::CallbackImplBase', 'ns3::empty', 'ns3::DefaultDeleter<ns3::CallbackImplBase>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EpcTft, ns3::empty, ns3::DefaultDeleter<ns3::EpcTft> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::EpcTft', 'ns3::empty', 'ns3::DefaultDeleter<ns3::EpcTft>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EpcTftClassifier, ns3::empty, ns3::DefaultDeleter<ns3::EpcTftClassifier> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::EpcTftClassifier', 'ns3::empty', 'ns3::DefaultDeleter<ns3::EpcTftClassifier>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::EventImpl', 'ns3::empty', 'ns3::DefaultDeleter<ns3::EventImpl>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Hash::Implementation', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Hash::Implementation>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Ipv4MulticastRoute', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Ipv4MulticastRoute>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Ipv4Route', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Ipv4Route>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteChunkProcessor, ns3::empty, ns3::DefaultDeleter<ns3::LteChunkProcessor> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::LteChunkProcessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::LteChunkProcessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter<ns3::LteControlMessage> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::LteControlMessage', 'ns3::empty', 'ns3::DefaultDeleter<ns3::LteControlMessage>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::LteHarqPhy', 'ns3::empty', 'ns3::DefaultDeleter<ns3::LteHarqPhy>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::NixVector', 'ns3::empty', 'ns3::DefaultDeleter<ns3::NixVector>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Packet', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Packet>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::SpectrumModel', 'ns3::empty', 'ns3::DefaultDeleter<ns3::SpectrumModel>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::SpectrumSignalParameters', 'ns3::empty', 'ns3::DefaultDeleter<ns3::SpectrumSignalParameters>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::SpectrumValue', 'ns3::empty', 'ns3::DefaultDeleter<ns3::SpectrumValue>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::TraceSourceAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::TraceSourceAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::VendorSpecificValue, ns3::empty, ns3::DefaultDeleter<ns3::VendorSpecificValue> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::VendorSpecificValue', 'ns3::empty', 'ns3::DefaultDeleter<ns3::VendorSpecificValue>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::X2CellInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2CellInfo> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::X2CellInfo', 'ns3::empty', 'ns3::DefaultDeleter<ns3::X2CellInfo>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::X2IfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2IfaceInfo> > [class]
-    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::X2IfaceInfo', 'ns3::empty', 'ns3::DefaultDeleter<ns3::X2IfaceInfo>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
-    ## socket.h (module 'network'): ns3::Socket [class]
-    module.add_class('Socket', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    ## socket.h (module 'network'): ns3::Socket::SocketErrno [enumeration]
-    module.add_enum('SocketErrno', ['ERROR_NOTERROR', 'ERROR_ISCONN', 'ERROR_NOTCONN', 'ERROR_MSGSIZE', 'ERROR_AGAIN', 'ERROR_SHUTDOWN', 'ERROR_OPNOTSUPP', 'ERROR_AFNOSUPPORT', 'ERROR_INVAL', 'ERROR_BADF', 'ERROR_NOROUTETOHOST', 'ERROR_NODEV', 'ERROR_ADDRNOTAVAIL', 'ERROR_ADDRINUSE', 'SOCKET_ERRNO_LAST'], outer_class=root_module['ns3::Socket'], import_from_module='ns.network')
-    ## socket.h (module 'network'): ns3::Socket::SocketType [enumeration]
-    module.add_enum('SocketType', ['NS3_SOCK_STREAM', 'NS3_SOCK_SEQPACKET', 'NS3_SOCK_DGRAM', 'NS3_SOCK_RAW'], outer_class=root_module['ns3::Socket'], import_from_module='ns.network')
-    ## socket.h (module 'network'): ns3::Socket::SocketPriority [enumeration]
-    module.add_enum('SocketPriority', ['NS3_PRIO_BESTEFFORT', 'NS3_PRIO_FILLER', 'NS3_PRIO_BULK', 'NS3_PRIO_INTERACTIVE_BULK', 'NS3_PRIO_INTERACTIVE', 'NS3_PRIO_CONTROL'], outer_class=root_module['ns3::Socket'], import_from_module='ns.network')
-    ## socket.h (module 'network'): ns3::Socket::Ipv6MulticastFilterMode [enumeration]
-    module.add_enum('Ipv6MulticastFilterMode', ['INCLUDE', 'EXCLUDE'], outer_class=root_module['ns3::Socket'], import_from_module='ns.network')
-    ## socket.h (module 'network'): ns3::SocketIpTosTag [class]
-    module.add_class('SocketIpTosTag', import_from_module='ns.network', parent=root_module['ns3::Tag'])
-    ## socket.h (module 'network'): ns3::SocketIpTtlTag [class]
-    module.add_class('SocketIpTtlTag', import_from_module='ns.network', parent=root_module['ns3::Tag'])
-    ## socket.h (module 'network'): ns3::SocketIpv6HopLimitTag [class]
-    module.add_class('SocketIpv6HopLimitTag', import_from_module='ns.network', parent=root_module['ns3::Tag'])
-    ## socket.h (module 'network'): ns3::SocketIpv6TclassTag [class]
-    module.add_class('SocketIpv6TclassTag', import_from_module='ns.network', parent=root_module['ns3::Tag'])
-    ## socket.h (module 'network'): ns3::SocketPriorityTag [class]
-    module.add_class('SocketPriorityTag', import_from_module='ns.network', parent=root_module['ns3::Tag'])
-    ## socket.h (module 'network'): ns3::SocketSetDontFragmentTag [class]
-    module.add_class('SocketSetDontFragmentTag', import_from_module='ns.network', parent=root_module['ns3::Tag'])
-    ## spectrum-interference.h (module 'spectrum'): ns3::SpectrumInterference [class]
-    module.add_class('SpectrumInterference', import_from_module='ns.spectrum', parent=root_module['ns3::Object'])
-    ## spectrum-model.h (module 'spectrum'): ns3::SpectrumModel [class]
-    module.add_class('SpectrumModel', import_from_module='ns.spectrum', parent=root_module['ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >'])
-    ## spectrum-phy.h (module 'spectrum'): ns3::SpectrumPhy [class]
-    module.add_class('SpectrumPhy', import_from_module='ns.spectrum', parent=root_module['ns3::Object'])
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): ns3::SpectrumPropagationLossModel [class]
-    module.add_class('SpectrumPropagationLossModel', import_from_module='ns.spectrum', parent=root_module['ns3::Object'])
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::SpectrumSignalParameters [struct]
-    module.add_class('SpectrumSignalParameters', import_from_module='ns.spectrum', parent=root_module['ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >'])
-    ## spectrum-value.h (module 'spectrum'): ns3::SpectrumValue [class]
-    module.add_class('SpectrumValue', import_from_module='ns.spectrum', parent=root_module['ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >'])
-    ## nstime.h (module 'core'): ns3::Time [class]
-    module.add_class('Time', import_from_module='ns.core')
-    ## nstime.h (module 'core'): ns3::Time::Unit [enumeration]
-    module.add_enum('Unit', ['Y', 'D', 'H', 'MIN', 'S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')
-    ## nstime.h (module 'core'): ns3::Time [class]
-    root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])
-    ## trace-fading-loss-model.h (module 'lte'): ns3::TraceFadingLossModel [class]
-    module.add_class('TraceFadingLossModel', parent=root_module['ns3::SpectrumPropagationLossModel'])
-    ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor [class]
-    module.add_class('TraceSourceAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
-    ## trailer.h (module 'network'): ns3::Trailer [class]
-    module.add_class('Trailer', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
-    ## random-variable-stream.h (module 'core'): ns3::TriangularRandomVariable [class]
-    module.add_class('TriangularRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager [class]
-    module.add_class('UeManager', parent=root_module['ns3::Object'])
-    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::State [enumeration]
-    module.add_enum('State', ['INITIAL_RANDOM_ACCESS', 'CONNECTION_SETUP', 'CONNECTION_REJECTED', 'CONNECTED_NORMALLY', 'CONNECTION_RECONFIGURATION', 'CONNECTION_REESTABLISHMENT', 'HANDOVER_PREPARATION', 'HANDOVER_JOINING', 'HANDOVER_PATH_SWITCH', 'HANDOVER_LEAVING', 'NUM_STATES'], outer_class=root_module['ns3::UeManager'])
-    ## random-variable-stream.h (module 'core'): ns3::UniformRandomVariable [class]
-    module.add_class('UniformRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificValue [struct]
-    module.add_class('VendorSpecificValue', parent=root_module['ns3::SimpleRefCount< ns3::VendorSpecificValue, ns3::empty, ns3::DefaultDeleter<ns3::VendorSpecificValue> >'])
-    ## random-variable-stream.h (module 'core'): ns3::WeibullRandomVariable [class]
-    module.add_class('WeibullRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## epc-x2.h (module 'lte'): ns3::X2CellInfo [class]
-    module.add_class('X2CellInfo', parent=root_module['ns3::SimpleRefCount< ns3::X2CellInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2CellInfo> >'])
-    ## epc-x2.h (module 'lte'): ns3::X2IfaceInfo [class]
-    module.add_class('X2IfaceInfo', parent=root_module['ns3::SimpleRefCount< ns3::X2IfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2IfaceInfo> >'])
-    ## random-variable-stream.h (module 'core'): ns3::ZetaRandomVariable [class]
-    module.add_class('ZetaRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## random-variable-stream.h (module 'core'): ns3::ZipfRandomVariable [class]
-    module.add_class('ZipfRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## application.h (module 'network'): ns3::Application [class]
-    module.add_class('Application', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    ## lte-asn1-header.h (module 'lte'): ns3::Asn1Header [class]
-    module.add_class('Asn1Header', parent=root_module['ns3::Header'])
-    ## attribute.h (module 'core'): ns3::AttributeAccessor [class]
-    module.add_class('AttributeAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
-    ## attribute.h (module 'core'): ns3::AttributeChecker [class]
-    module.add_class('AttributeChecker', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])
-    ## attribute.h (module 'core'): ns3::AttributeValue [class]
-    module.add_class('AttributeValue', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])
-    ## boolean.h (module 'core'): ns3::BooleanChecker [class]
-    module.add_class('BooleanChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## boolean.h (module 'core'): ns3::BooleanValue [class]
-    module.add_class('BooleanValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## callback.h (module 'core'): ns3::CallbackChecker [class]
-    module.add_class('CallbackChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## callback.h (module 'core'): ns3::CallbackImplBase [class]
-    module.add_class('CallbackImplBase', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])
-    ## callback.h (module 'core'): ns3::CallbackValue [class]
-    module.add_class('CallbackValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## cc-helper.h (module 'lte'): ns3::CcHelper [class]
-    module.add_class('CcHelper', parent=root_module['ns3::Object'])
-    ## channel.h (module 'network'): ns3::Channel [class]
-    module.add_class('Channel', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier [class]
-    module.add_class('ComponentCarrier', parent=root_module['ns3::Object'])
-    ## component-carrier-enb.h (module 'lte'): ns3::ComponentCarrierEnb [class]
-    module.add_class('ComponentCarrierEnb', parent=root_module['ns3::ComponentCarrier'])
-    ## component-carrier-ue.h (module 'lte'): ns3::ComponentCarrierUe [class]
-    module.add_class('ComponentCarrierUe', parent=root_module['ns3::ComponentCarrier'])
-    ## random-variable-stream.h (module 'core'): ns3::ConstantRandomVariable [class]
-    module.add_class('ConstantRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## data-calculator.h (module 'stats'): ns3::DataCalculator [class]
-    module.add_class('DataCalculator', import_from_module='ns.stats', parent=root_module['ns3::Object'])
-    ## data-output-interface.h (module 'stats'): ns3::DataOutputInterface [class]
-    module.add_class('DataOutputInterface', import_from_module='ns.stats', parent=root_module['ns3::Object'])
-    ## data-rate.h (module 'network'): ns3::DataRateChecker [class]
-    module.add_class('DataRateChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
-    ## data-rate.h (module 'network'): ns3::DataRateValue [class]
-    module.add_class('DataRateValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
-    ## random-variable-stream.h (module 'core'): ns3::DeterministicRandomVariable [class]
-    module.add_class('DeterministicRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## double.h (module 'core'): ns3::DoubleValue [class]
-    module.add_class('DoubleValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## random-variable-stream.h (module 'core'): ns3::EmpiricalRandomVariable [class]
-    module.add_class('EmpiricalRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## attribute.h (module 'core'): ns3::EmptyAttributeAccessor [class]
-    module.add_class('EmptyAttributeAccessor', import_from_module='ns.core', parent=root_module['ns3::AttributeAccessor'])
-    ## attribute.h (module 'core'): ns3::EmptyAttributeChecker [class]
-    module.add_class('EmptyAttributeChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## attribute.h (module 'core'): ns3::EmptyAttributeValue [class]
-    module.add_class('EmptyAttributeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## enum.h (module 'core'): ns3::EnumChecker [class]
-    module.add_class('EnumChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## enum.h (module 'core'): ns3::EnumValue [class]
-    module.add_class('EnumValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication [class]
-    module.add_class('EpcEnbApplication', parent=root_module['ns3::Application'])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpsFlowId_t [struct]
-    module.add_class('EpsFlowId_t', outer_class=root_module['ns3::EpcEnbApplication'])
-    ## epc-helper.h (module 'lte'): ns3::EpcHelper [class]
-    module.add_class('EpcHelper', parent=root_module['ns3::Object'])
-    ## epc-mme.h (module 'lte'): ns3::EpcMme [class]
-    module.add_class('EpcMme', parent=root_module['ns3::Object'])
-    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication [class]
-    module.add_class('EpcSgwPgwApplication', parent=root_module['ns3::Application'])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft [class]
-    module.add_class('EpcTft', parent=root_module['ns3::SimpleRefCount< ns3::EpcTft, ns3::empty, ns3::DefaultDeleter<ns3::EpcTft> >'])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::Direction [enumeration]
-    module.add_enum('Direction', ['DOWNLINK', 'UPLINK', 'BIDIRECTIONAL'], outer_class=root_module['ns3::EpcTft'])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter [struct]
-    module.add_class('PacketFilter', outer_class=root_module['ns3::EpcTft'])
-    ## epc-tft-classifier.h (module 'lte'): ns3::EpcTftClassifier [class]
-    module.add_class('EpcTftClassifier', parent=root_module['ns3::SimpleRefCount< ns3::EpcTftClassifier, ns3::empty, ns3::DefaultDeleter<ns3::EpcTftClassifier> >'])
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas [class]
-    module.add_class('EpcUeNas', parent=root_module['ns3::Object'])
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::State [enumeration]
-    module.add_enum('State', ['OFF', 'ATTACHING', 'IDLE_REGISTERED', 'CONNECTING_TO_EPC', 'ACTIVE', 'NUM_STATES'], outer_class=root_module['ns3::EpcUeNas'])
-    ## epc-x2.h (module 'lte'): ns3::EpcX2 [class]
-    module.add_class('EpcX2', parent=root_module['ns3::Object'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader [class]
-    module.add_class('EpcX2HandoverPreparationFailureHeader', parent=root_module['ns3::Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader [class]
-    module.add_class('EpcX2HandoverRequestAckHeader', parent=root_module['ns3::Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestHeader [class]
-    module.add_class('EpcX2HandoverRequestHeader', parent=root_module['ns3::Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header [class]
-    module.add_class('EpcX2Header', parent=root_module['ns3::Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::ProcedureCode_t [enumeration]
-    module.add_enum('ProcedureCode_t', ['HandoverPreparation', 'LoadIndication', 'SnStatusTransfer', 'UeContextRelease', 'ResourceStatusReporting'], outer_class=root_module['ns3::EpcX2Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::TypeOfMessage_t [enumeration]
-    module.add_enum('TypeOfMessage_t', ['InitiatingMessage', 'SuccessfulOutcome', 'UnsuccessfulOutcome'], outer_class=root_module['ns3::EpcX2Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader [class]
-    module.add_class('EpcX2LoadInformationHeader', parent=root_module['ns3::Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader [class]
-    module.add_class('EpcX2ResourceStatusUpdateHeader', parent=root_module['ns3::Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SnStatusTransferHeader [class]
-    module.add_class('EpcX2SnStatusTransferHeader', parent=root_module['ns3::Header'])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeContextReleaseHeader [class]
-    module.add_class('EpcX2UeContextReleaseHeader', parent=root_module['ns3::Header'])
-    ## random-variable-stream.h (module 'core'): ns3::ErlangRandomVariable [class]
-    module.add_class('ErlangRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## event-impl.h (module 'core'): ns3::EventImpl [class]
-    module.add_class('EventImpl', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])
-    ## random-variable-stream.h (module 'core'): ns3::ExponentialRandomVariable [class]
-    module.add_class('ExponentialRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## ff-mac-scheduler.h (module 'lte'): ns3::FfMacScheduler [class]
-    module.add_class('FfMacScheduler', parent=root_module['ns3::Object'])
-    ## ff-mac-scheduler.h (module 'lte'): ns3::FfMacScheduler::UlCqiFilter_t [enumeration]
-    module.add_enum('UlCqiFilter_t', ['SRS_UL_CQI', 'PUSCH_UL_CQI', 'ALL_UL_CQI'], outer_class=root_module['ns3::FfMacScheduler'])
-    ## random-variable-stream.h (module 'core'): ns3::GammaRandomVariable [class]
-    module.add_class('GammaRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## epc-gtpu-header.h (module 'lte'): ns3::GtpuHeader [class]
-    module.add_class('GtpuHeader', parent=root_module['ns3::Header'])
-    ## integer.h (module 'core'): ns3::IntegerValue [class]
-    module.add_class('IntegerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## ipv4.h (module 'internet'): ns3::Ipv4 [class]
-    module.add_class('Ipv4', import_from_module='ns.internet', parent=root_module['ns3::Object'])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4AddressChecker [class]
-    module.add_class('Ipv4AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4AddressValue [class]
-    module.add_class('Ipv4AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4MaskChecker [class]
-    module.add_class('Ipv4MaskChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4MaskValue [class]
-    module.add_class('Ipv4MaskValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4MulticastRoute [class]
-    module.add_class('Ipv4MulticastRoute', import_from_module='ns.internet', parent=root_module['ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >'])
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Route [class]
-    module.add_class('Ipv4Route', import_from_module='ns.internet', parent=root_module['ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >'])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6AddressChecker [class]
-    module.add_class('Ipv6AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6AddressValue [class]
-    module.add_class('Ipv6AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6PrefixChecker [class]
-    module.add_class('Ipv6PrefixChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6PrefixValue [class]
-    module.add_class('Ipv6PrefixValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
-    ## random-variable-stream.h (module 'core'): ns3::LogNormalRandomVariable [class]
-    module.add_class('LogNormalRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## lte-amc.h (module 'lte'): ns3::LteAmc [class]
-    module.add_class('LteAmc', parent=root_module['ns3::Object'])
-    ## lte-amc.h (module 'lte'): ns3::LteAmc::AmcModel [enumeration]
-    module.add_enum('AmcModel', ['PiroEW2010', 'MiErrorModel'], outer_class=root_module['ns3::LteAmc'])
-    ## lte-anr.h (module 'lte'): ns3::LteAnr [class]
-    module.add_class('LteAnr', parent=root_module['ns3::Object'])
-    ## lte-chunk-processor.h (module 'lte'): ns3::LteChunkProcessor [class]
-    module.add_class('LteChunkProcessor', parent=root_module['ns3::SimpleRefCount< ns3::LteChunkProcessor, ns3::empty, ns3::DefaultDeleter<ns3::LteChunkProcessor> >'])
-    ## lte-control-messages.h (module 'lte'): ns3::LteControlMessage [class]
-    module.add_class('LteControlMessage', parent=root_module['ns3::SimpleRefCount< ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter<ns3::LteControlMessage> >'])
-    ## lte-control-messages.h (module 'lte'): ns3::LteControlMessage::MessageType [enumeration]
-    module.add_enum('MessageType', ['DL_DCI', 'UL_DCI', 'DL_CQI', 'UL_CQI', 'BSR', 'DL_HARQ', 'RACH_PREAMBLE', 'RAR', 'MIB', 'SIB1'], outer_class=root_module['ns3::LteControlMessage'])
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteEnbComponentCarrierManager [class]
-    module.add_class('LteEnbComponentCarrierManager', parent=root_module['ns3::Object'])
-    ## lte-enb-mac.h (module 'lte'): ns3::LteEnbMac [class]
-    module.add_class('LteEnbMac', parent=root_module['ns3::Object'])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc [class]
-    module.add_class('LteEnbRrc', parent=root_module['ns3::Object'])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::LteEpsBearerToRlcMapping_t [enumeration]
-    module.add_enum('LteEpsBearerToRlcMapping_t', ['RLC_SM_ALWAYS', 'RLC_UM_ALWAYS', 'RLC_AM_ALWAYS', 'PER_BASED'], outer_class=root_module['ns3::LteEnbRrc'])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcProtocolIdeal [class]
-    module.add_class('LteEnbRrcProtocolIdeal', parent=root_module['ns3::Object'])
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteEnbRrcProtocolReal [class]
-    module.add_class('LteEnbRrcProtocolReal', parent=root_module['ns3::Object'])
-    ## lte-ffr-algorithm.h (module 'lte'): ns3::LteFfrAlgorithm [class]
-    module.add_class('LteFfrAlgorithm', parent=root_module['ns3::Object'])
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): ns3::LteFfrDistributedAlgorithm [class]
-    module.add_class('LteFfrDistributedAlgorithm', parent=root_module['ns3::LteFfrAlgorithm'])
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): ns3::LteFfrEnhancedAlgorithm [class]
-    module.add_class('LteFfrEnhancedAlgorithm', parent=root_module['ns3::LteFfrAlgorithm'])
-    ## lte-ffr-soft-algorithm.h (module 'lte'): ns3::LteFfrSoftAlgorithm [class]
-    module.add_class('LteFfrSoftAlgorithm', parent=root_module['ns3::LteFfrAlgorithm'])
-    ## lte-fr-hard-algorithm.h (module 'lte'): ns3::LteFrHardAlgorithm [class]
-    module.add_class('LteFrHardAlgorithm', parent=root_module['ns3::LteFfrAlgorithm'])
-    ## lte-fr-no-op-algorithm.h (module 'lte'): ns3::LteFrNoOpAlgorithm [class]
-    module.add_class('LteFrNoOpAlgorithm', parent=root_module['ns3::LteFfrAlgorithm'])
-    ## lte-fr-soft-algorithm.h (module 'lte'): ns3::LteFrSoftAlgorithm [class]
-    module.add_class('LteFrSoftAlgorithm', parent=root_module['ns3::LteFfrAlgorithm'])
-    ## lte-fr-strict-algorithm.h (module 'lte'): ns3::LteFrStrictAlgorithm [class]
-    module.add_class('LteFrStrictAlgorithm', parent=root_module['ns3::LteFfrAlgorithm'])
-    ## lte-handover-algorithm.h (module 'lte'): ns3::LteHandoverAlgorithm [class]
-    module.add_class('LteHandoverAlgorithm', parent=root_module['ns3::Object'])
-    ## lte-harq-phy.h (module 'lte'): ns3::LteHarqPhy [class]
-    module.add_class('LteHarqPhy', parent=root_module['ns3::SimpleRefCount< ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> >'])
-    ## lte-helper.h (module 'lte'): ns3::LteHelper [class]
-    module.add_class('LteHelper', parent=root_module['ns3::Object'])
-    ## lte-hex-grid-enb-topology-helper.h (module 'lte'): ns3::LteHexGridEnbTopologyHelper [class]
-    module.add_class('LteHexGridEnbTopologyHelper', parent=root_module['ns3::Object'])
-    ## lte-interference.h (module 'lte'): ns3::LteInterference [class]
-    module.add_class('LteInterference', parent=root_module['ns3::Object'])
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp [class]
-    module.add_class('LtePdcp', parent=root_module['ns3::Object'])
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::Status [struct]
-    module.add_class('Status', outer_class=root_module['ns3::LtePdcp'])
-    ## lte-phy.h (module 'lte'): ns3::LtePhy [class]
-    module.add_class('LtePhy', parent=root_module['ns3::Object'])
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteRadioBearerInfo [class]
-    module.add_class('LteRadioBearerInfo', parent=root_module['ns3::Object'])
-    ## lte-rlc.h (module 'lte'): ns3::LteRlc [class]
-    module.add_class('LteRlc', parent=root_module['ns3::Object'])
-    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm [class]
-    module.add_class('LteRlcAm', parent=root_module['ns3::LteRlc'])
-    ## lte-rlc.h (module 'lte'): ns3::LteRlcSm [class]
-    module.add_class('LteRlcSm', parent=root_module['ns3::LteRlc'])
-    ## lte-rlc-tm.h (module 'lte'): ns3::LteRlcTm [class]
-    module.add_class('LteRlcTm', parent=root_module['ns3::LteRlc'])
-    ## lte-rlc-um.h (module 'lte'): ns3::LteRlcUm [class]
-    module.add_class('LteRlcUm', parent=root_module['ns3::LteRlc'])
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo [class]
-    module.add_class('LteSignalingRadioBearerInfo', parent=root_module['ns3::LteRadioBearerInfo'])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::LteSpectrumPhy [class]
-    module.add_class('LteSpectrumPhy', parent=root_module['ns3::SpectrumPhy'])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::LteSpectrumPhy::State [enumeration]
-    module.add_enum('State', ['IDLE', 'TX_DL_CTRL', 'TX_DATA', 'TX_UL_SRS', 'RX_DL_CTRL', 'RX_DATA', 'RX_UL_SRS'], outer_class=root_module['ns3::LteSpectrumPhy'])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParameters [struct]
-    module.add_class('LteSpectrumSignalParameters', parent=root_module['ns3::SpectrumSignalParameters'])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDataFrame [struct]
-    module.add_class('LteSpectrumSignalParametersDataFrame', parent=root_module['ns3::SpectrumSignalParameters'])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDlCtrlFrame [struct]
-    module.add_class('LteSpectrumSignalParametersDlCtrlFrame', parent=root_module['ns3::SpectrumSignalParameters'])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersUlSrsFrame [struct]
-    module.add_class('LteSpectrumSignalParametersUlSrsFrame', parent=root_module['ns3::SpectrumSignalParameters'])
-    ## lte-stats-calculator.h (module 'lte'): ns3::LteStatsCalculator [class]
-    module.add_class('LteStatsCalculator', parent=root_module['ns3::Object'])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeComponentCarrierManager [class]
-    module.add_class('LteUeComponentCarrierManager', parent=root_module['ns3::Object'])
-    ## lte-ue-mac.h (module 'lte'): ns3::LteUeMac [class]
-    module.add_class('LteUeMac', parent=root_module['ns3::Object'])
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUePhy [class]
-    module.add_class('LteUePhy', parent=root_module['ns3::LtePhy'])
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUePhy::State [enumeration]
-    module.add_enum('State', ['CELL_SEARCH', 'SYNCHRONIZED', 'NUM_STATES'], outer_class=root_module['ns3::LteUePhy'])
-    ## lte-ue-power-control.h (module 'lte'): ns3::LteUePowerControl [class]
-    module.add_class('LteUePowerControl', parent=root_module['ns3::Object'])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc [class]
-    module.add_class('LteUeRrc', parent=root_module['ns3::Object'])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::State [enumeration]
-    module.add_enum('State', ['IDLE_START', 'IDLE_CELL_SEARCH', 'IDLE_WAIT_MIB_SIB1', 'IDLE_WAIT_MIB', 'IDLE_WAIT_SIB1', 'IDLE_CAMPED_NORMALLY', 'IDLE_WAIT_SIB2', 'IDLE_RANDOM_ACCESS', 'IDLE_CONNECTING', 'CONNECTED_NORMALLY', 'CONNECTED_HANDOVER', 'CONNECTED_PHY_PROBLEM', 'CONNECTED_REESTABLISHING', 'NUM_STATES'], outer_class=root_module['ns3::LteUeRrc'])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteUeRrcProtocolIdeal [class]
-    module.add_class('LteUeRrcProtocolIdeal', parent=root_module['ns3::Object'])
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteUeRrcProtocolReal [class]
-    module.add_class('LteUeRrcProtocolReal', parent=root_module['ns3::Object'])
-    ## mac48-address.h (module 'network'): ns3::Mac48AddressChecker [class]
-    module.add_class('Mac48AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
-    ## mac48-address.h (module 'network'): ns3::Mac48AddressValue [class]
-    module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
-    ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator [class]
-    module.add_class('MacStatsCalculator', parent=root_module['ns3::LteStatsCalculator'])
-    ## lte-control-messages.h (module 'lte'): ns3::MibLteControlMessage [class]
-    module.add_class('MibLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned int> [class]
-    module.add_class('MinMaxAvgTotalCalculator', import_from_module='ns.stats', template_parameters=['unsigned int'], parent=[root_module['ns3::DataCalculator'], root_module['ns3::StatisticalSummary']])
-    ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned long long> [class]
-    module.add_class('MinMaxAvgTotalCalculator', import_from_module='ns.stats', template_parameters=['unsigned long long'], parent=[root_module['ns3::DataCalculator'], root_module['ns3::StatisticalSummary']])
-    ## mobility-model.h (module 'mobility'): ns3::MobilityModel [class]
-    module.add_class('MobilityModel', import_from_module='ns.mobility', parent=root_module['ns3::Object'])
-    ## net-device.h (module 'network'): ns3::NetDevice [class]
-    module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    ## net-device.h (module 'network'): ns3::NetDevice::PacketType [enumeration]
-    module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
-    ## nix-vector.h (module 'network'): ns3::NixVector [class]
-    module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::NoOpComponentCarrierManager [class]
-    module.add_class('NoOpComponentCarrierManager', parent=root_module['ns3::LteEnbComponentCarrierManager'])
-    ## no-op-handover-algorithm.h (module 'lte'): ns3::NoOpHandoverAlgorithm [class]
-    module.add_class('NoOpHandoverAlgorithm', parent=root_module['ns3::LteHandoverAlgorithm'])
-    ## node.h (module 'network'): ns3::Node [class]
-    module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    ## random-variable-stream.h (module 'core'): ns3::NormalRandomVariable [class]
-    module.add_class('NormalRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## object-factory.h (module 'core'): ns3::ObjectFactoryChecker [class]
-    module.add_class('ObjectFactoryChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## object-factory.h (module 'core'): ns3::ObjectFactoryValue [class]
-    module.add_class('ObjectFactoryValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## packet.h (module 'network'): ns3::Packet [class]
-    module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
-    ## random-variable-stream.h (module 'core'): ns3::ParetoRandomVariable [class]
-    module.add_class('ParetoRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::PfFfMacScheduler [class]
-    module.add_class('PfFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## phy-rx-stats-calculator.h (module 'lte'): ns3::PhyRxStatsCalculator [class]
-    module.add_class('PhyRxStatsCalculator', parent=root_module['ns3::LteStatsCalculator'])
-    ## phy-stats-calculator.h (module 'lte'): ns3::PhyStatsCalculator [class]
-    module.add_class('PhyStatsCalculator', parent=root_module['ns3::LteStatsCalculator'])
-    ## phy-tx-stats-calculator.h (module 'lte'): ns3::PhyTxStatsCalculator [class]
-    module.add_class('PhyTxStatsCalculator', parent=root_module['ns3::LteStatsCalculator'])
-    ## point-to-point-epc-helper.h (module 'lte'): ns3::PointToPointEpcHelper [class]
-    module.add_class('PointToPointEpcHelper', parent=root_module['ns3::EpcHelper'])
-    ## pointer.h (module 'core'): ns3::PointerChecker [class]
-    module.add_class('PointerChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## pointer.h (module 'core'): ns3::PointerValue [class]
-    module.add_class('PointerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::PssFfMacScheduler [class]
-    module.add_class('PssFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## lte-control-messages.h (module 'lte'): ns3::RachPreambleLteControlMessage [class]
-    module.add_class('RachPreambleLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## radio-bearer-stats-calculator.h (module 'lte'): ns3::RadioBearerStatsCalculator [class]
-    module.add_class('RadioBearerStatsCalculator', parent=root_module['ns3::LteStatsCalculator'])
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage [class]
-    module.add_class('RarLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage::Rar [struct]
-    module.add_class('Rar', outer_class=root_module['ns3::RarLteControlMessage'])
-    ## rem-spectrum-phy.h (module 'lte'): ns3::RemSpectrumPhy [class]
-    module.add_class('RemSpectrumPhy', parent=root_module['ns3::SpectrumPhy'])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::RrComponentCarrierManager [class]
-    module.add_class('RrComponentCarrierManager', parent=root_module['ns3::NoOpComponentCarrierManager'])
-    ## rr-ff-mac-scheduler.h (module 'lte'): ns3::RrFfMacScheduler [class]
-    module.add_class('RrFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcAsn1Header [class]
-    module.add_class('RrcAsn1Header', parent=root_module['ns3::Asn1Header'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcDlCcchMessage [class]
-    module.add_class('RrcDlCcchMessage', parent=root_module['ns3::RrcAsn1Header'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcDlDcchMessage [class]
-    module.add_class('RrcDlDcchMessage', parent=root_module['ns3::RrcAsn1Header'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcUlCcchMessage [class]
-    module.add_class('RrcUlCcchMessage', parent=root_module['ns3::RrcAsn1Header'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcUlDcchMessage [class]
-    module.add_class('RrcUlDcchMessage', parent=root_module['ns3::RrcAsn1Header'])
-    ## lte-control-messages.h (module 'lte'): ns3::Sib1LteControlMessage [class]
-    module.add_class('Sib1LteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::SimpleUeComponentCarrierManager [class]
-    module.add_class('SimpleUeComponentCarrierManager', parent=root_module['ns3::LteUeComponentCarrierManager'])
-    ## spectrum-channel.h (module 'spectrum'): ns3::SpectrumChannel [class]
-    module.add_class('SpectrumChannel', import_from_module='ns.spectrum', parent=root_module['ns3::Channel'])
-    ## lte-vendor-specific-parameters.h (module 'lte'): ns3::SrsCqiRntiVsp [class]
-    module.add_class('SrsCqiRntiVsp', parent=root_module['ns3::VendorSpecificValue'])
-    ## string.h (module 'core'): ns3::StringChecker [class]
-    module.add_class('StringChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## string.h (module 'core'): ns3::StringValue [class]
-    module.add_class('StringValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::TdBetFfMacScheduler [class]
-    module.add_class('TdBetFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): ns3::TdMtFfMacScheduler [class]
-    module.add_class('TdMtFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::TdTbfqFfMacScheduler [class]
-    module.add_class('TdTbfqFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## nstime.h (module 'core'): ns3::TimeValue [class]
-    module.add_class('TimeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## tta-ff-mac-scheduler.h (module 'lte'): ns3::TtaFfMacScheduler [class]
-    module.add_class('TtaFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## type-id.h (module 'core'): ns3::TypeIdChecker [class]
-    module.add_class('TypeIdChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## type-id.h (module 'core'): ns3::TypeIdValue [class]
-    module.add_class('TypeIdValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## uinteger.h (module 'core'): ns3::UintegerValue [class]
-    module.add_class('UintegerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## lte-control-messages.h (module 'lte'): ns3::UlDciLteControlMessage [class]
-    module.add_class('UlDciLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## vector.h (module 'core'): ns3::Vector2DChecker [class]
-    module.add_class('Vector2DChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## vector.h (module 'core'): ns3::Vector2DValue [class]
-    module.add_class('Vector2DValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## vector.h (module 'core'): ns3::Vector3DChecker [class]
-    module.add_class('Vector3DChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
-    ## vector.h (module 'core'): ns3::Vector3DValue [class]
-    module.add_class('Vector3DValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::VirtualNetDevice [class]
-    module.add_class('VirtualNetDevice', import_from_module='ns.virtual_net_device', parent=root_module['ns3::NetDevice'])
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): ns3::A2A4RsrqHandoverAlgorithm [class]
-    module.add_class('A2A4RsrqHandoverAlgorithm', parent=root_module['ns3::LteHandoverAlgorithm'])
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): ns3::A3RsrpHandoverAlgorithm [class]
-    module.add_class('A3RsrpHandoverAlgorithm', parent=root_module['ns3::LteHandoverAlgorithm'])
-    ## address.h (module 'network'): ns3::AddressChecker [class]
-    module.add_class('AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
-    ## address.h (module 'network'): ns3::AddressValue [class]
-    module.add_class('AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
-    ## lte-control-messages.h (module 'lte'): ns3::BsrLteControlMessage [class]
-    module.add_class('BsrLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<const ns3::Packet>', 'unsigned short', 'const ns3::Address &', 'const ns3::Address &', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<const ns3::Packet>', 'unsigned short', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['bool', 'ns3::Ptr<ns3::Packet>', 'const ns3::Address &', 'const ns3::Address &', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['bool', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['ns3::ObjectBase *', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'const ns3::SpectrumValue &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'ns3::DlSchedulingCallbackInfo', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'ns3::EpcUeNas::State', 'ns3::EpcUeNas::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'ns3::PhyReceptionStatParameters', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'ns3::PhyTransmissionStatParameters', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::MobilityModel>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::Packet>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::PacketBurst>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<const ns3::Packet>', 'unsigned short', 'const ns3::Address &', 'const ns3::Address &', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::NetDevice>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Packet>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Socket>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Socket>', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned long long', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'unsigned long long', 'unsigned short', 'unsigned short', 'ns3::LteRrcSap::MeasurementReport', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'unsigned long long', 'unsigned short', 'unsigned short', 'ns3::LteUeRrc::State', 'ns3::LteUeRrc::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'unsigned long long', 'unsigned short', 'unsigned short', 'ns3::UeManager::State', 'ns3::UeManager::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned long long', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned long long', 'unsigned short', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'ns3::Ptr<ns3::SpectrumValue>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned long long', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'double', 'double', 'bool', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'double', 'double', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'double', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'double', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'unsigned short', 'unsigned short', 'ns3::LteUePhy::State', 'ns3::LteUePhy::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqaFfMacScheduler [class]
-    module.add_class('CqaFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## lte-control-messages.h (module 'lte'): ns3::DlCqiLteControlMessage [class]
-    module.add_class('DlCqiLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## lte-control-messages.h (module 'lte'): ns3::DlDciLteControlMessage [class]
-    module.add_class('DlDciLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## lte-control-messages.h (module 'lte'): ns3::DlHarqFeedbackLteControlMessage [class]
-    module.add_class('DlHarqFeedbackLteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## emu-epc-helper.h (module 'lte'): ns3::EmuEpcHelper [class]
-    module.add_class('EmuEpcHelper', parent=root_module['ns3::EpcHelper'])
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::FdBetFfMacScheduler [class]
-    module.add_class('FdBetFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): ns3::FdMtFfMacScheduler [class]
-    module.add_class('FdMtFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::FdTbfqFfMacScheduler [class]
-    module.add_class('FdTbfqFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
-    ## lte-rrc-header.h (module 'lte'): ns3::HandoverPreparationInfoHeader [class]
-    module.add_class('HandoverPreparationInfoHeader', parent=root_module['ns3::RrcAsn1Header'])
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo [class]
-    module.add_class('LteDataRadioBearerInfo', parent=root_module['ns3::LteRadioBearerInfo'])
-    ## lte-enb-phy.h (module 'lte'): ns3::LteEnbPhy [class]
-    module.add_class('LteEnbPhy', parent=root_module['ns3::LtePhy'])
-    ## lte-net-device.h (module 'lte'): ns3::LteNetDevice [class]
-    module.add_class('LteNetDevice', parent=root_module['ns3::NetDevice'])
-    ## lte-ue-net-device.h (module 'lte'): ns3::LteUeNetDevice [class]
-    module.add_class('LteUeNetDevice', parent=root_module['ns3::LteNetDevice'])
-    ## lte-rrc-header.h (module 'lte'): ns3::MeasurementReportHeader [class]
-    module.add_class('MeasurementReportHeader', parent=root_module['ns3::RrcUlDcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationCompleteHeader [class]
-    module.add_class('RrcConnectionReconfigurationCompleteHeader', parent=root_module['ns3::RrcUlDcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationHeader [class]
-    module.add_class('RrcConnectionReconfigurationHeader', parent=root_module['ns3::RrcDlDcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentCompleteHeader [class]
-    module.add_class('RrcConnectionReestablishmentCompleteHeader', parent=root_module['ns3::RrcUlDcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentHeader [class]
-    module.add_class('RrcConnectionReestablishmentHeader', parent=root_module['ns3::RrcDlCcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentRejectHeader [class]
-    module.add_class('RrcConnectionReestablishmentRejectHeader', parent=root_module['ns3::RrcDlCcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentRequestHeader [class]
-    module.add_class('RrcConnectionReestablishmentRequestHeader', parent=root_module['ns3::RrcUlCcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionRejectHeader [class]
-    module.add_class('RrcConnectionRejectHeader', parent=root_module['ns3::RrcDlCcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReleaseHeader [class]
-    module.add_class('RrcConnectionReleaseHeader', parent=root_module['ns3::RrcDlDcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionRequestHeader [class]
-    module.add_class('RrcConnectionRequestHeader', parent=root_module['ns3::RrcUlCcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupCompleteHeader [class]
-    module.add_class('RrcConnectionSetupCompleteHeader', parent=root_module['ns3::RrcUlDcchMessage'])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupHeader [class]
-    module.add_class('RrcConnectionSetupHeader', parent=root_module['ns3::RrcDlCcchMessage'])
-    ## lte-enb-net-device.h (module 'lte'): ns3::LteEnbNetDevice [class]
-    module.add_class('LteEnbNetDevice', parent=root_module['ns3::LteNetDevice'])
-    module.add_container('std::vector< ns3::CeBitmap_e >', 'ns3::CeBitmap_e', container_type=u'vector')
-    module.add_container('std::vector< std::vector< ns3::RlcPduListElement_s > >', 'std::vector< ns3::RlcPduListElement_s >', container_type=u'vector')
-    module.add_container('std::vector< unsigned char >', 'unsigned char', container_type=u'vector')
-    module.add_container('std::vector< unsigned short >', 'short unsigned int', container_type=u'vector')
-    module.add_container('std::vector< ns3::DlInfoListElement_s::HarqStatus_e >', 'ns3::DlInfoListElement_s::HarqStatus_e', container_type=u'vector')
-    module.add_container('std::list< ns3::EpcEnbS1SapProvider::BearerToBeSwitched >', 'ns3::EpcEnbS1SapProvider::BearerToBeSwitched', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS11SapMme::BearerContextCreated >', 'ns3::EpcS11SapMme::BearerContextCreated', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS11SapMme::BearerContextRemoved >', 'ns3::EpcS11SapMme::BearerContextRemoved', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextToBeCreated >', 'ns3::EpcS11SapSgw::BearerContextToBeCreated', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextToBeRemoved >', 'ns3::EpcS11SapSgw::BearerContextToBeRemoved', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw >', 'ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapEnb::ErabToBeSetupItem >', 'ns3::EpcS1apSapEnb::ErabToBeSetupItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem >', 'ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabToBeReleasedIndication >', 'ns3::EpcS1apSapMme::ErabToBeReleasedIndication', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabSetupItem >', 'ns3::EpcS1apSapMme::ErabSetupItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem >', 'ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem', container_type=u'list')
-    module.add_container('std::vector< bool >', 'bool', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem >', 'ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::UlHighInterferenceInformationItem >', 'ns3::EpcX2Sap::UlHighInterferenceInformationItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 'ns3::EpcX2Sap::ErabToBeSetupItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 'ns3::EpcX2Sap::ErabAdmittedItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 'ns3::EpcX2Sap::ErabNotAdmittedItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem >', 'ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::CellInformationItem >', 'ns3::EpcX2Sap::CellInformationItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 'ns3::EpcX2Sap::CellMeasurementResultItem', container_type=u'vector')
-    module.add_container('std::vector< ns3::VendorSpecificListElement_s >', 'ns3::VendorSpecificListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::LogicalChannelConfigListElement_s >', 'ns3::LogicalChannelConfigListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::PagingInfoListElement_s >', 'ns3::PagingInfoListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::DlInfoListElement_s >', 'ns3::DlInfoListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::RachListElement_s >', 'ns3::RachListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::CqiListElement_s >', 'ns3::CqiListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::UlInfoListElement_s >', 'ns3::UlInfoListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::SrListElement_s >', 'ns3::SrListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::MacCeListElement_s >', 'ns3::MacCeListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::BuildDataListElement_s >', 'ns3::BuildDataListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::BuildRarListElement_s >', 'ns3::BuildRarListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::BuildBroadcastListElement_s >', 'ns3::BuildBroadcastListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::UlDciListElement_s >', 'ns3::UlDciListElement_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::PhichListElement_s >', 'ns3::PhichListElement_s', container_type=u'vector')
-    module.add_container('std::map< std::string, ns3::LogComponent * >', ('std::string', 'ns3::LogComponent *'), container_type=u'map')
-    module.add_container('std::vector< ns3::LteCcmRrcSapProvider::LcsConfig >', 'ns3::LteCcmRrcSapProvider::LcsConfig', container_type=u'vector')
-    module.add_container('std::vector< ns3::LteRrcSap::LogicalChannelConfig >', 'ns3::LteRrcSap::LogicalChannelConfig', container_type=u'vector')
-    module.add_container('std::map< unsigned short, std::vector< double > >', ('short unsigned int', 'std::vector< double >'), container_type=u'map')
-    module.add_container('std::vector< int >', 'int', container_type=u'vector')
-    module.add_container('ns3::HarqProcessInfoList_t', 'ns3::HarqProcessInfoElement_t', container_type=u'vector')
-    module.add_container('std::list< ns3::LteRrcSap::SrbToAddMod >', 'ns3::LteRrcSap::SrbToAddMod', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::DrbToAddMod >', 'ns3::LteRrcSap::DrbToAddMod', container_type=u'list')
-    module.add_container('std::list< unsigned char >', 'unsigned char', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::CellsToAddMod >', 'ns3::LteRrcSap::CellsToAddMod', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::BlackCellsToAddMod >', 'ns3::LteRrcSap::BlackCellsToAddMod', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::MeasObjectToAddMod >', 'ns3::LteRrcSap::MeasObjectToAddMod', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::ReportConfigToAddMod >', 'ns3::LteRrcSap::ReportConfigToAddMod', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::MeasIdToAddMod >', 'ns3::LteRrcSap::MeasIdToAddMod', container_type=u'list')
-    module.add_container('std::list< unsigned int >', 'unsigned int', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::MeasResultScell >', 'ns3::LteRrcSap::MeasResultScell', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::MeasResultBestNeighCell >', 'ns3::LteRrcSap::MeasResultBestNeighCell', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::MeasResultEutra >', 'ns3::LteRrcSap::MeasResultEutra', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::SCellToAddMod >', 'ns3::LteRrcSap::SCellToAddMod', container_type=u'list')
-    module.add_container('std::map< int, double >', ('int', 'double'), container_type=u'map')
-    module.add_container('std::vector< ns3::LteUeCcmRrcSapProvider::LcsConfig >', 'ns3::LteUeCcmRrcSapProvider::LcsConfig', container_type=u'vector')
-    module.add_container('std::vector< ns3::LteUeCphySapUser::UeMeasurementsElement >', 'ns3::LteUeCphySapUser::UeMeasurementsElement', container_type=u'vector')
-    module.add_container('std::vector< ns3::HigherLayerSelected_s >', 'ns3::HigherLayerSelected_s', container_type=u'vector')
-    module.add_container('std::vector< ns3::SiMessageListElement_s >', 'ns3::SiMessageListElement_s', container_type=u'vector')
-    module.add_container('std::list< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type=u'list')
-    module.add_container('std::vector< ns3::Ipv6Address >', 'ns3::Ipv6Address', container_type=u'vector')
-    module.add_container('std::vector< double >', 'double', container_type=u'vector')
-    module.add_container('ns3::Bands', 'ns3::BandInfo', container_type=u'vector')
-    module.add_container('std::map< unsigned char, ns3::ComponentCarrier >', ('unsigned char', 'ns3::ComponentCarrier'), container_type=u'map')
-    module.add_container('std::map< unsigned int, unsigned int >', ('unsigned int', 'unsigned int'), container_type=u'map')
-    module.add_container('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', ('unsigned char', 'ns3::Ptr< ns3::ComponentCarrierEnb >'), container_type=u'map')
-    module.add_container('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'ns3::Ptr< ns3::LteControlMessage >', container_type=u'list')
-    module.add_container('std::list< ns3::UlDciLteControlMessage >', 'ns3::UlDciLteControlMessage', container_type=u'list')
-    module.add_container('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierUe > >', ('unsigned char', 'ns3::Ptr< ns3::ComponentCarrierUe >'), container_type=u'map')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >', u'ns3::DlHarqProcessesStatus_t')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >*', u'ns3::DlHarqProcessesStatus_t*')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >&', u'ns3::DlHarqProcessesStatus_t&')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >', u'ns3::DlHarqProcessesTimer_t')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >*', u'ns3::DlHarqProcessesTimer_t*')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >&', u'ns3::DlHarqProcessesTimer_t&')
-    typehandlers.add_type_alias(u'std::vector< ns3::DlDciListElement_s, std::allocator< ns3::DlDciListElement_s > >', u'ns3::DlHarqProcessesDciBuffer_t')
-    typehandlers.add_type_alias(u'std::vector< ns3::DlDciListElement_s, std::allocator< ns3::DlDciListElement_s > >*', u'ns3::DlHarqProcessesDciBuffer_t*')
-    typehandlers.add_type_alias(u'std::vector< ns3::DlDciListElement_s, std::allocator< ns3::DlDciListElement_s > >&', u'ns3::DlHarqProcessesDciBuffer_t&')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > >', u'ns3::RlcPduList_t')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > >*', u'ns3::RlcPduList_t*')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > >&', u'ns3::RlcPduList_t&')
-    typehandlers.add_type_alias(u'std::vector< std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > >, std::allocator< std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > > > >', u'ns3::DlHarqRlcPduListBuffer_t')
-    typehandlers.add_type_alias(u'std::vector< std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > >, std::allocator< std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > > > >*', u'ns3::DlHarqRlcPduListBuffer_t*')
-    typehandlers.add_type_alias(u'std::vector< std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > >, std::allocator< std::vector< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > >, std::allocator< std::vector< ns3::RlcPduListElement_s, std::allocator< ns3::RlcPduListElement_s > > > > > >&', u'ns3::DlHarqRlcPduListBuffer_t&')
-    typehandlers.add_type_alias(u'std::vector< ns3::UlDciListElement_s, std::allocator< ns3::UlDciListElement_s > >', u'ns3::UlHarqProcessesDciBuffer_t')
-    typehandlers.add_type_alias(u'std::vector< ns3::UlDciListElement_s, std::allocator< ns3::UlDciListElement_s > >*', u'ns3::UlHarqProcessesDciBuffer_t*')
-    typehandlers.add_type_alias(u'std::vector< ns3::UlDciListElement_s, std::allocator< ns3::UlDciListElement_s > >&', u'ns3::UlHarqProcessesDciBuffer_t&')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >', u'ns3::UlHarqProcessesStatus_t')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >*', u'ns3::UlHarqProcessesStatus_t*')
-    typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >&', u'ns3::UlHarqProcessesStatus_t&')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, unsigned int, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, unsigned int > > >', u'ns3::Uint32Map')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, unsigned int, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, unsigned int > > >*', u'ns3::Uint32Map*')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, unsigned int, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, unsigned int > > >&', u'ns3::Uint32Map&')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, unsigned long long, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, unsigned long long > > >', u'ns3::Uint64Map')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, unsigned long long, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, unsigned long long > > >*', u'ns3::Uint64Map*')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, unsigned long long, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, unsigned long long > > >&', u'ns3::Uint64Map&')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned int > >, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned int > > > > >', u'ns3::Uint32StatsMap')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned int > >, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned int > > > > >*', u'ns3::Uint32StatsMap*')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned int > >, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned int > > > > >&', u'ns3::Uint32StatsMap&')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned long long > >, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned long long > > > > >', u'ns3::Uint64StatsMap')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned long long > >, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned long long > > > > >*', u'ns3::Uint64StatsMap*')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned long long > >, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::Ptr< ns3::MinMaxAvgTotalCalculator< unsigned long long > > > > >&', u'ns3::Uint64StatsMap&')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, double, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, double > > >', u'ns3::DoubleMap')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, double, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, double > > >*', u'ns3::DoubleMap*')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, double, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, double > > >&', u'ns3::DoubleMap&')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::LteFlowId_t, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::LteFlowId_t > > >', u'ns3::FlowIdMap')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::LteFlowId_t, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::LteFlowId_t > > >*', u'ns3::FlowIdMap*')
-    typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::LteFlowId_t, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::LteFlowId_t > > >&', u'ns3::FlowIdMap&')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >', u'ns3::DlHarqProcessesBuffer_t')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >*', u'ns3::DlHarqProcessesBuffer_t*')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >&', u'ns3::DlHarqProcessesBuffer_t&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LteChunkProcessorCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LteChunkProcessorCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LteChunkProcessorCallback&')
-    typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t, std::less< ns3::TbId_t >, std::allocator< std::pair< ns3::TbId_t const, ns3::tbInfo_t > > >', u'ns3::expectedTbs_t')
-    typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t, std::less< ns3::TbId_t >, std::allocator< std::pair< ns3::TbId_t const, ns3::tbInfo_t > > >*', u'ns3::expectedTbs_t*')
-    typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t, std::less< ns3::TbId_t >, std::allocator< std::pair< ns3::TbId_t const, ns3::tbInfo_t > > >&', u'ns3::expectedTbs_t&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyRxDataEndErrorCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyRxDataEndErrorCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyRxDataEndErrorCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyRxDataEndOkCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyRxDataEndOkCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyRxDataEndOkCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, std::list< ns3::Ptr< ns3::LteControlMessage >, std::allocator< ns3::Ptr< ns3::LteControlMessage > > >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyRxCtrlEndOkCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, std::list< ns3::Ptr< ns3::LteControlMessage >, std::allocator< ns3::Ptr< ns3::LteControlMessage > > >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyRxCtrlEndOkCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, std::list< ns3::Ptr< ns3::LteControlMessage >, std::allocator< ns3::Ptr< ns3::LteControlMessage > > >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyRxCtrlEndOkCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyRxCtrlEndErrorCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyRxCtrlEndErrorCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyRxCtrlEndErrorCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, unsigned short, ns3::Ptr< ns3::SpectrumValue >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyRxPssCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, unsigned short, ns3::Ptr< ns3::SpectrumValue >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyRxPssCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, unsigned short, ns3::Ptr< ns3::SpectrumValue >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyRxPssCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::DlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyDlHarqFeedbackCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::DlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyDlHarqFeedbackCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::DlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyDlHarqFeedbackCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::UlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyUlHarqFeedbackCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::UlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyUlHarqFeedbackCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::UlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyUlHarqFeedbackCallback&')
-    typehandlers.add_type_alias(u'std::vector< ns3::HarqProcessInfoElement_t, std::allocator< ns3::HarqProcessInfoElement_t > >', u'ns3::HarqProcessInfoList_t')
-    typehandlers.add_type_alias(u'std::vector< ns3::HarqProcessInfoElement_t, std::allocator< ns3::HarqProcessInfoElement_t > >*', u'ns3::HarqProcessInfoList_t*')
-    typehandlers.add_type_alias(u'std::vector< ns3::HarqProcessInfoElement_t, std::allocator< ns3::HarqProcessInfoElement_t > >&', u'ns3::HarqProcessInfoList_t&')
-    typehandlers.add_type_alias(u'void ( * ) ( std::ostream & )', u'ns3::LogTimePrinter')
-    typehandlers.add_type_alias(u'void ( * ) ( std::ostream & )*', u'ns3::LogTimePrinter*')
-    typehandlers.add_type_alias(u'void ( * ) ( std::ostream & )&', u'ns3::LogTimePrinter&')
-    typehandlers.add_type_alias(u'void ( * ) ( std::ostream & )', u'ns3::LogNodePrinter')
-    typehandlers.add_type_alias(u'void ( * ) ( std::ostream & )*', u'ns3::LogNodePrinter*')
-    typehandlers.add_type_alias(u'void ( * ) ( std::ostream & )&', u'ns3::LogNodePrinter&')
-    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::GenericPhyTxStartCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::GenericPhyTxStartCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< bool, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::GenericPhyTxStartCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::GenericPhyTxEndCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::GenericPhyTxEndCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::GenericPhyTxEndCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::GenericPhyRxStartCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::GenericPhyRxStartCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::GenericPhyRxStartCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::GenericPhyRxEndErrorCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::GenericPhyRxEndErrorCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::GenericPhyRxEndErrorCallback&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::GenericPhyRxEndOkCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::GenericPhyRxEndOkCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::GenericPhyRxEndOkCallback&')
-    typehandlers.add_type_alias(u'ns3::Vector3D', u'ns3::Vector')
-    typehandlers.add_type_alias(u'ns3::Vector3D*', u'ns3::Vector*')
-    typehandlers.add_type_alias(u'ns3::Vector3D&', u'ns3::Vector&')
-    module.add_typedef(root_module['ns3::Vector3D'], 'Vector')
-    typehandlers.add_type_alias(u'ns3::Vector3DValue', u'ns3::VectorValue')
-    typehandlers.add_type_alias(u'ns3::Vector3DValue*', u'ns3::VectorValue*')
-    typehandlers.add_type_alias(u'ns3::Vector3DValue&', u'ns3::VectorValue&')
-    module.add_typedef(root_module['ns3::Vector3DValue'], 'VectorValue')
-    typehandlers.add_type_alias(u'ns3::Vector3DChecker', u'ns3::VectorChecker')
-    typehandlers.add_type_alias(u'ns3::Vector3DChecker*', u'ns3::VectorChecker*')
-    typehandlers.add_type_alias(u'ns3::Vector3DChecker&', u'ns3::VectorChecker&')
-    module.add_typedef(root_module['ns3::Vector3DChecker'], 'VectorChecker')
-    typehandlers.add_type_alias(u'std::vector< double, std::allocator< double > >', u'ns3::Values')
-    typehandlers.add_type_alias(u'std::vector< double, std::allocator< double > >*', u'ns3::Values*')
-    typehandlers.add_type_alias(u'std::vector< double, std::allocator< double > >&', u'ns3::Values&')
-    typehandlers.add_type_alias(u'std::vector< ns3::BandInfo, std::allocator< ns3::BandInfo > >', u'ns3::Bands')
-    typehandlers.add_type_alias(u'std::vector< ns3::BandInfo, std::allocator< ns3::BandInfo > >*', u'ns3::Bands*')
-    typehandlers.add_type_alias(u'std::vector< ns3::BandInfo, std::allocator< ns3::BandInfo > >&', u'ns3::Bands&')
-    typehandlers.add_type_alias(u'uint32_t', u'ns3::SpectrumModelUid_t')
-    typehandlers.add_type_alias(u'uint32_t*', u'ns3::SpectrumModelUid_t*')
-    typehandlers.add_type_alias(u'uint32_t&', u'ns3::SpectrumModelUid_t&')
-    
-    ## Register a nested module for the namespace Config
-    
-    nested_module = module.add_cpp_namespace('Config')
-    register_types_ns3_Config(nested_module)
-    
-    
-    ## Register a nested module for the namespace FatalImpl
-    
-    nested_module = module.add_cpp_namespace('FatalImpl')
-    register_types_ns3_FatalImpl(nested_module)
-    
-    
-    ## Register a nested module for the namespace Hash
-    
-    nested_module = module.add_cpp_namespace('Hash')
-    register_types_ns3_Hash(nested_module)
-    
-    
-    ## Register a nested module for the namespace TracedValueCallback
-    
-    nested_module = module.add_cpp_namespace('TracedValueCallback')
-    register_types_ns3_TracedValueCallback(nested_module)
-    
-    
-    ## Register a nested module for the namespace internal
-    
-    nested_module = module.add_cpp_namespace('internal')
-    register_types_ns3_internal(nested_module)
-    
-
-def register_types_ns3_Config(module):
-    root_module = module.get_root()
-    
-    ## config.h (module 'core'): ns3::Config::MatchContainer [class]
-    module.add_class('MatchContainer', import_from_module='ns.core')
-    module.add_container('std::vector< ns3::Ptr< ns3::Object > >', 'ns3::Ptr< ns3::Object >', container_type=u'vector')
-    module.add_container('std::vector< std::string >', 'std::string', container_type=u'vector')
-
-def register_types_ns3_FatalImpl(module):
-    root_module = module.get_root()
-    
-
-def register_types_ns3_Hash(module):
-    root_module = module.get_root()
-    
-    ## hash-function.h (module 'core'): ns3::Hash::Implementation [class]
-    module.add_class('Implementation', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >'])
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash32Function_ptr')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash32Function_ptr*')
-    typehandlers.add_type_alias(u'uint32_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash32Function_ptr&')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )', u'ns3::Hash::Hash64Function_ptr')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )*', u'ns3::Hash::Hash64Function_ptr*')
-    typehandlers.add_type_alias(u'uint64_t ( * ) ( char const *, size_t const )&', u'ns3::Hash::Hash64Function_ptr&')
-    
-    ## Register a nested module for the namespace Function
-    
-    nested_module = module.add_cpp_namespace('Function')
-    register_types_ns3_Hash_Function(nested_module)
-    
-
-def register_types_ns3_Hash_Function(module):
-    root_module = module.get_root()
-    
-    ## hash-fnv.h (module 'core'): ns3::Hash::Function::Fnv1a [class]
-    module.add_class('Fnv1a', import_from_module='ns.core', parent=root_module['ns3::Hash::Implementation'])
-    ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32 [class]
-    module.add_class('Hash32', import_from_module='ns.core', parent=root_module['ns3::Hash::Implementation'])
-    ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64 [class]
-    module.add_class('Hash64', import_from_module='ns.core', parent=root_module['ns3::Hash::Implementation'])
-    ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3 [class]
-    module.add_class('Murmur3', import_from_module='ns.core', parent=root_module['ns3::Hash::Implementation'])
-
-def register_types_ns3_TracedValueCallback(module):
-    root_module = module.get_root()
-    
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time, ns3::Time )', u'ns3::TracedValueCallback::Time')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time, ns3::Time )*', u'ns3::TracedValueCallback::Time*')
-    typehandlers.add_type_alias(u'void ( * ) ( ns3::Time, ns3::Time )&', u'ns3::TracedValueCallback::Time&')
-    typehandlers.add_type_alias(u'void ( * ) ( bool, bool )', u'ns3::TracedValueCallback::Bool')
-    typehandlers.add_type_alias(u'void ( * ) ( bool, bool )*', u'ns3::TracedValueCallback::Bool*')
-    typehandlers.add_type_alias(u'void ( * ) ( bool, bool )&', u'ns3::TracedValueCallback::Bool&')
-    typehandlers.add_type_alias(u'void ( * ) ( int8_t, int8_t )', u'ns3::TracedValueCallback::Int8')
-    typehandlers.add_type_alias(u'void ( * ) ( int8_t, int8_t )*', u'ns3::TracedValueCallback::Int8*')
-    typehandlers.add_type_alias(u'void ( * ) ( int8_t, int8_t )&', u'ns3::TracedValueCallback::Int8&')
-    typehandlers.add_type_alias(u'void ( * ) ( uint8_t, uint8_t )', u'ns3::TracedValueCallback::Uint8')
-    typehandlers.add_type_alias(u'void ( * ) ( uint8_t, uint8_t )*', u'ns3::TracedValueCallback::Uint8*')
-    typehandlers.add_type_alias(u'void ( * ) ( uint8_t, uint8_t )&', u'ns3::TracedValueCallback::Uint8&')
-    typehandlers.add_type_alias(u'void ( * ) ( int16_t, int16_t )', u'ns3::TracedValueCallback::Int16')
-    typehandlers.add_type_alias(u'void ( * ) ( int16_t, int16_t )*', u'ns3::TracedValueCallback::Int16*')
-    typehandlers.add_type_alias(u'void ( * ) ( int16_t, int16_t )&', u'ns3::TracedValueCallback::Int16&')
-    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint16_t )', u'ns3::TracedValueCallback::Uint16')
-    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint16_t )*', u'ns3::TracedValueCallback::Uint16*')
-    typehandlers.add_type_alias(u'void ( * ) ( uint16_t, uint16_t )&', u'ns3::TracedValueCallback::Uint16&')
-    typehandlers.add_type_alias(u'void ( * ) ( int32_t, int32_t )', u'ns3::TracedValueCallback::Int32')
-    typehandlers.add_type_alias(u'void ( * ) ( int32_t, int32_t )*', u'ns3::TracedValueCallback::Int32*')
-    typehandlers.add_type_alias(u'void ( * ) ( int32_t, int32_t )&', u'ns3::TracedValueCallback::Int32&')
-    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )', u'ns3::TracedValueCallback::Uint32')
-    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )*', u'ns3::TracedValueCallback::Uint32*')
-    typehandlers.add_type_alias(u'void ( * ) ( uint32_t, uint32_t )&', u'ns3::TracedValueCallback::Uint32&')
-    typehandlers.add_type_alias(u'void ( * ) ( double, double )', u'ns3::TracedValueCallback::Double')
-    typehandlers.add_type_alias(u'void ( * ) ( double, double )*', u'ns3::TracedValueCallback::Double*')
-    typehandlers.add_type_alias(u'void ( * ) ( double, double )&', u'ns3::TracedValueCallback::Double&')
-    typehandlers.add_type_alias(u'void ( * ) (  )', u'ns3::TracedValueCallback::Void')
-    typehandlers.add_type_alias(u'void ( * ) (  )*', u'ns3::TracedValueCallback::Void*')
-    typehandlers.add_type_alias(u'void ( * ) (  )&', u'ns3::TracedValueCallback::Void&')
-
-def register_types_ns3_internal(module):
-    root_module = module.get_root()
-    
-
-def register_methods(root_module):
-    register_Ns3Address_methods(root_module, root_module['ns3::Address'])
-    register_Ns3AllocationRetentionPriority_methods(root_module, root_module['ns3::AllocationRetentionPriority'])
-    register_Ns3AttributeConstructionList_methods(root_module, root_module['ns3::AttributeConstructionList'])
-    register_Ns3AttributeConstructionListItem_methods(root_module, root_module['ns3::AttributeConstructionList::Item'])
-    register_Ns3BandInfo_methods(root_module, root_module['ns3::BandInfo'])
-    register_Ns3Buffer_methods(root_module, root_module['ns3::Buffer'])
-    register_Ns3BufferIterator_methods(root_module, root_module['ns3::Buffer::Iterator'])
-    register_Ns3BufferSizeLevelBsr_methods(root_module, root_module['ns3::BufferSizeLevelBsr'])
-    register_Ns3BuildBroadcastListElement_s_methods(root_module, root_module['ns3::BuildBroadcastListElement_s'])
-    register_Ns3BuildDataListElement_s_methods(root_module, root_module['ns3::BuildDataListElement_s'])
-    register_Ns3BuildRarListElement_s_methods(root_module, root_module['ns3::BuildRarListElement_s'])
-    register_Ns3BwPart_s_methods(root_module, root_module['ns3::BwPart_s'])
-    register_Ns3ByteTagIterator_methods(root_module, root_module['ns3::ByteTagIterator'])
-    register_Ns3ByteTagIteratorItem_methods(root_module, root_module['ns3::ByteTagIterator::Item'])
-    register_Ns3ByteTagList_methods(root_module, root_module['ns3::ByteTagList'])
-    register_Ns3ByteTagListIterator_methods(root_module, root_module['ns3::ByteTagList::Iterator'])
-    register_Ns3ByteTagListIteratorItem_methods(root_module, root_module['ns3::ByteTagList::Iterator::Item'])
-    register_Ns3CallbackBase_methods(root_module, root_module['ns3::CallbackBase'])
-    register_Ns3CqasFlowPerf_t_methods(root_module, root_module['ns3::CqasFlowPerf_t'])
-    register_Ns3CqiConfig_s_methods(root_module, root_module['ns3::CqiConfig_s'])
-    register_Ns3CqiListElement_s_methods(root_module, root_module['ns3::CqiListElement_s'])
-    register_Ns3DataOutputCallback_methods(root_module, root_module['ns3::DataOutputCallback'])
-    register_Ns3DataRate_methods(root_module, root_module['ns3::DataRate'])
-    register_Ns3DefaultDeleter__Ns3AttributeAccessor_methods(root_module, root_module['ns3::DefaultDeleter< ns3::AttributeAccessor >'])
-    register_Ns3DefaultDeleter__Ns3AttributeChecker_methods(root_module, root_module['ns3::DefaultDeleter< ns3::AttributeChecker >'])
-    register_Ns3DefaultDeleter__Ns3AttributeValue_methods(root_module, root_module['ns3::DefaultDeleter< ns3::AttributeValue >'])
-    register_Ns3DefaultDeleter__Ns3CallbackImplBase_methods(root_module, root_module['ns3::DefaultDeleter< ns3::CallbackImplBase >'])
-    register_Ns3DefaultDeleter__Ns3EpcTft_methods(root_module, root_module['ns3::DefaultDeleter< ns3::EpcTft >'])
-    register_Ns3DefaultDeleter__Ns3EventImpl_methods(root_module, root_module['ns3::DefaultDeleter< ns3::EventImpl >'])
-    register_Ns3DefaultDeleter__Ns3HashImplementation_methods(root_module, root_module['ns3::DefaultDeleter< ns3::Hash::Implementation >'])
-    register_Ns3DefaultDeleter__Ns3LteChunkProcessor_methods(root_module, root_module['ns3::DefaultDeleter< ns3::LteChunkProcessor >'])
-    register_Ns3DefaultDeleter__Ns3LteControlMessage_methods(root_module, root_module['ns3::DefaultDeleter< ns3::LteControlMessage >'])
-    register_Ns3DefaultDeleter__Ns3LteHarqPhy_methods(root_module, root_module['ns3::DefaultDeleter< ns3::LteHarqPhy >'])
-    register_Ns3DefaultDeleter__Ns3NixVector_methods(root_module, root_module['ns3::DefaultDeleter< ns3::NixVector >'])
-    register_Ns3DefaultDeleter__Ns3Packet_methods(root_module, root_module['ns3::DefaultDeleter< ns3::Packet >'])
-    register_Ns3DefaultDeleter__Ns3SpectrumModel_methods(root_module, root_module['ns3::DefaultDeleter< ns3::SpectrumModel >'])
-    register_Ns3DefaultDeleter__Ns3SpectrumValue_methods(root_module, root_module['ns3::DefaultDeleter< ns3::SpectrumValue >'])
-    register_Ns3DefaultDeleter__Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::DefaultDeleter< ns3::TraceSourceAccessor >'])
-    register_Ns3DefaultDeleter__Ns3VendorSpecificValue_methods(root_module, root_module['ns3::DefaultDeleter< ns3::VendorSpecificValue >'])
-    register_Ns3DefaultDeleter__Ns3X2CellInfo_methods(root_module, root_module['ns3::DefaultDeleter< ns3::X2CellInfo >'])
-    register_Ns3DefaultDeleter__Ns3X2IfaceInfo_methods(root_module, root_module['ns3::DefaultDeleter< ns3::X2IfaceInfo >'])
-    register_Ns3DlDciListElement_s_methods(root_module, root_module['ns3::DlDciListElement_s'])
-    register_Ns3DlInfoListElement_s_methods(root_module, root_module['ns3::DlInfoListElement_s'])
-    register_Ns3DlSchedulingCallbackInfo_methods(root_module, root_module['ns3::DlSchedulingCallbackInfo'])
-    register_Ns3DrxConfig_s_methods(root_module, root_module['ns3::DrxConfig_s'])
-    register_Ns3EpcEnbS1SapProvider_methods(root_module, root_module['ns3::EpcEnbS1SapProvider'])
-    register_Ns3EpcEnbS1SapProviderBearerToBeSwitched_methods(root_module, root_module['ns3::EpcEnbS1SapProvider::BearerToBeSwitched'])
-    register_Ns3EpcEnbS1SapProviderPathSwitchRequestParameters_methods(root_module, root_module['ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters'])
-    register_Ns3EpcEnbS1SapUser_methods(root_module, root_module['ns3::EpcEnbS1SapUser'])
-    register_Ns3EpcEnbS1SapUserDataRadioBearerSetupRequestParameters_methods(root_module, root_module['ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters'])
-    register_Ns3EpcEnbS1SapUserPathSwitchRequestAcknowledgeParameters_methods(root_module, root_module['ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters'])
-    register_Ns3EpcS11Sap_methods(root_module, root_module['ns3::EpcS11Sap'])
-    register_Ns3EpcS11SapFteid_methods(root_module, root_module['ns3::EpcS11Sap::Fteid'])
-    register_Ns3EpcS11SapGtpcMessage_methods(root_module, root_module['ns3::EpcS11Sap::GtpcMessage'])
-    register_Ns3EpcS11SapUli_methods(root_module, root_module['ns3::EpcS11Sap::Uli'])
-    register_Ns3EpcS11SapMme_methods(root_module, root_module['ns3::EpcS11SapMme'])
-    register_Ns3EpcS11SapMmeBearerContextCreated_methods(root_module, root_module['ns3::EpcS11SapMme::BearerContextCreated'])
-    register_Ns3EpcS11SapMmeBearerContextRemoved_methods(root_module, root_module['ns3::EpcS11SapMme::BearerContextRemoved'])
-    register_Ns3EpcS11SapMmeCreateSessionResponseMessage_methods(root_module, root_module['ns3::EpcS11SapMme::CreateSessionResponseMessage'])
-    register_Ns3EpcS11SapMmeDeleteBearerRequestMessage_methods(root_module, root_module['ns3::EpcS11SapMme::DeleteBearerRequestMessage'])
-    register_Ns3EpcS11SapMmeModifyBearerResponseMessage_methods(root_module, root_module['ns3::EpcS11SapMme::ModifyBearerResponseMessage'])
-    register_Ns3EpcS11SapSgw_methods(root_module, root_module['ns3::EpcS11SapSgw'])
-    register_Ns3EpcS11SapSgwBearerContextRemovedSgwPgw_methods(root_module, root_module['ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw'])
-    register_Ns3EpcS11SapSgwBearerContextToBeCreated_methods(root_module, root_module['ns3::EpcS11SapSgw::BearerContextToBeCreated'])
-    register_Ns3EpcS11SapSgwBearerContextToBeRemoved_methods(root_module, root_module['ns3::EpcS11SapSgw::BearerContextToBeRemoved'])
-    register_Ns3EpcS11SapSgwCreateSessionRequestMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::CreateSessionRequestMessage'])
-    register_Ns3EpcS11SapSgwDeleteBearerCommandMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::DeleteBearerCommandMessage'])
-    register_Ns3EpcS11SapSgwDeleteBearerResponseMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::DeleteBearerResponseMessage'])
-    register_Ns3EpcS11SapSgwModifyBearerRequestMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::ModifyBearerRequestMessage'])
-    register_Ns3EpcS1apSap_methods(root_module, root_module['ns3::EpcS1apSap'])
-    register_Ns3EpcS1apSapEnb_methods(root_module, root_module['ns3::EpcS1apSapEnb'])
-    register_Ns3EpcS1apSapEnbErabSwitchedInUplinkItem_methods(root_module, root_module['ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem'])
-    register_Ns3EpcS1apSapEnbErabToBeSetupItem_methods(root_module, root_module['ns3::EpcS1apSapEnb::ErabToBeSetupItem'])
-    register_Ns3EpcS1apSapMme_methods(root_module, root_module['ns3::EpcS1apSapMme'])
-    register_Ns3EpcS1apSapMmeErabSetupItem_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabSetupItem'])
-    register_Ns3EpcS1apSapMmeErabSwitchedInDownlinkItem_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem'])
-    register_Ns3EpcS1apSapMmeErabToBeReleasedIndication_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabToBeReleasedIndication'])
-    register_Ns3EpcX2Sap_methods(root_module, root_module['ns3::EpcX2Sap'])
-    register_Ns3EpcX2SapCellInformationItem_methods(root_module, root_module['ns3::EpcX2Sap::CellInformationItem'])
-    register_Ns3EpcX2SapCellMeasurementResultItem_methods(root_module, root_module['ns3::EpcX2Sap::CellMeasurementResultItem'])
-    register_Ns3EpcX2SapCompositeAvailCapacity_methods(root_module, root_module['ns3::EpcX2Sap::CompositeAvailCapacity'])
-    register_Ns3EpcX2SapErabAdmittedItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabAdmittedItem'])
-    register_Ns3EpcX2SapErabNotAdmittedItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabNotAdmittedItem'])
-    register_Ns3EpcX2SapErabToBeSetupItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabToBeSetupItem'])
-    register_Ns3EpcX2SapErabsSubjectToStatusTransferItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem'])
-    register_Ns3EpcX2SapHandoverPreparationFailureParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverPreparationFailureParams'])
-    register_Ns3EpcX2SapHandoverRequestAckParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverRequestAckParams'])
-    register_Ns3EpcX2SapHandoverRequestParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverRequestParams'])
-    register_Ns3EpcX2SapLoadInformationParams_methods(root_module, root_module['ns3::EpcX2Sap::LoadInformationParams'])
-    register_Ns3EpcX2SapRelativeNarrowbandTxBand_methods(root_module, root_module['ns3::EpcX2Sap::RelativeNarrowbandTxBand'])
-    register_Ns3EpcX2SapResourceStatusUpdateParams_methods(root_module, root_module['ns3::EpcX2Sap::ResourceStatusUpdateParams'])
-    register_Ns3EpcX2SapSnStatusTransferParams_methods(root_module, root_module['ns3::EpcX2Sap::SnStatusTransferParams'])
-    register_Ns3EpcX2SapUeContextReleaseParams_methods(root_module, root_module['ns3::EpcX2Sap::UeContextReleaseParams'])
-    register_Ns3EpcX2SapUeDataParams_methods(root_module, root_module['ns3::EpcX2Sap::UeDataParams'])
-    register_Ns3EpcX2SapUlHighInterferenceInformationItem_methods(root_module, root_module['ns3::EpcX2Sap::UlHighInterferenceInformationItem'])
-    register_Ns3EpcX2SapProvider_methods(root_module, root_module['ns3::EpcX2SapProvider'])
-    register_Ns3EpcX2SapUser_methods(root_module, root_module['ns3::EpcX2SapUser'])
-    register_Ns3EpsBearer_methods(root_module, root_module['ns3::EpsBearer'])
-    register_Ns3EutranMeasurementMapping_methods(root_module, root_module['ns3::EutranMeasurementMapping'])
-    register_Ns3EventId_methods(root_module, root_module['ns3::EventId'])
-    register_Ns3FfMacCschedSapProvider_methods(root_module, root_module['ns3::FfMacCschedSapProvider'])
-    register_Ns3FfMacCschedSapProviderCschedCellConfigReqParameters_methods(root_module, root_module['ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters'])
-    register_Ns3FfMacCschedSapProviderCschedLcConfigReqParameters_methods(root_module, root_module['ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters'])
-    register_Ns3FfMacCschedSapProviderCschedLcReleaseReqParameters_methods(root_module, root_module['ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters'])
-    register_Ns3FfMacCschedSapProviderCschedUeConfigReqParameters_methods(root_module, root_module['ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters'])
-    register_Ns3FfMacCschedSapProviderCschedUeReleaseReqParameters_methods(root_module, root_module['ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters'])
-    register_Ns3FfMacCschedSapUser_methods(root_module, root_module['ns3::FfMacCschedSapUser'])
-    register_Ns3FfMacCschedSapUserCschedCellConfigCnfParameters_methods(root_module, root_module['ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters'])
-    register_Ns3FfMacCschedSapUserCschedCellConfigUpdateIndParameters_methods(root_module, root_module['ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters'])
-    register_Ns3FfMacCschedSapUserCschedLcConfigCnfParameters_methods(root_module, root_module['ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters'])
-    register_Ns3FfMacCschedSapUserCschedLcReleaseCnfParameters_methods(root_module, root_module['ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters'])
-    register_Ns3FfMacCschedSapUserCschedUeConfigCnfParameters_methods(root_module, root_module['ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters'])
-    register_Ns3FfMacCschedSapUserCschedUeConfigUpdateIndParameters_methods(root_module, root_module['ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters'])
-    register_Ns3FfMacCschedSapUserCschedUeReleaseCnfParameters_methods(root_module, root_module['ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters'])
-    register_Ns3FfMacSchedSapProvider_methods(root_module, root_module['ns3::FfMacSchedSapProvider'])
-    register_Ns3FfMacSchedSapProviderSchedDlCqiInfoReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedDlMacBufferReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedDlPagingBufferReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedDlRachInfoReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedDlRlcBufferReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedDlTriggerReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedUlCqiInfoReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedUlMacCtrlInfoReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedUlNoiseInterferenceReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedUlSrInfoReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters'])
-    register_Ns3FfMacSchedSapProviderSchedUlTriggerReqParameters_methods(root_module, root_module['ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters'])
-    register_Ns3FfMacSchedSapUser_methods(root_module, root_module['ns3::FfMacSchedSapUser'])
-    register_Ns3FfMacSchedSapUserSchedDlConfigIndParameters_methods(root_module, root_module['ns3::FfMacSchedSapUser::SchedDlConfigIndParameters'])
-    register_Ns3FfMacSchedSapUserSchedUlConfigIndParameters_methods(root_module, root_module['ns3::FfMacSchedSapUser::SchedUlConfigIndParameters'])
-    register_Ns3GbrQosInformation_methods(root_module, root_module['ns3::GbrQosInformation'])
-    register_Ns3HarqProcessInfoElement_t_methods(root_module, root_module['ns3::HarqProcessInfoElement_t'])
-    register_Ns3Hasher_methods(root_module, root_module['ns3::Hasher'])
-    register_Ns3HigherLayerSelected_s_methods(root_module, root_module['ns3::HigherLayerSelected_s'])
-    register_Ns3ImsiLcidPair_t_methods(root_module, root_module['ns3::ImsiLcidPair_t'])
-    register_Ns3Inet6SocketAddress_methods(root_module, root_module['ns3::Inet6SocketAddress'])
-    register_Ns3InetSocketAddress_methods(root_module, root_module['ns3::InetSocketAddress'])
-    register_Ns3Ipv4Address_methods(root_module, root_module['ns3::Ipv4Address'])
-    register_Ns3Ipv4AddressHelper_methods(root_module, root_module['ns3::Ipv4AddressHelper'])
-    register_Ns3Ipv4InterfaceAddress_methods(root_module, root_module['ns3::Ipv4InterfaceAddress'])
-    register_Ns3Ipv4InterfaceContainer_methods(root_module, root_module['ns3::Ipv4InterfaceContainer'])
-    register_Ns3Ipv4Mask_methods(root_module, root_module['ns3::Ipv4Mask'])
-    register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])
-    register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])
-    register_Ns3LogComponent_methods(root_module, root_module['ns3::LogComponent'])
-    register_Ns3LogicalChannelConfigListElement_s_methods(root_module, root_module['ns3::LogicalChannelConfigListElement_s'])
-    register_Ns3LteAnrSapProvider_methods(root_module, root_module['ns3::LteAnrSapProvider'])
-    register_Ns3LteAnrSapUser_methods(root_module, root_module['ns3::LteAnrSapUser'])
-    register_Ns3LteAsSapProvider_methods(root_module, root_module['ns3::LteAsSapProvider'])
-    register_Ns3LteAsSapUser_methods(root_module, root_module['ns3::LteAsSapUser'])
-    register_Ns3LteCcmMacSapProvider_methods(root_module, root_module['ns3::LteCcmMacSapProvider'])
-    register_Ns3LteCcmRrcSapProvider_methods(root_module, root_module['ns3::LteCcmRrcSapProvider'])
-    register_Ns3LteCcmRrcSapProviderLcsConfig_methods(root_module, root_module['ns3::LteCcmRrcSapProvider::LcsConfig'])
-    register_Ns3LteCcmRrcSapUser_methods(root_module, root_module['ns3::LteCcmRrcSapUser'])
-    register_Ns3LteEnbCmacSapProvider_methods(root_module, root_module['ns3::LteEnbCmacSapProvider'])
-    register_Ns3LteEnbCmacSapProviderAllocateNcRaPreambleReturnValue_methods(root_module, root_module['ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue'])
-    register_Ns3LteEnbCmacSapProviderLcInfo_methods(root_module, root_module['ns3::LteEnbCmacSapProvider::LcInfo'])
-    register_Ns3LteEnbCmacSapProviderRachConfig_methods(root_module, root_module['ns3::LteEnbCmacSapProvider::RachConfig'])
-    register_Ns3LteEnbCmacSapProviderUeConfig_methods(root_module, root_module['ns3::LteEnbCmacSapProvider::UeConfig'])
-    register_Ns3LteEnbCmacSapUser_methods(root_module, root_module['ns3::LteEnbCmacSapUser'])
-    register_Ns3LteEnbCmacSapUserUeConfig_methods(root_module, root_module['ns3::LteEnbCmacSapUser::UeConfig'])
-    register_Ns3LteEnbCphySapProvider_methods(root_module, root_module['ns3::LteEnbCphySapProvider'])
-    register_Ns3LteEnbCphySapUser_methods(root_module, root_module['ns3::LteEnbCphySapUser'])
-    register_Ns3LteEnbPhySapProvider_methods(root_module, root_module['ns3::LteEnbPhySapProvider'])
-    register_Ns3LteEnbPhySapUser_methods(root_module, root_module['ns3::LteEnbPhySapUser'])
-    register_Ns3LteFfConverter_methods(root_module, root_module['ns3::LteFfConverter'])
-    register_Ns3LteFfrRrcSapProvider_methods(root_module, root_module['ns3::LteFfrRrcSapProvider'])
-    register_Ns3LteFfrRrcSapUser_methods(root_module, root_module['ns3::LteFfrRrcSapUser'])
-    register_Ns3LteFfrSapProvider_methods(root_module, root_module['ns3::LteFfrSapProvider'])
-    register_Ns3LteFfrSapUser_methods(root_module, root_module['ns3::LteFfrSapUser'])
-    register_Ns3LteFlowId_t_methods(root_module, root_module['ns3::LteFlowId_t'])
-    register_Ns3LteGlobalPathlossDatabase_methods(root_module, root_module['ns3::LteGlobalPathlossDatabase'])
-    register_Ns3LteHandoverManagementSapProvider_methods(root_module, root_module['ns3::LteHandoverManagementSapProvider'])
-    register_Ns3LteHandoverManagementSapUser_methods(root_module, root_module['ns3::LteHandoverManagementSapUser'])
-    register_Ns3LteMacSapProvider_methods(root_module, root_module['ns3::LteMacSapProvider'])
-    register_Ns3LteMacSapProviderReportBufferStatusParameters_methods(root_module, root_module['ns3::LteMacSapProvider::ReportBufferStatusParameters'])
-    register_Ns3LteMacSapProviderTransmitPduParameters_methods(root_module, root_module['ns3::LteMacSapProvider::TransmitPduParameters'])
-    register_Ns3LteMacSapUser_methods(root_module, root_module['ns3::LteMacSapUser'])
-    register_Ns3LteMiErrorModel_methods(root_module, root_module['ns3::LteMiErrorModel'])
-    register_Ns3LtePdcpSapProvider_methods(root_module, root_module['ns3::LtePdcpSapProvider'])
-    register_Ns3LtePdcpSapProviderTransmitPdcpSduParameters_methods(root_module, root_module['ns3::LtePdcpSapProvider::TransmitPdcpSduParameters'])
-    register_Ns3LtePdcpSapUser_methods(root_module, root_module['ns3::LtePdcpSapUser'])
-    register_Ns3LtePdcpSapUserReceivePdcpSduParameters_methods(root_module, root_module['ns3::LtePdcpSapUser::ReceivePdcpSduParameters'])
-    register_Ns3LteRlcSapProvider_methods(root_module, root_module['ns3::LteRlcSapProvider'])
-    register_Ns3LteRlcSapProviderTransmitPdcpPduParameters_methods(root_module, root_module['ns3::LteRlcSapProvider::TransmitPdcpPduParameters'])
-    register_Ns3LteRlcSapUser_methods(root_module, root_module['ns3::LteRlcSapUser'])
-    register_Ns3LteRrcSap_methods(root_module, root_module['ns3::LteRrcSap'])
-    register_Ns3LteRrcSapAntennaInfoCommon_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoCommon'])
-    register_Ns3LteRrcSapAntennaInfoDedicated_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoDedicated'])
-    register_Ns3LteRrcSapAntennaInfoUl_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoUl'])
-    register_Ns3LteRrcSapAsConfig_methods(root_module, root_module['ns3::LteRrcSap::AsConfig'])
-    register_Ns3LteRrcSapBlackCellsToAddMod_methods(root_module, root_module['ns3::LteRrcSap::BlackCellsToAddMod'])
-    register_Ns3LteRrcSapCarrierBandwidthEutra_methods(root_module, root_module['ns3::LteRrcSap::CarrierBandwidthEutra'])
-    register_Ns3LteRrcSapCarrierFreqEutra_methods(root_module, root_module['ns3::LteRrcSap::CarrierFreqEutra'])
-    register_Ns3LteRrcSapCellAccessRelatedInfo_methods(root_module, root_module['ns3::LteRrcSap::CellAccessRelatedInfo'])
-    register_Ns3LteRrcSapCellIdentification_methods(root_module, root_module['ns3::LteRrcSap::CellIdentification'])
-    register_Ns3LteRrcSapCellSelectionInfo_methods(root_module, root_module['ns3::LteRrcSap::CellSelectionInfo'])
-    register_Ns3LteRrcSapCellsToAddMod_methods(root_module, root_module['ns3::LteRrcSap::CellsToAddMod'])
-    register_Ns3LteRrcSapCgiInfo_methods(root_module, root_module['ns3::LteRrcSap::CgiInfo'])
-    register_Ns3LteRrcSapDrbToAddMod_methods(root_module, root_module['ns3::LteRrcSap::DrbToAddMod'])
-    register_Ns3LteRrcSapFreqInfo_methods(root_module, root_module['ns3::LteRrcSap::FreqInfo'])
-    register_Ns3LteRrcSapHandoverPreparationInfo_methods(root_module, root_module['ns3::LteRrcSap::HandoverPreparationInfo'])
-    register_Ns3LteRrcSapLogicalChannelConfig_methods(root_module, root_module['ns3::LteRrcSap::LogicalChannelConfig'])
-    register_Ns3LteRrcSapMasterInformationBlock_methods(root_module, root_module['ns3::LteRrcSap::MasterInformationBlock'])
-    register_Ns3LteRrcSapMeasConfig_methods(root_module, root_module['ns3::LteRrcSap::MeasConfig'])
-    register_Ns3LteRrcSapMeasGapConfig_methods(root_module, root_module['ns3::LteRrcSap::MeasGapConfig'])
-    register_Ns3LteRrcSapMeasIdToAddMod_methods(root_module, root_module['ns3::LteRrcSap::MeasIdToAddMod'])
-    register_Ns3LteRrcSapMeasObjectEutra_methods(root_module, root_module['ns3::LteRrcSap::MeasObjectEutra'])
-    register_Ns3LteRrcSapMeasObjectToAddMod_methods(root_module, root_module['ns3::LteRrcSap::MeasObjectToAddMod'])
-    register_Ns3LteRrcSapMeasResultBestNeighCell_methods(root_module, root_module['ns3::LteRrcSap::MeasResultBestNeighCell'])
-    register_Ns3LteRrcSapMeasResultEutra_methods(root_module, root_module['ns3::LteRrcSap::MeasResultEutra'])
-    register_Ns3LteRrcSapMeasResultScell_methods(root_module, root_module['ns3::LteRrcSap::MeasResultScell'])
-    register_Ns3LteRrcSapMeasResultServFreqList_methods(root_module, root_module['ns3::LteRrcSap::MeasResultServFreqList'])
-    register_Ns3LteRrcSapMeasResults_methods(root_module, root_module['ns3::LteRrcSap::MeasResults'])
-    register_Ns3LteRrcSapMeasurementReport_methods(root_module, root_module['ns3::LteRrcSap::MeasurementReport'])
-    register_Ns3LteRrcSapMobilityControlInfo_methods(root_module, root_module['ns3::LteRrcSap::MobilityControlInfo'])
-    register_Ns3LteRrcSapMobilityStateParameters_methods(root_module, root_module['ns3::LteRrcSap::MobilityStateParameters'])
-    register_Ns3LteRrcSapNonCriticalExtensionConfiguration_methods(root_module, root_module['ns3::LteRrcSap::NonCriticalExtensionConfiguration'])
-    register_Ns3LteRrcSapNonUlConfiguration_methods(root_module, root_module['ns3::LteRrcSap::NonUlConfiguration'])
-    register_Ns3LteRrcSapPdschConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::PdschConfigCommon'])
-    register_Ns3LteRrcSapPdschConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::PdschConfigDedicated'])
-    register_Ns3LteRrcSapPhysCellIdRange_methods(root_module, root_module['ns3::LteRrcSap::PhysCellIdRange'])
-    register_Ns3LteRrcSapPhysicalConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::PhysicalConfigDedicated'])
-    register_Ns3LteRrcSapPhysicalConfigDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::PhysicalConfigDedicatedSCell'])
-    register_Ns3LteRrcSapPlmnIdentityInfo_methods(root_module, root_module['ns3::LteRrcSap::PlmnIdentityInfo'])
-    register_Ns3LteRrcSapPrachConfigSCell_methods(root_module, root_module['ns3::LteRrcSap::PrachConfigSCell'])
-    register_Ns3LteRrcSapPreambleInfo_methods(root_module, root_module['ns3::LteRrcSap::PreambleInfo'])
-    register_Ns3LteRrcSapPuschConfigDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::PuschConfigDedicatedSCell'])
-    register_Ns3LteRrcSapQuantityConfig_methods(root_module, root_module['ns3::LteRrcSap::QuantityConfig'])
-    register_Ns3LteRrcSapRaSupervisionInfo_methods(root_module, root_module['ns3::LteRrcSap::RaSupervisionInfo'])
-    register_Ns3LteRrcSapRachConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::RachConfigCommon'])
-    register_Ns3LteRrcSapRachConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::RachConfigDedicated'])
-    register_Ns3LteRrcSapRadioResourceConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigCommon'])
-    register_Ns3LteRrcSapRadioResourceConfigCommonSCell_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigCommonSCell'])
-    register_Ns3LteRrcSapRadioResourceConfigCommonSib_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigCommonSib'])
-    register_Ns3LteRrcSapRadioResourceConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigDedicated'])
-    register_Ns3LteRrcSapRadioResourceConfigDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigDedicatedSCell'])
-    register_Ns3LteRrcSapReestabUeIdentity_methods(root_module, root_module['ns3::LteRrcSap::ReestabUeIdentity'])
-    register_Ns3LteRrcSapReportConfigEutra_methods(root_module, root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    register_Ns3LteRrcSapReportConfigToAddMod_methods(root_module, root_module['ns3::LteRrcSap::ReportConfigToAddMod'])
-    register_Ns3LteRrcSapRlcConfig_methods(root_module, root_module['ns3::LteRrcSap::RlcConfig'])
-    register_Ns3LteRrcSapRrcConnectionReconfiguration_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionReconfiguration'])
-    register_Ns3LteRrcSapRrcConnectionReconfigurationCompleted_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionReconfigurationCompleted'])
-    register_Ns3LteRrcSapRrcConnectionReestablishment_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionReestablishment'])
-    register_Ns3LteRrcSapRrcConnectionReestablishmentComplete_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionReestablishmentComplete'])
-    register_Ns3LteRrcSapRrcConnectionReestablishmentReject_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionReestablishmentReject'])
-    register_Ns3LteRrcSapRrcConnectionReestablishmentRequest_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionReestablishmentRequest'])
-    register_Ns3LteRrcSapRrcConnectionReject_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionReject'])
-    register_Ns3LteRrcSapRrcConnectionRelease_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionRelease'])
-    register_Ns3LteRrcSapRrcConnectionRequest_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionRequest'])
-    register_Ns3LteRrcSapRrcConnectionSetup_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSetup'])
-    register_Ns3LteRrcSapRrcConnectionSetupCompleted_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSetupCompleted'])
-    register_Ns3LteRrcSapSCellToAddMod_methods(root_module, root_module['ns3::LteRrcSap::SCellToAddMod'])
-    register_Ns3LteRrcSapSoundingRsUlConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::SoundingRsUlConfigCommon'])
-    register_Ns3LteRrcSapSoundingRsUlConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::SoundingRsUlConfigDedicated'])
-    register_Ns3LteRrcSapSpeedStatePars_methods(root_module, root_module['ns3::LteRrcSap::SpeedStatePars'])
-    register_Ns3LteRrcSapSpeedStateScaleFactors_methods(root_module, root_module['ns3::LteRrcSap::SpeedStateScaleFactors'])
-    register_Ns3LteRrcSapSrbToAddMod_methods(root_module, root_module['ns3::LteRrcSap::SrbToAddMod'])
-    register_Ns3LteRrcSapSystemInformation_methods(root_module, root_module['ns3::LteRrcSap::SystemInformation'])
-    register_Ns3LteRrcSapSystemInformationBlockType1_methods(root_module, root_module['ns3::LteRrcSap::SystemInformationBlockType1'])
-    register_Ns3LteRrcSapSystemInformationBlockType2_methods(root_module, root_module['ns3::LteRrcSap::SystemInformationBlockType2'])
-    register_Ns3LteRrcSapThresholdEutra_methods(root_module, root_module['ns3::LteRrcSap::ThresholdEutra'])
-    register_Ns3LteRrcSapUlConfiguration_methods(root_module, root_module['ns3::LteRrcSap::UlConfiguration'])
-    register_Ns3LteRrcSapUlPowerControlCommonSCell_methods(root_module, root_module['ns3::LteRrcSap::UlPowerControlCommonSCell'])
-    register_Ns3LteRrcSapUlPowerControlDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::UlPowerControlDedicatedSCell'])
-    register_Ns3LteSpectrumValueCatcher_methods(root_module, root_module['ns3::LteSpectrumValueCatcher'])
-    register_Ns3LteSpectrumValueHelper_methods(root_module, root_module['ns3::LteSpectrumValueHelper'])
-    register_Ns3LteUeCcmRrcSapProvider_methods(root_module, root_module['ns3::LteUeCcmRrcSapProvider'])
-    register_Ns3LteUeCcmRrcSapProviderLcsConfig_methods(root_module, root_module['ns3::LteUeCcmRrcSapProvider::LcsConfig'])
-    register_Ns3LteUeCcmRrcSapUser_methods(root_module, root_module['ns3::LteUeCcmRrcSapUser'])
-    register_Ns3LteUeCmacSapProvider_methods(root_module, root_module['ns3::LteUeCmacSapProvider'])
-    register_Ns3LteUeCmacSapProviderLogicalChannelConfig_methods(root_module, root_module['ns3::LteUeCmacSapProvider::LogicalChannelConfig'])
-    register_Ns3LteUeCmacSapProviderRachConfig_methods(root_module, root_module['ns3::LteUeCmacSapProvider::RachConfig'])
-    register_Ns3LteUeCmacSapUser_methods(root_module, root_module['ns3::LteUeCmacSapUser'])
-    register_Ns3LteUeConfig_t_methods(root_module, root_module['ns3::LteUeConfig_t'])
-    register_Ns3LteUeCphySapProvider_methods(root_module, root_module['ns3::LteUeCphySapProvider'])
-    register_Ns3LteUeCphySapUser_methods(root_module, root_module['ns3::LteUeCphySapUser'])
-    register_Ns3LteUeCphySapUserUeMeasurementsElement_methods(root_module, root_module['ns3::LteUeCphySapUser::UeMeasurementsElement'])
-    register_Ns3LteUeCphySapUserUeMeasurementsParameters_methods(root_module, root_module['ns3::LteUeCphySapUser::UeMeasurementsParameters'])
-    register_Ns3LteUePhySapProvider_methods(root_module, root_module['ns3::LteUePhySapProvider'])
-    register_Ns3LteUePhySapUser_methods(root_module, root_module['ns3::LteUePhySapUser'])
-    register_Ns3LteUeRrcSapProvider_methods(root_module, root_module['ns3::LteUeRrcSapProvider'])
-    register_Ns3LteUeRrcSapProviderCompleteSetupParameters_methods(root_module, root_module['ns3::LteUeRrcSapProvider::CompleteSetupParameters'])
-    register_Ns3LteUeRrcSapUser_methods(root_module, root_module['ns3::LteUeRrcSapUser'])
-    register_Ns3LteUeRrcSapUserSetupParameters_methods(root_module, root_module['ns3::LteUeRrcSapUser::SetupParameters'])
-    register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])
-    register_Ns3MacCeListElement_s_methods(root_module, root_module['ns3::MacCeListElement_s'])
-    register_Ns3MacCeValue_u_methods(root_module, root_module['ns3::MacCeValue_u'])
-    register_Ns3Names_methods(root_module, root_module['ns3::Names'])
-    register_Ns3NetDeviceContainer_methods(root_module, root_module['ns3::NetDeviceContainer'])
-    register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])
-    register_Ns3ObjectBase_methods(root_module, root_module['ns3::ObjectBase'])
-    register_Ns3ObjectDeleter_methods(root_module, root_module['ns3::ObjectDeleter'])
-    register_Ns3ObjectFactory_methods(root_module, root_module['ns3::ObjectFactory'])
-    register_Ns3PacketMetadata_methods(root_module, root_module['ns3::PacketMetadata'])
-    register_Ns3PacketMetadataItem_methods(root_module, root_module['ns3::PacketMetadata::Item'])
-    register_Ns3PacketMetadataItemIterator_methods(root_module, root_module['ns3::PacketMetadata::ItemIterator'])
-    register_Ns3PacketTagIterator_methods(root_module, root_module['ns3::PacketTagIterator'])
-    register_Ns3PacketTagIteratorItem_methods(root_module, root_module['ns3::PacketTagIterator::Item'])
-    register_Ns3PacketTagList_methods(root_module, root_module['ns3::PacketTagList'])
-    register_Ns3PacketTagListTagData_methods(root_module, root_module['ns3::PacketTagList::TagData'])
-    register_Ns3PagingInfoListElement_s_methods(root_module, root_module['ns3::PagingInfoListElement_s'])
-    register_Ns3ParameterLogger_methods(root_module, root_module['ns3::ParameterLogger'])
-    register_Ns3PhichListElement_s_methods(root_module, root_module['ns3::PhichListElement_s'])
-    register_Ns3PhyReceptionStatParameters_methods(root_module, root_module['ns3::PhyReceptionStatParameters'])
-    register_Ns3PhyTransmissionStatParameters_methods(root_module, root_module['ns3::PhyTransmissionStatParameters'])
-    register_Ns3RachListElement_s_methods(root_module, root_module['ns3::RachListElement_s'])
-    register_Ns3RadioBearerStatsConnector_methods(root_module, root_module['ns3::RadioBearerStatsConnector'])
-    register_Ns3RealProtocolRlcSapUser_methods(root_module, root_module['ns3::RealProtocolRlcSapUser'])
-    register_Ns3RlcPduListElement_s_methods(root_module, root_module['ns3::RlcPduListElement_s'])
-    register_Ns3SbMeasResult_s_methods(root_module, root_module['ns3::SbMeasResult_s'])
-    register_Ns3SequenceNumber10_methods(root_module, root_module['ns3::SequenceNumber10'])
-    register_Ns3SiConfiguration_s_methods(root_module, root_module['ns3::SiConfiguration_s'])
-    register_Ns3SiMessageListElement_s_methods(root_module, root_module['ns3::SiMessageListElement_s'])
-    register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])
-    register_Ns3Simulator_methods(root_module, root_module['ns3::Simulator'])
-    register_Ns3SpsConfig_s_methods(root_module, root_module['ns3::SpsConfig_s'])
-    register_Ns3SrConfig_s_methods(root_module, root_module['ns3::SrConfig_s'])
-    register_Ns3SrListElement_s_methods(root_module, root_module['ns3::SrListElement_s'])
-    register_Ns3StatisticalSummary_methods(root_module, root_module['ns3::StatisticalSummary'])
-    register_Ns3Tag_methods(root_module, root_module['ns3::Tag'])
-    register_Ns3TagBuffer_methods(root_module, root_module['ns3::TagBuffer'])
-    register_Ns3TbId_t_methods(root_module, root_module['ns3::TbId_t'])
-    register_Ns3TbStats_t_methods(root_module, root_module['ns3::TbStats_t'])
-    register_Ns3TimeWithUnit_methods(root_module, root_module['ns3::TimeWithUnit'])
-    register_Ns3TransmissionModesLayers_methods(root_module, root_module['ns3::TransmissionModesLayers'])
-    register_Ns3TypeId_methods(root_module, root_module['ns3::TypeId'])
-    register_Ns3TypeIdAttributeInformation_methods(root_module, root_module['ns3::TypeId::AttributeInformation'])
-    register_Ns3TypeIdTraceSourceInformation_methods(root_module, root_module['ns3::TypeId::TraceSourceInformation'])
-    register_Ns3UeCapabilities_s_methods(root_module, root_module['ns3::UeCapabilities_s'])
-    register_Ns3UeSelected_s_methods(root_module, root_module['ns3::UeSelected_s'])
-    register_Ns3UlCqi_s_methods(root_module, root_module['ns3::UlCqi_s'])
-    register_Ns3UlDciListElement_s_methods(root_module, root_module['ns3::UlDciListElement_s'])
-    register_Ns3UlGrant_s_methods(root_module, root_module['ns3::UlGrant_s'])
-    register_Ns3UlInfoListElement_s_methods(root_module, root_module['ns3::UlInfoListElement_s'])
-    register_Ns3UplinkLteGlobalPathlossDatabase_methods(root_module, root_module['ns3::UplinkLteGlobalPathlossDatabase'])
-    register_Ns3Vector2D_methods(root_module, root_module['ns3::Vector2D'])
-    register_Ns3Vector3D_methods(root_module, root_module['ns3::Vector3D'])
-    register_Ns3VendorSpecificListElement_s_methods(root_module, root_module['ns3::VendorSpecificListElement_s'])
-    register_Ns3Empty_methods(root_module, root_module['ns3::empty'])
-    register_Ns3FdbetsFlowPerf_t_methods(root_module, root_module['ns3::fdbetsFlowPerf_t'])
-    register_Ns3FdtbfqsFlowPerf_t_methods(root_module, root_module['ns3::fdtbfqsFlowPerf_t'])
-    register_Ns3Int64x64_t_methods(root_module, root_module['ns3::int64x64_t'])
-    register_Ns3PfsFlowPerf_t_methods(root_module, root_module['ns3::pfsFlowPerf_t'])
-    register_Ns3PssFlowPerf_t_methods(root_module, root_module['ns3::pssFlowPerf_t'])
-    register_Ns3TbInfo_t_methods(root_module, root_module['ns3::tbInfo_t'])
-    register_Ns3TdbetsFlowPerf_t_methods(root_module, root_module['ns3::tdbetsFlowPerf_t'])
-    register_Ns3TdtbfqsFlowPerf_t_methods(root_module, root_module['ns3::tdtbfqsFlowPerf_t'])
-    register_Ns3Chunk_methods(root_module, root_module['ns3::Chunk'])
-    register_Ns3DownlinkLteGlobalPathlossDatabase_methods(root_module, root_module['ns3::DownlinkLteGlobalPathlossDatabase'])
-    register_Ns3EpsBearerTag_methods(root_module, root_module['ns3::EpsBearerTag'])
-    register_Ns3Header_methods(root_module, root_module['ns3::Header'])
-    register_Ns3Ipv4Header_methods(root_module, root_module['ns3::Ipv4Header'])
-    register_Ns3LteCcmMacSapUser_methods(root_module, root_module['ns3::LteCcmMacSapUser'])
-    register_Ns3LteEnbRrcSapProvider_methods(root_module, root_module['ns3::LteEnbRrcSapProvider'])
-    register_Ns3LteEnbRrcSapProviderCompleteSetupUeParameters_methods(root_module, root_module['ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters'])
-    register_Ns3LteEnbRrcSapUser_methods(root_module, root_module['ns3::LteEnbRrcSapUser'])
-    register_Ns3LteEnbRrcSapUserSetupUeParameters_methods(root_module, root_module['ns3::LteEnbRrcSapUser::SetupUeParameters'])
-    register_Ns3LtePdcpHeader_methods(root_module, root_module['ns3::LtePdcpHeader'])
-    register_Ns3LtePhyTag_methods(root_module, root_module['ns3::LtePhyTag'])
-    register_Ns3LteRadioBearerTag_methods(root_module, root_module['ns3::LteRadioBearerTag'])
-    register_Ns3LteRlcAmHeader_methods(root_module, root_module['ns3::LteRlcAmHeader'])
-    register_Ns3LteRlcHeader_methods(root_module, root_module['ns3::LteRlcHeader'])
-    register_Ns3LteRlcSduStatusTag_methods(root_module, root_module['ns3::LteRlcSduStatusTag'])
-    register_Ns3Object_methods(root_module, root_module['ns3::Object'])
-    register_Ns3ObjectAggregateIterator_methods(root_module, root_module['ns3::Object::AggregateIterator'])
-    register_Ns3PacketBurst_methods(root_module, root_module['ns3::PacketBurst'])
-    register_Ns3PdcpTag_methods(root_module, root_module['ns3::PdcpTag'])
-    register_Ns3RadioEnvironmentMapHelper_methods(root_module, root_module['ns3::RadioEnvironmentMapHelper'])
-    register_Ns3RandomVariableStream_methods(root_module, root_module['ns3::RandomVariableStream'])
-    register_Ns3RlcTag_methods(root_module, root_module['ns3::RlcTag'])
-    register_Ns3SequentialRandomVariable_methods(root_module, root_module['ns3::SequentialRandomVariable'])
-    register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
-    register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])
-    register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])
-    register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])
-    register_Ns3SimpleRefCount__Ns3EpcTft_Ns3Empty_Ns3DefaultDeleter__lt__ns3EpcTft__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::EpcTft, ns3::empty, ns3::DefaultDeleter<ns3::EpcTft> >'])
-    register_Ns3SimpleRefCount__Ns3EpcTftClassifier_Ns3Empty_Ns3DefaultDeleter__lt__ns3EpcTftClassifier__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::EpcTftClassifier, ns3::empty, ns3::DefaultDeleter<ns3::EpcTftClassifier> >'])
-    register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])
-    register_Ns3SimpleRefCount__Ns3HashImplementation_Ns3Empty_Ns3DefaultDeleter__lt__ns3HashImplementation__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >'])
-    register_Ns3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >'])
-    register_Ns3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >'])
-    register_Ns3SimpleRefCount__Ns3LteChunkProcessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteChunkProcessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::LteChunkProcessor, ns3::empty, ns3::DefaultDeleter<ns3::LteChunkProcessor> >'])
-    register_Ns3SimpleRefCount__Ns3LteControlMessage_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteControlMessage__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter<ns3::LteControlMessage> >'])
-    register_Ns3SimpleRefCount__Ns3LteHarqPhy_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteHarqPhy__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> >'])
-    register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
-    register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
-    register_Ns3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >'])
-    register_Ns3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >'])
-    register_Ns3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >'])
-    register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
-    register_Ns3SimpleRefCount__Ns3VendorSpecificValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3VendorSpecificValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::VendorSpecificValue, ns3::empty, ns3::DefaultDeleter<ns3::VendorSpecificValue> >'])
-    register_Ns3SimpleRefCount__Ns3X2CellInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3X2CellInfo__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::X2CellInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2CellInfo> >'])
-    register_Ns3SimpleRefCount__Ns3X2IfaceInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3X2IfaceInfo__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::X2IfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2IfaceInfo> >'])
-    register_Ns3Socket_methods(root_module, root_module['ns3::Socket'])
-    register_Ns3SocketIpTosTag_methods(root_module, root_module['ns3::SocketIpTosTag'])
-    register_Ns3SocketIpTtlTag_methods(root_module, root_module['ns3::SocketIpTtlTag'])
-    register_Ns3SocketIpv6HopLimitTag_methods(root_module, root_module['ns3::SocketIpv6HopLimitTag'])
-    register_Ns3SocketIpv6TclassTag_methods(root_module, root_module['ns3::SocketIpv6TclassTag'])
-    register_Ns3SocketPriorityTag_methods(root_module, root_module['ns3::SocketPriorityTag'])
-    register_Ns3SocketSetDontFragmentTag_methods(root_module, root_module['ns3::SocketSetDontFragmentTag'])
-    register_Ns3SpectrumInterference_methods(root_module, root_module['ns3::SpectrumInterference'])
-    register_Ns3SpectrumModel_methods(root_module, root_module['ns3::SpectrumModel'])
-    register_Ns3SpectrumPhy_methods(root_module, root_module['ns3::SpectrumPhy'])
-    register_Ns3SpectrumPropagationLossModel_methods(root_module, root_module['ns3::SpectrumPropagationLossModel'])
-    register_Ns3SpectrumSignalParameters_methods(root_module, root_module['ns3::SpectrumSignalParameters'])
-    register_Ns3SpectrumValue_methods(root_module, root_module['ns3::SpectrumValue'])
-    register_Ns3Time_methods(root_module, root_module['ns3::Time'])
-    register_Ns3TraceFadingLossModel_methods(root_module, root_module['ns3::TraceFadingLossModel'])
-    register_Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::TraceSourceAccessor'])
-    register_Ns3Trailer_methods(root_module, root_module['ns3::Trailer'])
-    register_Ns3TriangularRandomVariable_methods(root_module, root_module['ns3::TriangularRandomVariable'])
-    register_Ns3UeManager_methods(root_module, root_module['ns3::UeManager'])
-    register_Ns3UniformRandomVariable_methods(root_module, root_module['ns3::UniformRandomVariable'])
-    register_Ns3VendorSpecificValue_methods(root_module, root_module['ns3::VendorSpecificValue'])
-    register_Ns3WeibullRandomVariable_methods(root_module, root_module['ns3::WeibullRandomVariable'])
-    register_Ns3X2CellInfo_methods(root_module, root_module['ns3::X2CellInfo'])
-    register_Ns3X2IfaceInfo_methods(root_module, root_module['ns3::X2IfaceInfo'])
-    register_Ns3ZetaRandomVariable_methods(root_module, root_module['ns3::ZetaRandomVariable'])
-    register_Ns3ZipfRandomVariable_methods(root_module, root_module['ns3::ZipfRandomVariable'])
-    register_Ns3Application_methods(root_module, root_module['ns3::Application'])
-    register_Ns3Asn1Header_methods(root_module, root_module['ns3::Asn1Header'])
-    register_Ns3AttributeAccessor_methods(root_module, root_module['ns3::AttributeAccessor'])
-    register_Ns3AttributeChecker_methods(root_module, root_module['ns3::AttributeChecker'])
-    register_Ns3AttributeValue_methods(root_module, root_module['ns3::AttributeValue'])
-    register_Ns3BooleanChecker_methods(root_module, root_module['ns3::BooleanChecker'])
-    register_Ns3BooleanValue_methods(root_module, root_module['ns3::BooleanValue'])
-    register_Ns3CallbackChecker_methods(root_module, root_module['ns3::CallbackChecker'])
-    register_Ns3CallbackImplBase_methods(root_module, root_module['ns3::CallbackImplBase'])
-    register_Ns3CallbackValue_methods(root_module, root_module['ns3::CallbackValue'])
-    register_Ns3CcHelper_methods(root_module, root_module['ns3::CcHelper'])
-    register_Ns3Channel_methods(root_module, root_module['ns3::Channel'])
-    register_Ns3ComponentCarrier_methods(root_module, root_module['ns3::ComponentCarrier'])
-    register_Ns3ComponentCarrierEnb_methods(root_module, root_module['ns3::ComponentCarrierEnb'])
-    register_Ns3ComponentCarrierUe_methods(root_module, root_module['ns3::ComponentCarrierUe'])
-    register_Ns3ConstantRandomVariable_methods(root_module, root_module['ns3::ConstantRandomVariable'])
-    register_Ns3DataCalculator_methods(root_module, root_module['ns3::DataCalculator'])
-    register_Ns3DataOutputInterface_methods(root_module, root_module['ns3::DataOutputInterface'])
-    register_Ns3DataRateChecker_methods(root_module, root_module['ns3::DataRateChecker'])
-    register_Ns3DataRateValue_methods(root_module, root_module['ns3::DataRateValue'])
-    register_Ns3DeterministicRandomVariable_methods(root_module, root_module['ns3::DeterministicRandomVariable'])
-    register_Ns3DoubleValue_methods(root_module, root_module['ns3::DoubleValue'])
-    register_Ns3EmpiricalRandomVariable_methods(root_module, root_module['ns3::EmpiricalRandomVariable'])
-    register_Ns3EmptyAttributeAccessor_methods(root_module, root_module['ns3::EmptyAttributeAccessor'])
-    register_Ns3EmptyAttributeChecker_methods(root_module, root_module['ns3::EmptyAttributeChecker'])
-    register_Ns3EmptyAttributeValue_methods(root_module, root_module['ns3::EmptyAttributeValue'])
-    register_Ns3EnumChecker_methods(root_module, root_module['ns3::EnumChecker'])
-    register_Ns3EnumValue_methods(root_module, root_module['ns3::EnumValue'])
-    register_Ns3EpcEnbApplication_methods(root_module, root_module['ns3::EpcEnbApplication'])
-    register_Ns3EpcEnbApplicationEpsFlowId_t_methods(root_module, root_module['ns3::EpcEnbApplication::EpsFlowId_t'])
-    register_Ns3EpcHelper_methods(root_module, root_module['ns3::EpcHelper'])
-    register_Ns3EpcMme_methods(root_module, root_module['ns3::EpcMme'])
-    register_Ns3EpcSgwPgwApplication_methods(root_module, root_module['ns3::EpcSgwPgwApplication'])
-    register_Ns3EpcTft_methods(root_module, root_module['ns3::EpcTft'])
-    register_Ns3EpcTftPacketFilter_methods(root_module, root_module['ns3::EpcTft::PacketFilter'])
-    register_Ns3EpcTftClassifier_methods(root_module, root_module['ns3::EpcTftClassifier'])
-    register_Ns3EpcUeNas_methods(root_module, root_module['ns3::EpcUeNas'])
-    register_Ns3EpcX2_methods(root_module, root_module['ns3::EpcX2'])
-    register_Ns3EpcX2HandoverPreparationFailureHeader_methods(root_module, root_module['ns3::EpcX2HandoverPreparationFailureHeader'])
-    register_Ns3EpcX2HandoverRequestAckHeader_methods(root_module, root_module['ns3::EpcX2HandoverRequestAckHeader'])
-    register_Ns3EpcX2HandoverRequestHeader_methods(root_module, root_module['ns3::EpcX2HandoverRequestHeader'])
-    register_Ns3EpcX2Header_methods(root_module, root_module['ns3::EpcX2Header'])
-    register_Ns3EpcX2LoadInformationHeader_methods(root_module, root_module['ns3::EpcX2LoadInformationHeader'])
-    register_Ns3EpcX2ResourceStatusUpdateHeader_methods(root_module, root_module['ns3::EpcX2ResourceStatusUpdateHeader'])
-    register_Ns3EpcX2SnStatusTransferHeader_methods(root_module, root_module['ns3::EpcX2SnStatusTransferHeader'])
-    register_Ns3EpcX2UeContextReleaseHeader_methods(root_module, root_module['ns3::EpcX2UeContextReleaseHeader'])
-    register_Ns3ErlangRandomVariable_methods(root_module, root_module['ns3::ErlangRandomVariable'])
-    register_Ns3EventImpl_methods(root_module, root_module['ns3::EventImpl'])
-    register_Ns3ExponentialRandomVariable_methods(root_module, root_module['ns3::ExponentialRandomVariable'])
-    register_Ns3FfMacScheduler_methods(root_module, root_module['ns3::FfMacScheduler'])
-    register_Ns3GammaRandomVariable_methods(root_module, root_module['ns3::GammaRandomVariable'])
-    register_Ns3GtpuHeader_methods(root_module, root_module['ns3::GtpuHeader'])
-    register_Ns3IntegerValue_methods(root_module, root_module['ns3::IntegerValue'])
-    register_Ns3Ipv4_methods(root_module, root_module['ns3::Ipv4'])
-    register_Ns3Ipv4AddressChecker_methods(root_module, root_module['ns3::Ipv4AddressChecker'])
-    register_Ns3Ipv4AddressValue_methods(root_module, root_module['ns3::Ipv4AddressValue'])
-    register_Ns3Ipv4MaskChecker_methods(root_module, root_module['ns3::Ipv4MaskChecker'])
-    register_Ns3Ipv4MaskValue_methods(root_module, root_module['ns3::Ipv4MaskValue'])
-    register_Ns3Ipv4MulticastRoute_methods(root_module, root_module['ns3::Ipv4MulticastRoute'])
-    register_Ns3Ipv4Route_methods(root_module, root_module['ns3::Ipv4Route'])
-    register_Ns3Ipv6AddressChecker_methods(root_module, root_module['ns3::Ipv6AddressChecker'])
-    register_Ns3Ipv6AddressValue_methods(root_module, root_module['ns3::Ipv6AddressValue'])
-    register_Ns3Ipv6PrefixChecker_methods(root_module, root_module['ns3::Ipv6PrefixChecker'])
-    register_Ns3Ipv6PrefixValue_methods(root_module, root_module['ns3::Ipv6PrefixValue'])
-    register_Ns3LogNormalRandomVariable_methods(root_module, root_module['ns3::LogNormalRandomVariable'])
-    register_Ns3LteAmc_methods(root_module, root_module['ns3::LteAmc'])
-    register_Ns3LteAnr_methods(root_module, root_module['ns3::LteAnr'])
-    register_Ns3LteChunkProcessor_methods(root_module, root_module['ns3::LteChunkProcessor'])
-    register_Ns3LteControlMessage_methods(root_module, root_module['ns3::LteControlMessage'])
-    register_Ns3LteEnbComponentCarrierManager_methods(root_module, root_module['ns3::LteEnbComponentCarrierManager'])
-    register_Ns3LteEnbMac_methods(root_module, root_module['ns3::LteEnbMac'])
-    register_Ns3LteEnbRrc_methods(root_module, root_module['ns3::LteEnbRrc'])
-    register_Ns3LteEnbRrcProtocolIdeal_methods(root_module, root_module['ns3::LteEnbRrcProtocolIdeal'])
-    register_Ns3LteEnbRrcProtocolReal_methods(root_module, root_module['ns3::LteEnbRrcProtocolReal'])
-    register_Ns3LteFfrAlgorithm_methods(root_module, root_module['ns3::LteFfrAlgorithm'])
-    register_Ns3LteFfrDistributedAlgorithm_methods(root_module, root_module['ns3::LteFfrDistributedAlgorithm'])
-    register_Ns3LteFfrEnhancedAlgorithm_methods(root_module, root_module['ns3::LteFfrEnhancedAlgorithm'])
-    register_Ns3LteFfrSoftAlgorithm_methods(root_module, root_module['ns3::LteFfrSoftAlgorithm'])
-    register_Ns3LteFrHardAlgorithm_methods(root_module, root_module['ns3::LteFrHardAlgorithm'])
-    register_Ns3LteFrNoOpAlgorithm_methods(root_module, root_module['ns3::LteFrNoOpAlgorithm'])
-    register_Ns3LteFrSoftAlgorithm_methods(root_module, root_module['ns3::LteFrSoftAlgorithm'])
-    register_Ns3LteFrStrictAlgorithm_methods(root_module, root_module['ns3::LteFrStrictAlgorithm'])
-    register_Ns3LteHandoverAlgorithm_methods(root_module, root_module['ns3::LteHandoverAlgorithm'])
-    register_Ns3LteHarqPhy_methods(root_module, root_module['ns3::LteHarqPhy'])
-    register_Ns3LteHelper_methods(root_module, root_module['ns3::LteHelper'])
-    register_Ns3LteHexGridEnbTopologyHelper_methods(root_module, root_module['ns3::LteHexGridEnbTopologyHelper'])
-    register_Ns3LteInterference_methods(root_module, root_module['ns3::LteInterference'])
-    register_Ns3LtePdcp_methods(root_module, root_module['ns3::LtePdcp'])
-    register_Ns3LtePdcpStatus_methods(root_module, root_module['ns3::LtePdcp::Status'])
-    register_Ns3LtePhy_methods(root_module, root_module['ns3::LtePhy'])
-    register_Ns3LteRadioBearerInfo_methods(root_module, root_module['ns3::LteRadioBearerInfo'])
-    register_Ns3LteRlc_methods(root_module, root_module['ns3::LteRlc'])
-    register_Ns3LteRlcAm_methods(root_module, root_module['ns3::LteRlcAm'])
-    register_Ns3LteRlcSm_methods(root_module, root_module['ns3::LteRlcSm'])
-    register_Ns3LteRlcTm_methods(root_module, root_module['ns3::LteRlcTm'])
-    register_Ns3LteRlcUm_methods(root_module, root_module['ns3::LteRlcUm'])
-    register_Ns3LteSignalingRadioBearerInfo_methods(root_module, root_module['ns3::LteSignalingRadioBearerInfo'])
-    register_Ns3LteSpectrumPhy_methods(root_module, root_module['ns3::LteSpectrumPhy'])
-    register_Ns3LteSpectrumSignalParameters_methods(root_module, root_module['ns3::LteSpectrumSignalParameters'])
-    register_Ns3LteSpectrumSignalParametersDataFrame_methods(root_module, root_module['ns3::LteSpectrumSignalParametersDataFrame'])
-    register_Ns3LteSpectrumSignalParametersDlCtrlFrame_methods(root_module, root_module['ns3::LteSpectrumSignalParametersDlCtrlFrame'])
-    register_Ns3LteSpectrumSignalParametersUlSrsFrame_methods(root_module, root_module['ns3::LteSpectrumSignalParametersUlSrsFrame'])
-    register_Ns3LteStatsCalculator_methods(root_module, root_module['ns3::LteStatsCalculator'])
-    register_Ns3LteUeComponentCarrierManager_methods(root_module, root_module['ns3::LteUeComponentCarrierManager'])
-    register_Ns3LteUeMac_methods(root_module, root_module['ns3::LteUeMac'])
-    register_Ns3LteUePhy_methods(root_module, root_module['ns3::LteUePhy'])
-    register_Ns3LteUePowerControl_methods(root_module, root_module['ns3::LteUePowerControl'])
-    register_Ns3LteUeRrc_methods(root_module, root_module['ns3::LteUeRrc'])
-    register_Ns3LteUeRrcProtocolIdeal_methods(root_module, root_module['ns3::LteUeRrcProtocolIdeal'])
-    register_Ns3LteUeRrcProtocolReal_methods(root_module, root_module['ns3::LteUeRrcProtocolReal'])
-    register_Ns3Mac48AddressChecker_methods(root_module, root_module['ns3::Mac48AddressChecker'])
-    register_Ns3Mac48AddressValue_methods(root_module, root_module['ns3::Mac48AddressValue'])
-    register_Ns3MacStatsCalculator_methods(root_module, root_module['ns3::MacStatsCalculator'])
-    register_Ns3MibLteControlMessage_methods(root_module, root_module['ns3::MibLteControlMessage'])
-    register_Ns3MinMaxAvgTotalCalculator__Unsigned_int_methods(root_module, root_module['ns3::MinMaxAvgTotalCalculator< unsigned int >'])
-    register_Ns3MinMaxAvgTotalCalculator__Unsigned_long_methods(root_module, root_module['ns3::MinMaxAvgTotalCalculator< unsigned long long >'])
-    register_Ns3MobilityModel_methods(root_module, root_module['ns3::MobilityModel'])
-    register_Ns3NetDevice_methods(root_module, root_module['ns3::NetDevice'])
-    register_Ns3NixVector_methods(root_module, root_module['ns3::NixVector'])
-    register_Ns3NoOpComponentCarrierManager_methods(root_module, root_module['ns3::NoOpComponentCarrierManager'])
-    register_Ns3NoOpHandoverAlgorithm_methods(root_module, root_module['ns3::NoOpHandoverAlgorithm'])
-    register_Ns3Node_methods(root_module, root_module['ns3::Node'])
-    register_Ns3NormalRandomVariable_methods(root_module, root_module['ns3::NormalRandomVariable'])
-    register_Ns3ObjectFactoryChecker_methods(root_module, root_module['ns3::ObjectFactoryChecker'])
-    register_Ns3ObjectFactoryValue_methods(root_module, root_module['ns3::ObjectFactoryValue'])
-    register_Ns3Packet_methods(root_module, root_module['ns3::Packet'])
-    register_Ns3ParetoRandomVariable_methods(root_module, root_module['ns3::ParetoRandomVariable'])
-    register_Ns3PfFfMacScheduler_methods(root_module, root_module['ns3::PfFfMacScheduler'])
-    register_Ns3PhyRxStatsCalculator_methods(root_module, root_module['ns3::PhyRxStatsCalculator'])
-    register_Ns3PhyStatsCalculator_methods(root_module, root_module['ns3::PhyStatsCalculator'])
-    register_Ns3PhyTxStatsCalculator_methods(root_module, root_module['ns3::PhyTxStatsCalculator'])
-    register_Ns3PointToPointEpcHelper_methods(root_module, root_module['ns3::PointToPointEpcHelper'])
-    register_Ns3PointerChecker_methods(root_module, root_module['ns3::PointerChecker'])
-    register_Ns3PointerValue_methods(root_module, root_module['ns3::PointerValue'])
-    register_Ns3PssFfMacScheduler_methods(root_module, root_module['ns3::PssFfMacScheduler'])
-    register_Ns3RachPreambleLteControlMessage_methods(root_module, root_module['ns3::RachPreambleLteControlMessage'])
-    register_Ns3RadioBearerStatsCalculator_methods(root_module, root_module['ns3::RadioBearerStatsCalculator'])
-    register_Ns3RarLteControlMessage_methods(root_module, root_module['ns3::RarLteControlMessage'])
-    register_Ns3RarLteControlMessageRar_methods(root_module, root_module['ns3::RarLteControlMessage::Rar'])
-    register_Ns3RemSpectrumPhy_methods(root_module, root_module['ns3::RemSpectrumPhy'])
-    register_Ns3RrComponentCarrierManager_methods(root_module, root_module['ns3::RrComponentCarrierManager'])
-    register_Ns3RrFfMacScheduler_methods(root_module, root_module['ns3::RrFfMacScheduler'])
-    register_Ns3RrcAsn1Header_methods(root_module, root_module['ns3::RrcAsn1Header'])
-    register_Ns3RrcDlCcchMessage_methods(root_module, root_module['ns3::RrcDlCcchMessage'])
-    register_Ns3RrcDlDcchMessage_methods(root_module, root_module['ns3::RrcDlDcchMessage'])
-    register_Ns3RrcUlCcchMessage_methods(root_module, root_module['ns3::RrcUlCcchMessage'])
-    register_Ns3RrcUlDcchMessage_methods(root_module, root_module['ns3::RrcUlDcchMessage'])
-    register_Ns3Sib1LteControlMessage_methods(root_module, root_module['ns3::Sib1LteControlMessage'])
-    register_Ns3SimpleUeComponentCarrierManager_methods(root_module, root_module['ns3::SimpleUeComponentCarrierManager'])
-    register_Ns3SpectrumChannel_methods(root_module, root_module['ns3::SpectrumChannel'])
-    register_Ns3SrsCqiRntiVsp_methods(root_module, root_module['ns3::SrsCqiRntiVsp'])
-    register_Ns3StringChecker_methods(root_module, root_module['ns3::StringChecker'])
-    register_Ns3StringValue_methods(root_module, root_module['ns3::StringValue'])
-    register_Ns3TdBetFfMacScheduler_methods(root_module, root_module['ns3::TdBetFfMacScheduler'])
-    register_Ns3TdMtFfMacScheduler_methods(root_module, root_module['ns3::TdMtFfMacScheduler'])
-    register_Ns3TdTbfqFfMacScheduler_methods(root_module, root_module['ns3::TdTbfqFfMacScheduler'])
-    register_Ns3TimeValue_methods(root_module, root_module['ns3::TimeValue'])
-    register_Ns3TtaFfMacScheduler_methods(root_module, root_module['ns3::TtaFfMacScheduler'])
-    register_Ns3TypeIdChecker_methods(root_module, root_module['ns3::TypeIdChecker'])
-    register_Ns3TypeIdValue_methods(root_module, root_module['ns3::TypeIdValue'])
-    register_Ns3UintegerValue_methods(root_module, root_module['ns3::UintegerValue'])
-    register_Ns3UlDciLteControlMessage_methods(root_module, root_module['ns3::UlDciLteControlMessage'])
-    register_Ns3Vector2DChecker_methods(root_module, root_module['ns3::Vector2DChecker'])
-    register_Ns3Vector2DValue_methods(root_module, root_module['ns3::Vector2DValue'])
-    register_Ns3Vector3DChecker_methods(root_module, root_module['ns3::Vector3DChecker'])
-    register_Ns3Vector3DValue_methods(root_module, root_module['ns3::Vector3DValue'])
-    register_Ns3VirtualNetDevice_methods(root_module, root_module['ns3::VirtualNetDevice'])
-    register_Ns3A2A4RsrqHandoverAlgorithm_methods(root_module, root_module['ns3::A2A4RsrqHandoverAlgorithm'])
-    register_Ns3A3RsrpHandoverAlgorithm_methods(root_module, root_module['ns3::A3RsrpHandoverAlgorithm'])
-    register_Ns3AddressChecker_methods(root_module, root_module['ns3::AddressChecker'])
-    register_Ns3AddressValue_methods(root_module, root_module['ns3::AddressValue'])
-    register_Ns3BsrLteControlMessage_methods(root_module, root_module['ns3::BsrLteControlMessage'])
-    register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Packet__gt___Const_ns3Address___amp___Const_ns3Address___amp___Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Ns3ObjectBase___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Const_ns3SpectrumValue___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3DlSchedulingCallbackInfo_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3EpcUeNasState_Ns3EpcUeNasState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3PhyReceptionStatParameters_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3PhyTransmissionStatParameters_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3MobilityModel__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3Packet__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3PacketBurst__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Packet__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteRrcSapMeasurementReport_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteUeRrcState_Ns3LteUeRrcState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3UeManagerState_Ns3UeManagerState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Ns3Ptr__lt__ns3SpectrumValue__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_long_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Bool_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3LteUePhyState_Ns3LteUePhyState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CqaFfMacScheduler_methods(root_module, root_module['ns3::CqaFfMacScheduler'])
-    register_Ns3DlCqiLteControlMessage_methods(root_module, root_module['ns3::DlCqiLteControlMessage'])
-    register_Ns3DlDciLteControlMessage_methods(root_module, root_module['ns3::DlDciLteControlMessage'])
-    register_Ns3DlHarqFeedbackLteControlMessage_methods(root_module, root_module['ns3::DlHarqFeedbackLteControlMessage'])
-    register_Ns3EmuEpcHelper_methods(root_module, root_module['ns3::EmuEpcHelper'])
-    register_Ns3FdBetFfMacScheduler_methods(root_module, root_module['ns3::FdBetFfMacScheduler'])
-    register_Ns3FdMtFfMacScheduler_methods(root_module, root_module['ns3::FdMtFfMacScheduler'])
-    register_Ns3FdTbfqFfMacScheduler_methods(root_module, root_module['ns3::FdTbfqFfMacScheduler'])
-    register_Ns3HandoverPreparationInfoHeader_methods(root_module, root_module['ns3::HandoverPreparationInfoHeader'])
-    register_Ns3LteDataRadioBearerInfo_methods(root_module, root_module['ns3::LteDataRadioBearerInfo'])
-    register_Ns3LteEnbPhy_methods(root_module, root_module['ns3::LteEnbPhy'])
-    register_Ns3LteNetDevice_methods(root_module, root_module['ns3::LteNetDevice'])
-    register_Ns3LteUeNetDevice_methods(root_module, root_module['ns3::LteUeNetDevice'])
-    register_Ns3MeasurementReportHeader_methods(root_module, root_module['ns3::MeasurementReportHeader'])
-    register_Ns3RrcConnectionReconfigurationCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionReconfigurationCompleteHeader'])
-    register_Ns3RrcConnectionReconfigurationHeader_methods(root_module, root_module['ns3::RrcConnectionReconfigurationHeader'])
-    register_Ns3RrcConnectionReestablishmentCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionReestablishmentCompleteHeader'])
-    register_Ns3RrcConnectionReestablishmentHeader_methods(root_module, root_module['ns3::RrcConnectionReestablishmentHeader'])
-    register_Ns3RrcConnectionReestablishmentRejectHeader_methods(root_module, root_module['ns3::RrcConnectionReestablishmentRejectHeader'])
-    register_Ns3RrcConnectionReestablishmentRequestHeader_methods(root_module, root_module['ns3::RrcConnectionReestablishmentRequestHeader'])
-    register_Ns3RrcConnectionRejectHeader_methods(root_module, root_module['ns3::RrcConnectionRejectHeader'])
-    register_Ns3RrcConnectionReleaseHeader_methods(root_module, root_module['ns3::RrcConnectionReleaseHeader'])
-    register_Ns3RrcConnectionRequestHeader_methods(root_module, root_module['ns3::RrcConnectionRequestHeader'])
-    register_Ns3RrcConnectionSetupCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionSetupCompleteHeader'])
-    register_Ns3RrcConnectionSetupHeader_methods(root_module, root_module['ns3::RrcConnectionSetupHeader'])
-    register_Ns3LteEnbNetDevice_methods(root_module, root_module['ns3::LteEnbNetDevice'])
-    register_Ns3ConfigMatchContainer_methods(root_module, root_module['ns3::Config::MatchContainer'])
-    register_Ns3HashImplementation_methods(root_module, root_module['ns3::Hash::Implementation'])
-    register_Ns3HashFunctionFnv1a_methods(root_module, root_module['ns3::Hash::Function::Fnv1a'])
-    register_Ns3HashFunctionHash32_methods(root_module, root_module['ns3::Hash::Function::Hash32'])
-    register_Ns3HashFunctionHash64_methods(root_module, root_module['ns3::Hash::Function::Hash64'])
-    register_Ns3HashFunctionMurmur3_methods(root_module, root_module['ns3::Hash::Function::Murmur3'])
-    return
-
-def register_Ns3Address_methods(root_module, cls):
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<')
-    cls.add_output_stream_operator()
-    ## address.h (module 'network'): ns3::Address::Address() [constructor]
-    cls.add_constructor([])
-    ## address.h (module 'network'): ns3::Address::Address(uint8_t type, uint8_t const * buffer, uint8_t len) [constructor]
-    cls.add_constructor([param('uint8_t', 'type'), param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
-    ## address.h (module 'network'): ns3::Address::Address(ns3::Address const & address) [constructor]
-    cls.add_constructor([param('ns3::Address const &', 'address')])
-    ## address.h (module 'network'): bool ns3::Address::CheckCompatible(uint8_t type, uint8_t len) const [member function]
-    cls.add_method('CheckCompatible', 
-                   'bool', 
-                   [param('uint8_t', 'type'), param('uint8_t', 'len')], 
-                   is_const=True)
-    ## address.h (module 'network'): uint32_t ns3::Address::CopyAllFrom(uint8_t const * buffer, uint8_t len) [member function]
-    cls.add_method('CopyAllFrom', 
-                   'uint32_t', 
-                   [param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
-    ## address.h (module 'network'): uint32_t ns3::Address::CopyAllTo(uint8_t * buffer, uint8_t len) const [member function]
-    cls.add_method('CopyAllTo', 
-                   'uint32_t', 
-                   [param('uint8_t *', 'buffer'), param('uint8_t', 'len')], 
-                   is_const=True)
-    ## address.h (module 'network'): uint32_t ns3::Address::CopyFrom(uint8_t const * buffer, uint8_t len) [member function]
-    cls.add_method('CopyFrom', 
-                   'uint32_t', 
-                   [param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
-    ## address.h (module 'network'): uint32_t ns3::Address::CopyTo(uint8_t * buffer) const [member function]
-    cls.add_method('CopyTo', 
-                   'uint32_t', 
-                   [param('uint8_t *', 'buffer')], 
-                   is_const=True)
-    ## address.h (module 'network'): void ns3::Address::Deserialize(ns3::TagBuffer buffer) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'buffer')])
-    ## address.h (module 'network'): uint8_t ns3::Address::GetLength() const [member function]
-    cls.add_method('GetLength', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## address.h (module 'network'): uint32_t ns3::Address::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## address.h (module 'network'): bool ns3::Address::IsInvalid() const [member function]
-    cls.add_method('IsInvalid', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## address.h (module 'network'): bool ns3::Address::IsMatchingType(uint8_t type) const [member function]
-    cls.add_method('IsMatchingType', 
-                   'bool', 
-                   [param('uint8_t', 'type')], 
-                   is_const=True)
-    ## address.h (module 'network'): static uint8_t ns3::Address::Register() [member function]
-    cls.add_method('Register', 
-                   'uint8_t', 
-                   [], 
-                   is_static=True)
-    ## address.h (module 'network'): void ns3::Address::Serialize(ns3::TagBuffer buffer) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'buffer')], 
-                   is_const=True)
-    return
-
-def register_Ns3AllocationRetentionPriority_methods(root_module, cls):
-    ## eps-bearer.h (module 'lte'): ns3::AllocationRetentionPriority::AllocationRetentionPriority(ns3::AllocationRetentionPriority const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AllocationRetentionPriority const &', 'arg0')])
-    ## eps-bearer.h (module 'lte'): ns3::AllocationRetentionPriority::AllocationRetentionPriority() [constructor]
-    cls.add_constructor([])
-    ## eps-bearer.h (module 'lte'): ns3::AllocationRetentionPriority::preemptionCapability [variable]
-    cls.add_instance_attribute('preemptionCapability', 'bool', is_const=False)
-    ## eps-bearer.h (module 'lte'): ns3::AllocationRetentionPriority::preemptionVulnerability [variable]
-    cls.add_instance_attribute('preemptionVulnerability', 'bool', is_const=False)
-    ## eps-bearer.h (module 'lte'): ns3::AllocationRetentionPriority::priorityLevel [variable]
-    cls.add_instance_attribute('priorityLevel', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3AttributeConstructionList_methods(root_module, cls):
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::AttributeConstructionList(ns3::AttributeConstructionList const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AttributeConstructionList const &', 'arg0')])
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::AttributeConstructionList() [constructor]
-    cls.add_constructor([])
-    ## attribute-construction-list.h (module 'core'): void ns3::AttributeConstructionList::Add(std::string name, ns3::Ptr<const ns3::AttributeChecker> checker, ns3::Ptr<ns3::AttributeValue> value) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker'), param('ns3::Ptr< ns3::AttributeValue >', 'value')])
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::CIterator ns3::AttributeConstructionList::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'ns3::AttributeConstructionList::CIterator', 
-                   [], 
-                   is_const=True)
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::CIterator ns3::AttributeConstructionList::End() const [member function]
-    cls.add_method('End', 
-                   'ns3::AttributeConstructionList::CIterator', 
-                   [], 
-                   is_const=True)
-    ## attribute-construction-list.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::AttributeConstructionList::Find(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('Find', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True)
-    return
-
-def register_Ns3AttributeConstructionListItem_methods(root_module, cls):
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item::Item() [constructor]
-    cls.add_constructor([])
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item::Item(ns3::AttributeConstructionList::Item const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AttributeConstructionList::Item const &', 'arg0')])
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item::checker [variable]
-    cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item::name [variable]
-    cls.add_instance_attribute('name', 'std::string', is_const=False)
-    ## attribute-construction-list.h (module 'core'): ns3::AttributeConstructionList::Item::value [variable]
-    cls.add_instance_attribute('value', 'ns3::Ptr< ns3::AttributeValue >', is_const=False)
-    return
-
-def register_Ns3BandInfo_methods(root_module, cls):
-    ## spectrum-model.h (module 'spectrum'): ns3::BandInfo::BandInfo() [constructor]
-    cls.add_constructor([])
-    ## spectrum-model.h (module 'spectrum'): ns3::BandInfo::BandInfo(ns3::BandInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BandInfo const &', 'arg0')])
-    ## spectrum-model.h (module 'spectrum'): ns3::BandInfo::fc [variable]
-    cls.add_instance_attribute('fc', 'double', is_const=False)
-    ## spectrum-model.h (module 'spectrum'): ns3::BandInfo::fh [variable]
-    cls.add_instance_attribute('fh', 'double', is_const=False)
-    ## spectrum-model.h (module 'spectrum'): ns3::BandInfo::fl [variable]
-    cls.add_instance_attribute('fl', 'double', is_const=False)
-    return
-
-def register_Ns3Buffer_methods(root_module, cls):
-    ## buffer.h (module 'network'): ns3::Buffer::Buffer(ns3::Buffer const & o) [constructor]
-    cls.add_constructor([param('ns3::Buffer const &', 'o')])
-    ## buffer.h (module 'network'): ns3::Buffer::Buffer() [constructor]
-    cls.add_constructor([])
-    ## buffer.h (module 'network'): ns3::Buffer::Buffer(uint32_t dataSize) [constructor]
-    cls.add_constructor([param('uint32_t', 'dataSize')])
-    ## buffer.h (module 'network'): ns3::Buffer::Buffer(uint32_t dataSize, bool initialize) [constructor]
-    cls.add_constructor([param('uint32_t', 'dataSize'), param('bool', 'initialize')])
-    ## buffer.h (module 'network'): void ns3::Buffer::AddAtEnd(uint32_t end) [member function]
-    cls.add_method('AddAtEnd', 
-                   'void', 
-                   [param('uint32_t', 'end')])
-    ## buffer.h (module 'network'): void ns3::Buffer::AddAtEnd(ns3::Buffer const & o) [member function]
-    cls.add_method('AddAtEnd', 
-                   'void', 
-                   [param('ns3::Buffer const &', 'o')])
-    ## buffer.h (module 'network'): void ns3::Buffer::AddAtStart(uint32_t start) [member function]
-    cls.add_method('AddAtStart', 
-                   'void', 
-                   [param('uint32_t', 'start')])
-    ## buffer.h (module 'network'): ns3::Buffer::Iterator ns3::Buffer::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'ns3::Buffer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): void ns3::Buffer::CopyData(std::ostream * os, uint32_t size) const [member function]
-    cls.add_method('CopyData', 
-                   'void', 
-                   [param('std::ostream *', 'os'), param('uint32_t', 'size')], 
-                   is_const=True)
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::CopyData(uint8_t * buffer, uint32_t size) const [member function]
-    cls.add_method('CopyData', 
-                   'uint32_t', 
-                   [param('uint8_t *', 'buffer'), param('uint32_t', 'size')], 
-                   is_const=True)
-    ## buffer.h (module 'network'): ns3::Buffer ns3::Buffer::CreateFragment(uint32_t start, uint32_t length) const [member function]
-    cls.add_method('CreateFragment', 
-                   'ns3::Buffer', 
-                   [param('uint32_t', 'start'), param('uint32_t', 'length')], 
-                   is_const=True)
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Deserialize(uint8_t const * buffer, uint32_t size) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
-    ## buffer.h (module 'network'): ns3::Buffer::Iterator ns3::Buffer::End() const [member function]
-    cls.add_method('End', 
-                   'ns3::Buffer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::GetSize() const [member function]
-    cls.add_method('GetSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): uint8_t const * ns3::Buffer::PeekData() const [member function]
-    cls.add_method('PeekData', 
-                   'uint8_t const *', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): void ns3::Buffer::RemoveAtEnd(uint32_t end) [member function]
-    cls.add_method('RemoveAtEnd', 
-                   'void', 
-                   [param('uint32_t', 'end')])
-    ## buffer.h (module 'network'): void ns3::Buffer::RemoveAtStart(uint32_t start) [member function]
-    cls.add_method('RemoveAtStart', 
-                   'void', 
-                   [param('uint32_t', 'start')])
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Serialize(uint8_t * buffer, uint32_t maxSize) const [member function]
-    cls.add_method('Serialize', 
-                   'uint32_t', 
-                   [param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')], 
-                   is_const=True)
-    return
-
-def register_Ns3BufferIterator_methods(root_module, cls):
-    ## buffer.h (module 'network'): ns3::Buffer::Iterator::Iterator(ns3::Buffer::Iterator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Buffer::Iterator const &', 'arg0')])
-    ## buffer.h (module 'network'): ns3::Buffer::Iterator::Iterator() [constructor]
-    cls.add_constructor([])
-    ## buffer.h (module 'network'): uint16_t ns3::Buffer::Iterator::CalculateIpChecksum(uint16_t size) [member function]
-    cls.add_method('CalculateIpChecksum', 
-                   'uint16_t', 
-                   [param('uint16_t', 'size')])
-    ## buffer.h (module 'network'): uint16_t ns3::Buffer::Iterator::CalculateIpChecksum(uint16_t size, uint32_t initialChecksum) [member function]
-    cls.add_method('CalculateIpChecksum', 
-                   'uint16_t', 
-                   [param('uint16_t', 'size'), param('uint32_t', 'initialChecksum')])
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Iterator::GetDistanceFrom(ns3::Buffer::Iterator const & o) const [member function]
-    cls.add_method('GetDistanceFrom', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator const &', 'o')], 
-                   is_const=True)
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Iterator::GetRemainingSize() const [member function]
-    cls.add_method('GetRemainingSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Iterator::GetSize() const [member function]
-    cls.add_method('GetSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): bool ns3::Buffer::Iterator::IsEnd() const [member function]
-    cls.add_method('IsEnd', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): bool ns3::Buffer::Iterator::IsStart() const [member function]
-    cls.add_method('IsStart', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Next() [member function]
-    cls.add_method('Next', 
-                   'void', 
-                   [])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Next(uint32_t delta) [member function]
-    cls.add_method('Next', 
-                   'void', 
-                   [param('uint32_t', 'delta')])
-    ## buffer.h (module 'network'): uint8_t ns3::Buffer::Iterator::PeekU8() [member function]
-    cls.add_method('PeekU8', 
-                   'uint8_t', 
-                   [])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Prev() [member function]
-    cls.add_method('Prev', 
-                   'void', 
-                   [])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Prev(uint32_t delta) [member function]
-    cls.add_method('Prev', 
-                   'void', 
-                   [param('uint32_t', 'delta')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Read(uint8_t * buffer, uint32_t size) [member function]
-    cls.add_method('Read', 
-                   'void', 
-                   [param('uint8_t *', 'buffer'), param('uint32_t', 'size')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Read(ns3::Buffer::Iterator start, uint32_t size) [member function]
-    cls.add_method('Read', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start'), param('uint32_t', 'size')])
-    ## buffer.h (module 'network'): uint16_t ns3::Buffer::Iterator::ReadLsbtohU16() [member function]
-    cls.add_method('ReadLsbtohU16', 
-                   'uint16_t', 
-                   [])
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Iterator::ReadLsbtohU32() [member function]
-    cls.add_method('ReadLsbtohU32', 
-                   'uint32_t', 
-                   [])
-    ## buffer.h (module 'network'): uint64_t ns3::Buffer::Iterator::ReadLsbtohU64() [member function]
-    cls.add_method('ReadLsbtohU64', 
-                   'uint64_t', 
-                   [])
-    ## buffer.h (module 'network'): uint16_t ns3::Buffer::Iterator::ReadNtohU16() [member function]
-    cls.add_method('ReadNtohU16', 
-                   'uint16_t', 
-                   [])
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Iterator::ReadNtohU32() [member function]
-    cls.add_method('ReadNtohU32', 
-                   'uint32_t', 
-                   [])
-    ## buffer.h (module 'network'): uint64_t ns3::Buffer::Iterator::ReadNtohU64() [member function]
-    cls.add_method('ReadNtohU64', 
-                   'uint64_t', 
-                   [])
-    ## buffer.h (module 'network'): uint16_t ns3::Buffer::Iterator::ReadU16() [member function]
-    cls.add_method('ReadU16', 
-                   'uint16_t', 
-                   [])
-    ## buffer.h (module 'network'): uint32_t ns3::Buffer::Iterator::ReadU32() [member function]
-    cls.add_method('ReadU32', 
-                   'uint32_t', 
-                   [])
-    ## buffer.h (module 'network'): uint64_t ns3::Buffer::Iterator::ReadU64() [member function]
-    cls.add_method('ReadU64', 
-                   'uint64_t', 
-                   [])
-    ## buffer.h (module 'network'): uint8_t ns3::Buffer::Iterator::ReadU8() [member function]
-    cls.add_method('ReadU8', 
-                   'uint8_t', 
-                   [])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Write(uint8_t const * buffer, uint32_t size) [member function]
-    cls.add_method('Write', 
-                   'void', 
-                   [param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::Write(ns3::Buffer::Iterator start, ns3::Buffer::Iterator end) [member function]
-    cls.add_method('Write', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteHtolsbU16(uint16_t data) [member function]
-    cls.add_method('WriteHtolsbU16', 
-                   'void', 
-                   [param('uint16_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteHtolsbU32(uint32_t data) [member function]
-    cls.add_method('WriteHtolsbU32', 
-                   'void', 
-                   [param('uint32_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteHtolsbU64(uint64_t data) [member function]
-    cls.add_method('WriteHtolsbU64', 
-                   'void', 
-                   [param('uint64_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteHtonU16(uint16_t data) [member function]
-    cls.add_method('WriteHtonU16', 
-                   'void', 
-                   [param('uint16_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteHtonU32(uint32_t data) [member function]
-    cls.add_method('WriteHtonU32', 
-                   'void', 
-                   [param('uint32_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteHtonU64(uint64_t data) [member function]
-    cls.add_method('WriteHtonU64', 
-                   'void', 
-                   [param('uint64_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteU16(uint16_t data) [member function]
-    cls.add_method('WriteU16', 
-                   'void', 
-                   [param('uint16_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteU32(uint32_t data) [member function]
-    cls.add_method('WriteU32', 
-                   'void', 
-                   [param('uint32_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteU64(uint64_t data) [member function]
-    cls.add_method('WriteU64', 
-                   'void', 
-                   [param('uint64_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteU8(uint8_t data) [member function]
-    cls.add_method('WriteU8', 
-                   'void', 
-                   [param('uint8_t', 'data')])
-    ## buffer.h (module 'network'): void ns3::Buffer::Iterator::WriteU8(uint8_t data, uint32_t len) [member function]
-    cls.add_method('WriteU8', 
-                   'void', 
-                   [param('uint8_t', 'data'), param('uint32_t', 'len')])
-    return
-
-def register_Ns3BufferSizeLevelBsr_methods(root_module, cls):
-    ## lte-common.h (module 'lte'): ns3::BufferSizeLevelBsr::BufferSizeLevelBsr() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::BufferSizeLevelBsr::BufferSizeLevelBsr(ns3::BufferSizeLevelBsr const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BufferSizeLevelBsr const &', 'arg0')])
-    ## lte-common.h (module 'lte'): static uint32_t ns3::BufferSizeLevelBsr::BsrId2BufferSize(uint8_t val) [member function]
-    cls.add_method('BsrId2BufferSize', 
-                   'uint32_t', 
-                   [param('uint8_t', 'val')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static uint8_t ns3::BufferSizeLevelBsr::BufferSize2BsrId(uint32_t val) [member function]
-    cls.add_method('BufferSize2BsrId', 
-                   'uint8_t', 
-                   [param('uint32_t', 'val')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): ns3::BufferSizeLevelBsr::m_bufferSizeLevelBsr [variable]
-    cls.add_static_attribute('m_bufferSizeLevelBsr', 'int [ 64 ]', is_const=False)
-    return
-
-def register_Ns3BuildBroadcastListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::BuildBroadcastListElement_s::BuildBroadcastListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::BuildBroadcastListElement_s::BuildBroadcastListElement_s(ns3::BuildBroadcastListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BuildBroadcastListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::BuildBroadcastListElement_s::m_dci [variable]
-    cls.add_instance_attribute('m_dci', 'ns3::DlDciListElement_s', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BuildBroadcastListElement_s::m_index [variable]
-    cls.add_instance_attribute('m_index', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BuildBroadcastListElement_s::m_type [variable]
-    cls.add_instance_attribute('m_type', 'ns3::BuildBroadcastListElement_s::Type_e', is_const=False)
-    return
-
-def register_Ns3BuildDataListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::BuildDataListElement_s::BuildDataListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::BuildDataListElement_s::BuildDataListElement_s(ns3::BuildDataListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BuildDataListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::BuildDataListElement_s::m_ceBitmap [variable]
-    cls.add_instance_attribute('m_ceBitmap', 'std::vector< ns3::CeBitmap_e >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BuildDataListElement_s::m_dci [variable]
-    cls.add_instance_attribute('m_dci', 'ns3::DlDciListElement_s', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BuildDataListElement_s::m_rlcPduList [variable]
-    cls.add_instance_attribute('m_rlcPduList', 'std::vector< std::vector< ns3::RlcPduListElement_s > >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BuildDataListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3BuildRarListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::BuildRarListElement_s::BuildRarListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::BuildRarListElement_s::BuildRarListElement_s(ns3::BuildRarListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BuildRarListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::BuildRarListElement_s::m_dci [variable]
-    cls.add_instance_attribute('m_dci', 'ns3::DlDciListElement_s', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BuildRarListElement_s::m_grant [variable]
-    cls.add_instance_attribute('m_grant', 'ns3::UlGrant_s', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BuildRarListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3BwPart_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::BwPart_s::BwPart_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::BwPart_s::BwPart_s(ns3::BwPart_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BwPart_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::BwPart_s::m_bwPartIndex [variable]
-    cls.add_instance_attribute('m_bwPartIndex', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BwPart_s::m_cqi [variable]
-    cls.add_instance_attribute('m_cqi', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::BwPart_s::m_sb [variable]
-    cls.add_instance_attribute('m_sb', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3ByteTagIterator_methods(root_module, cls):
-    ## packet.h (module 'network'): ns3::ByteTagIterator::ByteTagIterator(ns3::ByteTagIterator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ByteTagIterator const &', 'arg0')])
-    ## packet.h (module 'network'): bool ns3::ByteTagIterator::HasNext() const [member function]
-    cls.add_method('HasNext', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::ByteTagIterator::Item ns3::ByteTagIterator::Next() [member function]
-    cls.add_method('Next', 
-                   'ns3::ByteTagIterator::Item', 
-                   [])
-    return
-
-def register_Ns3ByteTagIteratorItem_methods(root_module, cls):
-    ## packet.h (module 'network'): ns3::ByteTagIterator::Item::Item(ns3::ByteTagIterator::Item const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ByteTagIterator::Item const &', 'arg0')])
-    ## packet.h (module 'network'): uint32_t ns3::ByteTagIterator::Item::GetEnd() const [member function]
-    cls.add_method('GetEnd', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): uint32_t ns3::ByteTagIterator::Item::GetStart() const [member function]
-    cls.add_method('GetStart', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::ByteTagIterator::Item::GetTag(ns3::Tag & tag) const [member function]
-    cls.add_method('GetTag', 
-                   'void', 
-                   [param('ns3::Tag &', 'tag')], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::TypeId ns3::ByteTagIterator::Item::GetTypeId() const [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True)
-    return
-
-def register_Ns3ByteTagList_methods(root_module, cls):
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::ByteTagList() [constructor]
-    cls.add_constructor([])
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::ByteTagList(ns3::ByteTagList const & o) [constructor]
-    cls.add_constructor([param('ns3::ByteTagList const &', 'o')])
-    ## byte-tag-list.h (module 'network'): ns3::TagBuffer ns3::ByteTagList::Add(ns3::TypeId tid, uint32_t bufferSize, int32_t start, int32_t end) [member function]
-    cls.add_method('Add', 
-                   'ns3::TagBuffer', 
-                   [param('ns3::TypeId', 'tid'), param('uint32_t', 'bufferSize'), param('int32_t', 'start'), param('int32_t', 'end')])
-    ## byte-tag-list.h (module 'network'): void ns3::ByteTagList::Add(ns3::ByteTagList const & o) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::ByteTagList const &', 'o')])
-    ## byte-tag-list.h (module 'network'): void ns3::ByteTagList::AddAtEnd(int32_t appendOffset) [member function]
-    cls.add_method('AddAtEnd', 
-                   'void', 
-                   [param('int32_t', 'appendOffset')])
-    ## byte-tag-list.h (module 'network'): void ns3::ByteTagList::AddAtStart(int32_t prependOffset) [member function]
-    cls.add_method('AddAtStart', 
-                   'void', 
-                   [param('int32_t', 'prependOffset')])
-    ## byte-tag-list.h (module 'network'): void ns3::ByteTagList::Adjust(int32_t adjustment) [member function]
-    cls.add_method('Adjust', 
-                   'void', 
-                   [param('int32_t', 'adjustment')])
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator ns3::ByteTagList::Begin(int32_t offsetStart, int32_t offsetEnd) const [member function]
-    cls.add_method('Begin', 
-                   'ns3::ByteTagList::Iterator', 
-                   [param('int32_t', 'offsetStart'), param('int32_t', 'offsetEnd')], 
-                   is_const=True)
-    ## byte-tag-list.h (module 'network'): void ns3::ByteTagList::RemoveAll() [member function]
-    cls.add_method('RemoveAll', 
-                   'void', 
-                   [])
-    return
-
-def register_Ns3ByteTagListIterator_methods(root_module, cls):
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Iterator(ns3::ByteTagList::Iterator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ByteTagList::Iterator const &', 'arg0')])
-    ## byte-tag-list.h (module 'network'): uint32_t ns3::ByteTagList::Iterator::GetOffsetStart() const [member function]
-    cls.add_method('GetOffsetStart', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## byte-tag-list.h (module 'network'): bool ns3::ByteTagList::Iterator::HasNext() const [member function]
-    cls.add_method('HasNext', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item ns3::ByteTagList::Iterator::Next() [member function]
-    cls.add_method('Next', 
-                   'ns3::ByteTagList::Iterator::Item', 
-                   [])
-    return
-
-def register_Ns3ByteTagListIteratorItem_methods(root_module, cls):
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item::Item(ns3::ByteTagList::Iterator::Item const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ByteTagList::Iterator::Item const &', 'arg0')])
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item::Item(ns3::TagBuffer buf) [constructor]
-    cls.add_constructor([param('ns3::TagBuffer', 'buf')])
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item::buf [variable]
-    cls.add_instance_attribute('buf', 'ns3::TagBuffer', is_const=False)
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item::end [variable]
-    cls.add_instance_attribute('end', 'int32_t', is_const=False)
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item::size [variable]
-    cls.add_instance_attribute('size', 'uint32_t', is_const=False)
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item::start [variable]
-    cls.add_instance_attribute('start', 'int32_t', is_const=False)
-    ## byte-tag-list.h (module 'network'): ns3::ByteTagList::Iterator::Item::tid [variable]
-    cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
-    return
-
-def register_Ns3CallbackBase_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackBase::CallbackBase(ns3::CallbackBase const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackBase const &', 'arg0')])
-    ## callback.h (module 'core'): ns3::CallbackBase::CallbackBase() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::Ptr<ns3::CallbackImplBase> ns3::CallbackBase::GetImpl() const [member function]
-    cls.add_method('GetImpl', 
-                   'ns3::Ptr< ns3::CallbackImplBase >', 
-                   [], 
-                   is_const=True)
-    ## callback.h (module 'core'): ns3::CallbackBase::CallbackBase(ns3::Ptr<ns3::CallbackImplBase> impl) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::CallbackImplBase >', 'impl')], 
-                        visibility='protected')
-    return
-
-def register_Ns3CqasFlowPerf_t_methods(root_module, cls):
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::CqasFlowPerf_t() [constructor]
-    cls.add_constructor([])
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::CqasFlowPerf_t(ns3::CqasFlowPerf_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CqasFlowPerf_t const &', 'arg0')])
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::flowStart [variable]
-    cls.add_instance_attribute('flowStart', 'ns3::Time', is_const=False)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::lastAveragedThroughput [variable]
-    cls.add_instance_attribute('lastAveragedThroughput', 'double', is_const=False)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::lastTtiBytesTransmitted [variable]
-    cls.add_instance_attribute('lastTtiBytesTransmitted', 'unsigned int', is_const=False)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::secondLastAveragedThroughput [variable]
-    cls.add_instance_attribute('secondLastAveragedThroughput', 'double', is_const=False)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::targetThroughput [variable]
-    cls.add_instance_attribute('targetThroughput', 'double', is_const=False)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqasFlowPerf_t::totalBytesTransmitted [variable]
-    cls.add_instance_attribute('totalBytesTransmitted', 'long unsigned int', is_const=False)
-    return
-
-def register_Ns3CqiConfig_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::CqiConfig_s::CqiConfig_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::CqiConfig_s::CqiConfig_s(ns3::CqiConfig_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CqiConfig_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::CqiConfig_s::m_action [variable]
-    cls.add_instance_attribute('m_action', 'ns3::SetupRelease_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::CqiConfig_s::m_cqiSchedInterval [variable]
-    cls.add_instance_attribute('m_cqiSchedInterval', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::CqiConfig_s::m_riSchedInterval [variable]
-    cls.add_instance_attribute('m_riSchedInterval', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3CqiListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::CqiListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::CqiListElement_s(ns3::CqiListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CqiListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::m_cqiType [variable]
-    cls.add_instance_attribute('m_cqiType', 'ns3::CqiListElement_s::CqiType_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::m_ri [variable]
-    cls.add_instance_attribute('m_ri', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::m_sbMeasResult [variable]
-    cls.add_instance_attribute('m_sbMeasResult', 'ns3::SbMeasResult_s', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::m_wbCqi [variable]
-    cls.add_instance_attribute('m_wbCqi', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::CqiListElement_s::m_wbPmi [variable]
-    cls.add_instance_attribute('m_wbPmi', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3DataOutputCallback_methods(root_module, cls):
-    ## data-output-interface.h (module 'stats'): ns3::DataOutputCallback::DataOutputCallback() [constructor]
-    cls.add_constructor([])
-    ## data-output-interface.h (module 'stats'): ns3::DataOutputCallback::DataOutputCallback(ns3::DataOutputCallback const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DataOutputCallback const &', 'arg0')])
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputCallback::OutputSingleton(std::string key, std::string variable, int val) [member function]
-    cls.add_method('OutputSingleton', 
-                   'void', 
-                   [param('std::string', 'key'), param('std::string', 'variable'), param('int', 'val')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputCallback::OutputSingleton(std::string key, std::string variable, uint32_t val) [member function]
-    cls.add_method('OutputSingleton', 
-                   'void', 
-                   [param('std::string', 'key'), param('std::string', 'variable'), param('uint32_t', 'val')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputCallback::OutputSingleton(std::string key, std::string variable, double val) [member function]
-    cls.add_method('OutputSingleton', 
-                   'void', 
-                   [param('std::string', 'key'), param('std::string', 'variable'), param('double', 'val')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputCallback::OutputSingleton(std::string key, std::string variable, std::string val) [member function]
-    cls.add_method('OutputSingleton', 
-                   'void', 
-                   [param('std::string', 'key'), param('std::string', 'variable'), param('std::string', 'val')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputCallback::OutputSingleton(std::string key, std::string variable, ns3::Time val) [member function]
-    cls.add_method('OutputSingleton', 
-                   'void', 
-                   [param('std::string', 'key'), param('std::string', 'variable'), param('ns3::Time', 'val')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputCallback::OutputStatistic(std::string key, std::string variable, ns3::StatisticalSummary const * statSum) [member function]
-    cls.add_method('OutputStatistic', 
-                   'void', 
-                   [param('std::string', 'key'), param('std::string', 'variable'), param('ns3::StatisticalSummary const *', 'statSum')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3DataRate_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('<=')
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('>')
-    cls.add_binary_comparison_operator('>=')
-    ## data-rate.h (module 'network'): ns3::DataRate::DataRate(ns3::DataRate const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DataRate const &', 'arg0')])
-    ## data-rate.h (module 'network'): ns3::DataRate::DataRate() [constructor]
-    cls.add_constructor([])
-    ## data-rate.h (module 'network'): ns3::DataRate::DataRate(uint64_t bps) [constructor]
-    cls.add_constructor([param('uint64_t', 'bps')])
-    ## data-rate.h (module 'network'): ns3::DataRate::DataRate(std::string rate) [constructor]
-    cls.add_constructor([param('std::string', 'rate')])
-    ## data-rate.h (module 'network'): ns3::Time ns3::DataRate::CalculateBitsTxTime(uint32_t bits) const [member function]
-    cls.add_method('CalculateBitsTxTime', 
-                   'ns3::Time', 
-                   [param('uint32_t', 'bits')], 
-                   is_const=True)
-    ## data-rate.h (module 'network'): ns3::Time ns3::DataRate::CalculateBytesTxTime(uint32_t bytes) const [member function]
-    cls.add_method('CalculateBytesTxTime', 
-                   'ns3::Time', 
-                   [param('uint32_t', 'bytes')], 
-                   is_const=True)
-    ## data-rate.h (module 'network'): double ns3::DataRate::CalculateTxTime(uint32_t bytes) const [member function]
-    cls.add_method('CalculateTxTime', 
-                   'double', 
-                   [param('uint32_t', 'bytes')], 
-                   is_const=True)
-    ## data-rate.h (module 'network'): uint64_t ns3::DataRate::GetBitRate() const [member function]
-    cls.add_method('GetBitRate', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3AttributeAccessor_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeAccessor>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeAccessor>::DefaultDeleter(ns3::DefaultDeleter<ns3::AttributeAccessor> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::AttributeAccessor > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::AttributeAccessor>::Delete(ns3::AttributeAccessor * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::AttributeAccessor *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3AttributeChecker_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeChecker>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeChecker>::DefaultDeleter(ns3::DefaultDeleter<ns3::AttributeChecker> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::AttributeChecker > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::AttributeChecker>::Delete(ns3::AttributeChecker * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::AttributeChecker *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3AttributeValue_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeValue>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::AttributeValue>::DefaultDeleter(ns3::DefaultDeleter<ns3::AttributeValue> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::AttributeValue > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::AttributeValue>::Delete(ns3::AttributeValue * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::AttributeValue *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3CallbackImplBase_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::CallbackImplBase>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::CallbackImplBase>::DefaultDeleter(ns3::DefaultDeleter<ns3::CallbackImplBase> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::CallbackImplBase > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::CallbackImplBase>::Delete(ns3::CallbackImplBase * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::CallbackImplBase *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3EpcTft_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::EpcTft>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::EpcTft>::DefaultDeleter(ns3::DefaultDeleter<ns3::EpcTft> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::EpcTft > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::EpcTft>::Delete(ns3::EpcTft * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::EpcTft *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3EventImpl_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::EventImpl>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::EventImpl>::DefaultDeleter(ns3::DefaultDeleter<ns3::EventImpl> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::EventImpl > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::EventImpl>::Delete(ns3::EventImpl * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::EventImpl *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3HashImplementation_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Hash::Implementation>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Hash::Implementation>::DefaultDeleter(ns3::DefaultDeleter<ns3::Hash::Implementation> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::Hash::Implementation > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::Hash::Implementation>::Delete(ns3::Hash::Implementation * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::Hash::Implementation *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3LteChunkProcessor_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteChunkProcessor>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteChunkProcessor>::DefaultDeleter(ns3::DefaultDeleter<ns3::LteChunkProcessor> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::LteChunkProcessor > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::LteChunkProcessor>::Delete(ns3::LteChunkProcessor * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::LteChunkProcessor *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3LteControlMessage_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteControlMessage>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteControlMessage>::DefaultDeleter(ns3::DefaultDeleter<ns3::LteControlMessage> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::LteControlMessage > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::LteControlMessage>::Delete(ns3::LteControlMessage * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::LteControlMessage *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3LteHarqPhy_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteHarqPhy>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::LteHarqPhy>::DefaultDeleter(ns3::DefaultDeleter<ns3::LteHarqPhy> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::LteHarqPhy > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::LteHarqPhy>::Delete(ns3::LteHarqPhy * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::LteHarqPhy *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3NixVector_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::NixVector>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::NixVector>::DefaultDeleter(ns3::DefaultDeleter<ns3::NixVector> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::NixVector > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::NixVector>::Delete(ns3::NixVector * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::NixVector *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3Packet_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Packet>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Packet>::DefaultDeleter(ns3::DefaultDeleter<ns3::Packet> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::Packet > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::Packet>::Delete(ns3::Packet * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::Packet *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3SpectrumModel_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumModel>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumModel>::DefaultDeleter(ns3::DefaultDeleter<ns3::SpectrumModel> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::SpectrumModel > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::SpectrumModel>::Delete(ns3::SpectrumModel * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::SpectrumModel *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3SpectrumValue_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumValue>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumValue>::DefaultDeleter(ns3::DefaultDeleter<ns3::SpectrumValue> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::SpectrumValue > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::SpectrumValue>::Delete(ns3::SpectrumValue * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::SpectrumValue *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3TraceSourceAccessor_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::TraceSourceAccessor>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::TraceSourceAccessor>::DefaultDeleter(ns3::DefaultDeleter<ns3::TraceSourceAccessor> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::TraceSourceAccessor > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::TraceSourceAccessor>::Delete(ns3::TraceSourceAccessor * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::TraceSourceAccessor *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3VendorSpecificValue_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::VendorSpecificValue>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::VendorSpecificValue>::DefaultDeleter(ns3::DefaultDeleter<ns3::VendorSpecificValue> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::VendorSpecificValue > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::VendorSpecificValue>::Delete(ns3::VendorSpecificValue * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::VendorSpecificValue *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3X2CellInfo_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::X2CellInfo>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::X2CellInfo>::DefaultDeleter(ns3::DefaultDeleter<ns3::X2CellInfo> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::X2CellInfo > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::X2CellInfo>::Delete(ns3::X2CellInfo * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::X2CellInfo *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DefaultDeleter__Ns3X2IfaceInfo_methods(root_module, cls):
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::X2IfaceInfo>::DefaultDeleter() [constructor]
-    cls.add_constructor([])
-    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::X2IfaceInfo>::DefaultDeleter(ns3::DefaultDeleter<ns3::X2IfaceInfo> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DefaultDeleter< ns3::X2IfaceInfo > const &', 'arg0')])
-    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::X2IfaceInfo>::Delete(ns3::X2IfaceInfo * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::X2IfaceInfo *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3DlDciListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::DlDciListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::DlDciListElement_s(ns3::DlDciListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DlDciListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_aggrLevel [variable]
-    cls.add_instance_attribute('m_aggrLevel', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_cceIndex [variable]
-    cls.add_instance_attribute('m_cceIndex', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_dai [variable]
-    cls.add_instance_attribute('m_dai', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_dlPowerOffset [variable]
-    cls.add_instance_attribute('m_dlPowerOffset', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_format [variable]
-    cls.add_instance_attribute('m_format', 'ns3::DlDciListElement_s::Format_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_harqProcess [variable]
-    cls.add_instance_attribute('m_harqProcess', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_mcs [variable]
-    cls.add_instance_attribute('m_mcs', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_nGap [variable]
-    cls.add_instance_attribute('m_nGap', 'ns3::DlDciListElement_s::Ngap_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_ndi [variable]
-    cls.add_instance_attribute('m_ndi', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_pdcchOrder [variable]
-    cls.add_instance_attribute('m_pdcchOrder', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_pdcchPowerOffset [variable]
-    cls.add_instance_attribute('m_pdcchPowerOffset', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_prachMaskIndex [variable]
-    cls.add_instance_attribute('m_prachMaskIndex', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_preambleIndex [variable]
-    cls.add_instance_attribute('m_preambleIndex', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_precodingInfo [variable]
-    cls.add_instance_attribute('m_precodingInfo', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_rbBitmap [variable]
-    cls.add_instance_attribute('m_rbBitmap', 'uint32_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_rbShift [variable]
-    cls.add_instance_attribute('m_rbShift', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_resAlloc [variable]
-    cls.add_instance_attribute('m_resAlloc', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_rv [variable]
-    cls.add_instance_attribute('m_rv', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_spsRelease [variable]
-    cls.add_instance_attribute('m_spsRelease', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_tbSwap [variable]
-    cls.add_instance_attribute('m_tbSwap', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_tbsIdx [variable]
-    cls.add_instance_attribute('m_tbsIdx', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_tbsSize [variable]
-    cls.add_instance_attribute('m_tbsSize', 'std::vector< unsigned short >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_tpc [variable]
-    cls.add_instance_attribute('m_tpc', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlDciListElement_s::m_vrbFormat [variable]
-    cls.add_instance_attribute('m_vrbFormat', 'ns3::DlDciListElement_s::VrbFormat_e', is_const=False)
-    return
-
-def register_Ns3DlInfoListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::DlInfoListElement_s::DlInfoListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::DlInfoListElement_s::DlInfoListElement_s(ns3::DlInfoListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DlInfoListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::DlInfoListElement_s::m_harqProcessId [variable]
-    cls.add_instance_attribute('m_harqProcessId', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlInfoListElement_s::m_harqStatus [variable]
-    cls.add_instance_attribute('m_harqStatus', 'std::vector< ns3::DlInfoListElement_s::HarqStatus_e >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DlInfoListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3DlSchedulingCallbackInfo_methods(root_module, cls):
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::DlSchedulingCallbackInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::DlSchedulingCallbackInfo(ns3::DlSchedulingCallbackInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DlSchedulingCallbackInfo const &', 'arg0')])
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::componentCarrierId [variable]
-    cls.add_instance_attribute('componentCarrierId', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::frameNo [variable]
-    cls.add_instance_attribute('frameNo', 'uint32_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::mcsTb1 [variable]
-    cls.add_instance_attribute('mcsTb1', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::mcsTb2 [variable]
-    cls.add_instance_attribute('mcsTb2', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::sizeTb1 [variable]
-    cls.add_instance_attribute('sizeTb1', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::sizeTb2 [variable]
-    cls.add_instance_attribute('sizeTb2', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::DlSchedulingCallbackInfo::subframeNo [variable]
-    cls.add_instance_attribute('subframeNo', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3DrxConfig_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::DrxConfig_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::DrxConfig_s(ns3::DrxConfig_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DrxConfig_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::m_drxInactivityTimer [variable]
-    cls.add_instance_attribute('m_drxInactivityTimer', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::m_drxRetransmissionTimer [variable]
-    cls.add_instance_attribute('m_drxRetransmissionTimer', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::m_drxShortCycleTimer [variable]
-    cls.add_instance_attribute('m_drxShortCycleTimer', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::m_longDrxCycle [variable]
-    cls.add_instance_attribute('m_longDrxCycle', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::m_longDrxCycleStartOffset [variable]
-    cls.add_instance_attribute('m_longDrxCycleStartOffset', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::m_onDurationTimer [variable]
-    cls.add_instance_attribute('m_onDurationTimer', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::DrxConfig_s::m_shortDrxCycle [variable]
-    cls.add_instance_attribute('m_shortDrxCycle', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcEnbS1SapProvider_methods(root_module, cls):
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::EpcEnbS1SapProvider() [constructor]
-    cls.add_constructor([])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::EpcEnbS1SapProvider(ns3::EpcEnbS1SapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbS1SapProvider const &', 'arg0')])
-    ## epc-enb-s1-sap.h (module 'lte'): void ns3::EpcEnbS1SapProvider::DoSendReleaseIndication(uint64_t imsi, uint16_t rnti, uint8_t bearerId) [member function]
-    cls.add_method('DoSendReleaseIndication', 
-                   'void', 
-                   [param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'bearerId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-enb-s1-sap.h (module 'lte'): void ns3::EpcEnbS1SapProvider::InitialUeMessage(uint64_t imsi, uint16_t rnti) [member function]
-    cls.add_method('InitialUeMessage', 
-                   'void', 
-                   [param('uint64_t', 'imsi'), param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-enb-s1-sap.h (module 'lte'): void ns3::EpcEnbS1SapProvider::PathSwitchRequest(ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters params) [member function]
-    cls.add_method('PathSwitchRequest', 
-                   'void', 
-                   [param('ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-enb-s1-sap.h (module 'lte'): void ns3::EpcEnbS1SapProvider::UeContextRelease(uint16_t rnti) [member function]
-    cls.add_method('UeContextRelease', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcEnbS1SapProviderBearerToBeSwitched_methods(root_module, cls):
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::BearerToBeSwitched::BearerToBeSwitched() [constructor]
-    cls.add_constructor([])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::BearerToBeSwitched::BearerToBeSwitched(ns3::EpcEnbS1SapProvider::BearerToBeSwitched const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbS1SapProvider::BearerToBeSwitched const &', 'arg0')])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::BearerToBeSwitched::epsBearerId [variable]
-    cls.add_instance_attribute('epsBearerId', 'uint8_t', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::BearerToBeSwitched::teid [variable]
-    cls.add_instance_attribute('teid', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3EpcEnbS1SapProviderPathSwitchRequestParameters_methods(root_module, cls):
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters::PathSwitchRequestParameters() [constructor]
-    cls.add_constructor([])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters::PathSwitchRequestParameters(ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters const &', 'arg0')])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters::bearersToBeSwitched [variable]
-    cls.add_instance_attribute('bearersToBeSwitched', 'std::list< ns3::EpcEnbS1SapProvider::BearerToBeSwitched >', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters::cellId [variable]
-    cls.add_instance_attribute('cellId', 'uint16_t', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters::mmeUeS1Id [variable]
-    cls.add_instance_attribute('mmeUeS1Id', 'uint32_t', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapProvider::PathSwitchRequestParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcEnbS1SapUser_methods(root_module, cls):
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::EpcEnbS1SapUser() [constructor]
-    cls.add_constructor([])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::EpcEnbS1SapUser(ns3::EpcEnbS1SapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbS1SapUser const &', 'arg0')])
-    ## epc-enb-s1-sap.h (module 'lte'): void ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequest(ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters params) [member function]
-    cls.add_method('DataRadioBearerSetupRequest', 
-                   'void', 
-                   [param('ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-enb-s1-sap.h (module 'lte'): void ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledge(ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters params) [member function]
-    cls.add_method('PathSwitchRequestAcknowledge', 
-                   'void', 
-                   [param('ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcEnbS1SapUserDataRadioBearerSetupRequestParameters_methods(root_module, cls):
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters::DataRadioBearerSetupRequestParameters() [constructor]
-    cls.add_constructor([])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters::DataRadioBearerSetupRequestParameters(ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters const &', 'arg0')])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters::bearer [variable]
-    cls.add_instance_attribute('bearer', 'ns3::EpsBearer', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters::bearerId [variable]
-    cls.add_instance_attribute('bearerId', 'uint8_t', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters::gtpTeid [variable]
-    cls.add_instance_attribute('gtpTeid', 'uint32_t', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters::transportLayerAddress [variable]
-    cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    return
-
-def register_Ns3EpcEnbS1SapUserPathSwitchRequestAcknowledgeParameters_methods(root_module, cls):
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters::PathSwitchRequestAcknowledgeParameters() [constructor]
-    cls.add_constructor([])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters::PathSwitchRequestAcknowledgeParameters(ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters const &', 'arg0')])
-    ## epc-enb-s1-sap.h (module 'lte'): ns3::EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS11Sap_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::EpcS11Sap() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::EpcS11Sap(ns3::EpcS11Sap const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11Sap const &', 'arg0')])
-    return
-
-def register_Ns3EpcS11SapFteid_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Fteid::Fteid() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Fteid::Fteid(ns3::EpcS11Sap::Fteid const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11Sap::Fteid const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Fteid::address [variable]
-    cls.add_instance_attribute('address', 'ns3::Ipv4Address', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Fteid::teid [variable]
-    cls.add_instance_attribute('teid', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3EpcS11SapGtpcMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::GtpcMessage::GtpcMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::GtpcMessage::GtpcMessage(ns3::EpcS11Sap::GtpcMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11Sap::GtpcMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::GtpcMessage::teid [variable]
-    cls.add_instance_attribute('teid', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3EpcS11SapUli_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Uli::Uli() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Uli::Uli(ns3::EpcS11Sap::Uli const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11Sap::Uli const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11Sap::Uli::gci [variable]
-    cls.add_instance_attribute('gci', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS11SapMme_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::EpcS11SapMme() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::EpcS11SapMme(ns3::EpcS11SapMme const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapMme const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): void ns3::EpcS11SapMme::CreateSessionResponse(ns3::EpcS11SapMme::CreateSessionResponseMessage msg) [member function]
-    cls.add_method('CreateSessionResponse', 
-                   'void', 
-                   [param('ns3::EpcS11SapMme::CreateSessionResponseMessage', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s11-sap.h (module 'lte'): void ns3::EpcS11SapMme::DeleteBearerRequest(ns3::EpcS11SapMme::DeleteBearerRequestMessage msg) [member function]
-    cls.add_method('DeleteBearerRequest', 
-                   'void', 
-                   [param('ns3::EpcS11SapMme::DeleteBearerRequestMessage', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s11-sap.h (module 'lte'): void ns3::EpcS11SapMme::ModifyBearerResponse(ns3::EpcS11SapMme::ModifyBearerResponseMessage msg) [member function]
-    cls.add_method('ModifyBearerResponse', 
-                   'void', 
-                   [param('ns3::EpcS11SapMme::ModifyBearerResponseMessage', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcS11SapMmeBearerContextCreated_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextCreated::BearerContextCreated() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextCreated::BearerContextCreated(ns3::EpcS11SapMme::BearerContextCreated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapMme::BearerContextCreated const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextCreated::bearerLevelQos [variable]
-    cls.add_instance_attribute('bearerLevelQos', 'ns3::EpsBearer', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextCreated::epsBearerId [variable]
-    cls.add_instance_attribute('epsBearerId', 'uint8_t', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextCreated::sgwFteid [variable]
-    cls.add_instance_attribute('sgwFteid', 'ns3::EpcS11Sap::Fteid', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextCreated::tft [variable]
-    cls.add_instance_attribute('tft', 'ns3::Ptr< ns3::EpcTft >', is_const=False)
-    return
-
-def register_Ns3EpcS11SapMmeBearerContextRemoved_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextRemoved::BearerContextRemoved() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextRemoved::BearerContextRemoved(ns3::EpcS11SapMme::BearerContextRemoved const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapMme::BearerContextRemoved const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::BearerContextRemoved::epsBearerId [variable]
-    cls.add_instance_attribute('epsBearerId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3EpcS11SapMmeCreateSessionResponseMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::CreateSessionResponseMessage::CreateSessionResponseMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::CreateSessionResponseMessage::CreateSessionResponseMessage(ns3::EpcS11SapMme::CreateSessionResponseMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapMme::CreateSessionResponseMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::CreateSessionResponseMessage::bearerContextsCreated [variable]
-    cls.add_instance_attribute('bearerContextsCreated', 'std::list< ns3::EpcS11SapMme::BearerContextCreated >', is_const=False)
-    return
-
-def register_Ns3EpcS11SapMmeDeleteBearerRequestMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::DeleteBearerRequestMessage::DeleteBearerRequestMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::DeleteBearerRequestMessage::DeleteBearerRequestMessage(ns3::EpcS11SapMme::DeleteBearerRequestMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapMme::DeleteBearerRequestMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::DeleteBearerRequestMessage::bearerContextsRemoved [variable]
-    cls.add_instance_attribute('bearerContextsRemoved', 'std::list< ns3::EpcS11SapMme::BearerContextRemoved >', is_const=False)
-    return
-
-def register_Ns3EpcS11SapMmeModifyBearerResponseMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::ModifyBearerResponseMessage::ModifyBearerResponseMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::ModifyBearerResponseMessage::ModifyBearerResponseMessage(ns3::EpcS11SapMme::ModifyBearerResponseMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapMme::ModifyBearerResponseMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapMme::ModifyBearerResponseMessage::cause [variable]
-    cls.add_instance_attribute('cause', 'ns3::EpcS11SapMme::ModifyBearerResponseMessage::Cause', is_const=False)
-    return
-
-def register_Ns3EpcS11SapSgw_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::EpcS11SapSgw() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::EpcS11SapSgw(ns3::EpcS11SapSgw const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): void ns3::EpcS11SapSgw::CreateSessionRequest(ns3::EpcS11SapSgw::CreateSessionRequestMessage msg) [member function]
-    cls.add_method('CreateSessionRequest', 
-                   'void', 
-                   [param('ns3::EpcS11SapSgw::CreateSessionRequestMessage', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s11-sap.h (module 'lte'): void ns3::EpcS11SapSgw::DeleteBearerCommand(ns3::EpcS11SapSgw::DeleteBearerCommandMessage msg) [member function]
-    cls.add_method('DeleteBearerCommand', 
-                   'void', 
-                   [param('ns3::EpcS11SapSgw::DeleteBearerCommandMessage', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s11-sap.h (module 'lte'): void ns3::EpcS11SapSgw::DeleteBearerResponse(ns3::EpcS11SapSgw::DeleteBearerResponseMessage msg) [member function]
-    cls.add_method('DeleteBearerResponse', 
-                   'void', 
-                   [param('ns3::EpcS11SapSgw::DeleteBearerResponseMessage', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s11-sap.h (module 'lte'): void ns3::EpcS11SapSgw::ModifyBearerRequest(ns3::EpcS11SapSgw::ModifyBearerRequestMessage msg) [member function]
-    cls.add_method('ModifyBearerRequest', 
-                   'void', 
-                   [param('ns3::EpcS11SapSgw::ModifyBearerRequestMessage', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcS11SapSgwBearerContextRemovedSgwPgw_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw::BearerContextRemovedSgwPgw() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw::BearerContextRemovedSgwPgw(ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw::epsBearerId [variable]
-    cls.add_instance_attribute('epsBearerId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3EpcS11SapSgwBearerContextToBeCreated_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeCreated::BearerContextToBeCreated() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeCreated::BearerContextToBeCreated(ns3::EpcS11SapSgw::BearerContextToBeCreated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw::BearerContextToBeCreated const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeCreated::bearerLevelQos [variable]
-    cls.add_instance_attribute('bearerLevelQos', 'ns3::EpsBearer', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeCreated::epsBearerId [variable]
-    cls.add_instance_attribute('epsBearerId', 'uint8_t', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeCreated::sgwFteid [variable]
-    cls.add_instance_attribute('sgwFteid', 'ns3::EpcS11Sap::Fteid', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeCreated::tft [variable]
-    cls.add_instance_attribute('tft', 'ns3::Ptr< ns3::EpcTft >', is_const=False)
-    return
-
-def register_Ns3EpcS11SapSgwBearerContextToBeRemoved_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeRemoved::BearerContextToBeRemoved() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeRemoved::BearerContextToBeRemoved(ns3::EpcS11SapSgw::BearerContextToBeRemoved const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw::BearerContextToBeRemoved const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::BearerContextToBeRemoved::epsBearerId [variable]
-    cls.add_instance_attribute('epsBearerId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3EpcS11SapSgwCreateSessionRequestMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::CreateSessionRequestMessage::CreateSessionRequestMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::CreateSessionRequestMessage::CreateSessionRequestMessage(ns3::EpcS11SapSgw::CreateSessionRequestMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw::CreateSessionRequestMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::CreateSessionRequestMessage::bearerContextsToBeCreated [variable]
-    cls.add_instance_attribute('bearerContextsToBeCreated', 'std::list< ns3::EpcS11SapSgw::BearerContextToBeCreated >', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::CreateSessionRequestMessage::imsi [variable]
-    cls.add_instance_attribute('imsi', 'uint64_t', is_const=False)
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::CreateSessionRequestMessage::uli [variable]
-    cls.add_instance_attribute('uli', 'ns3::EpcS11Sap::Uli', is_const=False)
-    return
-
-def register_Ns3EpcS11SapSgwDeleteBearerCommandMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerCommandMessage::DeleteBearerCommandMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerCommandMessage::DeleteBearerCommandMessage(ns3::EpcS11SapSgw::DeleteBearerCommandMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw::DeleteBearerCommandMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerCommandMessage::bearerContextsToBeRemoved [variable]
-    cls.add_instance_attribute('bearerContextsToBeRemoved', 'std::list< ns3::EpcS11SapSgw::BearerContextToBeRemoved >', is_const=False)
-    return
-
-def register_Ns3EpcS11SapSgwDeleteBearerResponseMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerResponseMessage::DeleteBearerResponseMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerResponseMessage::DeleteBearerResponseMessage(ns3::EpcS11SapSgw::DeleteBearerResponseMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw::DeleteBearerResponseMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::DeleteBearerResponseMessage::bearerContextsRemoved [variable]
-    cls.add_instance_attribute('bearerContextsRemoved', 'std::list< ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw >', is_const=False)
-    return
-
-def register_Ns3EpcS11SapSgwModifyBearerRequestMessage_methods(root_module, cls):
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::ModifyBearerRequestMessage::ModifyBearerRequestMessage() [constructor]
-    cls.add_constructor([])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::ModifyBearerRequestMessage::ModifyBearerRequestMessage(ns3::EpcS11SapSgw::ModifyBearerRequestMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS11SapSgw::ModifyBearerRequestMessage const &', 'arg0')])
-    ## epc-s11-sap.h (module 'lte'): ns3::EpcS11SapSgw::ModifyBearerRequestMessage::uli [variable]
-    cls.add_instance_attribute('uli', 'ns3::EpcS11Sap::Uli', is_const=False)
-    return
-
-def register_Ns3EpcS1apSap_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::EpcS1apSap() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::EpcS1apSap(ns3::EpcS1apSap const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSap const &', 'arg0')])
-    return
-
-def register_Ns3EpcS1apSapEnb_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb(ns3::EpcS1apSapEnb const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::InitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapEnb::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSapEnb::ErabToBeSetupItem> > erabToBeSetupList) [member function]
-    cls.add_method('InitialContextSetupRequest', 
-                   'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapEnb::ErabToBeSetupItem >', 'erabToBeSetupList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::PathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
-    cls.add_method('PathSwitchRequestAcknowledge', 
-                   'void', 
-                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcS1apSapEnbErabSwitchedInUplinkItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem(ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::enbTeid [variable]
-    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::transportLayerAddress [variable]
-    cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapEnbErabToBeSetupItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::ErabToBeSetupItem() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::ErabToBeSetupItem(ns3::EpcS1apSapEnb::ErabToBeSetupItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb::ErabToBeSetupItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::erabLevelQosParameters [variable]
-    cls.add_instance_attribute('erabLevelQosParameters', 'ns3::EpsBearer', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::sgwTeid [variable]
-    cls.add_instance_attribute('sgwTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::transportLayerAddress [variable]
-    cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapMme_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::EpcS1apSapMme() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::EpcS1apSapMme(ns3::EpcS1apSapMme const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::ErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapMme::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSapMme::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
-    cls.add_method('ErabReleaseIndication', 
-                   'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapMme::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapMme::ErabSetupItem, std::allocator<ns3::EpcS1apSapMme::ErabSetupItem> > erabSetupList) [member function]
-    cls.add_method('InitialContextSetupResponse', 
-                   'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapMme::ErabSetupItem >', 'erabSetupList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialUeMessage(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) [member function]
-    cls.add_method('InitialUeMessage', 
-                   'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('uint64_t', 'stmsi'), param('uint16_t', 'ecgi')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::PathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
-    cls.add_method('PathSwitchRequest', 
-                   'void', 
-                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcS1apSapMmeErabSetupItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::ErabSetupItem() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::ErabSetupItem(ns3::EpcS1apSapMme::ErabSetupItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabSetupItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::enbTeid [variable]
-    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::enbTransportLayerAddress [variable]
-    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapMmeErabSwitchedInDownlinkItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem(ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::enbTeid [variable]
-    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::enbTransportLayerAddress [variable]
-    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapMmeErabToBeReleasedIndication_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::ErabToBeReleasedIndication() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::ErabToBeReleasedIndication(ns3::EpcS1apSapMme::ErabToBeReleasedIndication const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabToBeReleasedIndication const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3EpcX2Sap_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::EpcX2Sap() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::EpcX2Sap(ns3::EpcX2Sap const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::m_maxPdcpSn [variable]
-    cls.add_static_attribute('m_maxPdcpSn', 'uint16_t const', is_const=True)
-    return
-
-def register_Ns3EpcX2SapCellInformationItem_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellInformationItem::CellInformationItem() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellInformationItem::CellInformationItem(ns3::EpcX2Sap::CellInformationItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::CellInformationItem const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellInformationItem::relativeNarrowbandTxBand [variable]
-    cls.add_instance_attribute('relativeNarrowbandTxBand', 'ns3::EpcX2Sap::RelativeNarrowbandTxBand', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellInformationItem::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellInformationItem::ulHighInterferenceInformationList [variable]
-    cls.add_instance_attribute('ulHighInterferenceInformationList', 'std::vector< ns3::EpcX2Sap::UlHighInterferenceInformationItem >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellInformationItem::ulInterferenceOverloadIndicationList [variable]
-    cls.add_instance_attribute('ulInterferenceOverloadIndicationList', 'std::vector< ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem >', is_const=False)
-    return
-
-def register_Ns3EpcX2SapCellMeasurementResultItem_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::CellMeasurementResultItem() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::CellMeasurementResultItem(ns3::EpcX2Sap::CellMeasurementResultItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::CellMeasurementResultItem const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::dlCompositeAvailableCapacity [variable]
-    cls.add_instance_attribute('dlCompositeAvailableCapacity', 'ns3::EpcX2Sap::CompositeAvailCapacity', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::dlGbrPrbUsage [variable]
-    cls.add_instance_attribute('dlGbrPrbUsage', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::dlHardwareLoadIndicator [variable]
-    cls.add_instance_attribute('dlHardwareLoadIndicator', 'ns3::EpcX2Sap::LoadIndicator', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::dlNonGbrPrbUsage [variable]
-    cls.add_instance_attribute('dlNonGbrPrbUsage', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::dlS1TnlLoadIndicator [variable]
-    cls.add_instance_attribute('dlS1TnlLoadIndicator', 'ns3::EpcX2Sap::LoadIndicator', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::dlTotalPrbUsage [variable]
-    cls.add_instance_attribute('dlTotalPrbUsage', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::ulCompositeAvailableCapacity [variable]
-    cls.add_instance_attribute('ulCompositeAvailableCapacity', 'ns3::EpcX2Sap::CompositeAvailCapacity', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::ulGbrPrbUsage [variable]
-    cls.add_instance_attribute('ulGbrPrbUsage', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::ulHardwareLoadIndicator [variable]
-    cls.add_instance_attribute('ulHardwareLoadIndicator', 'ns3::EpcX2Sap::LoadIndicator', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::ulNonGbrPrbUsage [variable]
-    cls.add_instance_attribute('ulNonGbrPrbUsage', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::ulS1TnlLoadIndicator [variable]
-    cls.add_instance_attribute('ulS1TnlLoadIndicator', 'ns3::EpcX2Sap::LoadIndicator', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CellMeasurementResultItem::ulTotalPrbUsage [variable]
-    cls.add_instance_attribute('ulTotalPrbUsage', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapCompositeAvailCapacity_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CompositeAvailCapacity::CompositeAvailCapacity() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CompositeAvailCapacity::CompositeAvailCapacity(ns3::EpcX2Sap::CompositeAvailCapacity const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::CompositeAvailCapacity const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CompositeAvailCapacity::capacityValue [variable]
-    cls.add_instance_attribute('capacityValue', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::CompositeAvailCapacity::cellCapacityClassValue [variable]
-    cls.add_instance_attribute('cellCapacityClassValue', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapErabAdmittedItem_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabAdmittedItem::ErabAdmittedItem() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabAdmittedItem::ErabAdmittedItem(ns3::EpcX2Sap::ErabAdmittedItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::ErabAdmittedItem const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabAdmittedItem::dlGtpTeid [variable]
-    cls.add_instance_attribute('dlGtpTeid', 'uint32_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabAdmittedItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabAdmittedItem::ulGtpTeid [variable]
-    cls.add_instance_attribute('ulGtpTeid', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapErabNotAdmittedItem_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabNotAdmittedItem::ErabNotAdmittedItem() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabNotAdmittedItem::ErabNotAdmittedItem(ns3::EpcX2Sap::ErabNotAdmittedItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::ErabNotAdmittedItem const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabNotAdmittedItem::cause [variable]
-    cls.add_instance_attribute('cause', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabNotAdmittedItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapErabToBeSetupItem_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem::ErabToBeSetupItem(ns3::EpcX2Sap::ErabToBeSetupItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::ErabToBeSetupItem const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem::ErabToBeSetupItem() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem::dlForwarding [variable]
-    cls.add_instance_attribute('dlForwarding', 'bool', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem::erabLevelQosParameters [variable]
-    cls.add_instance_attribute('erabLevelQosParameters', 'ns3::EpsBearer', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem::gtpTeid [variable]
-    cls.add_instance_attribute('gtpTeid', 'uint32_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabToBeSetupItem::transportLayerAddress [variable]
-    cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    return
-
-def register_Ns3EpcX2SapErabsSubjectToStatusTransferItem_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::ErabsSubjectToStatusTransferItem() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::ErabsSubjectToStatusTransferItem(ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::dlHfn [variable]
-    cls.add_instance_attribute('dlHfn', 'uint32_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::dlPdcpSn [variable]
-    cls.add_instance_attribute('dlPdcpSn', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::receiveStatusOfUlPdcpSdus [variable]
-    cls.add_instance_attribute('receiveStatusOfUlPdcpSdus', 'std::bitset< 4096 >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::ulHfn [variable]
-    cls.add_instance_attribute('ulHfn', 'uint32_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem::ulPdcpSn [variable]
-    cls.add_instance_attribute('ulPdcpSn', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapHandoverPreparationFailureParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::HandoverPreparationFailureParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::HandoverPreparationFailureParams(ns3::EpcX2Sap::HandoverPreparationFailureParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::HandoverPreparationFailureParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::cause [variable]
-    cls.add_instance_attribute('cause', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::criticalityDiagnostics [variable]
-    cls.add_instance_attribute('criticalityDiagnostics', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::oldEnbUeX2apId [variable]
-    cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapHandoverRequestAckParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::HandoverRequestAckParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::HandoverRequestAckParams(ns3::EpcX2Sap::HandoverRequestAckParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::HandoverRequestAckParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::admittedBearers [variable]
-    cls.add_instance_attribute('admittedBearers', 'std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::newEnbUeX2apId [variable]
-    cls.add_instance_attribute('newEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::notAdmittedBearers [variable]
-    cls.add_instance_attribute('notAdmittedBearers', 'std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::oldEnbUeX2apId [variable]
-    cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::rrcContext [variable]
-    cls.add_instance_attribute('rrcContext', 'ns3::Ptr< ns3::Packet >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapHandoverRequestParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::HandoverRequestParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::HandoverRequestParams(ns3::EpcX2Sap::HandoverRequestParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::HandoverRequestParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::bearers [variable]
-    cls.add_instance_attribute('bearers', 'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::cause [variable]
-    cls.add_instance_attribute('cause', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::mmeUeS1apId [variable]
-    cls.add_instance_attribute('mmeUeS1apId', 'uint32_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::oldEnbUeX2apId [variable]
-    cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::rrcContext [variable]
-    cls.add_instance_attribute('rrcContext', 'ns3::Ptr< ns3::Packet >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::ueAggregateMaxBitRateDownlink [variable]
-    cls.add_instance_attribute('ueAggregateMaxBitRateDownlink', 'uint64_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::ueAggregateMaxBitRateUplink [variable]
-    cls.add_instance_attribute('ueAggregateMaxBitRateUplink', 'uint64_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapLoadInformationParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::LoadInformationParams::LoadInformationParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::LoadInformationParams::LoadInformationParams(ns3::EpcX2Sap::LoadInformationParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::LoadInformationParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::LoadInformationParams::cellInformationList [variable]
-    cls.add_instance_attribute('cellInformationList', 'std::vector< ns3::EpcX2Sap::CellInformationItem >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::LoadInformationParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapRelativeNarrowbandTxBand_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand::RelativeNarrowbandTxBand() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand::RelativeNarrowbandTxBand(ns3::EpcX2Sap::RelativeNarrowbandTxBand const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::RelativeNarrowbandTxBand const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand::antennaPorts [variable]
-    cls.add_instance_attribute('antennaPorts', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand::pB [variable]
-    cls.add_instance_attribute('pB', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand::pdcchInterferenceImpact [variable]
-    cls.add_instance_attribute('pdcchInterferenceImpact', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand::rntpPerPrbList [variable]
-    cls.add_instance_attribute('rntpPerPrbList', 'std::vector< bool >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RelativeNarrowbandTxBand::rntpThreshold [variable]
-    cls.add_instance_attribute('rntpThreshold', 'int16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapResourceStatusUpdateParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams::ResourceStatusUpdateParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams::ResourceStatusUpdateParams(ns3::EpcX2Sap::ResourceStatusUpdateParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::ResourceStatusUpdateParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams::cellMeasurementResultList [variable]
-    cls.add_instance_attribute('cellMeasurementResultList', 'std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams::enb1MeasurementId [variable]
-    cls.add_instance_attribute('enb1MeasurementId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams::enb2MeasurementId [variable]
-    cls.add_instance_attribute('enb2MeasurementId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapSnStatusTransferParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::SnStatusTransferParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::SnStatusTransferParams(ns3::EpcX2Sap::SnStatusTransferParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::SnStatusTransferParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::erabsSubjectToStatusTransferList [variable]
-    cls.add_instance_attribute('erabsSubjectToStatusTransferList', 'std::vector< ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem >', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::newEnbUeX2apId [variable]
-    cls.add_instance_attribute('newEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::oldEnbUeX2apId [variable]
-    cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapUeContextReleaseParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::UeContextReleaseParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::UeContextReleaseParams(ns3::EpcX2Sap::UeContextReleaseParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::UeContextReleaseParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::newEnbUeX2apId [variable]
-    cls.add_instance_attribute('newEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::oldEnbUeX2apId [variable]
-    cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcX2SapUeDataParams_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams::UeDataParams() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams::UeDataParams(ns3::EpcX2Sap::UeDataParams const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::UeDataParams const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams::gtpTeid [variable]
-    cls.add_instance_attribute('gtpTeid', 'uint32_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams::sourceCellId [variable]
-    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams::ueData [variable]
-    cls.add_instance_attribute('ueData', 'ns3::Ptr< ns3::Packet >', is_const=False)
-    return
-
-def register_Ns3EpcX2SapUlHighInterferenceInformationItem_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem::UlHighInterferenceInformationItem() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem::UlHighInterferenceInformationItem(ns3::EpcX2Sap::UlHighInterferenceInformationItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Sap::UlHighInterferenceInformationItem const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem::targetCellId [variable]
-    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem::ulHighInterferenceIndicationList [variable]
-    cls.add_instance_attribute('ulHighInterferenceIndicationList', 'std::vector< bool >', is_const=False)
-    return
-
-def register_Ns3EpcX2SapProvider_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapProvider::EpcX2SapProvider() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapProvider::EpcX2SapProvider(ns3::EpcX2SapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2SapProvider const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
-    cls.add_method('SendHandoverPreparationFailure', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverPreparationFailureParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendHandoverRequest(ns3::EpcX2Sap::HandoverRequestParams params) [member function]
-    cls.add_method('SendHandoverRequest', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendHandoverRequestAck(ns3::EpcX2Sap::HandoverRequestAckParams params) [member function]
-    cls.add_method('SendHandoverRequestAck', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestAckParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('SendLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
-    cls.add_method('SendResourceStatusUpdate', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
-    cls.add_method('SendSnStatusTransfer', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
-    cls.add_method('SendUeContextRelease', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::UeContextReleaseParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendUeData(ns3::EpcX2Sap::UeDataParams params) [member function]
-    cls.add_method('SendUeData', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcX2SapUser_methods(root_module, cls):
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapUser::EpcX2SapUser() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapUser::EpcX2SapUser(ns3::EpcX2SapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2SapUser const &', 'arg0')])
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
-    cls.add_method('RecvHandoverPreparationFailure', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverPreparationFailureParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvHandoverRequest(ns3::EpcX2Sap::HandoverRequestParams params) [member function]
-    cls.add_method('RecvHandoverRequest', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvHandoverRequestAck(ns3::EpcX2Sap::HandoverRequestAckParams params) [member function]
-    cls.add_method('RecvHandoverRequestAck', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestAckParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('RecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
-    cls.add_method('RecvResourceStatusUpdate', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
-    cls.add_method('RecvSnStatusTransfer', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
-    cls.add_method('RecvUeContextRelease', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::UeContextReleaseParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvUeData(ns3::EpcX2Sap::UeDataParams params) [member function]
-    cls.add_method('RecvUeData', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpsBearer_methods(root_module, cls):
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::EpsBearer(ns3::EpsBearer const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpsBearer const &', 'arg0')])
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::EpsBearer() [constructor]
-    cls.add_constructor([])
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::EpsBearer(ns3::EpsBearer::Qci x) [constructor]
-    cls.add_constructor([param('ns3::EpsBearer::Qci', 'x')])
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::EpsBearer(ns3::EpsBearer::Qci x, ns3::GbrQosInformation y) [constructor]
-    cls.add_constructor([param('ns3::EpsBearer::Qci', 'x'), param('ns3::GbrQosInformation', 'y')])
-    ## eps-bearer.h (module 'lte'): uint16_t ns3::EpsBearer::GetPacketDelayBudgetMs() const [member function]
-    cls.add_method('GetPacketDelayBudgetMs', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## eps-bearer.h (module 'lte'): double ns3::EpsBearer::GetPacketErrorLossRate() const [member function]
-    cls.add_method('GetPacketErrorLossRate', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## eps-bearer.h (module 'lte'): uint8_t ns3::EpsBearer::GetPriority() const [member function]
-    cls.add_method('GetPriority', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## eps-bearer.h (module 'lte'): bool ns3::EpsBearer::IsGbr() const [member function]
-    cls.add_method('IsGbr', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::arp [variable]
-    cls.add_instance_attribute('arp', 'ns3::AllocationRetentionPriority', is_const=False)
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::gbrQosInfo [variable]
-    cls.add_instance_attribute('gbrQosInfo', 'ns3::GbrQosInformation', is_const=False)
-    ## eps-bearer.h (module 'lte'): ns3::EpsBearer::qci [variable]
-    cls.add_instance_attribute('qci', 'ns3::EpsBearer::Qci', is_const=False)
-    return
-
-def register_Ns3EutranMeasurementMapping_methods(root_module, cls):
-    ## lte-common.h (module 'lte'): ns3::EutranMeasurementMapping::EutranMeasurementMapping() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::EutranMeasurementMapping::EutranMeasurementMapping(ns3::EutranMeasurementMapping const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EutranMeasurementMapping const &', 'arg0')])
-    ## lte-common.h (module 'lte'): static int8_t ns3::EutranMeasurementMapping::ActualA3Offset2IeValue(double a3OffsetDb) [member function]
-    cls.add_method('ActualA3Offset2IeValue', 
-                   'int8_t', 
-                   [param('double', 'a3OffsetDb')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static uint8_t ns3::EutranMeasurementMapping::ActualHysteresis2IeValue(double hysteresisDb) [member function]
-    cls.add_method('ActualHysteresis2IeValue', 
-                   'uint8_t', 
-                   [param('double', 'hysteresisDb')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static uint8_t ns3::EutranMeasurementMapping::Db2RsrqRange(double db) [member function]
-    cls.add_method('Db2RsrqRange', 
-                   'uint8_t', 
-                   [param('double', 'db')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static uint8_t ns3::EutranMeasurementMapping::Dbm2RsrpRange(double dbm) [member function]
-    cls.add_method('Dbm2RsrpRange', 
-                   'uint8_t', 
-                   [param('double', 'dbm')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::IeValue2ActualA3Offset(int8_t a3OffsetIeValue) [member function]
-    cls.add_method('IeValue2ActualA3Offset', 
-                   'double', 
-                   [param('int8_t', 'a3OffsetIeValue')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::IeValue2ActualHysteresis(uint8_t hysteresisIeValue) [member function]
-    cls.add_method('IeValue2ActualHysteresis', 
-                   'double', 
-                   [param('uint8_t', 'hysteresisIeValue')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::IeValue2ActualQQualMin(int8_t qQualMinIeValue) [member function]
-    cls.add_method('IeValue2ActualQQualMin', 
-                   'double', 
-                   [param('int8_t', 'qQualMinIeValue')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::IeValue2ActualQRxLevMin(int8_t qRxLevMinIeValue) [member function]
-    cls.add_method('IeValue2ActualQRxLevMin', 
-                   'double', 
-                   [param('int8_t', 'qRxLevMinIeValue')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::QuantizeRsrp(double v) [member function]
-    cls.add_method('QuantizeRsrp', 
-                   'double', 
-                   [param('double', 'v')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::QuantizeRsrq(double v) [member function]
-    cls.add_method('QuantizeRsrq', 
-                   'double', 
-                   [param('double', 'v')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::RsrpRange2Dbm(uint8_t range) [member function]
-    cls.add_method('RsrpRange2Dbm', 
-                   'double', 
-                   [param('uint8_t', 'range')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::EutranMeasurementMapping::RsrqRange2Db(uint8_t range) [member function]
-    cls.add_method('RsrqRange2Db', 
-                   'double', 
-                   [param('uint8_t', 'range')], 
-                   is_static=True)
-    return
-
-def register_Ns3EventId_methods(root_module, cls):
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<')
-    ## event-id.h (module 'core'): ns3::EventId::EventId(ns3::EventId const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EventId const &', 'arg0')])
-    ## event-id.h (module 'core'): ns3::EventId::EventId() [constructor]
-    cls.add_constructor([])
-    ## event-id.h (module 'core'): ns3::EventId::EventId(ns3::Ptr<ns3::EventImpl> const & impl, uint64_t ts, uint32_t context, uint32_t uid) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::EventImpl > const &', 'impl'), param('uint64_t', 'ts'), param('uint32_t', 'context'), param('uint32_t', 'uid')])
-    ## event-id.h (module 'core'): void ns3::EventId::Cancel() [member function]
-    cls.add_method('Cancel', 
-                   'void', 
-                   [])
-    ## event-id.h (module 'core'): uint32_t ns3::EventId::GetContext() const [member function]
-    cls.add_method('GetContext', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## event-id.h (module 'core'): uint64_t ns3::EventId::GetTs() const [member function]
-    cls.add_method('GetTs', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## event-id.h (module 'core'): uint32_t ns3::EventId::GetUid() const [member function]
-    cls.add_method('GetUid', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## event-id.h (module 'core'): bool ns3::EventId::IsExpired() const [member function]
-    cls.add_method('IsExpired', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## event-id.h (module 'core'): bool ns3::EventId::IsRunning() const [member function]
-    cls.add_method('IsRunning', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## event-id.h (module 'core'): ns3::EventImpl * ns3::EventId::PeekEventImpl() const [member function]
-    cls.add_method('PeekEventImpl', 
-                   'ns3::EventImpl *', 
-                   [], 
-                   is_const=True)
-    return
-
-def register_Ns3FfMacCschedSapProvider_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::FfMacCschedSapProvider() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::FfMacCschedSapProvider(ns3::FfMacCschedSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapProvider const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapProvider::CschedCellConfigReq(ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters const & params) [member function]
-    cls.add_method('CschedCellConfigReq', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapProvider::CschedLcConfigReq(ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters const & params) [member function]
-    cls.add_method('CschedLcConfigReq', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapProvider::CschedLcReleaseReq(ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters const & params) [member function]
-    cls.add_method('CschedLcReleaseReq', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapProvider::CschedUeConfigReq(ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters const & params) [member function]
-    cls.add_method('CschedUeConfigReq', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapProvider::CschedUeReleaseReq(ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters const & params) [member function]
-    cls.add_method('CschedUeReleaseReq', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3FfMacCschedSapProviderCschedCellConfigReqParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::CschedCellConfigReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::CschedCellConfigReqParameters(ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_antennaPortsCount [variable]
-    cls.add_instance_attribute('m_antennaPortsCount', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_deltaPucchShift [variable]
-    cls.add_instance_attribute('m_deltaPucchShift', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_dlBandwidth [variable]
-    cls.add_instance_attribute('m_dlBandwidth', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_dlCyclicPrefixLength [variable]
-    cls.add_instance_attribute('m_dlCyclicPrefixLength', 'ns3::NormalExtended_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_duplexMode [variable]
-    cls.add_instance_attribute('m_duplexMode', 'ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::DuplexMode_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_enable64Qam [variable]
-    cls.add_instance_attribute('m_enable64Qam', 'ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::Enable64Qam_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_hoppingMode [variable]
-    cls.add_instance_attribute('m_hoppingMode', 'ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::HoppingMode_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_initialNrOfPdcchOfdmSymbols [variable]
-    cls.add_instance_attribute('m_initialNrOfPdcchOfdmSymbols', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_macContentionResolutionTimer [variable]
-    cls.add_instance_attribute('m_macContentionResolutionTimer', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_maxHarqMsg3Tx [variable]
-    cls.add_instance_attribute('m_maxHarqMsg3Tx', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_mbsfnSubframeConfigRfOffset [variable]
-    cls.add_instance_attribute('m_mbsfnSubframeConfigRfOffset', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_mbsfnSubframeConfigRfPeriod [variable]
-    cls.add_instance_attribute('m_mbsfnSubframeConfigRfPeriod', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_mbsfnSubframeConfigSfAllocation [variable]
-    cls.add_instance_attribute('m_mbsfnSubframeConfigSfAllocation', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_n1PucchAn [variable]
-    cls.add_instance_attribute('m_n1PucchAn', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_nSb [variable]
-    cls.add_instance_attribute('m_nSb', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_ncsAn [variable]
-    cls.add_instance_attribute('m_ncsAn', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_nrbCqi [variable]
-    cls.add_instance_attribute('m_nrbCqi', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_phichDuration [variable]
-    cls.add_instance_attribute('m_phichDuration', 'ns3::NormalExtended_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_phichResource [variable]
-    cls.add_instance_attribute('m_phichResource', 'ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::PhichResource_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_prachConfigurationIndex [variable]
-    cls.add_instance_attribute('m_prachConfigurationIndex', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_prachFreqOffset [variable]
-    cls.add_instance_attribute('m_prachFreqOffset', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_puschHoppingOffset [variable]
-    cls.add_instance_attribute('m_puschHoppingOffset', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_raResponseWindowSize [variable]
-    cls.add_instance_attribute('m_raResponseWindowSize', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_siConfiguration [variable]
-    cls.add_instance_attribute('m_siConfiguration', 'ns3::SiConfiguration_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_specialSubframePatterns [variable]
-    cls.add_instance_attribute('m_specialSubframePatterns', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_srsBandwidthConfiguration [variable]
-    cls.add_instance_attribute('m_srsBandwidthConfiguration', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_srsMaxUpPts [variable]
-    cls.add_instance_attribute('m_srsMaxUpPts', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_srsSubframeConfiguration [variable]
-    cls.add_instance_attribute('m_srsSubframeConfiguration', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_srsSubframeOffset [variable]
-    cls.add_instance_attribute('m_srsSubframeOffset', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_subframeAssignment [variable]
-    cls.add_instance_attribute('m_subframeAssignment', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_ulBandwidth [variable]
-    cls.add_instance_attribute('m_ulBandwidth', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_ulCyclicPrefixLength [variable]
-    cls.add_instance_attribute('m_ulCyclicPrefixLength', 'ns3::NormalExtended_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedCellConfigReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapProviderCschedLcConfigReqParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters::CschedLcConfigReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters::CschedLcConfigReqParameters(ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters::m_logicalChannelConfigList [variable]
-    cls.add_instance_attribute('m_logicalChannelConfigList', 'std::vector< ns3::LogicalChannelConfigListElement_s >', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters::m_reconfigureFlag [variable]
-    cls.add_instance_attribute('m_reconfigureFlag', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcConfigReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapProviderCschedLcReleaseReqParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters::CschedLcReleaseReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters::CschedLcReleaseReqParameters(ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters::m_logicalChannelIdentity [variable]
-    cls.add_instance_attribute('m_logicalChannelIdentity', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedLcReleaseReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapProviderCschedUeConfigReqParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::CschedUeConfigReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::CschedUeConfigReqParameters(ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_ackNackRepetitionFactor [variable]
-    cls.add_instance_attribute('m_ackNackRepetitionFactor', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_ackNackSrsSimultaneousTransmission [variable]
-    cls.add_instance_attribute('m_ackNackSrsSimultaneousTransmission', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_aperiodicCqiRepMode [variable]
-    cls.add_instance_attribute('m_aperiodicCqiRepMode', 'ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::RepMode_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_betaOffsetAckIndex [variable]
-    cls.add_instance_attribute('m_betaOffsetAckIndex', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_betaOffsetCqiIndex [variable]
-    cls.add_instance_attribute('m_betaOffsetCqiIndex', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_betaOffsetRiIndex [variable]
-    cls.add_instance_attribute('m_betaOffsetRiIndex', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_cqiConfig [variable]
-    cls.add_instance_attribute('m_cqiConfig', 'ns3::CqiConfig_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_cqiConfigPresent [variable]
-    cls.add_instance_attribute('m_cqiConfigPresent', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_drxConfig [variable]
-    cls.add_instance_attribute('m_drxConfig', 'ns3::DrxConfig_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_drxConfigPresent [variable]
-    cls.add_instance_attribute('m_drxConfigPresent', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_maxHarqTx [variable]
-    cls.add_instance_attribute('m_maxHarqTx', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_measGapConfigPattern [variable]
-    cls.add_instance_attribute('m_measGapConfigPattern', 'ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::MeasGapConfigPattern_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_measGapConfigSubframeOffset [variable]
-    cls.add_instance_attribute('m_measGapConfigSubframeOffset', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_reconfigureFlag [variable]
-    cls.add_instance_attribute('m_reconfigureFlag', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_simultaneousAckNackAndCqi [variable]
-    cls.add_instance_attribute('m_simultaneousAckNackAndCqi', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_spsConfig [variable]
-    cls.add_instance_attribute('m_spsConfig', 'ns3::SpsConfig_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_spsConfigPresent [variable]
-    cls.add_instance_attribute('m_spsConfigPresent', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_srConfig [variable]
-    cls.add_instance_attribute('m_srConfig', 'ns3::SrConfig_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_srConfigPresent [variable]
-    cls.add_instance_attribute('m_srConfigPresent', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_tddAckNackFeedbackMode [variable]
-    cls.add_instance_attribute('m_tddAckNackFeedbackMode', 'ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::FeedbackMode_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_timeAlignmentTimer [variable]
-    cls.add_instance_attribute('m_timeAlignmentTimer', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_transmissionMode [variable]
-    cls.add_instance_attribute('m_transmissionMode', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_ttiBundling [variable]
-    cls.add_instance_attribute('m_ttiBundling', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_ueAggregatedMaximumBitrateDl [variable]
-    cls.add_instance_attribute('m_ueAggregatedMaximumBitrateDl', 'uint64_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_ueAggregatedMaximumBitrateUl [variable]
-    cls.add_instance_attribute('m_ueAggregatedMaximumBitrateUl', 'uint64_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_ueCapabilities [variable]
-    cls.add_instance_attribute('m_ueCapabilities', 'ns3::UeCapabilities_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_ueTransmitAntennaSelection [variable]
-    cls.add_instance_attribute('m_ueTransmitAntennaSelection', 'ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::OpenClosedLoop_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeConfigReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapProviderCschedUeReleaseReqParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters::CschedUeReleaseReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters::CschedUeReleaseReqParameters(ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapProvider::CschedUeReleaseReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapUser_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::FfMacCschedSapUser() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::FfMacCschedSapUser(ns3::FfMacCschedSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapUser::CschedCellConfigCnf(ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters const & params) [member function]
-    cls.add_method('CschedCellConfigCnf', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapUser::CschedCellConfigUpdateInd(ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters const & params) [member function]
-    cls.add_method('CschedCellConfigUpdateInd', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapUser::CschedLcConfigCnf(ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters const & params) [member function]
-    cls.add_method('CschedLcConfigCnf', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapUser::CschedLcReleaseCnf(ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters const & params) [member function]
-    cls.add_method('CschedLcReleaseCnf', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapUser::CschedUeConfigCnf(ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters const & params) [member function]
-    cls.add_method('CschedUeConfigCnf', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapUser::CschedUeConfigUpdateInd(ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters const & params) [member function]
-    cls.add_method('CschedUeConfigUpdateInd', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-csched-sap.h (module 'lte'): void ns3::FfMacCschedSapUser::CschedUeReleaseCnf(ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters const & params) [member function]
-    cls.add_method('CschedUeReleaseCnf', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3FfMacCschedSapUserCschedCellConfigCnfParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters::CschedCellConfigCnfParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters::CschedCellConfigCnfParameters(ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters::m_result [variable]
-    cls.add_instance_attribute('m_result', 'ns3::Result_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigCnfParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapUserCschedCellConfigUpdateIndParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters::CschedCellConfigUpdateIndParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters::CschedCellConfigUpdateIndParameters(ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters::m_prbUtilizationDl [variable]
-    cls.add_instance_attribute('m_prbUtilizationDl', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters::m_prbUtilizationUl [variable]
-    cls.add_instance_attribute('m_prbUtilizationUl', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedCellConfigUpdateIndParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapUserCschedLcConfigCnfParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters::CschedLcConfigCnfParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters::CschedLcConfigCnfParameters(ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters::m_logicalChannelIdentity [variable]
-    cls.add_instance_attribute('m_logicalChannelIdentity', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters::m_result [variable]
-    cls.add_instance_attribute('m_result', 'ns3::Result_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcConfigCnfParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapUserCschedLcReleaseCnfParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters::CschedLcReleaseCnfParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters::CschedLcReleaseCnfParameters(ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters::m_logicalChannelIdentity [variable]
-    cls.add_instance_attribute('m_logicalChannelIdentity', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters::m_result [variable]
-    cls.add_instance_attribute('m_result', 'ns3::Result_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedLcReleaseCnfParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapUserCschedUeConfigCnfParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters::CschedUeConfigCnfParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters::CschedUeConfigCnfParameters(ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters::m_result [variable]
-    cls.add_instance_attribute('m_result', 'ns3::Result_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigCnfParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapUserCschedUeConfigUpdateIndParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::CschedUeConfigUpdateIndParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::CschedUeConfigUpdateIndParameters(ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_cqiConfig [variable]
-    cls.add_instance_attribute('m_cqiConfig', 'ns3::CqiConfig_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_cqiConfigPresent [variable]
-    cls.add_instance_attribute('m_cqiConfigPresent', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_spsConfig [variable]
-    cls.add_instance_attribute('m_spsConfig', 'ns3::SpsConfig_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_spsConfigPresent [variable]
-    cls.add_instance_attribute('m_spsConfigPresent', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_srConfig [variable]
-    cls.add_instance_attribute('m_srConfig', 'ns3::SrConfig_s', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_srConfigPresent [variable]
-    cls.add_instance_attribute('m_srConfigPresent', 'bool', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_transmissionMode [variable]
-    cls.add_instance_attribute('m_transmissionMode', 'uint8_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeConfigUpdateIndParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacCschedSapUserCschedUeReleaseCnfParameters_methods(root_module, cls):
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters::CschedUeReleaseCnfParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters::CschedUeReleaseCnfParameters(ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters const &', 'arg0')])
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters::m_result [variable]
-    cls.add_instance_attribute('m_result', 'ns3::Result_e', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-csched-sap.h (module 'lte'): ns3::FfMacCschedSapUser::CschedUeReleaseCnfParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProvider_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::FfMacSchedSapProvider() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::FfMacSchedSapProvider(ns3::FfMacSchedSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedDlCqiInfoReq(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('SchedDlCqiInfoReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedDlMacBufferReq(ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters const & params) [member function]
-    cls.add_method('SchedDlMacBufferReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedDlPagingBufferReq(ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters const & params) [member function]
-    cls.add_method('SchedDlPagingBufferReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedDlRachInfoReq(ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters const & params) [member function]
-    cls.add_method('SchedDlRachInfoReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedDlRlcBufferReq(ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters const & params) [member function]
-    cls.add_method('SchedDlRlcBufferReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedDlTriggerReq(ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters const & params) [member function]
-    cls.add_method('SchedDlTriggerReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedUlCqiInfoReq(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('SchedUlCqiInfoReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReq(ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters const & params) [member function]
-    cls.add_method('SchedUlMacCtrlInfoReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReq(ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters const & params) [member function]
-    cls.add_method('SchedUlNoiseInterferenceReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedUlSrInfoReq(ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters const & params) [member function]
-    cls.add_method('SchedUlSrInfoReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapProvider::SchedUlTriggerReq(ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters const & params) [member function]
-    cls.add_method('SchedUlTriggerReq', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedDlCqiInfoReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters::SchedDlCqiInfoReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters::SchedDlCqiInfoReqParameters(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters::m_cqiList [variable]
-    cls.add_instance_attribute('m_cqiList', 'std::vector< ns3::CqiListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedDlMacBufferReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters::SchedDlMacBufferReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters::SchedDlMacBufferReqParameters(ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters::m_ceBitmap [variable]
-    cls.add_instance_attribute('m_ceBitmap', 'ns3::CeBitmap_e', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlMacBufferReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedDlPagingBufferReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters::SchedDlPagingBufferReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters::SchedDlPagingBufferReqParameters(ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters::m_pagingInfoList [variable]
-    cls.add_instance_attribute('m_pagingInfoList', 'std::vector< ns3::PagingInfoListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlPagingBufferReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedDlRachInfoReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters::SchedDlRachInfoReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters::SchedDlRachInfoReqParameters(ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters::m_rachList [variable]
-    cls.add_instance_attribute('m_rachList', 'std::vector< ns3::RachListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRachInfoReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedDlRlcBufferReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::SchedDlRlcBufferReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::SchedDlRlcBufferReqParameters(ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_logicalChannelIdentity [variable]
-    cls.add_instance_attribute('m_logicalChannelIdentity', 'uint8_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_rlcRetransmissionHolDelay [variable]
-    cls.add_instance_attribute('m_rlcRetransmissionHolDelay', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_rlcRetransmissionQueueSize [variable]
-    cls.add_instance_attribute('m_rlcRetransmissionQueueSize', 'uint32_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_rlcStatusPduSize [variable]
-    cls.add_instance_attribute('m_rlcStatusPduSize', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_rlcTransmissionQueueHolDelay [variable]
-    cls.add_instance_attribute('m_rlcTransmissionQueueHolDelay', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_rlcTransmissionQueueSize [variable]
-    cls.add_instance_attribute('m_rlcTransmissionQueueSize', 'uint32_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlRlcBufferReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedDlTriggerReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters::SchedDlTriggerReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters::SchedDlTriggerReqParameters(ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters::m_dlInfoList [variable]
-    cls.add_instance_attribute('m_dlInfoList', 'std::vector< ns3::DlInfoListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedDlTriggerReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedUlCqiInfoReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters::SchedUlCqiInfoReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters::SchedUlCqiInfoReqParameters(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters::m_ulCqi [variable]
-    cls.add_instance_attribute('m_ulCqi', 'ns3::UlCqi_s', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedUlMacCtrlInfoReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters::SchedUlMacCtrlInfoReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters::SchedUlMacCtrlInfoReqParameters(ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters::m_macCeList [variable]
-    cls.add_instance_attribute('m_macCeList', 'std::vector< ns3::MacCeListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlMacCtrlInfoReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedUlNoiseInterferenceReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters::SchedUlNoiseInterferenceReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters::SchedUlNoiseInterferenceReqParameters(ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters::m_rip [variable]
-    cls.add_instance_attribute('m_rip', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters::m_tnp [variable]
-    cls.add_instance_attribute('m_tnp', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlNoiseInterferenceReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedUlSrInfoReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters::SchedUlSrInfoReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters::SchedUlSrInfoReqParameters(ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters::m_srList [variable]
-    cls.add_instance_attribute('m_srList', 'std::vector< ns3::SrListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlSrInfoReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapProviderSchedUlTriggerReqParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters::SchedUlTriggerReqParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters::SchedUlTriggerReqParameters(ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters::m_sfnSf [variable]
-    cls.add_instance_attribute('m_sfnSf', 'uint16_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters::m_ulInfoList [variable]
-    cls.add_instance_attribute('m_ulInfoList', 'std::vector< ns3::UlInfoListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlTriggerReqParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapUser_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::FfMacSchedSapUser() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::FfMacSchedSapUser(ns3::FfMacSchedSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapUser const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapUser::SchedDlConfigInd(ns3::FfMacSchedSapUser::SchedDlConfigIndParameters const & params) [member function]
-    cls.add_method('SchedDlConfigInd', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser::SchedDlConfigIndParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-sched-sap.h (module 'lte'): void ns3::FfMacSchedSapUser::SchedUlConfigInd(ns3::FfMacSchedSapUser::SchedUlConfigIndParameters const & params) [member function]
-    cls.add_method('SchedUlConfigInd', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser::SchedUlConfigIndParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3FfMacSchedSapUserSchedDlConfigIndParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters::SchedDlConfigIndParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters::SchedDlConfigIndParameters(ns3::FfMacSchedSapUser::SchedDlConfigIndParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapUser::SchedDlConfigIndParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters::m_buildBroadcastList [variable]
-    cls.add_instance_attribute('m_buildBroadcastList', 'std::vector< ns3::BuildBroadcastListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters::m_buildDataList [variable]
-    cls.add_instance_attribute('m_buildDataList', 'std::vector< ns3::BuildDataListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters::m_buildRarList [variable]
-    cls.add_instance_attribute('m_buildRarList', 'std::vector< ns3::BuildRarListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters::m_nrOfPdcchOfdmSymbols [variable]
-    cls.add_instance_attribute('m_nrOfPdcchOfdmSymbols', 'uint8_t', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedDlConfigIndParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3FfMacSchedSapUserSchedUlConfigIndParameters_methods(root_module, cls):
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedUlConfigIndParameters::SchedUlConfigIndParameters() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedUlConfigIndParameters::SchedUlConfigIndParameters(ns3::FfMacSchedSapUser::SchedUlConfigIndParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacSchedSapUser::SchedUlConfigIndParameters const &', 'arg0')])
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedUlConfigIndParameters::m_dciList [variable]
-    cls.add_instance_attribute('m_dciList', 'std::vector< ns3::UlDciListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedUlConfigIndParameters::m_phichList [variable]
-    cls.add_instance_attribute('m_phichList', 'std::vector< ns3::PhichListElement_s >', is_const=False)
-    ## ff-mac-sched-sap.h (module 'lte'): ns3::FfMacSchedSapUser::SchedUlConfigIndParameters::m_vendorSpecificList [variable]
-    cls.add_instance_attribute('m_vendorSpecificList', 'std::vector< ns3::VendorSpecificListElement_s >', is_const=False)
-    return
-
-def register_Ns3GbrQosInformation_methods(root_module, cls):
-    ## eps-bearer.h (module 'lte'): ns3::GbrQosInformation::GbrQosInformation(ns3::GbrQosInformation const & arg0) [constructor]
-    cls.add_constructor([param('ns3::GbrQosInformation const &', 'arg0')])
-    ## eps-bearer.h (module 'lte'): ns3::GbrQosInformation::GbrQosInformation() [constructor]
-    cls.add_constructor([])
-    ## eps-bearer.h (module 'lte'): ns3::GbrQosInformation::gbrDl [variable]
-    cls.add_instance_attribute('gbrDl', 'uint64_t', is_const=False)
-    ## eps-bearer.h (module 'lte'): ns3::GbrQosInformation::gbrUl [variable]
-    cls.add_instance_attribute('gbrUl', 'uint64_t', is_const=False)
-    ## eps-bearer.h (module 'lte'): ns3::GbrQosInformation::mbrDl [variable]
-    cls.add_instance_attribute('mbrDl', 'uint64_t', is_const=False)
-    ## eps-bearer.h (module 'lte'): ns3::GbrQosInformation::mbrUl [variable]
-    cls.add_instance_attribute('mbrUl', 'uint64_t', is_const=False)
-    return
-
-def register_Ns3HarqProcessInfoElement_t_methods(root_module, cls):
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoElement_t::HarqProcessInfoElement_t() [constructor]
-    cls.add_constructor([])
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoElement_t::HarqProcessInfoElement_t(ns3::HarqProcessInfoElement_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::HarqProcessInfoElement_t const &', 'arg0')])
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoElement_t::m_codeBits [variable]
-    cls.add_instance_attribute('m_codeBits', 'uint16_t', is_const=False)
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoElement_t::m_infoBits [variable]
-    cls.add_instance_attribute('m_infoBits', 'uint16_t', is_const=False)
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoElement_t::m_mi [variable]
-    cls.add_instance_attribute('m_mi', 'double', is_const=False)
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoElement_t::m_rv [variable]
-    cls.add_instance_attribute('m_rv', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3Hasher_methods(root_module, cls):
-    ## hash.h (module 'core'): ns3::Hasher::Hasher(ns3::Hasher const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Hasher const &', 'arg0')])
-    ## hash.h (module 'core'): ns3::Hasher::Hasher() [constructor]
-    cls.add_constructor([])
-    ## hash.h (module 'core'): ns3::Hasher::Hasher(ns3::Ptr<ns3::Hash::Implementation> hp) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::Hash::Implementation >', 'hp')])
-    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash32', 
-                   'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
-    ## hash.h (module 'core'): uint32_t ns3::Hasher::GetHash32(std::string const s) [member function]
-    cls.add_method('GetHash32', 
-                   'uint32_t', 
-                   [param('std::string const', 's')])
-    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash64', 
-                   'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')])
-    ## hash.h (module 'core'): uint64_t ns3::Hasher::GetHash64(std::string const s) [member function]
-    cls.add_method('GetHash64', 
-                   'uint64_t', 
-                   [param('std::string const', 's')])
-    ## hash.h (module 'core'): ns3::Hasher & ns3::Hasher::clear() [member function]
-    cls.add_method('clear', 
-                   'ns3::Hasher &', 
-                   [])
-    return
-
-def register_Ns3HigherLayerSelected_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::HigherLayerSelected_s::HigherLayerSelected_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::HigherLayerSelected_s::HigherLayerSelected_s(ns3::HigherLayerSelected_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::HigherLayerSelected_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::HigherLayerSelected_s::m_sbCqi [variable]
-    cls.add_instance_attribute('m_sbCqi', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::HigherLayerSelected_s::m_sbPmi [variable]
-    cls.add_instance_attribute('m_sbPmi', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3ImsiLcidPair_t_methods(root_module, cls):
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('==')
-    ## lte-common.h (module 'lte'): ns3::ImsiLcidPair_t::ImsiLcidPair_t(ns3::ImsiLcidPair_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ImsiLcidPair_t const &', 'arg0')])
-    ## lte-common.h (module 'lte'): ns3::ImsiLcidPair_t::ImsiLcidPair_t() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::ImsiLcidPair_t::ImsiLcidPair_t(uint64_t const a, uint8_t const b) [constructor]
-    cls.add_constructor([param('uint64_t const', 'a'), param('uint8_t const', 'b')])
-    ## lte-common.h (module 'lte'): ns3::ImsiLcidPair_t::m_imsi [variable]
-    cls.add_instance_attribute('m_imsi', 'uint64_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::ImsiLcidPair_t::m_lcId [variable]
-    cls.add_instance_attribute('m_lcId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3Inet6SocketAddress_methods(root_module, cls):
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress::Inet6SocketAddress(ns3::Inet6SocketAddress const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Inet6SocketAddress const &', 'arg0')])
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress::Inet6SocketAddress(ns3::Ipv6Address ipv6, uint16_t port) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Address', 'ipv6'), param('uint16_t', 'port')])
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress::Inet6SocketAddress(ns3::Ipv6Address ipv6) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Address', 'ipv6')])
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress::Inet6SocketAddress(uint16_t port) [constructor]
-    cls.add_constructor([param('uint16_t', 'port')])
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress::Inet6SocketAddress(char const * ipv6, uint16_t port) [constructor]
-    cls.add_constructor([param('char const *', 'ipv6'), param('uint16_t', 'port')])
-    ## inet6-socket-address.h (module 'network'): ns3::Inet6SocketAddress::Inet6SocketAddress(char const * ipv6) [constructor]
-    cls.add_constructor([param('char const *', 'ipv6')])
-    ## inet6-socket-address.h (module 'network'): static ns3::Inet6SocketAddress ns3::Inet6SocketAddress::ConvertFrom(ns3::Address const & addr) [member function]
-    cls.add_method('ConvertFrom', 
-                   'ns3::Inet6SocketAddress', 
-                   [param('ns3::Address const &', 'addr')], 
-                   is_static=True)
-    ## inet6-socket-address.h (module 'network'): ns3::Ipv6Address ns3::Inet6SocketAddress::GetIpv6() const [member function]
-    cls.add_method('GetIpv6', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_const=True)
-    ## inet6-socket-address.h (module 'network'): uint16_t ns3::Inet6SocketAddress::GetPort() const [member function]
-    cls.add_method('GetPort', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## inet6-socket-address.h (module 'network'): static bool ns3::Inet6SocketAddress::IsMatchingType(ns3::Address const & addr) [member function]
-    cls.add_method('IsMatchingType', 
-                   'bool', 
-                   [param('ns3::Address const &', 'addr')], 
-                   is_static=True)
-    ## inet6-socket-address.h (module 'network'): void ns3::Inet6SocketAddress::SetIpv6(ns3::Ipv6Address ipv6) [member function]
-    cls.add_method('SetIpv6', 
-                   'void', 
-                   [param('ns3::Ipv6Address', 'ipv6')])
-    ## inet6-socket-address.h (module 'network'): void ns3::Inet6SocketAddress::SetPort(uint16_t port) [member function]
-    cls.add_method('SetPort', 
-                   'void', 
-                   [param('uint16_t', 'port')])
-    return
-
-def register_Ns3InetSocketAddress_methods(root_module, cls):
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress::InetSocketAddress(ns3::InetSocketAddress const & arg0) [constructor]
-    cls.add_constructor([param('ns3::InetSocketAddress const &', 'arg0')])
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress::InetSocketAddress(ns3::Ipv4Address ipv4, uint16_t port) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Address', 'ipv4'), param('uint16_t', 'port')])
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress::InetSocketAddress(ns3::Ipv4Address ipv4) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Address', 'ipv4')])
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress::InetSocketAddress(uint16_t port) [constructor]
-    cls.add_constructor([param('uint16_t', 'port')])
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress::InetSocketAddress(char const * ipv4, uint16_t port) [constructor]
-    cls.add_constructor([param('char const *', 'ipv4'), param('uint16_t', 'port')])
-    ## inet-socket-address.h (module 'network'): ns3::InetSocketAddress::InetSocketAddress(char const * ipv4) [constructor]
-    cls.add_constructor([param('char const *', 'ipv4')])
-    ## inet-socket-address.h (module 'network'): static ns3::InetSocketAddress ns3::InetSocketAddress::ConvertFrom(ns3::Address const & address) [member function]
-    cls.add_method('ConvertFrom', 
-                   'ns3::InetSocketAddress', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    ## inet-socket-address.h (module 'network'): ns3::Ipv4Address ns3::InetSocketAddress::GetIpv4() const [member function]
-    cls.add_method('GetIpv4', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## inet-socket-address.h (module 'network'): uint16_t ns3::InetSocketAddress::GetPort() const [member function]
-    cls.add_method('GetPort', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## inet-socket-address.h (module 'network'): uint8_t ns3::InetSocketAddress::GetTos() const [member function]
-    cls.add_method('GetTos', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## inet-socket-address.h (module 'network'): static bool ns3::InetSocketAddress::IsMatchingType(ns3::Address const & address) [member function]
-    cls.add_method('IsMatchingType', 
-                   'bool', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    ## inet-socket-address.h (module 'network'): void ns3::InetSocketAddress::SetIpv4(ns3::Ipv4Address address) [member function]
-    cls.add_method('SetIpv4', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'address')])
-    ## inet-socket-address.h (module 'network'): void ns3::InetSocketAddress::SetPort(uint16_t port) [member function]
-    cls.add_method('SetPort', 
-                   'void', 
-                   [param('uint16_t', 'port')])
-    ## inet-socket-address.h (module 'network'): void ns3::InetSocketAddress::SetTos(uint8_t tos) [member function]
-    cls.add_method('SetTos', 
-                   'void', 
-                   [param('uint8_t', 'tos')])
-    return
-
-def register_Ns3Ipv4Address_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<')
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address::Ipv4Address(ns3::Ipv4Address const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Address const &', 'arg0')])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address::Ipv4Address() [constructor]
-    cls.add_constructor([])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address::Ipv4Address(uint32_t address) [constructor]
-    cls.add_constructor([param('uint32_t', 'address')])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address::Ipv4Address(char const * address) [constructor]
-    cls.add_constructor([param('char const *', 'address')])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address ns3::Ipv4Address::CombineMask(ns3::Ipv4Mask const & mask) const [member function]
-    cls.add_method('CombineMask', 
-                   'ns3::Ipv4Address', 
-                   [param('ns3::Ipv4Mask const &', 'mask')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Address ns3::Ipv4Address::ConvertFrom(ns3::Address const & address) [member function]
-    cls.add_method('ConvertFrom', 
-                   'ns3::Ipv4Address', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Address ns3::Ipv4Address::Deserialize(uint8_t const * buf) [member function]
-    cls.add_method('Deserialize', 
-                   'ns3::Ipv4Address', 
-                   [param('uint8_t const *', 'buf')], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): uint32_t ns3::Ipv4Address::Get() const [member function]
-    cls.add_method('Get', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Address ns3::Ipv4Address::GetAny() [member function]
-    cls.add_method('GetAny', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Address ns3::Ipv4Address::GetBroadcast() [member function]
-    cls.add_method('GetBroadcast', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Address ns3::Ipv4Address::GetLoopback() [member function]
-    cls.add_method('GetLoopback', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address ns3::Ipv4Address::GetSubnetDirectedBroadcast(ns3::Ipv4Mask const & mask) const [member function]
-    cls.add_method('GetSubnetDirectedBroadcast', 
-                   'ns3::Ipv4Address', 
-                   [param('ns3::Ipv4Mask const &', 'mask')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Address ns3::Ipv4Address::GetZero() [member function]
-    cls.add_method('GetZero', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Address::IsAny() const [member function]
-    cls.add_method('IsAny', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Address::IsBroadcast() const [member function]
-    cls.add_method('IsBroadcast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Address::IsEqual(ns3::Ipv4Address const & other) const [member function]
-    cls.add_method('IsEqual', 
-                   'bool', 
-                   [param('ns3::Ipv4Address const &', 'other')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Address::IsLocalMulticast() const [member function]
-    cls.add_method('IsLocalMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Address::IsLocalhost() const [member function]
-    cls.add_method('IsLocalhost', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): static bool ns3::Ipv4Address::IsMatchingType(ns3::Address const & address) [member function]
-    cls.add_method('IsMatchingType', 
-                   'bool', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Address::IsMulticast() const [member function]
-    cls.add_method('IsMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Address::IsSubnetDirectedBroadcast(ns3::Ipv4Mask const & mask) const [member function]
-    cls.add_method('IsSubnetDirectedBroadcast', 
-                   'bool', 
-                   [param('ns3::Ipv4Mask const &', 'mask')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4Address::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4Address::Serialize(uint8_t * buf) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('uint8_t *', 'buf')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4Address::Set(uint32_t address) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('uint32_t', 'address')])
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4Address::Set(char const * address) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('char const *', 'address')])
-    return
-
-def register_Ns3Ipv4AddressHelper_methods(root_module, cls):
-    ## ipv4-address-helper.h (module 'internet'): ns3::Ipv4AddressHelper::Ipv4AddressHelper(ns3::Ipv4AddressHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4AddressHelper const &', 'arg0')])
-    ## ipv4-address-helper.h (module 'internet'): ns3::Ipv4AddressHelper::Ipv4AddressHelper() [constructor]
-    cls.add_constructor([])
-    ## ipv4-address-helper.h (module 'internet'): ns3::Ipv4AddressHelper::Ipv4AddressHelper(ns3::Ipv4Address network, ns3::Ipv4Mask mask, ns3::Ipv4Address base="0.0.0.1") [constructor]
-    cls.add_constructor([param('ns3::Ipv4Address', 'network'), param('ns3::Ipv4Mask', 'mask'), param('ns3::Ipv4Address', 'base', default_value='"0.0.0.1"')])
-    ## ipv4-address-helper.h (module 'internet'): ns3::Ipv4InterfaceContainer ns3::Ipv4AddressHelper::Assign(ns3::NetDeviceContainer const & c) [member function]
-    cls.add_method('Assign', 
-                   'ns3::Ipv4InterfaceContainer', 
-                   [param('ns3::NetDeviceContainer const &', 'c')])
-    ## ipv4-address-helper.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4AddressHelper::NewAddress() [member function]
-    cls.add_method('NewAddress', 
-                   'ns3::Ipv4Address', 
-                   [])
-    ## ipv4-address-helper.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4AddressHelper::NewNetwork() [member function]
-    cls.add_method('NewNetwork', 
-                   'ns3::Ipv4Address', 
-                   [])
-    ## ipv4-address-helper.h (module 'internet'): void ns3::Ipv4AddressHelper::SetBase(ns3::Ipv4Address network, ns3::Ipv4Mask mask, ns3::Ipv4Address base="0.0.0.1") [member function]
-    cls.add_method('SetBase', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'network'), param('ns3::Ipv4Mask', 'mask'), param('ns3::Ipv4Address', 'base', default_value='"0.0.0.1"')])
-    return
-
-def register_Ns3Ipv4InterfaceAddress_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4InterfaceAddress::Ipv4InterfaceAddress() [constructor]
-    cls.add_constructor([])
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4InterfaceAddress::Ipv4InterfaceAddress(ns3::Ipv4Address local, ns3::Ipv4Mask mask) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Address', 'local'), param('ns3::Ipv4Mask', 'mask')])
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4InterfaceAddress::Ipv4InterfaceAddress(ns3::Ipv4InterfaceAddress const & o) [constructor]
-    cls.add_constructor([param('ns3::Ipv4InterfaceAddress const &', 'o')])
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4InterfaceAddress::GetBroadcast() const [member function]
-    cls.add_method('GetBroadcast', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4InterfaceAddress::GetLocal() const [member function]
-    cls.add_method('GetLocal', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4Mask ns3::Ipv4InterfaceAddress::GetMask() const [member function]
-    cls.add_method('GetMask', 
-                   'ns3::Ipv4Mask', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-address.h (module 'internet'): ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e ns3::Ipv4InterfaceAddress::GetScope() const [member function]
-    cls.add_method('GetScope', 
-                   'ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-address.h (module 'internet'): bool ns3::Ipv4InterfaceAddress::IsSecondary() const [member function]
-    cls.add_method('IsSecondary', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-address.h (module 'internet'): void ns3::Ipv4InterfaceAddress::SetBroadcast(ns3::Ipv4Address broadcast) [member function]
-    cls.add_method('SetBroadcast', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'broadcast')])
-    ## ipv4-interface-address.h (module 'internet'): void ns3::Ipv4InterfaceAddress::SetLocal(ns3::Ipv4Address local) [member function]
-    cls.add_method('SetLocal', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'local')])
-    ## ipv4-interface-address.h (module 'internet'): void ns3::Ipv4InterfaceAddress::SetMask(ns3::Ipv4Mask mask) [member function]
-    cls.add_method('SetMask', 
-                   'void', 
-                   [param('ns3::Ipv4Mask', 'mask')])
-    ## ipv4-interface-address.h (module 'internet'): void ns3::Ipv4InterfaceAddress::SetPrimary() [member function]
-    cls.add_method('SetPrimary', 
-                   'void', 
-                   [])
-    ## ipv4-interface-address.h (module 'internet'): void ns3::Ipv4InterfaceAddress::SetScope(ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e scope) [member function]
-    cls.add_method('SetScope', 
-                   'void', 
-                   [param('ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e', 'scope')])
-    ## ipv4-interface-address.h (module 'internet'): void ns3::Ipv4InterfaceAddress::SetSecondary() [member function]
-    cls.add_method('SetSecondary', 
-                   'void', 
-                   [])
-    return
-
-def register_Ns3Ipv4InterfaceContainer_methods(root_module, cls):
-    ## ipv4-interface-container.h (module 'internet'): ns3::Ipv4InterfaceContainer::Ipv4InterfaceContainer(ns3::Ipv4InterfaceContainer const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4InterfaceContainer const &', 'arg0')])
-    ## ipv4-interface-container.h (module 'internet'): ns3::Ipv4InterfaceContainer::Ipv4InterfaceContainer() [constructor]
-    cls.add_constructor([])
-    ## ipv4-interface-container.h (module 'internet'): void ns3::Ipv4InterfaceContainer::Add(ns3::Ipv4InterfaceContainer const & other) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::Ipv4InterfaceContainer const &', 'other')])
-    ## ipv4-interface-container.h (module 'internet'): void ns3::Ipv4InterfaceContainer::Add(ns3::Ptr<ns3::Ipv4> ipv4, uint32_t interface) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Ipv4 >', 'ipv4'), param('uint32_t', 'interface')])
-    ## ipv4-interface-container.h (module 'internet'): void ns3::Ipv4InterfaceContainer::Add(std::pair<ns3::Ptr<ns3::Ipv4>, unsigned int> ipInterfacePair) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('std::pair< ns3::Ptr< ns3::Ipv4 >, unsigned int >', 'ipInterfacePair')])
-    ## ipv4-interface-container.h (module 'internet'): void ns3::Ipv4InterfaceContainer::Add(std::string ipv4Name, uint32_t interface) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('std::string', 'ipv4Name'), param('uint32_t', 'interface')])
-    ## ipv4-interface-container.h (module 'internet'): ns3::Ipv4InterfaceContainer::Iterator ns3::Ipv4InterfaceContainer::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'ns3::Ipv4InterfaceContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-container.h (module 'internet'): ns3::Ipv4InterfaceContainer::Iterator ns3::Ipv4InterfaceContainer::End() const [member function]
-    cls.add_method('End', 
-                   'ns3::Ipv4InterfaceContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-container.h (module 'internet'): std::pair<ns3::Ptr<ns3::Ipv4>, unsigned int> ns3::Ipv4InterfaceContainer::Get(uint32_t i) const [member function]
-    cls.add_method('Get', 
-                   'std::pair< ns3::Ptr< ns3::Ipv4 >, unsigned int >', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## ipv4-interface-container.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4InterfaceContainer::GetAddress(uint32_t i, uint32_t j=0) const [member function]
-    cls.add_method('GetAddress', 
-                   'ns3::Ipv4Address', 
-                   [param('uint32_t', 'i'), param('uint32_t', 'j', default_value='0')], 
-                   is_const=True)
-    ## ipv4-interface-container.h (module 'internet'): uint32_t ns3::Ipv4InterfaceContainer::GetN() const [member function]
-    cls.add_method('GetN', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-interface-container.h (module 'internet'): void ns3::Ipv4InterfaceContainer::SetMetric(uint32_t i, uint16_t metric) [member function]
-    cls.add_method('SetMetric', 
-                   'void', 
-                   [param('uint32_t', 'i'), param('uint16_t', 'metric')])
-    return
-
-def register_Ns3Ipv4Mask_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Mask::Ipv4Mask(ns3::Ipv4Mask const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Mask const &', 'arg0')])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Mask::Ipv4Mask() [constructor]
-    cls.add_constructor([])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Mask::Ipv4Mask(uint32_t mask) [constructor]
-    cls.add_constructor([param('uint32_t', 'mask')])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Mask::Ipv4Mask(char const * mask) [constructor]
-    cls.add_constructor([param('char const *', 'mask')])
-    ## ipv4-address.h (module 'network'): uint32_t ns3::Ipv4Mask::Get() const [member function]
-    cls.add_method('Get', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): uint32_t ns3::Ipv4Mask::GetInverse() const [member function]
-    cls.add_method('GetInverse', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Mask ns3::Ipv4Mask::GetLoopback() [member function]
-    cls.add_method('GetLoopback', 
-                   'ns3::Ipv4Mask', 
-                   [], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Mask ns3::Ipv4Mask::GetOnes() [member function]
-    cls.add_method('GetOnes', 
-                   'ns3::Ipv4Mask', 
-                   [], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): uint16_t ns3::Ipv4Mask::GetPrefixLength() const [member function]
-    cls.add_method('GetPrefixLength', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): static ns3::Ipv4Mask ns3::Ipv4Mask::GetZero() [member function]
-    cls.add_method('GetZero', 
-                   'ns3::Ipv4Mask', 
-                   [], 
-                   is_static=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Mask::IsEqual(ns3::Ipv4Mask other) const [member function]
-    cls.add_method('IsEqual', 
-                   'bool', 
-                   [param('ns3::Ipv4Mask', 'other')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4Mask::IsMatch(ns3::Ipv4Address a, ns3::Ipv4Address b) const [member function]
-    cls.add_method('IsMatch', 
-                   'bool', 
-                   [param('ns3::Ipv4Address', 'a'), param('ns3::Ipv4Address', 'b')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4Mask::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4Mask::Set(uint32_t mask) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('uint32_t', 'mask')])
-    return
-
-def register_Ns3Ipv6Address_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<')
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address::Ipv6Address() [constructor]
-    cls.add_constructor([])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address::Ipv6Address(char const * address) [constructor]
-    cls.add_constructor([param('char const *', 'address')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address::Ipv6Address(uint8_t * address) [constructor]
-    cls.add_constructor([param('uint8_t *', 'address')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address::Ipv6Address(ns3::Ipv6Address const & addr) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Address const &', 'addr')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address::Ipv6Address(ns3::Ipv6Address const * addr) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Address const *', 'addr')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address ns3::Ipv6Address::CombinePrefix(ns3::Ipv6Prefix const & prefix) [member function]
-    cls.add_method('CombinePrefix', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Ipv6Prefix const &', 'prefix')])
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::ConvertFrom(ns3::Address const & address) [member function]
-    cls.add_method('ConvertFrom', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::Deserialize(uint8_t const * buf) [member function]
-    cls.add_method('Deserialize', 
-                   'ns3::Ipv6Address', 
-                   [param('uint8_t const *', 'buf')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::GetAllHostsMulticast() [member function]
-    cls.add_method('GetAllHostsMulticast', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::GetAllNodesMulticast() [member function]
-    cls.add_method('GetAllNodesMulticast', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::GetAllRoutersMulticast() [member function]
-    cls.add_method('GetAllRoutersMulticast', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::GetAny() [member function]
-    cls.add_method('GetAny', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6Address::GetBytes(uint8_t * buf) const [member function]
-    cls.add_method('GetBytes', 
-                   'void', 
-                   [param('uint8_t *', 'buf')], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): ns3::Ipv4Address ns3::Ipv6Address::GetIpv4MappedAddress() const [member function]
-    cls.add_method('GetIpv4MappedAddress', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::GetLoopback() [member function]
-    cls.add_method('GetLoopback', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::GetOnes() [member function]
-    cls.add_method('GetOnes', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::GetZero() [member function]
-    cls.add_method('GetZero', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAllHostsMulticast() const [member function]
-    cls.add_method('IsAllHostsMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAllNodesMulticast() const [member function]
-    cls.add_method('IsAllNodesMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAllRoutersMulticast() const [member function]
-    cls.add_method('IsAllRoutersMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsAny() const [member function]
-    cls.add_method('IsAny', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsDocumentation() const [member function]
-    cls.add_method('IsDocumentation', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsEqual(ns3::Ipv6Address const & other) const [member function]
-    cls.add_method('IsEqual', 
-                   'bool', 
-                   [param('ns3::Ipv6Address const &', 'other')], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsIpv4MappedAddress() const [member function]
-    cls.add_method('IsIpv4MappedAddress', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsLinkLocal() const [member function]
-    cls.add_method('IsLinkLocal', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsLinkLocalMulticast() const [member function]
-    cls.add_method('IsLinkLocalMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsLocalhost() const [member function]
-    cls.add_method('IsLocalhost', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): static bool ns3::Ipv6Address::IsMatchingType(ns3::Address const & address) [member function]
-    cls.add_method('IsMatchingType', 
-                   'bool', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsMulticast() const [member function]
-    cls.add_method('IsMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Address::IsSolicitedMulticast() const [member function]
-    cls.add_method('IsSolicitedMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac16Address addr, ns3::Ipv6Address prefix) [member function]
-    cls.add_method('MakeAutoconfiguredAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Mac16Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac48Address addr, ns3::Ipv6Address prefix) [member function]
-    cls.add_method('MakeAutoconfiguredAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Mac48Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredAddress(ns3::Mac64Address addr, ns3::Ipv6Address prefix) [member function]
-    cls.add_method('MakeAutoconfiguredAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Mac64Address', 'addr'), param('ns3::Ipv6Address', 'prefix')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac16Address mac) [member function]
-    cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Mac16Address', 'mac')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac48Address mac) [member function]
-    cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Mac48Address', 'mac')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeAutoconfiguredLinkLocalAddress(ns3::Mac64Address mac) [member function]
-    cls.add_method('MakeAutoconfiguredLinkLocalAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Mac64Address', 'mac')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeIpv4MappedAddress(ns3::Ipv4Address addr) [member function]
-    cls.add_method('MakeIpv4MappedAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Ipv4Address', 'addr')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Address ns3::Ipv6Address::MakeSolicitedAddress(ns3::Ipv6Address addr) [member function]
-    cls.add_method('MakeSolicitedAddress', 
-                   'ns3::Ipv6Address', 
-                   [param('ns3::Ipv6Address', 'addr')], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6Address::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6Address::Serialize(uint8_t * buf) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('uint8_t *', 'buf')], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6Address::Set(char const * address) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('char const *', 'address')])
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6Address::Set(uint8_t * address) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('uint8_t *', 'address')])
-    return
-
-def register_Ns3Ipv6Prefix_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix::Ipv6Prefix() [constructor]
-    cls.add_constructor([])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix::Ipv6Prefix(uint8_t * prefix) [constructor]
-    cls.add_constructor([param('uint8_t *', 'prefix')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix::Ipv6Prefix(char const * prefix) [constructor]
-    cls.add_constructor([param('char const *', 'prefix')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix::Ipv6Prefix(uint8_t prefix) [constructor]
-    cls.add_constructor([param('uint8_t', 'prefix')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix::Ipv6Prefix(ns3::Ipv6Prefix const & prefix) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Prefix const &', 'prefix')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix::Ipv6Prefix(ns3::Ipv6Prefix const * prefix) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Prefix const *', 'prefix')])
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6Prefix::GetBytes(uint8_t * buf) const [member function]
-    cls.add_method('GetBytes', 
-                   'void', 
-                   [param('uint8_t *', 'buf')], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Prefix ns3::Ipv6Prefix::GetLoopback() [member function]
-    cls.add_method('GetLoopback', 
-                   'ns3::Ipv6Prefix', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Prefix ns3::Ipv6Prefix::GetOnes() [member function]
-    cls.add_method('GetOnes', 
-                   'ns3::Ipv6Prefix', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): uint8_t ns3::Ipv6Prefix::GetPrefixLength() const [member function]
-    cls.add_method('GetPrefixLength', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): static ns3::Ipv6Prefix ns3::Ipv6Prefix::GetZero() [member function]
-    cls.add_method('GetZero', 
-                   'ns3::Ipv6Prefix', 
-                   [], 
-                   is_static=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Prefix::IsEqual(ns3::Ipv6Prefix const & other) const [member function]
-    cls.add_method('IsEqual', 
-                   'bool', 
-                   [param('ns3::Ipv6Prefix const &', 'other')], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6Prefix::IsMatch(ns3::Ipv6Address a, ns3::Ipv6Address b) const [member function]
-    cls.add_method('IsMatch', 
-                   'bool', 
-                   [param('ns3::Ipv6Address', 'a'), param('ns3::Ipv6Address', 'b')], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6Prefix::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True)
-    return
-
-def register_Ns3LogComponent_methods(root_module, cls):
-    ## log.h (module 'core'): ns3::LogComponent::LogComponent(ns3::LogComponent const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LogComponent const &', 'arg0')])
-    ## log.h (module 'core'): ns3::LogComponent::LogComponent(std::string const & name, std::string const & file, ns3::LogLevel const mask=::ns3::LogLevel::LOG_NONE) [constructor]
-    cls.add_constructor([param('std::string const &', 'name'), param('std::string const &', 'file'), param('ns3::LogLevel const', 'mask', default_value='::ns3::LogLevel::LOG_NONE')])
-    ## log.h (module 'core'): void ns3::LogComponent::Disable(ns3::LogLevel const level) [member function]
-    cls.add_method('Disable', 
-                   'void', 
-                   [param('ns3::LogLevel const', 'level')])
-    ## log.h (module 'core'): void ns3::LogComponent::Enable(ns3::LogLevel const level) [member function]
-    cls.add_method('Enable', 
-                   'void', 
-                   [param('ns3::LogLevel const', 'level')])
-    ## log.h (module 'core'): std::string ns3::LogComponent::File() const [member function]
-    cls.add_method('File', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## log.h (module 'core'): static ns3::LogComponent::ComponentList * ns3::LogComponent::GetComponentList() [member function]
-    cls.add_method('GetComponentList', 
-                   'ns3::LogComponent::ComponentList *', 
-                   [], 
-                   is_static=True)
-    ## log.h (module 'core'): static std::string ns3::LogComponent::GetLevelLabel(ns3::LogLevel const level) [member function]
-    cls.add_method('GetLevelLabel', 
-                   'std::string', 
-                   [param('ns3::LogLevel const', 'level')], 
-                   is_static=True)
-    ## log.h (module 'core'): bool ns3::LogComponent::IsEnabled(ns3::LogLevel const level) const [member function]
-    cls.add_method('IsEnabled', 
-                   'bool', 
-                   [param('ns3::LogLevel const', 'level')], 
-                   is_const=True)
-    ## log.h (module 'core'): bool ns3::LogComponent::IsNoneEnabled() const [member function]
-    cls.add_method('IsNoneEnabled', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## log.h (module 'core'): char const * ns3::LogComponent::Name() const [member function]
-    cls.add_method('Name', 
-                   'char const *', 
-                   [], 
-                   is_const=True)
-    ## log.h (module 'core'): void ns3::LogComponent::SetMask(ns3::LogLevel const level) [member function]
-    cls.add_method('SetMask', 
-                   'void', 
-                   [param('ns3::LogLevel const', 'level')])
-    return
-
-def register_Ns3LogicalChannelConfigListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::LogicalChannelConfigListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::LogicalChannelConfigListElement_s(ns3::LogicalChannelConfigListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LogicalChannelConfigListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_direction [variable]
-    cls.add_instance_attribute('m_direction', 'ns3::LogicalChannelConfigListElement_s::Direction_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_eRabGuaranteedBitrateDl [variable]
-    cls.add_instance_attribute('m_eRabGuaranteedBitrateDl', 'uint64_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_eRabGuaranteedBitrateUl [variable]
-    cls.add_instance_attribute('m_eRabGuaranteedBitrateUl', 'uint64_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_eRabMaximulBitrateDl [variable]
-    cls.add_instance_attribute('m_eRabMaximulBitrateDl', 'uint64_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_eRabMaximulBitrateUl [variable]
-    cls.add_instance_attribute('m_eRabMaximulBitrateUl', 'uint64_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_logicalChannelGroup [variable]
-    cls.add_instance_attribute('m_logicalChannelGroup', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_logicalChannelIdentity [variable]
-    cls.add_instance_attribute('m_logicalChannelIdentity', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_qci [variable]
-    cls.add_instance_attribute('m_qci', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::LogicalChannelConfigListElement_s::m_qosBearerType [variable]
-    cls.add_instance_attribute('m_qosBearerType', 'ns3::LogicalChannelConfigListElement_s::QosBearerType_e', is_const=False)
-    return
-
-def register_Ns3LteAnrSapProvider_methods(root_module, cls):
-    ## lte-anr-sap.h (module 'lte'): ns3::LteAnrSapProvider::LteAnrSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-anr-sap.h (module 'lte'): ns3::LteAnrSapProvider::LteAnrSapProvider(ns3::LteAnrSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteAnrSapProvider const &', 'arg0')])
-    ## lte-anr-sap.h (module 'lte'): void ns3::LteAnrSapProvider::AddNeighbourRelation(uint16_t cellId) [member function]
-    cls.add_method('AddNeighbourRelation', 
-                   'void', 
-                   [param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-anr-sap.h (module 'lte'): bool ns3::LteAnrSapProvider::GetNoHo(uint16_t cellId) const [member function]
-    cls.add_method('GetNoHo', 
-                   'bool', 
-                   [param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## lte-anr-sap.h (module 'lte'): bool ns3::LteAnrSapProvider::GetNoRemove(uint16_t cellId) const [member function]
-    cls.add_method('GetNoRemove', 
-                   'bool', 
-                   [param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## lte-anr-sap.h (module 'lte'): bool ns3::LteAnrSapProvider::GetNoX2(uint16_t cellId) const [member function]
-    cls.add_method('GetNoX2', 
-                   'bool', 
-                   [param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## lte-anr-sap.h (module 'lte'): void ns3::LteAnrSapProvider::ReportUeMeas(ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('ReportUeMeas', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteAnrSapUser_methods(root_module, cls):
-    ## lte-anr-sap.h (module 'lte'): ns3::LteAnrSapUser::LteAnrSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-anr-sap.h (module 'lte'): ns3::LteAnrSapUser::LteAnrSapUser(ns3::LteAnrSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteAnrSapUser const &', 'arg0')])
-    ## lte-anr-sap.h (module 'lte'): uint8_t ns3::LteAnrSapUser::AddUeMeasReportConfigForAnr(ns3::LteRrcSap::ReportConfigEutra reportConfig) [member function]
-    cls.add_method('AddUeMeasReportConfigForAnr', 
-                   'uint8_t', 
-                   [param('ns3::LteRrcSap::ReportConfigEutra', 'reportConfig')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteAsSapProvider_methods(root_module, cls):
-    ## lte-as-sap.h (module 'lte'): ns3::LteAsSapProvider::LteAsSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-as-sap.h (module 'lte'): ns3::LteAsSapProvider::LteAsSapProvider(ns3::LteAsSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteAsSapProvider const &', 'arg0')])
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::Connect() [member function]
-    cls.add_method('Connect', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::Disconnect() [member function]
-    cls.add_method('Disconnect', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::ForceCampedOnEnb(uint16_t cellId, uint32_t dlEarfcn) [member function]
-    cls.add_method('ForceCampedOnEnb', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::SendData(ns3::Ptr<ns3::Packet> packet, uint8_t bid) [member function]
-    cls.add_method('SendData', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('uint8_t', 'bid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::SetCsgWhiteList(uint32_t csgId) [member function]
-    cls.add_method('SetCsgWhiteList', 
-                   'void', 
-                   [param('uint32_t', 'csgId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::StartCellSelection(uint32_t dlEarfcn) [member function]
-    cls.add_method('StartCellSelection', 
-                   'void', 
-                   [param('uint32_t', 'dlEarfcn')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteAsSapUser_methods(root_module, cls):
-    ## lte-as-sap.h (module 'lte'): ns3::LteAsSapUser::LteAsSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-as-sap.h (module 'lte'): ns3::LteAsSapUser::LteAsSapUser(ns3::LteAsSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteAsSapUser const &', 'arg0')])
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionFailed() [member function]
-    cls.add_method('NotifyConnectionFailed', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionReleased() [member function]
-    cls.add_method('NotifyConnectionReleased', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionSuccessful() [member function]
-    cls.add_method('NotifyConnectionSuccessful', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::RecvData(ns3::Ptr<ns3::Packet> packet) [member function]
-    cls.add_method('RecvData', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteCcmMacSapProvider_methods(root_module, cls):
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapProvider::LteCcmMacSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapProvider::LteCcmMacSapProvider(ns3::LteCcmMacSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmMacSapProvider const &', 'arg0')])
-    ## lte-ccm-mac-sap.h (module 'lte'): void ns3::LteCcmMacSapProvider::ReportMacCeToScheduler(ns3::MacCeListElement_s bsr) [member function]
-    cls.add_method('ReportMacCeToScheduler', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteCcmRrcSapProvider_methods(root_module, cls):
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LteCcmRrcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LteCcmRrcSapProvider(ns3::LteCcmRrcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmRrcSapProvider const &', 'arg0')])
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::AddLc(ns3::LteEnbCmacSapProvider::LcInfo lcInfo, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('AddLc', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::AddUe(uint16_t rnti, uint8_t state) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'state')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteMacSapUser * ns3::LteCcmRrcSapProvider::ConfigureSignalBearer(ns3::LteEnbCmacSapProvider::LcInfo lcInfo, ns3::LteMacSapUser * rlcMacSapUser) [member function]
-    cls.add_method('ConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo'), param('ns3::LteMacSapUser *', 'rlcMacSapUser')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): std::vector<unsigned char, std::allocator<unsigned char> > ns3::LteCcmRrcSapProvider::ReleaseDataRadioBearer(uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('ReleaseDataRadioBearer', 
-                   'std::vector< unsigned char >', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::RemoveUe(uint16_t rnti) [member function]
-    cls.add_method('RemoveUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::ReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('ReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): std::vector<ns3::LteCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteCcmRrcSapProvider::LcsConfig> > ns3::LteCcmRrcSapProvider::SetupDataRadioBearer(ns3::EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('SetupDataRadioBearer', 
-                   'std::vector< ns3::LteCcmRrcSapProvider::LcsConfig >', 
-                   [param('ns3::EpsBearer', 'bearer'), param('uint8_t', 'bearerId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint8_t', 'lcGroup'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteCcmRrcSapProviderLcsConfig_methods(root_module, cls):
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::LcsConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::LcsConfig(ns3::LteCcmRrcSapProvider::LcsConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmRrcSapProvider::LcsConfig const &', 'arg0')])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::componentCarrierId [variable]
-    cls.add_instance_attribute('componentCarrierId', 'uint16_t', is_const=False)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::lc [variable]
-    cls.add_instance_attribute('lc', 'ns3::LteEnbCmacSapProvider::LcInfo', is_const=False)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::msu [variable]
-    cls.add_instance_attribute('msu', 'ns3::LteMacSapUser *', is_const=False)
-    return
-
-def register_Ns3LteCcmRrcSapUser_methods(root_module, cls):
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapUser::LteCcmRrcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapUser::LteCcmRrcSapUser(ns3::LteCcmRrcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmRrcSapUser const &', 'arg0')])
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapUser::AddLcs(std::vector<ns3::LteRrcSap::LogicalChannelConfig, std::allocator<ns3::LteRrcSap::LogicalChannelConfig> > lcConfig) [member function]
-    cls.add_method('AddLcs', 
-                   'void', 
-                   [param('std::vector< ns3::LteRrcSap::LogicalChannelConfig >', 'lcConfig')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): uint8_t ns3::LteCcmRrcSapUser::AddUeMeasReportConfigForComponentCarrier(ns3::LteRrcSap::ReportConfigEutra reportConfig) [member function]
-    cls.add_method('AddUeMeasReportConfigForComponentCarrier', 
-                   'uint8_t', 
-                   [param('ns3::LteRrcSap::ReportConfigEutra', 'reportConfig')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::Ptr<ns3::UeManager> ns3::LteCcmRrcSapUser::GetUeManager(uint16_t rnti) [member function]
-    cls.add_method('GetUeManager', 
-                   'ns3::Ptr< ns3::UeManager >', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapUser::ReleaseLcs(uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('ReleaseLcs', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapUser::TriggerComponentCarrier(uint16_t rnti, uint16_t targetCellId) [member function]
-    cls.add_method('TriggerComponentCarrier', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint16_t', 'targetCellId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbCmacSapProvider_methods(root_module, cls):
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LteEnbCmacSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LteEnbCmacSapProvider(ns3::LteEnbCmacSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCmacSapProvider const &', 'arg0')])
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapProvider::AddLc(ns3::LteEnbCmacSapProvider::LcInfo lcinfo, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('AddLc', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcinfo'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapProvider::AddUe(uint16_t rnti) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue ns3::LteEnbCmacSapProvider::AllocateNcRaPreamble(uint16_t rnti) [member function]
-    cls.add_method('AllocateNcRaPreamble', 
-                   'ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapProvider::ConfigureMac(uint8_t ulBandwidth, uint8_t dlBandwidth) [member function]
-    cls.add_method('ConfigureMac', 
-                   'void', 
-                   [param('uint8_t', 'ulBandwidth'), param('uint8_t', 'dlBandwidth')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::RachConfig ns3::LteEnbCmacSapProvider::GetRachConfig() [member function]
-    cls.add_method('GetRachConfig', 
-                   'ns3::LteEnbCmacSapProvider::RachConfig', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapProvider::ReconfigureLc(ns3::LteEnbCmacSapProvider::LcInfo lcinfo) [member function]
-    cls.add_method('ReconfigureLc', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcinfo')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapProvider::ReleaseLc(uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('ReleaseLc', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapProvider::RemoveUe(uint16_t rnti) [member function]
-    cls.add_method('RemoveUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapProvider::UeUpdateConfigurationReq(ns3::LteEnbCmacSapProvider::UeConfig params) [member function]
-    cls.add_method('UeUpdateConfigurationReq', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider::UeConfig', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbCmacSapProviderAllocateNcRaPreambleReturnValue_methods(root_module, cls):
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue::AllocateNcRaPreambleReturnValue() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue::AllocateNcRaPreambleReturnValue(ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue const &', 'arg0')])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue::raPrachMaskIndex [variable]
-    cls.add_instance_attribute('raPrachMaskIndex', 'uint8_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue::raPreambleId [variable]
-    cls.add_instance_attribute('raPreambleId', 'uint8_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue::valid [variable]
-    cls.add_instance_attribute('valid', 'bool', is_const=False)
-    return
-
-def register_Ns3LteEnbCmacSapProviderLcInfo_methods(root_module, cls):
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::LcInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::LcInfo(ns3::LteEnbCmacSapProvider::LcInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCmacSapProvider::LcInfo const &', 'arg0')])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::gbrDl [variable]
-    cls.add_instance_attribute('gbrDl', 'uint64_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::gbrUl [variable]
-    cls.add_instance_attribute('gbrUl', 'uint64_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::isGbr [variable]
-    cls.add_instance_attribute('isGbr', 'bool', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::lcGroup [variable]
-    cls.add_instance_attribute('lcGroup', 'uint8_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::lcId [variable]
-    cls.add_instance_attribute('lcId', 'uint8_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::mbrDl [variable]
-    cls.add_instance_attribute('mbrDl', 'uint64_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::mbrUl [variable]
-    cls.add_instance_attribute('mbrUl', 'uint64_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::qci [variable]
-    cls.add_instance_attribute('qci', 'uint8_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteEnbCmacSapProviderRachConfig_methods(root_module, cls):
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::RachConfig::RachConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::RachConfig::RachConfig(ns3::LteEnbCmacSapProvider::RachConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCmacSapProvider::RachConfig const &', 'arg0')])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::RachConfig::numberOfRaPreambles [variable]
-    cls.add_instance_attribute('numberOfRaPreambles', 'uint8_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::RachConfig::preambleTransMax [variable]
-    cls.add_instance_attribute('preambleTransMax', 'uint8_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::RachConfig::raResponseWindowSize [variable]
-    cls.add_instance_attribute('raResponseWindowSize', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteEnbCmacSapProviderUeConfig_methods(root_module, cls):
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::UeConfig::UeConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::UeConfig::UeConfig(ns3::LteEnbCmacSapProvider::UeConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCmacSapProvider::UeConfig const &', 'arg0')])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::UeConfig::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::UeConfig::m_transmissionMode [variable]
-    cls.add_instance_attribute('m_transmissionMode', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteEnbCmacSapUser_methods(root_module, cls):
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser::LteEnbCmacSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser::LteEnbCmacSapUser(ns3::LteEnbCmacSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCmacSapUser const &', 'arg0')])
-    ## lte-enb-cmac-sap.h (module 'lte'): uint16_t ns3::LteEnbCmacSapUser::AllocateTemporaryCellRnti() [member function]
-    cls.add_method('AllocateTemporaryCellRnti', 
-                   'uint16_t', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapUser::NotifyLcConfigResult(uint16_t rnti, uint8_t lcid, bool success) [member function]
-    cls.add_method('NotifyLcConfigResult', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('bool', 'success')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cmac-sap.h (module 'lte'): void ns3::LteEnbCmacSapUser::RrcConfigurationUpdateInd(ns3::LteEnbCmacSapUser::UeConfig params) [member function]
-    cls.add_method('RrcConfigurationUpdateInd', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapUser::UeConfig', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbCmacSapUserUeConfig_methods(root_module, cls):
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser::UeConfig::UeConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser::UeConfig::UeConfig(ns3::LteEnbCmacSapUser::UeConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCmacSapUser::UeConfig const &', 'arg0')])
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser::UeConfig::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapUser::UeConfig::m_transmissionMode [variable]
-    cls.add_instance_attribute('m_transmissionMode', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteEnbCphySapProvider_methods(root_module, cls):
-    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapProvider::LteEnbCphySapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapProvider::LteEnbCphySapProvider(ns3::LteEnbCphySapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCphySapProvider const &', 'arg0')])
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::AddUe(uint16_t rnti) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): int8_t ns3::LteEnbCphySapProvider::GetReferenceSignalPower() [member function]
-    cls.add_method('GetReferenceSignalPower', 
-                   'int8_t', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::RemoveUe(uint16_t rnti) [member function]
-    cls.add_method('RemoveUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetBandwidth(uint8_t ulBandwidth, uint8_t dlBandwidth) [member function]
-    cls.add_method('SetBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'ulBandwidth'), param('uint8_t', 'dlBandwidth')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetEarfcn(uint32_t ulEarfcn, uint32_t dlEarfcn) [member function]
-    cls.add_method('SetEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'ulEarfcn'), param('uint32_t', 'dlEarfcn')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetMasterInformationBlock(ns3::LteRrcSap::MasterInformationBlock mib) [member function]
-    cls.add_method('SetMasterInformationBlock', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MasterInformationBlock', 'mib')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetPa(uint16_t rnti, double pa) [member function]
-    cls.add_method('SetPa', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('double', 'pa')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetSrsConfigurationIndex(uint16_t rnti, uint16_t srsCi) [member function]
-    cls.add_method('SetSrsConfigurationIndex', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint16_t', 'srsCi')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetSystemInformationBlockType1(ns3::LteRrcSap::SystemInformationBlockType1 sib1) [member function]
-    cls.add_method('SetSystemInformationBlockType1', 
-                   'void', 
-                   [param('ns3::LteRrcSap::SystemInformationBlockType1', 'sib1')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetTransmissionMode(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('SetTransmissionMode', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbCphySapUser_methods(root_module, cls):
-    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::LteEnbCphySapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::LteEnbCphySapUser(ns3::LteEnbCphySapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbCphySapUser const &', 'arg0')])
-    return
-
-def register_Ns3LteEnbPhySapProvider_methods(root_module, cls):
-    ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapProvider::LteEnbPhySapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapProvider::LteEnbPhySapProvider(ns3::LteEnbPhySapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbPhySapProvider const &', 'arg0')])
-    ## lte-enb-phy-sap.h (module 'lte'): uint8_t ns3::LteEnbPhySapProvider::GetMacChTtiDelay() [member function]
-    cls.add_method('GetMacChTtiDelay', 
-                   'uint8_t', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapProvider::SendLteControlMessage(ns3::Ptr<ns3::LteControlMessage> msg) [member function]
-    cls.add_method('SendLteControlMessage', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteControlMessage >', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapProvider::SendMacPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('SendMacPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbPhySapUser_methods(root_module, cls):
-    ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapUser::LteEnbPhySapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapUser::LteEnbPhySapUser(ns3::LteEnbPhySapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbPhySapUser const &', 'arg0')])
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapUser::DlInfoListElementHarqFeeback(ns3::DlInfoListElement_s params) [member function]
-    cls.add_method('DlInfoListElementHarqFeeback', 
-                   'void', 
-                   [param('ns3::DlInfoListElement_s', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapUser::ReceiveLteControlMessage(ns3::Ptr<ns3::LteControlMessage> msg) [member function]
-    cls.add_method('ReceiveLteControlMessage', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteControlMessage >', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapUser::ReceivePhyPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('ReceivePhyPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapUser::ReceiveRachPreamble(uint32_t prachId) [member function]
-    cls.add_method('ReceiveRachPreamble', 
-                   'void', 
-                   [param('uint32_t', 'prachId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapUser::SubframeIndication(uint32_t frameNo, uint32_t subframeNo) [member function]
-    cls.add_method('SubframeIndication', 
-                   'void', 
-                   [param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapUser::UlCqiReport(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters ulcqi) [member function]
-    cls.add_method('UlCqiReport', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters', 'ulcqi')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-phy-sap.h (module 'lte'): void ns3::LteEnbPhySapUser::UlInfoListElementHarqFeeback(ns3::UlInfoListElement_s params) [member function]
-    cls.add_method('UlInfoListElementHarqFeeback', 
-                   'void', 
-                   [param('ns3::UlInfoListElement_s', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteFfConverter_methods(root_module, cls):
-    ## lte-common.h (module 'lte'): ns3::LteFfConverter::LteFfConverter() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::LteFfConverter::LteFfConverter(ns3::LteFfConverter const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfConverter const &', 'arg0')])
-    ## lte-common.h (module 'lte'): static uint16_t ns3::LteFfConverter::double2fpS11dot3(double val) [member function]
-    cls.add_method('double2fpS11dot3', 
-                   'uint16_t', 
-                   [param('double', 'val')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::LteFfConverter::fpS11dot3toDouble(uint16_t val) [member function]
-    cls.add_method('fpS11dot3toDouble', 
-                   'double', 
-                   [param('uint16_t', 'val')], 
-                   is_static=True)
-    ## lte-common.h (module 'lte'): static double ns3::LteFfConverter::getMinFpS11dot3Value() [member function]
-    cls.add_method('getMinFpS11dot3Value', 
-                   'double', 
-                   [], 
-                   is_static=True)
-    return
-
-def register_Ns3LteFfrRrcSapProvider_methods(root_module, cls):
-    ## lte-ffr-rrc-sap.h (module 'lte'): ns3::LteFfrRrcSapProvider::LteFfrRrcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-rrc-sap.h (module 'lte'): ns3::LteFfrRrcSapProvider::LteFfrRrcSapProvider(ns3::LteFfrRrcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrRrcSapProvider const &', 'arg0')])
-    ## lte-ffr-rrc-sap.h (module 'lte'): void ns3::LteFfrRrcSapProvider::RecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('RecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-rrc-sap.h (module 'lte'): void ns3::LteFfrRrcSapProvider::ReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('ReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-rrc-sap.h (module 'lte'): void ns3::LteFfrRrcSapProvider::SetBandwidth(uint8_t ulBandwidth, uint8_t dlBandwidth) [member function]
-    cls.add_method('SetBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'ulBandwidth'), param('uint8_t', 'dlBandwidth')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-rrc-sap.h (module 'lte'): void ns3::LteFfrRrcSapProvider::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteFfrRrcSapUser_methods(root_module, cls):
-    ## lte-ffr-rrc-sap.h (module 'lte'): ns3::LteFfrRrcSapUser::LteFfrRrcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-rrc-sap.h (module 'lte'): ns3::LteFfrRrcSapUser::LteFfrRrcSapUser(ns3::LteFfrRrcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrRrcSapUser const &', 'arg0')])
-    ## lte-ffr-rrc-sap.h (module 'lte'): uint8_t ns3::LteFfrRrcSapUser::AddUeMeasReportConfigForFfr(ns3::LteRrcSap::ReportConfigEutra reportConfig) [member function]
-    cls.add_method('AddUeMeasReportConfigForFfr', 
-                   'uint8_t', 
-                   [param('ns3::LteRrcSap::ReportConfigEutra', 'reportConfig')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-rrc-sap.h (module 'lte'): void ns3::LteFfrRrcSapUser::SendLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('SendLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-rrc-sap.h (module 'lte'): void ns3::LteFfrRrcSapUser::SetPdschConfigDedicated(uint16_t rnti, ns3::LteRrcSap::PdschConfigDedicated pdschConfigDedicated) [member function]
-    cls.add_method('SetPdschConfigDedicated', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::PdschConfigDedicated', 'pdschConfigDedicated')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteFfrSapProvider_methods(root_module, cls):
-    ## lte-ffr-sap.h (module 'lte'): ns3::LteFfrSapProvider::LteFfrSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-sap.h (module 'lte'): ns3::LteFfrSapProvider::LteFfrSapProvider(ns3::LteFfrSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrSapProvider const &', 'arg0')])
-    ## lte-ffr-sap.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrSapProvider::GetAvailableDlRbg() [member function]
-    cls.add_method('GetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrSapProvider::GetAvailableUlRbg() [member function]
-    cls.add_method('GetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): uint8_t ns3::LteFfrSapProvider::GetMinContinuousUlBandwidth() [member function]
-    cls.add_method('GetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): uint8_t ns3::LteFfrSapProvider::GetTpc(uint16_t rnti) [member function]
-    cls.add_method('GetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): bool ns3::LteFfrSapProvider::IsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('IsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): bool ns3::LteFfrSapProvider::IsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('IsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): void ns3::LteFfrSapProvider::ReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('ReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): void ns3::LteFfrSapProvider::ReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('ReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-sap.h (module 'lte'): void ns3::LteFfrSapProvider::ReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('ReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteFfrSapUser_methods(root_module, cls):
-    ## lte-ffr-sap.h (module 'lte'): ns3::LteFfrSapUser::LteFfrSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-sap.h (module 'lte'): ns3::LteFfrSapUser::LteFfrSapUser(ns3::LteFfrSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrSapUser const &', 'arg0')])
-    return
-
-def register_Ns3LteFlowId_t_methods(root_module, cls):
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('==')
-    ## lte-common.h (module 'lte'): ns3::LteFlowId_t::LteFlowId_t(ns3::LteFlowId_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFlowId_t const &', 'arg0')])
-    ## lte-common.h (module 'lte'): ns3::LteFlowId_t::LteFlowId_t() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::LteFlowId_t::LteFlowId_t(uint16_t const a, uint8_t const b) [constructor]
-    cls.add_constructor([param('uint16_t const', 'a'), param('uint8_t const', 'b')])
-    ## lte-common.h (module 'lte'): ns3::LteFlowId_t::m_lcId [variable]
-    cls.add_instance_attribute('m_lcId', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::LteFlowId_t::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteGlobalPathlossDatabase_methods(root_module, cls):
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::LteGlobalPathlossDatabase::LteGlobalPathlossDatabase() [constructor]
-    cls.add_constructor([])
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::LteGlobalPathlossDatabase::LteGlobalPathlossDatabase(ns3::LteGlobalPathlossDatabase const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteGlobalPathlossDatabase const &', 'arg0')])
-    ## lte-global-pathloss-database.h (module 'lte'): double ns3::LteGlobalPathlossDatabase::GetPathloss(uint16_t cellId, uint64_t imsi) [member function]
-    cls.add_method('GetPathloss', 
-                   'double', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi')])
-    ## lte-global-pathloss-database.h (module 'lte'): void ns3::LteGlobalPathlossDatabase::Print() [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [])
-    ## lte-global-pathloss-database.h (module 'lte'): void ns3::LteGlobalPathlossDatabase::UpdatePathloss(std::string context, ns3::Ptr<ns3::SpectrumPhy> txPhy, ns3::Ptr<ns3::SpectrumPhy> rxPhy, double lossDb) [member function]
-    cls.add_method('UpdatePathloss', 
-                   'void', 
-                   [param('std::string', 'context'), param('ns3::Ptr< ns3::SpectrumPhy >', 'txPhy'), param('ns3::Ptr< ns3::SpectrumPhy >', 'rxPhy'), param('double', 'lossDb')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteHandoverManagementSapProvider_methods(root_module, cls):
-    ## lte-handover-management-sap.h (module 'lte'): ns3::LteHandoverManagementSapProvider::LteHandoverManagementSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-handover-management-sap.h (module 'lte'): ns3::LteHandoverManagementSapProvider::LteHandoverManagementSapProvider(ns3::LteHandoverManagementSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteHandoverManagementSapProvider const &', 'arg0')])
-    ## lte-handover-management-sap.h (module 'lte'): void ns3::LteHandoverManagementSapProvider::ReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('ReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteHandoverManagementSapUser_methods(root_module, cls):
-    ## lte-handover-management-sap.h (module 'lte'): ns3::LteHandoverManagementSapUser::LteHandoverManagementSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-handover-management-sap.h (module 'lte'): ns3::LteHandoverManagementSapUser::LteHandoverManagementSapUser(ns3::LteHandoverManagementSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteHandoverManagementSapUser const &', 'arg0')])
-    ## lte-handover-management-sap.h (module 'lte'): uint8_t ns3::LteHandoverManagementSapUser::AddUeMeasReportConfigForHandover(ns3::LteRrcSap::ReportConfigEutra reportConfig) [member function]
-    cls.add_method('AddUeMeasReportConfigForHandover', 
-                   'uint8_t', 
-                   [param('ns3::LteRrcSap::ReportConfigEutra', 'reportConfig')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-handover-management-sap.h (module 'lte'): void ns3::LteHandoverManagementSapUser::TriggerHandover(uint16_t rnti, uint16_t targetCellId) [member function]
-    cls.add_method('TriggerHandover', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint16_t', 'targetCellId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteMacSapProvider_methods(root_module, cls):
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::LteMacSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::LteMacSapProvider(ns3::LteMacSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteMacSapProvider const &', 'arg0')])
-    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapProvider::ReportBufferStatus(ns3::LteMacSapProvider::ReportBufferStatusParameters params) [member function]
-    cls.add_method('ReportBufferStatus', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::ReportBufferStatusParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapProvider::TransmitPdu(ns3::LteMacSapProvider::TransmitPduParameters params) [member function]
-    cls.add_method('TransmitPdu', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::TransmitPduParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteMacSapProviderReportBufferStatusParameters_methods(root_module, cls):
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::ReportBufferStatusParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::ReportBufferStatusParameters(ns3::LteMacSapProvider::ReportBufferStatusParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteMacSapProvider::ReportBufferStatusParameters const &', 'arg0')])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::lcid [variable]
-    cls.add_instance_attribute('lcid', 'uint8_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxQueueHolDelay [variable]
-    cls.add_instance_attribute('retxQueueHolDelay', 'uint16_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxQueueSize [variable]
-    cls.add_instance_attribute('retxQueueSize', 'uint32_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::statusPduSize [variable]
-    cls.add_instance_attribute('statusPduSize', 'uint16_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txQueueHolDelay [variable]
-    cls.add_instance_attribute('txQueueHolDelay', 'uint16_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txQueueSize [variable]
-    cls.add_instance_attribute('txQueueSize', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3LteMacSapProviderTransmitPduParameters_methods(root_module, cls):
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::TransmitPduParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::TransmitPduParameters(ns3::LteMacSapProvider::TransmitPduParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteMacSapProvider::TransmitPduParameters const &', 'arg0')])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::componentCarrierId [variable]
-    cls.add_instance_attribute('componentCarrierId', 'uint8_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::harqProcessId [variable]
-    cls.add_instance_attribute('harqProcessId', 'uint8_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::layer [variable]
-    cls.add_instance_attribute('layer', 'uint8_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::lcid [variable]
-    cls.add_instance_attribute('lcid', 'uint8_t', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::pdu [variable]
-    cls.add_instance_attribute('pdu', 'ns3::Ptr< ns3::Packet >', is_const=False)
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteMacSapUser_methods(root_module, cls):
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapUser::LteMacSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapUser::LteMacSapUser(ns3::LteMacSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteMacSapUser const &', 'arg0')])
-    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyHarqDeliveryFailure() [member function]
-    cls.add_method('NotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('NotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::ReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('ReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteMiErrorModel_methods(root_module, cls):
-    ## lte-mi-error-model.h (module 'lte'): ns3::LteMiErrorModel::LteMiErrorModel() [constructor]
-    cls.add_constructor([])
-    ## lte-mi-error-model.h (module 'lte'): ns3::LteMiErrorModel::LteMiErrorModel(ns3::LteMiErrorModel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteMiErrorModel const &', 'arg0')])
-    ## lte-mi-error-model.h (module 'lte'): static double ns3::LteMiErrorModel::GetPcfichPdcchError(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GetPcfichPdcchError', 
-                   'double', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_static=True)
-    ## lte-mi-error-model.h (module 'lte'): static ns3::TbStats_t ns3::LteMiErrorModel::GetTbDecodificationStats(ns3::SpectrumValue const & sinr, std::vector<int, std::allocator<int> > const & map, uint16_t size, uint8_t mcs, ns3::HarqProcessInfoList_t miHistory) [member function]
-    cls.add_method('GetTbDecodificationStats', 
-                   'ns3::TbStats_t', 
-                   [param('ns3::SpectrumValue const &', 'sinr'), param('std::vector< int > const &', 'map'), param('uint16_t', 'size'), param('uint8_t', 'mcs'), param('std::vector< ns3::HarqProcessInfoElement_t >', 'miHistory')], 
-                   is_static=True)
-    ## lte-mi-error-model.h (module 'lte'): static double ns3::LteMiErrorModel::MappingMiBler(double mib, uint8_t ecrId, uint16_t cbSize) [member function]
-    cls.add_method('MappingMiBler', 
-                   'double', 
-                   [param('double', 'mib'), param('uint8_t', 'ecrId'), param('uint16_t', 'cbSize')], 
-                   is_static=True)
-    ## lte-mi-error-model.h (module 'lte'): static double ns3::LteMiErrorModel::Mib(ns3::SpectrumValue const & sinr, std::vector<int, std::allocator<int> > const & map, uint8_t mcs) [member function]
-    cls.add_method('Mib', 
-                   'double', 
-                   [param('ns3::SpectrumValue const &', 'sinr'), param('std::vector< int > const &', 'map'), param('uint8_t', 'mcs')], 
-                   is_static=True)
-    return
-
-def register_Ns3LtePdcpSapProvider_methods(root_module, cls):
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::LtePdcpSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::LtePdcpSapProvider(ns3::LtePdcpSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePdcpSapProvider const &', 'arg0')])
-    ## lte-pdcp-sap.h (module 'lte'): void ns3::LtePdcpSapProvider::TransmitPdcpSdu(ns3::LtePdcpSapProvider::TransmitPdcpSduParameters params) [member function]
-    cls.add_method('TransmitPdcpSdu', 
-                   'void', 
-                   [param('ns3::LtePdcpSapProvider::TransmitPdcpSduParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LtePdcpSapProviderTransmitPdcpSduParameters_methods(root_module, cls):
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::TransmitPdcpSduParameters::TransmitPdcpSduParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::TransmitPdcpSduParameters::TransmitPdcpSduParameters(ns3::LtePdcpSapProvider::TransmitPdcpSduParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePdcpSapProvider::TransmitPdcpSduParameters const &', 'arg0')])
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::TransmitPdcpSduParameters::lcid [variable]
-    cls.add_instance_attribute('lcid', 'uint8_t', is_const=False)
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::TransmitPdcpSduParameters::pdcpSdu [variable]
-    cls.add_instance_attribute('pdcpSdu', 'ns3::Ptr< ns3::Packet >', is_const=False)
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapProvider::TransmitPdcpSduParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LtePdcpSapUser_methods(root_module, cls):
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::LtePdcpSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::LtePdcpSapUser(ns3::LtePdcpSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePdcpSapUser const &', 'arg0')])
-    ## lte-pdcp-sap.h (module 'lte'): void ns3::LtePdcpSapUser::ReceivePdcpSdu(ns3::LtePdcpSapUser::ReceivePdcpSduParameters params) [member function]
-    cls.add_method('ReceivePdcpSdu', 
-                   'void', 
-                   [param('ns3::LtePdcpSapUser::ReceivePdcpSduParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LtePdcpSapUserReceivePdcpSduParameters_methods(root_module, cls):
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::ReceivePdcpSduParameters::ReceivePdcpSduParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::ReceivePdcpSduParameters::ReceivePdcpSduParameters(ns3::LtePdcpSapUser::ReceivePdcpSduParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePdcpSapUser::ReceivePdcpSduParameters const &', 'arg0')])
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::ReceivePdcpSduParameters::lcid [variable]
-    cls.add_instance_attribute('lcid', 'uint8_t', is_const=False)
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::ReceivePdcpSduParameters::pdcpSdu [variable]
-    cls.add_instance_attribute('pdcpSdu', 'ns3::Ptr< ns3::Packet >', is_const=False)
-    ## lte-pdcp-sap.h (module 'lte'): ns3::LtePdcpSapUser::ReceivePdcpSduParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRlcSapProvider_methods(root_module, cls):
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::LteRlcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::LteRlcSapProvider(ns3::LteRlcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcSapProvider const &', 'arg0')])
-    ## lte-rlc-sap.h (module 'lte'): void ns3::LteRlcSapProvider::TransmitPdcpPdu(ns3::LteRlcSapProvider::TransmitPdcpPduParameters params) [member function]
-    cls.add_method('TransmitPdcpPdu', 
-                   'void', 
-                   [param('ns3::LteRlcSapProvider::TransmitPdcpPduParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteRlcSapProviderTransmitPdcpPduParameters_methods(root_module, cls):
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::TransmitPdcpPduParameters::TransmitPdcpPduParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::TransmitPdcpPduParameters::TransmitPdcpPduParameters(ns3::LteRlcSapProvider::TransmitPdcpPduParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcSapProvider::TransmitPdcpPduParameters const &', 'arg0')])
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::TransmitPdcpPduParameters::lcid [variable]
-    cls.add_instance_attribute('lcid', 'uint8_t', is_const=False)
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::TransmitPdcpPduParameters::pdcpPdu [variable]
-    cls.add_instance_attribute('pdcpPdu', 'ns3::Ptr< ns3::Packet >', is_const=False)
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapProvider::TransmitPdcpPduParameters::rnti [variable]
-    cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRlcSapUser_methods(root_module, cls):
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapUser::LteRlcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapUser::LteRlcSapUser(ns3::LteRlcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcSapUser const &', 'arg0')])
-    ## lte-rlc-sap.h (module 'lte'): void ns3::LteRlcSapUser::ReceivePdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('ReceivePdcpPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteRrcSap_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LteRrcSap() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LteRrcSap(ns3::LteRrcSap const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): static double ns3::LteRrcSap::ConvertPdschConfigDedicated2Double(ns3::LteRrcSap::PdschConfigDedicated pdschConfigDedicated) [member function]
-    cls.add_method('ConvertPdschConfigDedicated2Double', 
-                   'double', 
-                   [param('ns3::LteRrcSap::PdschConfigDedicated', 'pdschConfigDedicated')], 
-                   is_static=True)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MaxReportCells [variable]
-    cls.add_static_attribute('MaxReportCells', 'uint8_t const', is_const=True)
-    return
-
-def register_Ns3LteRrcSapAntennaInfoCommon_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon::AntennaInfoCommon() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon::AntennaInfoCommon(ns3::LteRrcSap::AntennaInfoCommon const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::AntennaInfoCommon const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon::antennaPortsCount [variable]
-    cls.add_instance_attribute('antennaPortsCount', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapAntennaInfoDedicated_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoDedicated::AntennaInfoDedicated() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoDedicated::AntennaInfoDedicated(ns3::LteRrcSap::AntennaInfoDedicated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::AntennaInfoDedicated const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoDedicated::transmissionMode [variable]
-    cls.add_instance_attribute('transmissionMode', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapAntennaInfoUl_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl::AntennaInfoUl() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl::AntennaInfoUl(ns3::LteRrcSap::AntennaInfoUl const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::AntennaInfoUl const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl::transmissionMode [variable]
-    cls.add_instance_attribute('transmissionMode', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapAsConfig_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::AsConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::AsConfig(ns3::LteRrcSap::AsConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::AsConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceDlCarrierFreq [variable]
-    cls.add_instance_attribute('sourceDlCarrierFreq', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceMasterInformationBlock [variable]
-    cls.add_instance_attribute('sourceMasterInformationBlock', 'ns3::LteRrcSap::MasterInformationBlock', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceMeasConfig [variable]
-    cls.add_instance_attribute('sourceMeasConfig', 'ns3::LteRrcSap::MeasConfig', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceRadioResourceConfig [variable]
-    cls.add_instance_attribute('sourceRadioResourceConfig', 'ns3::LteRrcSap::RadioResourceConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceSystemInformationBlockType1 [variable]
-    cls.add_instance_attribute('sourceSystemInformationBlockType1', 'ns3::LteRrcSap::SystemInformationBlockType1', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceSystemInformationBlockType2 [variable]
-    cls.add_instance_attribute('sourceSystemInformationBlockType2', 'ns3::LteRrcSap::SystemInformationBlockType2', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceUeIdentity [variable]
-    cls.add_instance_attribute('sourceUeIdentity', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapBlackCellsToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::BlackCellsToAddMod::BlackCellsToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::BlackCellsToAddMod::BlackCellsToAddMod(ns3::LteRrcSap::BlackCellsToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::BlackCellsToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::BlackCellsToAddMod::cellIndex [variable]
-    cls.add_instance_attribute('cellIndex', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::BlackCellsToAddMod::physCellIdRange [variable]
-    cls.add_instance_attribute('physCellIdRange', 'ns3::LteRrcSap::PhysCellIdRange', is_const=False)
-    return
-
-def register_Ns3LteRrcSapCarrierBandwidthEutra_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierBandwidthEutra::CarrierBandwidthEutra() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierBandwidthEutra::CarrierBandwidthEutra(ns3::LteRrcSap::CarrierBandwidthEutra const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CarrierBandwidthEutra const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierBandwidthEutra::dlBandwidth [variable]
-    cls.add_instance_attribute('dlBandwidth', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierBandwidthEutra::ulBandwidth [variable]
-    cls.add_instance_attribute('ulBandwidth', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapCarrierFreqEutra_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra::CarrierFreqEutra() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra::CarrierFreqEutra(ns3::LteRrcSap::CarrierFreqEutra const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CarrierFreqEutra const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra::dlCarrierFreq [variable]
-    cls.add_instance_attribute('dlCarrierFreq', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra::ulCarrierFreq [variable]
-    cls.add_instance_attribute('ulCarrierFreq', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapCellAccessRelatedInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo::CellAccessRelatedInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo::CellAccessRelatedInfo(ns3::LteRrcSap::CellAccessRelatedInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CellAccessRelatedInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo::cellIdentity [variable]
-    cls.add_instance_attribute('cellIdentity', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo::csgIdentity [variable]
-    cls.add_instance_attribute('csgIdentity', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo::csgIndication [variable]
-    cls.add_instance_attribute('csgIndication', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo::plmnIdentityInfo [variable]
-    cls.add_instance_attribute('plmnIdentityInfo', 'ns3::LteRrcSap::PlmnIdentityInfo', is_const=False)
-    return
-
-def register_Ns3LteRrcSapCellIdentification_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::CellIdentification() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::CellIdentification(ns3::LteRrcSap::CellIdentification const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CellIdentification const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::dlCarrierFreq [variable]
-    cls.add_instance_attribute('dlCarrierFreq', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::physCellId [variable]
-    cls.add_instance_attribute('physCellId', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapCellSelectionInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellSelectionInfo::CellSelectionInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellSelectionInfo::CellSelectionInfo(ns3::LteRrcSap::CellSelectionInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CellSelectionInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellSelectionInfo::qQualMin [variable]
-    cls.add_instance_attribute('qQualMin', 'int8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellSelectionInfo::qRxLevMin [variable]
-    cls.add_instance_attribute('qRxLevMin', 'int8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapCellsToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellsToAddMod::CellsToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellsToAddMod::CellsToAddMod(ns3::LteRrcSap::CellsToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CellsToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellsToAddMod::cellIndex [variable]
-    cls.add_instance_attribute('cellIndex', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellsToAddMod::cellIndividualOffset [variable]
-    cls.add_instance_attribute('cellIndividualOffset', 'int8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellsToAddMod::physCellId [variable]
-    cls.add_instance_attribute('physCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapCgiInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CgiInfo::CgiInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CgiInfo::CgiInfo(ns3::LteRrcSap::CgiInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CgiInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CgiInfo::cellIdentity [variable]
-    cls.add_instance_attribute('cellIdentity', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CgiInfo::plmnIdentity [variable]
-    cls.add_instance_attribute('plmnIdentity', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CgiInfo::plmnIdentityList [variable]
-    cls.add_instance_attribute('plmnIdentityList', 'std::list< unsigned int >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CgiInfo::trackingAreaCode [variable]
-    cls.add_instance_attribute('trackingAreaCode', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapDrbToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::DrbToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::DrbToAddMod(ns3::LteRrcSap::DrbToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::DrbToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::drbIdentity [variable]
-    cls.add_instance_attribute('drbIdentity', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::epsBearerIdentity [variable]
-    cls.add_instance_attribute('epsBearerIdentity', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::logicalChannelConfig [variable]
-    cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::logicalChannelIdentity [variable]
-    cls.add_instance_attribute('logicalChannelIdentity', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::rlcConfig [variable]
-    cls.add_instance_attribute('rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
-    return
-
-def register_Ns3LteRrcSapFreqInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::FreqInfo::FreqInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::FreqInfo::FreqInfo(ns3::LteRrcSap::FreqInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::FreqInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::FreqInfo::ulBandwidth [variable]
-    cls.add_instance_attribute('ulBandwidth', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::FreqInfo::ulCarrierFreq [variable]
-    cls.add_instance_attribute('ulCarrierFreq', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapHandoverPreparationInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::HandoverPreparationInfo::HandoverPreparationInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::HandoverPreparationInfo::HandoverPreparationInfo(ns3::LteRrcSap::HandoverPreparationInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::HandoverPreparationInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::HandoverPreparationInfo::asConfig [variable]
-    cls.add_instance_attribute('asConfig', 'ns3::LteRrcSap::AsConfig', is_const=False)
-    return
-
-def register_Ns3LteRrcSapLogicalChannelConfig_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig::LogicalChannelConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig::LogicalChannelConfig(ns3::LteRrcSap::LogicalChannelConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::LogicalChannelConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig::bucketSizeDurationMs [variable]
-    cls.add_instance_attribute('bucketSizeDurationMs', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig::logicalChannelGroup [variable]
-    cls.add_instance_attribute('logicalChannelGroup', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig::prioritizedBitRateKbps [variable]
-    cls.add_instance_attribute('prioritizedBitRateKbps', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig::priority [variable]
-    cls.add_instance_attribute('priority', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMasterInformationBlock_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MasterInformationBlock::MasterInformationBlock() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MasterInformationBlock::MasterInformationBlock(ns3::LteRrcSap::MasterInformationBlock const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MasterInformationBlock const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MasterInformationBlock::dlBandwidth [variable]
-    cls.add_instance_attribute('dlBandwidth', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MasterInformationBlock::systemFrameNumber [variable]
-    cls.add_instance_attribute('systemFrameNumber', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasConfig_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::MeasConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::MeasConfig(ns3::LteRrcSap::MeasConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::haveMeasGapConfig [variable]
-    cls.add_instance_attribute('haveMeasGapConfig', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::haveQuantityConfig [variable]
-    cls.add_instance_attribute('haveQuantityConfig', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::haveSmeasure [variable]
-    cls.add_instance_attribute('haveSmeasure', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::haveSpeedStatePars [variable]
-    cls.add_instance_attribute('haveSpeedStatePars', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::measGapConfig [variable]
-    cls.add_instance_attribute('measGapConfig', 'ns3::LteRrcSap::MeasGapConfig', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::measIdToAddModList [variable]
-    cls.add_instance_attribute('measIdToAddModList', 'std::list< ns3::LteRrcSap::MeasIdToAddMod >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::measIdToRemoveList [variable]
-    cls.add_instance_attribute('measIdToRemoveList', 'std::list< unsigned char >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::measObjectToAddModList [variable]
-    cls.add_instance_attribute('measObjectToAddModList', 'std::list< ns3::LteRrcSap::MeasObjectToAddMod >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::measObjectToRemoveList [variable]
-    cls.add_instance_attribute('measObjectToRemoveList', 'std::list< unsigned char >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::quantityConfig [variable]
-    cls.add_instance_attribute('quantityConfig', 'ns3::LteRrcSap::QuantityConfig', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::reportConfigToAddModList [variable]
-    cls.add_instance_attribute('reportConfigToAddModList', 'std::list< ns3::LteRrcSap::ReportConfigToAddMod >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::reportConfigToRemoveList [variable]
-    cls.add_instance_attribute('reportConfigToRemoveList', 'std::list< unsigned char >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::sMeasure [variable]
-    cls.add_instance_attribute('sMeasure', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasConfig::speedStatePars [variable]
-    cls.add_instance_attribute('speedStatePars', 'ns3::LteRrcSap::SpeedStatePars', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasGapConfig_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::MeasGapConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::MeasGapConfig(ns3::LteRrcSap::MeasGapConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasGapConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::gapOffsetChoice [variable]
-    cls.add_instance_attribute('gapOffsetChoice', 'ns3::LteRrcSap::MeasGapConfig::gap', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::gapOffsetValue [variable]
-    cls.add_instance_attribute('gapOffsetValue', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::MeasGapConfig::action', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasIdToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasIdToAddMod::MeasIdToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasIdToAddMod::MeasIdToAddMod(ns3::LteRrcSap::MeasIdToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasIdToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasIdToAddMod::measId [variable]
-    cls.add_instance_attribute('measId', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasIdToAddMod::measObjectId [variable]
-    cls.add_instance_attribute('measObjectId', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasIdToAddMod::reportConfigId [variable]
-    cls.add_instance_attribute('reportConfigId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasObjectEutra_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::MeasObjectEutra() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::MeasObjectEutra(ns3::LteRrcSap::MeasObjectEutra const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasObjectEutra const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::allowedMeasBandwidth [variable]
-    cls.add_instance_attribute('allowedMeasBandwidth', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::blackCellsToAddModList [variable]
-    cls.add_instance_attribute('blackCellsToAddModList', 'std::list< ns3::LteRrcSap::BlackCellsToAddMod >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::blackCellsToRemoveList [variable]
-    cls.add_instance_attribute('blackCellsToRemoveList', 'std::list< unsigned char >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::carrierFreq [variable]
-    cls.add_instance_attribute('carrierFreq', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::cellForWhichToReportCGI [variable]
-    cls.add_instance_attribute('cellForWhichToReportCGI', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::cellsToAddModList [variable]
-    cls.add_instance_attribute('cellsToAddModList', 'std::list< ns3::LteRrcSap::CellsToAddMod >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::cellsToRemoveList [variable]
-    cls.add_instance_attribute('cellsToRemoveList', 'std::list< unsigned char >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::haveCellForWhichToReportCGI [variable]
-    cls.add_instance_attribute('haveCellForWhichToReportCGI', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::neighCellConfig [variable]
-    cls.add_instance_attribute('neighCellConfig', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::offsetFreq [variable]
-    cls.add_instance_attribute('offsetFreq', 'int8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::presenceAntennaPort1 [variable]
-    cls.add_instance_attribute('presenceAntennaPort1', 'bool', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasObjectToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectToAddMod::MeasObjectToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectToAddMod::MeasObjectToAddMod(ns3::LteRrcSap::MeasObjectToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasObjectToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectToAddMod::measObjectEutra [variable]
-    cls.add_instance_attribute('measObjectEutra', 'ns3::LteRrcSap::MeasObjectEutra', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectToAddMod::measObjectId [variable]
-    cls.add_instance_attribute('measObjectId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasResultBestNeighCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::MeasResultBestNeighCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::MeasResultBestNeighCell(ns3::LteRrcSap::MeasResultBestNeighCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResultBestNeighCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::haveRsrpResult [variable]
-    cls.add_instance_attribute('haveRsrpResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::haveRsrqResult [variable]
-    cls.add_instance_attribute('haveRsrqResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::physCellId [variable]
-    cls.add_instance_attribute('physCellId', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::rsrpResult [variable]
-    cls.add_instance_attribute('rsrpResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::rsrqResult [variable]
-    cls.add_instance_attribute('rsrqResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::servFreqId [variable]
-    cls.add_instance_attribute('servFreqId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasResultEutra_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::MeasResultEutra() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::MeasResultEutra(ns3::LteRrcSap::MeasResultEutra const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResultEutra const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::cgiInfo [variable]
-    cls.add_instance_attribute('cgiInfo', 'ns3::LteRrcSap::CgiInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::haveCgiInfo [variable]
-    cls.add_instance_attribute('haveCgiInfo', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::haveRsrpResult [variable]
-    cls.add_instance_attribute('haveRsrpResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::haveRsrqResult [variable]
-    cls.add_instance_attribute('haveRsrqResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::physCellId [variable]
-    cls.add_instance_attribute('physCellId', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::rsrpResult [variable]
-    cls.add_instance_attribute('rsrpResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::rsrqResult [variable]
-    cls.add_instance_attribute('rsrqResult', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasResultScell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::MeasResultScell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::MeasResultScell(ns3::LteRrcSap::MeasResultScell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResultScell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::haveRsrpResult [variable]
-    cls.add_instance_attribute('haveRsrpResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::haveRsrqResult [variable]
-    cls.add_instance_attribute('haveRsrqResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::rsrpResult [variable]
-    cls.add_instance_attribute('rsrpResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::rsrqResult [variable]
-    cls.add_instance_attribute('rsrqResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::servFreqId [variable]
-    cls.add_instance_attribute('servFreqId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasResultServFreqList_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::MeasResultServFreqList() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::MeasResultServFreqList(ns3::LteRrcSap::MeasResultServFreqList const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResultServFreqList const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::haveMeasurementResultsNeighCell [variable]
-    cls.add_instance_attribute('haveMeasurementResultsNeighCell', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::haveMeasurementResultsServingSCells [variable]
-    cls.add_instance_attribute('haveMeasurementResultsServingSCells', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::measResultBestNeighCell [variable]
-    cls.add_instance_attribute('measResultBestNeighCell', 'std::list< ns3::LteRrcSap::MeasResultBestNeighCell >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::measResultScell [variable]
-    cls.add_instance_attribute('measResultScell', 'std::list< ns3::LteRrcSap::MeasResultScell >', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasResults_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::MeasResults() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::MeasResults(ns3::LteRrcSap::MeasResults const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResults const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::haveMeasResultNeighCells [variable]
-    cls.add_instance_attribute('haveMeasResultNeighCells', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::haveScellsMeas [variable]
-    cls.add_instance_attribute('haveScellsMeas', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::measId [variable]
-    cls.add_instance_attribute('measId', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::measResultListEutra [variable]
-    cls.add_instance_attribute('measResultListEutra', 'std::list< ns3::LteRrcSap::MeasResultEutra >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::measScellResultList [variable]
-    cls.add_instance_attribute('measScellResultList', 'ns3::LteRrcSap::MeasResultServFreqList', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::rsrpResult [variable]
-    cls.add_instance_attribute('rsrpResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::rsrqResult [variable]
-    cls.add_instance_attribute('rsrqResult', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasurementReport_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasurementReport::MeasurementReport() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasurementReport::MeasurementReport(ns3::LteRrcSap::MeasurementReport const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasurementReport const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasurementReport::measResults [variable]
-    cls.add_instance_attribute('measResults', 'ns3::LteRrcSap::MeasResults', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMobilityControlInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::MobilityControlInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::MobilityControlInfo(ns3::LteRrcSap::MobilityControlInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MobilityControlInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::carrierBandwidth [variable]
-    cls.add_instance_attribute('carrierBandwidth', 'ns3::LteRrcSap::CarrierBandwidthEutra', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::carrierFreq [variable]
-    cls.add_instance_attribute('carrierFreq', 'ns3::LteRrcSap::CarrierFreqEutra', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::haveCarrierBandwidth [variable]
-    cls.add_instance_attribute('haveCarrierBandwidth', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::haveCarrierFreq [variable]
-    cls.add_instance_attribute('haveCarrierFreq', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::haveRachConfigDedicated [variable]
-    cls.add_instance_attribute('haveRachConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::newUeIdentity [variable]
-    cls.add_instance_attribute('newUeIdentity', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::rachConfigDedicated [variable]
-    cls.add_instance_attribute('rachConfigDedicated', 'ns3::LteRrcSap::RachConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::radioResourceConfigCommon [variable]
-    cls.add_instance_attribute('radioResourceConfigCommon', 'ns3::LteRrcSap::RadioResourceConfigCommon', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo::targetPhysCellId [variable]
-    cls.add_instance_attribute('targetPhysCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMobilityStateParameters_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters::MobilityStateParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters::MobilityStateParameters(ns3::LteRrcSap::MobilityStateParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MobilityStateParameters const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters::nCellChangeHigh [variable]
-    cls.add_instance_attribute('nCellChangeHigh', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters::nCellChangeMedium [variable]
-    cls.add_instance_attribute('nCellChangeMedium', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters::tEvaluation [variable]
-    cls.add_instance_attribute('tEvaluation', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters::tHystNormal [variable]
-    cls.add_instance_attribute('tHystNormal', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapNonCriticalExtensionConfiguration_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::NonCriticalExtensionConfiguration() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::NonCriticalExtensionConfiguration(ns3::LteRrcSap::NonCriticalExtensionConfiguration const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::NonCriticalExtensionConfiguration const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::sCellToReleaseList [variable]
-    cls.add_instance_attribute('sCellToReleaseList', 'std::list< unsigned int >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::sCellsToAddModList [variable]
-    cls.add_instance_attribute('sCellsToAddModList', 'std::list< ns3::LteRrcSap::SCellToAddMod >', is_const=False)
-    return
-
-def register_Ns3LteRrcSapNonUlConfiguration_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::NonUlConfiguration() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::NonUlConfiguration(ns3::LteRrcSap::NonUlConfiguration const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::NonUlConfiguration const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::antennaInfoCommon [variable]
-    cls.add_instance_attribute('antennaInfoCommon', 'ns3::LteRrcSap::AntennaInfoCommon', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::dlBandwidth [variable]
-    cls.add_instance_attribute('dlBandwidth', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::pdschConfigCommon [variable]
-    cls.add_instance_attribute('pdschConfigCommon', 'ns3::LteRrcSap::PdschConfigCommon', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPdschConfigCommon_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigCommon::PdschConfigCommon() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigCommon::PdschConfigCommon(ns3::LteRrcSap::PdschConfigCommon const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PdschConfigCommon const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigCommon::pb [variable]
-    cls.add_instance_attribute('pb', 'int8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigCommon::referenceSignalPower [variable]
-    cls.add_instance_attribute('referenceSignalPower', 'int8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPdschConfigDedicated_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated::PdschConfigDedicated() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated::PdschConfigDedicated(ns3::LteRrcSap::PdschConfigDedicated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PdschConfigDedicated const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated::pa [variable]
-    cls.add_instance_attribute('pa', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPhysCellIdRange_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysCellIdRange::PhysCellIdRange() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysCellIdRange::PhysCellIdRange(ns3::LteRrcSap::PhysCellIdRange const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PhysCellIdRange const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysCellIdRange::haveRange [variable]
-    cls.add_instance_attribute('haveRange', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysCellIdRange::range [variable]
-    cls.add_instance_attribute('range', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysCellIdRange::start [variable]
-    cls.add_instance_attribute('start', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPhysicalConfigDedicated_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::PhysicalConfigDedicated() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::PhysicalConfigDedicated(ns3::LteRrcSap::PhysicalConfigDedicated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PhysicalConfigDedicated const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::antennaInfo [variable]
-    cls.add_instance_attribute('antennaInfo', 'ns3::LteRrcSap::AntennaInfoDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::haveAntennaInfoDedicated [variable]
-    cls.add_instance_attribute('haveAntennaInfoDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::havePdschConfigDedicated [variable]
-    cls.add_instance_attribute('havePdschConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::haveSoundingRsUlConfigDedicated [variable]
-    cls.add_instance_attribute('haveSoundingRsUlConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::pdschConfigDedicated [variable]
-    cls.add_instance_attribute('pdschConfigDedicated', 'ns3::LteRrcSap::PdschConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated::soundingRsUlConfigDedicated [variable]
-    cls.add_instance_attribute('soundingRsUlConfigDedicated', 'ns3::LteRrcSap::SoundingRsUlConfigDedicated', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPhysicalConfigDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::PhysicalConfigDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::PhysicalConfigDedicatedSCell(ns3::LteRrcSap::PhysicalConfigDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PhysicalConfigDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::antennaInfo [variable]
-    cls.add_instance_attribute('antennaInfo', 'ns3::LteRrcSap::AntennaInfoDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::antennaInfoUl [variable]
-    cls.add_instance_attribute('antennaInfoUl', 'ns3::LteRrcSap::AntennaInfoDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::crossCarrierSchedulingConfig [variable]
-    cls.add_instance_attribute('crossCarrierSchedulingConfig', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveAntennaInfoDedicated [variable]
-    cls.add_instance_attribute('haveAntennaInfoDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveAntennaInfoUlDedicated [variable]
-    cls.add_instance_attribute('haveAntennaInfoUlDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveNonUlConfiguration [variable]
-    cls.add_instance_attribute('haveNonUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::havePdschConfigDedicated [variable]
-    cls.add_instance_attribute('havePdschConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveSoundingRsUlConfigDedicated [variable]
-    cls.add_instance_attribute('haveSoundingRsUlConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveUlConfiguration [variable]
-    cls.add_instance_attribute('haveUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::pdschConfigDedicated [variable]
-    cls.add_instance_attribute('pdschConfigDedicated', 'ns3::LteRrcSap::PdschConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::pushConfigDedicatedSCell [variable]
-    cls.add_instance_attribute('pushConfigDedicatedSCell', 'ns3::LteRrcSap::PuschConfigDedicatedSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::soundingRsUlConfigDedicated [variable]
-    cls.add_instance_attribute('soundingRsUlConfigDedicated', 'ns3::LteRrcSap::SoundingRsUlConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::ulPowerControlDedicatedSCell [variable]
-    cls.add_instance_attribute('ulPowerControlDedicatedSCell', 'ns3::LteRrcSap::UlPowerControlDedicatedSCell', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPlmnIdentityInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PlmnIdentityInfo::PlmnIdentityInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PlmnIdentityInfo::PlmnIdentityInfo(ns3::LteRrcSap::PlmnIdentityInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PlmnIdentityInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PlmnIdentityInfo::plmnIdentity [variable]
-    cls.add_instance_attribute('plmnIdentity', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPrachConfigSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell::PrachConfigSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell::PrachConfigSCell(ns3::LteRrcSap::PrachConfigSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PrachConfigSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell::index [variable]
-    cls.add_instance_attribute('index', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPreambleInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PreambleInfo::PreambleInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PreambleInfo::PreambleInfo(ns3::LteRrcSap::PreambleInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PreambleInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PreambleInfo::numberOfRaPreambles [variable]
-    cls.add_instance_attribute('numberOfRaPreambles', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapPuschConfigDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell::PuschConfigDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell::PuschConfigDedicatedSCell(ns3::LteRrcSap::PuschConfigDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PuschConfigDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell::nPuschIdentity [variable]
-    cls.add_instance_attribute('nPuschIdentity', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapQuantityConfig_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::QuantityConfig::QuantityConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::QuantityConfig::QuantityConfig(ns3::LteRrcSap::QuantityConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::QuantityConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::QuantityConfig::filterCoefficientRSRP [variable]
-    cls.add_instance_attribute('filterCoefficientRSRP', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::QuantityConfig::filterCoefficientRSRQ [variable]
-    cls.add_instance_attribute('filterCoefficientRSRQ', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRaSupervisionInfo_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RaSupervisionInfo::RaSupervisionInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RaSupervisionInfo::RaSupervisionInfo(ns3::LteRrcSap::RaSupervisionInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RaSupervisionInfo const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RaSupervisionInfo::preambleTransMax [variable]
-    cls.add_instance_attribute('preambleTransMax', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RaSupervisionInfo::raResponseWindowSize [variable]
-    cls.add_instance_attribute('raResponseWindowSize', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRachConfigCommon_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigCommon::RachConfigCommon() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigCommon::RachConfigCommon(ns3::LteRrcSap::RachConfigCommon const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RachConfigCommon const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigCommon::preambleInfo [variable]
-    cls.add_instance_attribute('preambleInfo', 'ns3::LteRrcSap::PreambleInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigCommon::raSupervisionInfo [variable]
-    cls.add_instance_attribute('raSupervisionInfo', 'ns3::LteRrcSap::RaSupervisionInfo', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRachConfigDedicated_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigDedicated::RachConfigDedicated() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigDedicated::RachConfigDedicated(ns3::LteRrcSap::RachConfigDedicated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RachConfigDedicated const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigDedicated::raPrachMaskIndex [variable]
-    cls.add_instance_attribute('raPrachMaskIndex', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RachConfigDedicated::raPreambleIndex [variable]
-    cls.add_instance_attribute('raPreambleIndex', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRadioResourceConfigCommon_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommon::RadioResourceConfigCommon() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommon::RadioResourceConfigCommon(ns3::LteRrcSap::RadioResourceConfigCommon const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RadioResourceConfigCommon const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommon::rachConfigCommon [variable]
-    cls.add_instance_attribute('rachConfigCommon', 'ns3::LteRrcSap::RachConfigCommon', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRadioResourceConfigCommonSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::RadioResourceConfigCommonSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::RadioResourceConfigCommonSCell(ns3::LteRrcSap::RadioResourceConfigCommonSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RadioResourceConfigCommonSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::haveNonUlConfiguration [variable]
-    cls.add_instance_attribute('haveNonUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::haveUlConfiguration [variable]
-    cls.add_instance_attribute('haveUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::nonUlConfiguration [variable]
-    cls.add_instance_attribute('nonUlConfiguration', 'ns3::LteRrcSap::NonUlConfiguration', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::ulConfiguration [variable]
-    cls.add_instance_attribute('ulConfiguration', 'ns3::LteRrcSap::UlConfiguration', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRadioResourceConfigCommonSib_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSib::RadioResourceConfigCommonSib() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSib::RadioResourceConfigCommonSib(ns3::LteRrcSap::RadioResourceConfigCommonSib const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RadioResourceConfigCommonSib const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSib::pdschConfigCommon [variable]
-    cls.add_instance_attribute('pdschConfigCommon', 'ns3::LteRrcSap::PdschConfigCommon', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSib::rachConfigCommon [variable]
-    cls.add_instance_attribute('rachConfigCommon', 'ns3::LteRrcSap::RachConfigCommon', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRadioResourceConfigDedicated_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated::RadioResourceConfigDedicated() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated::RadioResourceConfigDedicated(ns3::LteRrcSap::RadioResourceConfigDedicated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RadioResourceConfigDedicated const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated::drbToAddModList [variable]
-    cls.add_instance_attribute('drbToAddModList', 'std::list< ns3::LteRrcSap::DrbToAddMod >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated::drbToReleaseList [variable]
-    cls.add_instance_attribute('drbToReleaseList', 'std::list< unsigned char >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated::havePhysicalConfigDedicated [variable]
-    cls.add_instance_attribute('havePhysicalConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated::physicalConfigDedicated [variable]
-    cls.add_instance_attribute('physicalConfigDedicated', 'ns3::LteRrcSap::PhysicalConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated::srbToAddModList [variable]
-    cls.add_instance_attribute('srbToAddModList', 'std::list< ns3::LteRrcSap::SrbToAddMod >', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRadioResourceConfigDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell::RadioResourceConfigDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell::RadioResourceConfigDedicatedSCell(ns3::LteRrcSap::RadioResourceConfigDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RadioResourceConfigDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell::physicalConfigDedicatedSCell [variable]
-    cls.add_instance_attribute('physicalConfigDedicatedSCell', 'ns3::LteRrcSap::PhysicalConfigDedicatedSCell', is_const=False)
-    return
-
-def register_Ns3LteRrcSapReestabUeIdentity_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity::ReestabUeIdentity() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity::ReestabUeIdentity(ns3::LteRrcSap::ReestabUeIdentity const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::ReestabUeIdentity const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity::cRnti [variable]
-    cls.add_instance_attribute('cRnti', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity::physCellId [variable]
-    cls.add_instance_attribute('physCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapReportConfigEutra_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::ReportConfigEutra(ns3::LteRrcSap::ReportConfigEutra const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::ReportConfigEutra const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::ReportConfigEutra() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::a3Offset [variable]
-    cls.add_instance_attribute('a3Offset', 'int8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::hysteresis [variable]
-    cls.add_instance_attribute('hysteresis', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::maxReportCells [variable]
-    cls.add_instance_attribute('maxReportCells', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::purpose [variable]
-    cls.add_instance_attribute('purpose', 'ns3::LteRrcSap::ReportConfigEutra::report', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::reportAmount [variable]
-    cls.add_instance_attribute('reportAmount', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::reportOnLeave [variable]
-    cls.add_instance_attribute('reportOnLeave', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::threshold1 [variable]
-    cls.add_instance_attribute('threshold1', 'ns3::LteRrcSap::ThresholdEutra', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::threshold2 [variable]
-    cls.add_instance_attribute('threshold2', 'ns3::LteRrcSap::ThresholdEutra', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::timeToTrigger [variable]
-    cls.add_instance_attribute('timeToTrigger', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapReportConfigToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigToAddMod::ReportConfigToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigToAddMod::ReportConfigToAddMod(ns3::LteRrcSap::ReportConfigToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::ReportConfigToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigToAddMod::reportConfigEutra [variable]
-    cls.add_instance_attribute('reportConfigEutra', 'ns3::LteRrcSap::ReportConfigEutra', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigToAddMod::reportConfigId [variable]
-    cls.add_instance_attribute('reportConfigId', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRlcConfig_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::RlcConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::RlcConfig(ns3::LteRrcSap::RlcConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RlcConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::choice [variable]
-    cls.add_instance_attribute('choice', 'ns3::LteRrcSap::RlcConfig::direction', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionReconfiguration_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::RrcConnectionReconfiguration() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::RrcConnectionReconfiguration(ns3::LteRrcSap::RrcConnectionReconfiguration const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionReconfiguration const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::haveMeasConfig [variable]
-    cls.add_instance_attribute('haveMeasConfig', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::haveMobilityControlInfo [variable]
-    cls.add_instance_attribute('haveMobilityControlInfo', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::haveNonCriticalExtension [variable]
-    cls.add_instance_attribute('haveNonCriticalExtension', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::haveRadioResourceConfigDedicated [variable]
-    cls.add_instance_attribute('haveRadioResourceConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::measConfig [variable]
-    cls.add_instance_attribute('measConfig', 'ns3::LteRrcSap::MeasConfig', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::mobilityControlInfo [variable]
-    cls.add_instance_attribute('mobilityControlInfo', 'ns3::LteRrcSap::MobilityControlInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::nonCriticalExtension [variable]
-    cls.add_instance_attribute('nonCriticalExtension', 'ns3::LteRrcSap::NonCriticalExtensionConfiguration', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::radioResourceConfigDedicated [variable]
-    cls.add_instance_attribute('radioResourceConfigDedicated', 'ns3::LteRrcSap::RadioResourceConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::rrcTransactionIdentifier [variable]
-    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionReconfigurationCompleted_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfigurationCompleted::RrcConnectionReconfigurationCompleted() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfigurationCompleted::RrcConnectionReconfigurationCompleted(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionReconfigurationCompleted const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfigurationCompleted::rrcTransactionIdentifier [variable]
-    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionReestablishment_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishment::RrcConnectionReestablishment() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishment::RrcConnectionReestablishment(ns3::LteRrcSap::RrcConnectionReestablishment const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionReestablishment const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishment::radioResourceConfigDedicated [variable]
-    cls.add_instance_attribute('radioResourceConfigDedicated', 'ns3::LteRrcSap::RadioResourceConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishment::rrcTransactionIdentifier [variable]
-    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionReestablishmentComplete_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentComplete::RrcConnectionReestablishmentComplete() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentComplete::RrcConnectionReestablishmentComplete(ns3::LteRrcSap::RrcConnectionReestablishmentComplete const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionReestablishmentComplete const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentComplete::rrcTransactionIdentifier [variable]
-    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionReestablishmentReject_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentReject::RrcConnectionReestablishmentReject() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentReject::RrcConnectionReestablishmentReject(ns3::LteRrcSap::RrcConnectionReestablishmentReject const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionReestablishmentReject const &', 'arg0')])
-    return
-
-def register_Ns3LteRrcSapRrcConnectionReestablishmentRequest_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentRequest::RrcConnectionReestablishmentRequest() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentRequest::RrcConnectionReestablishmentRequest(ns3::LteRrcSap::RrcConnectionReestablishmentRequest const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionReestablishmentRequest const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentRequest::reestablishmentCause [variable]
-    cls.add_instance_attribute('reestablishmentCause', 'ns3::LteRrcSap::ReestablishmentCause', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentRequest::ueIdentity [variable]
-    cls.add_instance_attribute('ueIdentity', 'ns3::LteRrcSap::ReestabUeIdentity', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionReject_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReject::RrcConnectionReject() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReject::RrcConnectionReject(ns3::LteRrcSap::RrcConnectionReject const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionReject const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReject::waitTime [variable]
-    cls.add_instance_attribute('waitTime', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionRelease_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRelease::RrcConnectionRelease() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRelease::RrcConnectionRelease(ns3::LteRrcSap::RrcConnectionRelease const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionRelease const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRelease::rrcTransactionIdentifier [variable]
-    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionRequest_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::RrcConnectionRequest() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::RrcConnectionRequest(ns3::LteRrcSap::RrcConnectionRequest const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionRequest const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::ueIdentity [variable]
-    cls.add_instance_attribute('ueIdentity', 'uint64_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionSetup_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetup::RrcConnectionSetup() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetup::RrcConnectionSetup(ns3::LteRrcSap::RrcConnectionSetup const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionSetup const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetup::radioResourceConfigDedicated [variable]
-    cls.add_instance_attribute('radioResourceConfigDedicated', 'ns3::LteRrcSap::RadioResourceConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetup::rrcTransactionIdentifier [variable]
-    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapRrcConnectionSetupCompleted_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetupCompleted::RrcConnectionSetupCompleted() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetupCompleted::RrcConnectionSetupCompleted(ns3::LteRrcSap::RrcConnectionSetupCompleted const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionSetupCompleted const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetupCompleted::rrcTransactionIdentifier [variable]
-    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSCellToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::SCellToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::SCellToAddMod(ns3::LteRrcSap::SCellToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SCellToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::cellIdentification [variable]
-    cls.add_instance_attribute('cellIdentification', 'ns3::LteRrcSap::CellIdentification', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::haveRadioResourceConfigDedicatedSCell [variable]
-    cls.add_instance_attribute('haveRadioResourceConfigDedicatedSCell', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::radioResourceConfigCommonSCell [variable]
-    cls.add_instance_attribute('radioResourceConfigCommonSCell', 'ns3::LteRrcSap::RadioResourceConfigCommonSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::radioResourceConfigDedicateSCell [variable]
-    cls.add_instance_attribute('radioResourceConfigDedicateSCell', 'ns3::LteRrcSap::RadioResourceConfigDedicatedSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::sCellIndex [variable]
-    cls.add_instance_attribute('sCellIndex', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSoundingRsUlConfigCommon_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::SoundingRsUlConfigCommon() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::SoundingRsUlConfigCommon(ns3::LteRrcSap::SoundingRsUlConfigCommon const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SoundingRsUlConfigCommon const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::srsBandwidthConfig [variable]
-    cls.add_instance_attribute('srsBandwidthConfig', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::srsSubframeConfig [variable]
-    cls.add_instance_attribute('srsSubframeConfig', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::SoundingRsUlConfigCommon::action', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSoundingRsUlConfigDedicated_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::SoundingRsUlConfigDedicated() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::SoundingRsUlConfigDedicated(ns3::LteRrcSap::SoundingRsUlConfigDedicated const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SoundingRsUlConfigDedicated const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::srsBandwidth [variable]
-    cls.add_instance_attribute('srsBandwidth', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::srsConfigIndex [variable]
-    cls.add_instance_attribute('srsConfigIndex', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::SoundingRsUlConfigDedicated::action', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSpeedStatePars_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::SpeedStatePars() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::SpeedStatePars(ns3::LteRrcSap::SpeedStatePars const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SpeedStatePars const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::mobilityStateParameters [variable]
-    cls.add_instance_attribute('mobilityStateParameters', 'ns3::LteRrcSap::MobilityStateParameters', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::timeToTriggerSf [variable]
-    cls.add_instance_attribute('timeToTriggerSf', 'ns3::LteRrcSap::SpeedStateScaleFactors', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::SpeedStatePars::action', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSpeedStateScaleFactors_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStateScaleFactors::SpeedStateScaleFactors() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStateScaleFactors::SpeedStateScaleFactors(ns3::LteRrcSap::SpeedStateScaleFactors const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SpeedStateScaleFactors const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStateScaleFactors::sfHigh [variable]
-    cls.add_instance_attribute('sfHigh', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStateScaleFactors::sfMedium [variable]
-    cls.add_instance_attribute('sfMedium', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSrbToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SrbToAddMod::SrbToAddMod() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SrbToAddMod::SrbToAddMod(ns3::LteRrcSap::SrbToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SrbToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SrbToAddMod::logicalChannelConfig [variable]
-    cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SrbToAddMod::srbIdentity [variable]
-    cls.add_instance_attribute('srbIdentity', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSystemInformation_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformation::SystemInformation() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformation::SystemInformation(ns3::LteRrcSap::SystemInformation const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SystemInformation const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformation::haveSib2 [variable]
-    cls.add_instance_attribute('haveSib2', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformation::sib2 [variable]
-    cls.add_instance_attribute('sib2', 'ns3::LteRrcSap::SystemInformationBlockType2', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSystemInformationBlockType1_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType1::SystemInformationBlockType1() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType1::SystemInformationBlockType1(ns3::LteRrcSap::SystemInformationBlockType1 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SystemInformationBlockType1 const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType1::cellAccessRelatedInfo [variable]
-    cls.add_instance_attribute('cellAccessRelatedInfo', 'ns3::LteRrcSap::CellAccessRelatedInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType1::cellSelectionInfo [variable]
-    cls.add_instance_attribute('cellSelectionInfo', 'ns3::LteRrcSap::CellSelectionInfo', is_const=False)
-    return
-
-def register_Ns3LteRrcSapSystemInformationBlockType2_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType2::SystemInformationBlockType2() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType2::SystemInformationBlockType2(ns3::LteRrcSap::SystemInformationBlockType2 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SystemInformationBlockType2 const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType2::freqInfo [variable]
-    cls.add_instance_attribute('freqInfo', 'ns3::LteRrcSap::FreqInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType2::radioResourceConfigCommon [variable]
-    cls.add_instance_attribute('radioResourceConfigCommon', 'ns3::LteRrcSap::RadioResourceConfigCommonSib', is_const=False)
-    return
-
-def register_Ns3LteRrcSapThresholdEutra_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ThresholdEutra::ThresholdEutra() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ThresholdEutra::ThresholdEutra(ns3::LteRrcSap::ThresholdEutra const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::ThresholdEutra const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ThresholdEutra::range [variable]
-    cls.add_instance_attribute('range', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapUlConfiguration_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::UlConfiguration() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::UlConfiguration(ns3::LteRrcSap::UlConfiguration const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::UlConfiguration const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::prachConfigSCell [variable]
-    cls.add_instance_attribute('prachConfigSCell', 'ns3::LteRrcSap::PrachConfigSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::soundingRsUlConfigCommon [variable]
-    cls.add_instance_attribute('soundingRsUlConfigCommon', 'ns3::LteRrcSap::SoundingRsUlConfigCommon', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::ulFreqInfo [variable]
-    cls.add_instance_attribute('ulFreqInfo', 'ns3::LteRrcSap::FreqInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::ulPowerControlCommonSCell [variable]
-    cls.add_instance_attribute('ulPowerControlCommonSCell', 'ns3::LteRrcSap::UlPowerControlCommonSCell', is_const=False)
-    return
-
-def register_Ns3LteRrcSapUlPowerControlCommonSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell::UlPowerControlCommonSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell::UlPowerControlCommonSCell(ns3::LteRrcSap::UlPowerControlCommonSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::UlPowerControlCommonSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell::alpha [variable]
-    cls.add_instance_attribute('alpha', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapUlPowerControlDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell::UlPowerControlDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell::UlPowerControlDedicatedSCell(ns3::LteRrcSap::UlPowerControlDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::UlPowerControlDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell::pSrsOffset [variable]
-    cls.add_instance_attribute('pSrsOffset', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteSpectrumValueCatcher_methods(root_module, cls):
-    ## lte-chunk-processor.h (module 'lte'): ns3::LteSpectrumValueCatcher::LteSpectrumValueCatcher() [constructor]
-    cls.add_constructor([])
-    ## lte-chunk-processor.h (module 'lte'): ns3::LteSpectrumValueCatcher::LteSpectrumValueCatcher(ns3::LteSpectrumValueCatcher const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteSpectrumValueCatcher const &', 'arg0')])
-    ## lte-chunk-processor.h (module 'lte'): ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueCatcher::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [])
-    ## lte-chunk-processor.h (module 'lte'): void ns3::LteSpectrumValueCatcher::ReportValue(ns3::SpectrumValue const & value) [member function]
-    cls.add_method('ReportValue', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'value')])
-    return
-
-def register_Ns3LteSpectrumValueHelper_methods(root_module, cls):
-    ## lte-spectrum-value-helper.h (module 'lte'): ns3::LteSpectrumValueHelper::LteSpectrumValueHelper() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-value-helper.h (module 'lte'): ns3::LteSpectrumValueHelper::LteSpectrumValueHelper(ns3::LteSpectrumValueHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteSpectrumValueHelper const &', 'arg0')])
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateNoisePowerSpectralDensity(uint32_t earfcn, uint8_t bandwidth, double noiseFigure) [member function]
-    cls.add_method('CreateNoisePowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'noiseFigure')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateNoisePowerSpectralDensity(double noiseFigure, ns3::Ptr<ns3::SpectrumModel> spectrumModel) [member function]
-    cls.add_method('CreateNoisePowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('double', 'noiseFigure'), param('ns3::Ptr< ns3::SpectrumModel >', 'spectrumModel')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateTxPowerSpectralDensity(uint32_t earfcn, uint8_t bandwidth, double powerTx, std::vector<int, std::allocator<int> > activeRbs) [member function]
-    cls.add_method('CreateTxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'powerTx'), param('std::vector< int >', 'activeRbs')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateTxPowerSpectralDensity(uint32_t earfcn, uint8_t bandwidth, double powerTx, std::map<int, double, std::less<int>, std::allocator<std::pair<const int, double> > > powerTxMap, std::vector<int, std::allocator<int> > activeRbs) [member function]
-    cls.add_method('CreateTxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'powerTx'), param('std::map< int, double >', 'powerTxMap'), param('std::vector< int >', 'activeRbs')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetCarrierFrequency(uint32_t earfcn) [member function]
-    cls.add_method('GetCarrierFrequency', 
-                   'double', 
-                   [param('uint32_t', 'earfcn')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetChannelBandwidth(uint8_t txBandwidthConf) [member function]
-    cls.add_method('GetChannelBandwidth', 
-                   'double', 
-                   [param('uint8_t', 'txBandwidthConf')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static uint16_t ns3::LteSpectrumValueHelper::GetDownlinkCarrierBand(uint32_t nDl) [member function]
-    cls.add_method('GetDownlinkCarrierBand', 
-                   'uint16_t', 
-                   [param('uint32_t', 'nDl')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetDownlinkCarrierFrequency(uint32_t earfcn) [member function]
-    cls.add_method('GetDownlinkCarrierFrequency', 
-                   'double', 
-                   [param('uint32_t', 'earfcn')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumModel> ns3::LteSpectrumValueHelper::GetSpectrumModel(uint32_t earfcn, uint8_t bandwidth) [member function]
-    cls.add_method('GetSpectrumModel', 
-                   'ns3::Ptr< ns3::SpectrumModel >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static uint16_t ns3::LteSpectrumValueHelper::GetUplinkCarrierBand(uint32_t nDl) [member function]
-    cls.add_method('GetUplinkCarrierBand', 
-                   'uint16_t', 
-                   [param('uint32_t', 'nDl')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetUplinkCarrierFrequency(uint32_t earfcn) [member function]
-    cls.add_method('GetUplinkCarrierFrequency', 
-                   'double', 
-                   [param('uint32_t', 'earfcn')], 
-                   is_static=True)
-    return
-
-def register_Ns3LteUeCcmRrcSapProvider_methods(root_module, cls):
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LteUeCcmRrcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LteUeCcmRrcSapProvider(ns3::LteUeCcmRrcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCcmRrcSapProvider const &', 'arg0')])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): std::vector<ns3::LteUeCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteUeCcmRrcSapProvider::LcsConfig> > ns3::LteUeCcmRrcSapProvider::AddLc(uint8_t lcId, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('AddLc', 
-                   'std::vector< ns3::LteUeCcmRrcSapProvider::LcsConfig >', 
-                   [param('uint8_t', 'lcId'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteMacSapUser * ns3::LteUeCcmRrcSapProvider::ConfigureSignalBearer(uint8_t lcid, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('ConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('uint8_t', 'lcid'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): void ns3::LteUeCcmRrcSapProvider::NotifyConnectionReconfigurationMsg() [member function]
-    cls.add_method('NotifyConnectionReconfigurationMsg', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): std::vector<unsigned short, std::allocator<unsigned short> > ns3::LteUeCcmRrcSapProvider::RemoveLc(uint8_t lcid) [member function]
-    cls.add_method('RemoveLc', 
-                   'std::vector< unsigned short >', 
-                   [param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeCcmRrcSapProviderLcsConfig_methods(root_module, cls):
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::LcsConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::LcsConfig(ns3::LteUeCcmRrcSapProvider::LcsConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCcmRrcSapProvider::LcsConfig const &', 'arg0')])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::componentCarrierId [variable]
-    cls.add_instance_attribute('componentCarrierId', 'uint8_t', is_const=False)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::lcConfig [variable]
-    cls.add_instance_attribute('lcConfig', 'ns3::LteUeCmacSapProvider::LogicalChannelConfig *', is_const=False)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::msu [variable]
-    cls.add_instance_attribute('msu', 'ns3::LteMacSapUser *', is_const=False)
-    return
-
-def register_Ns3LteUeCcmRrcSapUser_methods(root_module, cls):
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapUser::LteUeCcmRrcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapUser::LteUeCcmRrcSapUser(ns3::LteUeCcmRrcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCcmRrcSapUser const &', 'arg0')])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): void ns3::LteUeCcmRrcSapUser::ComponentCarrierEnabling(std::vector<unsigned char, std::allocator<unsigned char> > componentCarrierList) [member function]
-    cls.add_method('ComponentCarrierEnabling', 
-                   'void', 
-                   [param('std::vector< unsigned char >', 'componentCarrierList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeCmacSapProvider_methods(root_module, cls):
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LteUeCmacSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LteUeCmacSapProvider(ns3::LteUeCmacSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCmacSapProvider const &', 'arg0')])
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::AddLc(uint8_t lcId, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('AddLc', 
-                   'void', 
-                   [param('uint8_t', 'lcId'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::ConfigureRach(ns3::LteUeCmacSapProvider::RachConfig rc) [member function]
-    cls.add_method('ConfigureRach', 
-                   'void', 
-                   [param('ns3::LteUeCmacSapProvider::RachConfig', 'rc')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::RemoveLc(uint8_t lcId) [member function]
-    cls.add_method('RemoveLc', 
-                   'void', 
-                   [param('uint8_t', 'lcId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::Reset() [member function]
-    cls.add_method('Reset', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::StartContentionBasedRandomAccessProcedure() [member function]
-    cls.add_method('StartContentionBasedRandomAccessProcedure', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::StartNonContentionBasedRandomAccessProcedure(uint16_t rnti, uint8_t rapId, uint8_t prachMask) [member function]
-    cls.add_method('StartNonContentionBasedRandomAccessProcedure', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'rapId'), param('uint8_t', 'prachMask')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeCmacSapProviderLogicalChannelConfig_methods(root_module, cls):
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig::LogicalChannelConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig::LogicalChannelConfig(ns3::LteUeCmacSapProvider::LogicalChannelConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCmacSapProvider::LogicalChannelConfig const &', 'arg0')])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig::bucketSizeDurationMs [variable]
-    cls.add_instance_attribute('bucketSizeDurationMs', 'uint16_t', is_const=False)
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig::logicalChannelGroup [variable]
-    cls.add_instance_attribute('logicalChannelGroup', 'uint8_t', is_const=False)
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig::prioritizedBitRateKbps [variable]
-    cls.add_instance_attribute('prioritizedBitRateKbps', 'uint16_t', is_const=False)
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig::priority [variable]
-    cls.add_instance_attribute('priority', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteUeCmacSapProviderRachConfig_methods(root_module, cls):
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::RachConfig::RachConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::RachConfig::RachConfig(ns3::LteUeCmacSapProvider::RachConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCmacSapProvider::RachConfig const &', 'arg0')])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::RachConfig::numberOfRaPreambles [variable]
-    cls.add_instance_attribute('numberOfRaPreambles', 'uint8_t', is_const=False)
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::RachConfig::preambleTransMax [variable]
-    cls.add_instance_attribute('preambleTransMax', 'uint8_t', is_const=False)
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::RachConfig::raResponseWindowSize [variable]
-    cls.add_instance_attribute('raResponseWindowSize', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteUeCmacSapUser_methods(root_module, cls):
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapUser::LteUeCmacSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapUser::LteUeCmacSapUser(ns3::LteUeCmacSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCmacSapUser const &', 'arg0')])
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapUser::NotifyRandomAccessFailed() [member function]
-    cls.add_method('NotifyRandomAccessFailed', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapUser::NotifyRandomAccessSuccessful() [member function]
-    cls.add_method('NotifyRandomAccessSuccessful', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapUser::SetTemporaryCellRnti(uint16_t rnti) [member function]
-    cls.add_method('SetTemporaryCellRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeConfig_t_methods(root_module, cls):
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('==')
-    ## lte-common.h (module 'lte'): ns3::LteUeConfig_t::LteUeConfig_t(ns3::LteUeConfig_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeConfig_t const &', 'arg0')])
-    ## lte-common.h (module 'lte'): ns3::LteUeConfig_t::LteUeConfig_t() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::LteUeConfig_t::m_reconfigureFlag [variable]
-    cls.add_instance_attribute('m_reconfigureFlag', 'bool', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::LteUeConfig_t::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::LteUeConfig_t::m_srsConfigurationIndex [variable]
-    cls.add_instance_attribute('m_srsConfigurationIndex', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::LteUeConfig_t::m_transmissionMode [variable]
-    cls.add_instance_attribute('m_transmissionMode', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteUeCphySapProvider_methods(root_module, cls):
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapProvider::LteUeCphySapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapProvider::LteUeCphySapProvider(ns3::LteUeCphySapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCphySapProvider const &', 'arg0')])
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::ConfigureReferenceSignalPower(int8_t referenceSignalPower) [member function]
-    cls.add_method('ConfigureReferenceSignalPower', 
-                   'void', 
-                   [param('int8_t', 'referenceSignalPower')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::ConfigureUplink(uint32_t ulEarfcn, uint8_t ulBandwidth) [member function]
-    cls.add_method('ConfigureUplink', 
-                   'void', 
-                   [param('uint32_t', 'ulEarfcn'), param('uint8_t', 'ulBandwidth')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::Reset() [member function]
-    cls.add_method('Reset', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SetDlBandwidth(uint8_t dlBandwidth) [member function]
-    cls.add_method('SetDlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'dlBandwidth')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SetPa(double pa) [member function]
-    cls.add_method('SetPa', 
-                   'void', 
-                   [param('double', 'pa')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SetSrsConfigurationIndex(uint16_t srcCi) [member function]
-    cls.add_method('SetSrsConfigurationIndex', 
-                   'void', 
-                   [param('uint16_t', 'srcCi')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SetTransmissionMode(uint8_t txMode) [member function]
-    cls.add_method('SetTransmissionMode', 
-                   'void', 
-                   [param('uint8_t', 'txMode')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::StartCellSearch(uint32_t dlEarfcn) [member function]
-    cls.add_method('StartCellSearch', 
-                   'void', 
-                   [param('uint32_t', 'dlEarfcn')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SynchronizeWithEnb(uint16_t cellId) [member function]
-    cls.add_method('SynchronizeWithEnb', 
-                   'void', 
-                   [param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SynchronizeWithEnb(uint16_t cellId, uint32_t dlEarfcn) [member function]
-    cls.add_method('SynchronizeWithEnb', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeCphySapUser_methods(root_module, cls):
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::LteUeCphySapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::LteUeCphySapUser(ns3::LteUeCphySapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCphySapUser const &', 'arg0')])
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapUser::RecvMasterInformationBlock(uint16_t cellId, ns3::LteRrcSap::MasterInformationBlock mib) [member function]
-    cls.add_method('RecvMasterInformationBlock', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::LteRrcSap::MasterInformationBlock', 'mib')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapUser::RecvSystemInformationBlockType1(uint16_t cellId, ns3::LteRrcSap::SystemInformationBlockType1 sib1) [member function]
-    cls.add_method('RecvSystemInformationBlockType1', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::LteRrcSap::SystemInformationBlockType1', 'sib1')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapUser::ReportUeMeasurements(ns3::LteUeCphySapUser::UeMeasurementsParameters params) [member function]
-    cls.add_method('ReportUeMeasurements', 
-                   'void', 
-                   [param('ns3::LteUeCphySapUser::UeMeasurementsParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeCphySapUserUeMeasurementsElement_methods(root_module, cls):
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsElement::UeMeasurementsElement() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsElement::UeMeasurementsElement(ns3::LteUeCphySapUser::UeMeasurementsElement const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCphySapUser::UeMeasurementsElement const &', 'arg0')])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsElement::m_cellId [variable]
-    cls.add_instance_attribute('m_cellId', 'uint16_t', is_const=False)
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsElement::m_rsrp [variable]
-    cls.add_instance_attribute('m_rsrp', 'double', is_const=False)
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsElement::m_rsrq [variable]
-    cls.add_instance_attribute('m_rsrq', 'double', is_const=False)
-    return
-
-def register_Ns3LteUeCphySapUserUeMeasurementsParameters_methods(root_module, cls):
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters::UeMeasurementsParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters::UeMeasurementsParameters(ns3::LteUeCphySapUser::UeMeasurementsParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCphySapUser::UeMeasurementsParameters const &', 'arg0')])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters::m_componentCarrierId [variable]
-    cls.add_instance_attribute('m_componentCarrierId', 'uint8_t', is_const=False)
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters::m_ueMeasurementsList [variable]
-    cls.add_instance_attribute('m_ueMeasurementsList', 'std::vector< ns3::LteUeCphySapUser::UeMeasurementsElement >', is_const=False)
-    return
-
-def register_Ns3LteUePhySapProvider_methods(root_module, cls):
-    ## lte-ue-phy-sap.h (module 'lte'): ns3::LteUePhySapProvider::LteUePhySapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-phy-sap.h (module 'lte'): ns3::LteUePhySapProvider::LteUePhySapProvider(ns3::LteUePhySapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUePhySapProvider const &', 'arg0')])
-    ## lte-ue-phy-sap.h (module 'lte'): void ns3::LteUePhySapProvider::SendLteControlMessage(ns3::Ptr<ns3::LteControlMessage> msg) [member function]
-    cls.add_method('SendLteControlMessage', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteControlMessage >', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-phy-sap.h (module 'lte'): void ns3::LteUePhySapProvider::SendMacPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('SendMacPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-phy-sap.h (module 'lte'): void ns3::LteUePhySapProvider::SendRachPreamble(uint32_t prachId, uint32_t raRnti) [member function]
-    cls.add_method('SendRachPreamble', 
-                   'void', 
-                   [param('uint32_t', 'prachId'), param('uint32_t', 'raRnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUePhySapUser_methods(root_module, cls):
-    ## lte-ue-phy-sap.h (module 'lte'): ns3::LteUePhySapUser::LteUePhySapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-phy-sap.h (module 'lte'): ns3::LteUePhySapUser::LteUePhySapUser(ns3::LteUePhySapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUePhySapUser const &', 'arg0')])
-    ## lte-ue-phy-sap.h (module 'lte'): void ns3::LteUePhySapUser::ReceiveLteControlMessage(ns3::Ptr<ns3::LteControlMessage> msg) [member function]
-    cls.add_method('ReceiveLteControlMessage', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteControlMessage >', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-phy-sap.h (module 'lte'): void ns3::LteUePhySapUser::ReceivePhyPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('ReceivePhyPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-phy-sap.h (module 'lte'): void ns3::LteUePhySapUser::SubframeIndication(uint32_t frameNo, uint32_t subframeNo) [member function]
-    cls.add_method('SubframeIndication', 
-                   'void', 
-                   [param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeRrcSapProvider_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider::LteUeRrcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider::LteUeRrcSapProvider(ns3::LteUeRrcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeRrcSapProvider const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::CompleteSetup(ns3::LteUeRrcSapProvider::CompleteSetupParameters params) [member function]
-    cls.add_method('CompleteSetup', 
-                   'void', 
-                   [param('ns3::LteUeRrcSapProvider::CompleteSetupParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionReconfiguration(ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
-    cls.add_method('RecvRrcConnectionReconfiguration', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReconfiguration', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionReestablishment(ns3::LteRrcSap::RrcConnectionReestablishment msg) [member function]
-    cls.add_method('RecvRrcConnectionReestablishment', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishment', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionReestablishmentReject(ns3::LteRrcSap::RrcConnectionReestablishmentReject msg) [member function]
-    cls.add_method('RecvRrcConnectionReestablishmentReject', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentReject', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionReject(ns3::LteRrcSap::RrcConnectionReject msg) [member function]
-    cls.add_method('RecvRrcConnectionReject', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReject', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionRelease(ns3::LteRrcSap::RrcConnectionRelease msg) [member function]
-    cls.add_method('RecvRrcConnectionRelease', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionRelease', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionSetup(ns3::LteRrcSap::RrcConnectionSetup msg) [member function]
-    cls.add_method('RecvRrcConnectionSetup', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvSystemInformation(ns3::LteRrcSap::SystemInformation msg) [member function]
-    cls.add_method('RecvSystemInformation', 
-                   'void', 
-                   [param('ns3::LteRrcSap::SystemInformation', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeRrcSapProviderCompleteSetupParameters_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider::CompleteSetupParameters::CompleteSetupParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider::CompleteSetupParameters::CompleteSetupParameters(ns3::LteUeRrcSapProvider::CompleteSetupParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeRrcSapProvider::CompleteSetupParameters const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider::CompleteSetupParameters::srb0SapUser [variable]
-    cls.add_instance_attribute('srb0SapUser', 'ns3::LteRlcSapUser *', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapProvider::CompleteSetupParameters::srb1SapUser [variable]
-    cls.add_instance_attribute('srb1SapUser', 'ns3::LtePdcpSapUser *', is_const=False)
-    return
-
-def register_Ns3LteUeRrcSapUser_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser::LteUeRrcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser::LteUeRrcSapUser(ns3::LteUeRrcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeRrcSapUser const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendMeasurementReport(ns3::LteRrcSap::MeasurementReport msg) [member function]
-    cls.add_method('SendMeasurementReport', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MeasurementReport', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendRrcConnectionReconfigurationCompleted(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
-    cls.add_method('SendRrcConnectionReconfigurationCompleted', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReconfigurationCompleted', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendRrcConnectionReestablishmentComplete(ns3::LteRrcSap::RrcConnectionReestablishmentComplete msg) [member function]
-    cls.add_method('SendRrcConnectionReestablishmentComplete', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentComplete', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendRrcConnectionReestablishmentRequest(ns3::LteRrcSap::RrcConnectionReestablishmentRequest msg) [member function]
-    cls.add_method('SendRrcConnectionReestablishmentRequest', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentRequest', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendRrcConnectionRequest(ns3::LteRrcSap::RrcConnectionRequest msg) [member function]
-    cls.add_method('SendRrcConnectionRequest', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionRequest', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendRrcConnectionSetupCompleted(ns3::LteRrcSap::RrcConnectionSetupCompleted msg) [member function]
-    cls.add_method('SendRrcConnectionSetupCompleted', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::Setup(ns3::LteUeRrcSapUser::SetupParameters params) [member function]
-    cls.add_method('Setup', 
-                   'void', 
-                   [param('ns3::LteUeRrcSapUser::SetupParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeRrcSapUserSetupParameters_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser::SetupParameters::SetupParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser::SetupParameters::SetupParameters(ns3::LteUeRrcSapUser::SetupParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeRrcSapUser::SetupParameters const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser::SetupParameters::srb0SapProvider [variable]
-    cls.add_instance_attribute('srb0SapProvider', 'ns3::LteRlcSapProvider *', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteUeRrcSapUser::SetupParameters::srb1SapProvider [variable]
-    cls.add_instance_attribute('srb1SapProvider', 'ns3::LtePdcpSapProvider *', is_const=False)
-    return
-
-def register_Ns3Mac48Address_methods(root_module, cls):
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<')
-    cls.add_output_stream_operator()
-    ## mac48-address.h (module 'network'): ns3::Mac48Address::Mac48Address(ns3::Mac48Address const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Mac48Address const &', 'arg0')])
-    ## mac48-address.h (module 'network'): ns3::Mac48Address::Mac48Address() [constructor]
-    cls.add_constructor([])
-    ## mac48-address.h (module 'network'): ns3::Mac48Address::Mac48Address(char const * str) [constructor]
-    cls.add_constructor([param('char const *', 'str')])
-    ## mac48-address.h (module 'network'): static ns3::Mac48Address ns3::Mac48Address::Allocate() [member function]
-    cls.add_method('Allocate', 
-                   'ns3::Mac48Address', 
-                   [], 
-                   is_static=True)
-    ## mac48-address.h (module 'network'): static ns3::Mac48Address ns3::Mac48Address::ConvertFrom(ns3::Address const & address) [member function]
-    cls.add_method('ConvertFrom', 
-                   'ns3::Mac48Address', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    ## mac48-address.h (module 'network'): void ns3::Mac48Address::CopyFrom(uint8_t const * buffer) [member function]
-    cls.add_method('CopyFrom', 
-                   'void', 
-                   [param('uint8_t const *', 'buffer')])
-    ## mac48-address.h (module 'network'): void ns3::Mac48Address::CopyTo(uint8_t * buffer) const [member function]
-    cls.add_method('CopyTo', 
-                   'void', 
-                   [param('uint8_t *', 'buffer')], 
-                   is_const=True)
-    ## mac48-address.h (module 'network'): static ns3::Mac48Address ns3::Mac48Address::GetBroadcast() [member function]
-    cls.add_method('GetBroadcast', 
-                   'ns3::Mac48Address', 
-                   [], 
-                   is_static=True)
-    ## mac48-address.h (module 'network'): static ns3::Mac48Address ns3::Mac48Address::GetMulticast(ns3::Ipv4Address address) [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Mac48Address', 
-                   [param('ns3::Ipv4Address', 'address')], 
-                   is_static=True)
-    ## mac48-address.h (module 'network'): static ns3::Mac48Address ns3::Mac48Address::GetMulticast(ns3::Ipv6Address address) [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Mac48Address', 
-                   [param('ns3::Ipv6Address', 'address')], 
-                   is_static=True)
-    ## mac48-address.h (module 'network'): static ns3::Mac48Address ns3::Mac48Address::GetMulticast6Prefix() [member function]
-    cls.add_method('GetMulticast6Prefix', 
-                   'ns3::Mac48Address', 
-                   [], 
-                   is_static=True)
-    ## mac48-address.h (module 'network'): static ns3::Mac48Address ns3::Mac48Address::GetMulticastPrefix() [member function]
-    cls.add_method('GetMulticastPrefix', 
-                   'ns3::Mac48Address', 
-                   [], 
-                   is_static=True)
-    ## mac48-address.h (module 'network'): bool ns3::Mac48Address::IsBroadcast() const [member function]
-    cls.add_method('IsBroadcast', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## mac48-address.h (module 'network'): bool ns3::Mac48Address::IsGroup() const [member function]
-    cls.add_method('IsGroup', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## mac48-address.h (module 'network'): static bool ns3::Mac48Address::IsMatchingType(ns3::Address const & address) [member function]
-    cls.add_method('IsMatchingType', 
-                   'bool', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_static=True)
-    return
-
-def register_Ns3MacCeListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeListElement_s::MacCeListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeListElement_s::MacCeListElement_s(ns3::MacCeListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MacCeListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeListElement_s::m_macCeType [variable]
-    cls.add_instance_attribute('m_macCeType', 'ns3::MacCeListElement_s::MacCeType_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeListElement_s::m_macCeValue [variable]
-    cls.add_instance_attribute('m_macCeValue', 'ns3::MacCeValue_u', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3MacCeValue_u_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeValue_u::MacCeValue_u() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeValue_u::MacCeValue_u(ns3::MacCeValue_u const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MacCeValue_u const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeValue_u::m_bufferStatus [variable]
-    cls.add_instance_attribute('m_bufferStatus', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeValue_u::m_crnti [variable]
-    cls.add_instance_attribute('m_crnti', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::MacCeValue_u::m_phr [variable]
-    cls.add_instance_attribute('m_phr', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3Names_methods(root_module, cls):
-    ## names.h (module 'core'): ns3::Names::Names() [constructor]
-    cls.add_constructor([])
-    ## names.h (module 'core'): ns3::Names::Names(ns3::Names const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Names const &', 'arg0')])
-    ## names.h (module 'core'): static void ns3::Names::Add(std::string name, ns3::Ptr<ns3::Object> object) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::Ptr< ns3::Object >', 'object')], 
-                   is_static=True)
-    ## names.h (module 'core'): static void ns3::Names::Add(std::string path, std::string name, ns3::Ptr<ns3::Object> object) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('std::string', 'path'), param('std::string', 'name'), param('ns3::Ptr< ns3::Object >', 'object')], 
-                   is_static=True)
-    ## names.h (module 'core'): static void ns3::Names::Add(ns3::Ptr<ns3::Object> context, std::string name, ns3::Ptr<ns3::Object> object) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Object >', 'context'), param('std::string', 'name'), param('ns3::Ptr< ns3::Object >', 'object')], 
-                   is_static=True)
-    ## names.h (module 'core'): static void ns3::Names::Clear() [member function]
-    cls.add_method('Clear', 
-                   'void', 
-                   [], 
-                   is_static=True)
-    ## names.h (module 'core'): static std::string ns3::Names::FindName(ns3::Ptr<ns3::Object> object) [member function]
-    cls.add_method('FindName', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::Object >', 'object')], 
-                   is_static=True)
-    ## names.h (module 'core'): static std::string ns3::Names::FindPath(ns3::Ptr<ns3::Object> object) [member function]
-    cls.add_method('FindPath', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::Object >', 'object')], 
-                   is_static=True)
-    ## names.h (module 'core'): static void ns3::Names::Rename(std::string oldpath, std::string newname) [member function]
-    cls.add_method('Rename', 
-                   'void', 
-                   [param('std::string', 'oldpath'), param('std::string', 'newname')], 
-                   is_static=True)
-    ## names.h (module 'core'): static void ns3::Names::Rename(std::string path, std::string oldname, std::string newname) [member function]
-    cls.add_method('Rename', 
-                   'void', 
-                   [param('std::string', 'path'), param('std::string', 'oldname'), param('std::string', 'newname')], 
-                   is_static=True)
-    ## names.h (module 'core'): static void ns3::Names::Rename(ns3::Ptr<ns3::Object> context, std::string oldname, std::string newname) [member function]
-    cls.add_method('Rename', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Object >', 'context'), param('std::string', 'oldname'), param('std::string', 'newname')], 
-                   is_static=True)
-    return
-
-def register_Ns3NetDeviceContainer_methods(root_module, cls):
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer::NetDeviceContainer(ns3::NetDeviceContainer const & arg0) [constructor]
-    cls.add_constructor([param('ns3::NetDeviceContainer const &', 'arg0')])
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer::NetDeviceContainer() [constructor]
-    cls.add_constructor([])
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer::NetDeviceContainer(ns3::Ptr<ns3::NetDevice> dev) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::NetDevice >', 'dev')])
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer::NetDeviceContainer(std::string devName) [constructor]
-    cls.add_constructor([param('std::string', 'devName')])
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer::NetDeviceContainer(ns3::NetDeviceContainer const & a, ns3::NetDeviceContainer const & b) [constructor]
-    cls.add_constructor([param('ns3::NetDeviceContainer const &', 'a'), param('ns3::NetDeviceContainer const &', 'b')])
-    ## net-device-container.h (module 'network'): void ns3::NetDeviceContainer::Add(ns3::NetDeviceContainer other) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::NetDeviceContainer', 'other')])
-    ## net-device-container.h (module 'network'): void ns3::NetDeviceContainer::Add(ns3::Ptr<ns3::NetDevice> device) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'device')])
-    ## net-device-container.h (module 'network'): void ns3::NetDeviceContainer::Add(std::string deviceName) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('std::string', 'deviceName')])
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer::Iterator ns3::NetDeviceContainer::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'ns3::NetDeviceContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## net-device-container.h (module 'network'): ns3::NetDeviceContainer::Iterator ns3::NetDeviceContainer::End() const [member function]
-    cls.add_method('End', 
-                   'ns3::NetDeviceContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## net-device-container.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::NetDeviceContainer::Get(uint32_t i) const [member function]
-    cls.add_method('Get', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## net-device-container.h (module 'network'): uint32_t ns3::NetDeviceContainer::GetN() const [member function]
-    cls.add_method('GetN', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    return
-
-def register_Ns3NodeContainer_methods(root_module, cls):
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::NodeContainer const & arg0) [constructor]
-    cls.add_constructor([param('ns3::NodeContainer const &', 'arg0')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer() [constructor]
-    cls.add_constructor([])
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::Ptr<ns3::Node> node) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(std::string nodeName) [constructor]
-    cls.add_constructor([param('std::string', 'nodeName')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::NodeContainer const & a, ns3::NodeContainer const & b) [constructor]
-    cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::NodeContainer const & a, ns3::NodeContainer const & b, ns3::NodeContainer const & c) [constructor]
-    cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::NodeContainer const & a, ns3::NodeContainer const & b, ns3::NodeContainer const & c, ns3::NodeContainer const & d) [constructor]
-    cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::NodeContainer(ns3::NodeContainer const & a, ns3::NodeContainer const & b, ns3::NodeContainer const & c, ns3::NodeContainer const & d, ns3::NodeContainer const & e) [constructor]
-    cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd'), param('ns3::NodeContainer const &', 'e')])
-    ## node-container.h (module 'network'): void ns3::NodeContainer::Add(ns3::NodeContainer other) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::NodeContainer', 'other')])
-    ## node-container.h (module 'network'): void ns3::NodeContainer::Add(ns3::Ptr<ns3::Node> node) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'node')])
-    ## node-container.h (module 'network'): void ns3::NodeContainer::Add(std::string nodeName) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('std::string', 'nodeName')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::Iterator ns3::NodeContainer::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'ns3::NodeContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## node-container.h (module 'network'): void ns3::NodeContainer::Create(uint32_t n) [member function]
-    cls.add_method('Create', 
-                   'void', 
-                   [param('uint32_t', 'n')])
-    ## node-container.h (module 'network'): void ns3::NodeContainer::Create(uint32_t n, uint32_t systemId) [member function]
-    cls.add_method('Create', 
-                   'void', 
-                   [param('uint32_t', 'n'), param('uint32_t', 'systemId')])
-    ## node-container.h (module 'network'): ns3::NodeContainer::Iterator ns3::NodeContainer::End() const [member function]
-    cls.add_method('End', 
-                   'ns3::NodeContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## node-container.h (module 'network'): ns3::Ptr<ns3::Node> ns3::NodeContainer::Get(uint32_t i) const [member function]
-    cls.add_method('Get', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## node-container.h (module 'network'): static ns3::NodeContainer ns3::NodeContainer::GetGlobal() [member function]
-    cls.add_method('GetGlobal', 
-                   'ns3::NodeContainer', 
-                   [], 
-                   is_static=True)
-    ## node-container.h (module 'network'): uint32_t ns3::NodeContainer::GetN() const [member function]
-    cls.add_method('GetN', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    return
-
-def register_Ns3ObjectBase_methods(root_module, cls):
-    ## object-base.h (module 'core'): ns3::ObjectBase::ObjectBase() [constructor]
-    cls.add_constructor([])
-    ## object-base.h (module 'core'): ns3::ObjectBase::ObjectBase(ns3::ObjectBase const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ObjectBase const &', 'arg0')])
-    ## object-base.h (module 'core'): void ns3::ObjectBase::GetAttribute(std::string name, ns3::AttributeValue & value) const [member function]
-    cls.add_method('GetAttribute', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::AttributeValue &', 'value')], 
-                   is_const=True)
-    ## object-base.h (module 'core'): bool ns3::ObjectBase::GetAttributeFailSafe(std::string name, ns3::AttributeValue & value) const [member function]
-    cls.add_method('GetAttributeFailSafe', 
-                   'bool', 
-                   [param('std::string', 'name'), param('ns3::AttributeValue &', 'value')], 
-                   is_const=True)
-    ## object-base.h (module 'core'): ns3::TypeId ns3::ObjectBase::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## object-base.h (module 'core'): static ns3::TypeId ns3::ObjectBase::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## object-base.h (module 'core'): void ns3::ObjectBase::SetAttribute(std::string name, ns3::AttributeValue const & value) [member function]
-    cls.add_method('SetAttribute', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
-    ## object-base.h (module 'core'): bool ns3::ObjectBase::SetAttributeFailSafe(std::string name, ns3::AttributeValue const & value) [member function]
-    cls.add_method('SetAttributeFailSafe', 
-                   'bool', 
-                   [param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
-    ## object-base.h (module 'core'): bool ns3::ObjectBase::TraceConnect(std::string name, std::string context, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('TraceConnect', 
-                   'bool', 
-                   [param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])
-    ## object-base.h (module 'core'): bool ns3::ObjectBase::TraceConnectWithoutContext(std::string name, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('TraceConnectWithoutContext', 
-                   'bool', 
-                   [param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
-    ## object-base.h (module 'core'): bool ns3::ObjectBase::TraceDisconnect(std::string name, std::string context, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('TraceDisconnect', 
-                   'bool', 
-                   [param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])
-    ## object-base.h (module 'core'): bool ns3::ObjectBase::TraceDisconnectWithoutContext(std::string name, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('TraceDisconnectWithoutContext', 
-                   'bool', 
-                   [param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
-    ## object-base.h (module 'core'): void ns3::ObjectBase::ConstructSelf(ns3::AttributeConstructionList const & attributes) [member function]
-    cls.add_method('ConstructSelf', 
-                   'void', 
-                   [param('ns3::AttributeConstructionList const &', 'attributes')], 
-                   visibility='protected')
-    ## object-base.h (module 'core'): void ns3::ObjectBase::NotifyConstructionCompleted() [member function]
-    cls.add_method('NotifyConstructionCompleted', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ObjectDeleter_methods(root_module, cls):
-    ## object.h (module 'core'): ns3::ObjectDeleter::ObjectDeleter() [constructor]
-    cls.add_constructor([])
-    ## object.h (module 'core'): ns3::ObjectDeleter::ObjectDeleter(ns3::ObjectDeleter const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ObjectDeleter const &', 'arg0')])
-    ## object.h (module 'core'): static void ns3::ObjectDeleter::Delete(ns3::Object * object) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('ns3::Object *', 'object')], 
-                   is_static=True)
-    return
-
-def register_Ns3ObjectFactory_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## object-factory.h (module 'core'): ns3::ObjectFactory::ObjectFactory(ns3::ObjectFactory const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ObjectFactory const &', 'arg0')])
-    ## object-factory.h (module 'core'): ns3::ObjectFactory::ObjectFactory() [constructor]
-    cls.add_constructor([])
-    ## object-factory.h (module 'core'): ns3::ObjectFactory::ObjectFactory(std::string typeId) [constructor]
-    cls.add_constructor([param('std::string', 'typeId')])
-    ## object-factory.h (module 'core'): ns3::Ptr<ns3::Object> ns3::ObjectFactory::Create() const [member function]
-    cls.add_method('Create', 
-                   'ns3::Ptr< ns3::Object >', 
-                   [], 
-                   is_const=True)
-    ## object-factory.h (module 'core'): ns3::TypeId ns3::ObjectFactory::GetTypeId() const [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True)
-    ## object-factory.h (module 'core'): void ns3::ObjectFactory::Set(std::string name, ns3::AttributeValue const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
-    ## object-factory.h (module 'core'): void ns3::ObjectFactory::SetTypeId(ns3::TypeId tid) [member function]
-    cls.add_method('SetTypeId', 
-                   'void', 
-                   [param('ns3::TypeId', 'tid')])
-    ## object-factory.h (module 'core'): void ns3::ObjectFactory::SetTypeId(char const * tid) [member function]
-    cls.add_method('SetTypeId', 
-                   'void', 
-                   [param('char const *', 'tid')])
-    ## object-factory.h (module 'core'): void ns3::ObjectFactory::SetTypeId(std::string tid) [member function]
-    cls.add_method('SetTypeId', 
-                   'void', 
-                   [param('std::string', 'tid')])
-    return
-
-def register_Ns3PacketMetadata_methods(root_module, cls):
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::PacketMetadata(uint64_t uid, uint32_t size) [constructor]
-    cls.add_constructor([param('uint64_t', 'uid'), param('uint32_t', 'size')])
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::PacketMetadata(ns3::PacketMetadata const & o) [constructor]
-    cls.add_constructor([param('ns3::PacketMetadata const &', 'o')])
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::AddAtEnd(ns3::PacketMetadata const & o) [member function]
-    cls.add_method('AddAtEnd', 
-                   'void', 
-                   [param('ns3::PacketMetadata const &', 'o')])
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::AddHeader(ns3::Header const & header, uint32_t size) [member function]
-    cls.add_method('AddHeader', 
-                   'void', 
-                   [param('ns3::Header const &', 'header'), param('uint32_t', 'size')])
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::AddPaddingAtEnd(uint32_t end) [member function]
-    cls.add_method('AddPaddingAtEnd', 
-                   'void', 
-                   [param('uint32_t', 'end')])
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::AddTrailer(ns3::Trailer const & trailer, uint32_t size) [member function]
-    cls.add_method('AddTrailer', 
-                   'void', 
-                   [param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::ItemIterator ns3::PacketMetadata::BeginItem(ns3::Buffer buffer) const [member function]
-    cls.add_method('BeginItem', 
-                   'ns3::PacketMetadata::ItemIterator', 
-                   [param('ns3::Buffer', 'buffer')], 
-                   is_const=True)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata ns3::PacketMetadata::CreateFragment(uint32_t start, uint32_t end) const [member function]
-    cls.add_method('CreateFragment', 
-                   'ns3::PacketMetadata', 
-                   [param('uint32_t', 'start'), param('uint32_t', 'end')], 
-                   is_const=True)
-    ## packet-metadata.h (module 'network'): uint32_t ns3::PacketMetadata::Deserialize(uint8_t const * buffer, uint32_t size) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
-    ## packet-metadata.h (module 'network'): static void ns3::PacketMetadata::Enable() [member function]
-    cls.add_method('Enable', 
-                   'void', 
-                   [], 
-                   is_static=True)
-    ## packet-metadata.h (module 'network'): static void ns3::PacketMetadata::EnableChecking() [member function]
-    cls.add_method('EnableChecking', 
-                   'void', 
-                   [], 
-                   is_static=True)
-    ## packet-metadata.h (module 'network'): uint32_t ns3::PacketMetadata::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## packet-metadata.h (module 'network'): uint64_t ns3::PacketMetadata::GetUid() const [member function]
-    cls.add_method('GetUid', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::RemoveAtEnd(uint32_t end) [member function]
-    cls.add_method('RemoveAtEnd', 
-                   'void', 
-                   [param('uint32_t', 'end')])
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::RemoveAtStart(uint32_t start) [member function]
-    cls.add_method('RemoveAtStart', 
-                   'void', 
-                   [param('uint32_t', 'start')])
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::RemoveHeader(ns3::Header const & header, uint32_t size) [member function]
-    cls.add_method('RemoveHeader', 
-                   'void', 
-                   [param('ns3::Header const &', 'header'), param('uint32_t', 'size')])
-    ## packet-metadata.h (module 'network'): void ns3::PacketMetadata::RemoveTrailer(ns3::Trailer const & trailer, uint32_t size) [member function]
-    cls.add_method('RemoveTrailer', 
-                   'void', 
-                   [param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])
-    ## packet-metadata.h (module 'network'): uint32_t ns3::PacketMetadata::Serialize(uint8_t * buffer, uint32_t maxSize) const [member function]
-    cls.add_method('Serialize', 
-                   'uint32_t', 
-                   [param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')], 
-                   is_const=True)
-    return
-
-def register_Ns3PacketMetadataItem_methods(root_module, cls):
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::Item() [constructor]
-    cls.add_constructor([])
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::Item(ns3::PacketMetadata::Item const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PacketMetadata::Item const &', 'arg0')])
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::current [variable]
-    cls.add_instance_attribute('current', 'ns3::Buffer::Iterator', is_const=False)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::currentSize [variable]
-    cls.add_instance_attribute('currentSize', 'uint32_t', is_const=False)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::currentTrimedFromEnd [variable]
-    cls.add_instance_attribute('currentTrimedFromEnd', 'uint32_t', is_const=False)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::currentTrimedFromStart [variable]
-    cls.add_instance_attribute('currentTrimedFromStart', 'uint32_t', is_const=False)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::isFragment [variable]
-    cls.add_instance_attribute('isFragment', 'bool', is_const=False)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::tid [variable]
-    cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item::type [variable]
-    cls.add_instance_attribute('type', 'ns3::PacketMetadata::Item::ItemType', is_const=False)
-    return
-
-def register_Ns3PacketMetadataItemIterator_methods(root_module, cls):
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::ItemIterator::ItemIterator(ns3::PacketMetadata::ItemIterator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PacketMetadata::ItemIterator const &', 'arg0')])
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::ItemIterator::ItemIterator(ns3::PacketMetadata const * metadata, ns3::Buffer buffer) [constructor]
-    cls.add_constructor([param('ns3::PacketMetadata const *', 'metadata'), param('ns3::Buffer', 'buffer')])
-    ## packet-metadata.h (module 'network'): bool ns3::PacketMetadata::ItemIterator::HasNext() const [member function]
-    cls.add_method('HasNext', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## packet-metadata.h (module 'network'): ns3::PacketMetadata::Item ns3::PacketMetadata::ItemIterator::Next() [member function]
-    cls.add_method('Next', 
-                   'ns3::PacketMetadata::Item', 
-                   [])
-    return
-
-def register_Ns3PacketTagIterator_methods(root_module, cls):
-    ## packet.h (module 'network'): ns3::PacketTagIterator::PacketTagIterator(ns3::PacketTagIterator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PacketTagIterator const &', 'arg0')])
-    ## packet.h (module 'network'): bool ns3::PacketTagIterator::HasNext() const [member function]
-    cls.add_method('HasNext', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::PacketTagIterator::Item ns3::PacketTagIterator::Next() [member function]
-    cls.add_method('Next', 
-                   'ns3::PacketTagIterator::Item', 
-                   [])
-    return
-
-def register_Ns3PacketTagIteratorItem_methods(root_module, cls):
-    ## packet.h (module 'network'): ns3::PacketTagIterator::Item::Item(ns3::PacketTagIterator::Item const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PacketTagIterator::Item const &', 'arg0')])
-    ## packet.h (module 'network'): void ns3::PacketTagIterator::Item::GetTag(ns3::Tag & tag) const [member function]
-    cls.add_method('GetTag', 
-                   'void', 
-                   [param('ns3::Tag &', 'tag')], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::TypeId ns3::PacketTagIterator::Item::GetTypeId() const [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True)
-    return
-
-def register_Ns3PacketTagList_methods(root_module, cls):
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::PacketTagList() [constructor]
-    cls.add_constructor([])
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::PacketTagList(ns3::PacketTagList const & o) [constructor]
-    cls.add_constructor([param('ns3::PacketTagList const &', 'o')])
-    ## packet-tag-list.h (module 'network'): void ns3::PacketTagList::Add(ns3::Tag const & tag) const [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::Tag const &', 'tag')], 
-                   is_const=True)
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData const * ns3::PacketTagList::Head() const [member function]
-    cls.add_method('Head', 
-                   'ns3::PacketTagList::TagData const *', 
-                   [], 
-                   is_const=True)
-    ## packet-tag-list.h (module 'network'): bool ns3::PacketTagList::Peek(ns3::Tag & tag) const [member function]
-    cls.add_method('Peek', 
-                   'bool', 
-                   [param('ns3::Tag &', 'tag')], 
-                   is_const=True)
-    ## packet-tag-list.h (module 'network'): bool ns3::PacketTagList::Remove(ns3::Tag & tag) [member function]
-    cls.add_method('Remove', 
-                   'bool', 
-                   [param('ns3::Tag &', 'tag')])
-    ## packet-tag-list.h (module 'network'): void ns3::PacketTagList::RemoveAll() [member function]
-    cls.add_method('RemoveAll', 
-                   'void', 
-                   [])
-    ## packet-tag-list.h (module 'network'): bool ns3::PacketTagList::Replace(ns3::Tag & tag) [member function]
-    cls.add_method('Replace', 
-                   'bool', 
-                   [param('ns3::Tag &', 'tag')])
-    return
-
-def register_Ns3PacketTagListTagData_methods(root_module, cls):
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData::TagData() [constructor]
-    cls.add_constructor([])
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData::TagData(ns3::PacketTagList::TagData const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PacketTagList::TagData const &', 'arg0')])
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData::count [variable]
-    cls.add_instance_attribute('count', 'uint32_t', is_const=False)
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData::data [variable]
-    cls.add_instance_attribute('data', 'uint8_t [ 1 ]', is_const=False)
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData::next [variable]
-    cls.add_instance_attribute('next', 'ns3::PacketTagList::TagData *', is_const=False)
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData::size [variable]
-    cls.add_instance_attribute('size', 'uint32_t', is_const=False)
-    ## packet-tag-list.h (module 'network'): ns3::PacketTagList::TagData::tid [variable]
-    cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
-    return
-
-def register_Ns3PagingInfoListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::PagingInfoListElement_s::PagingInfoListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::PagingInfoListElement_s::PagingInfoListElement_s(ns3::PagingInfoListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PagingInfoListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::PagingInfoListElement_s::m_pagingIndex [variable]
-    cls.add_instance_attribute('m_pagingIndex', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::PagingInfoListElement_s::m_pagingMessageSize [variable]
-    cls.add_instance_attribute('m_pagingMessageSize', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::PagingInfoListElement_s::m_pagingSubframe [variable]
-    cls.add_instance_attribute('m_pagingSubframe', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3ParameterLogger_methods(root_module, cls):
-    ## log.h (module 'core'): ns3::ParameterLogger::ParameterLogger(ns3::ParameterLogger const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ParameterLogger const &', 'arg0')])
-    ## log.h (module 'core'): ns3::ParameterLogger::ParameterLogger(std::ostream & os) [constructor]
-    cls.add_constructor([param('std::ostream &', 'os')])
-    return
-
-def register_Ns3PhichListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::PhichListElement_s::PhichListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::PhichListElement_s::PhichListElement_s(ns3::PhichListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PhichListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::PhichListElement_s::m_phich [variable]
-    cls.add_instance_attribute('m_phich', 'ns3::PhichListElement_s::Phich_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::PhichListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3PhyReceptionStatParameters_methods(root_module, cls):
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::PhyReceptionStatParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::PhyReceptionStatParameters(ns3::PhyReceptionStatParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PhyReceptionStatParameters const &', 'arg0')])
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_ccId [variable]
-    cls.add_instance_attribute('m_ccId', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_cellId [variable]
-    cls.add_instance_attribute('m_cellId', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_correctness [variable]
-    cls.add_instance_attribute('m_correctness', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_imsi [variable]
-    cls.add_instance_attribute('m_imsi', 'uint64_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_layer [variable]
-    cls.add_instance_attribute('m_layer', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_mcs [variable]
-    cls.add_instance_attribute('m_mcs', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_ndi [variable]
-    cls.add_instance_attribute('m_ndi', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_rv [variable]
-    cls.add_instance_attribute('m_rv', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_size [variable]
-    cls.add_instance_attribute('m_size', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_timestamp [variable]
-    cls.add_instance_attribute('m_timestamp', 'int64_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyReceptionStatParameters::m_txMode [variable]
-    cls.add_instance_attribute('m_txMode', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3PhyTransmissionStatParameters_methods(root_module, cls):
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::PhyTransmissionStatParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::PhyTransmissionStatParameters(ns3::PhyTransmissionStatParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PhyTransmissionStatParameters const &', 'arg0')])
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_ccId [variable]
-    cls.add_instance_attribute('m_ccId', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_cellId [variable]
-    cls.add_instance_attribute('m_cellId', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_imsi [variable]
-    cls.add_instance_attribute('m_imsi', 'uint64_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_layer [variable]
-    cls.add_instance_attribute('m_layer', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_mcs [variable]
-    cls.add_instance_attribute('m_mcs', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_ndi [variable]
-    cls.add_instance_attribute('m_ndi', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_rv [variable]
-    cls.add_instance_attribute('m_rv', 'uint8_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_size [variable]
-    cls.add_instance_attribute('m_size', 'uint16_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_timestamp [variable]
-    cls.add_instance_attribute('m_timestamp', 'int64_t', is_const=False)
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_txMode [variable]
-    cls.add_instance_attribute('m_txMode', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3RachListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::RachListElement_s::RachListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::RachListElement_s::RachListElement_s(ns3::RachListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RachListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::RachListElement_s::m_estimatedSize [variable]
-    cls.add_instance_attribute('m_estimatedSize', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::RachListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3RadioBearerStatsConnector_methods(root_module, cls):
-    ## radio-bearer-stats-connector.h (module 'lte'): ns3::RadioBearerStatsConnector::RadioBearerStatsConnector(ns3::RadioBearerStatsConnector const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RadioBearerStatsConnector const &', 'arg0')])
-    ## radio-bearer-stats-connector.h (module 'lte'): ns3::RadioBearerStatsConnector::RadioBearerStatsConnector() [constructor]
-    cls.add_constructor([])
-    ## radio-bearer-stats-connector.h (module 'lte'): void ns3::RadioBearerStatsConnector::EnablePdcpStats(ns3::Ptr<ns3::RadioBearerStatsCalculator> pdcpStats) [member function]
-    cls.add_method('EnablePdcpStats', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::RadioBearerStatsCalculator >', 'pdcpStats')])
-    ## radio-bearer-stats-connector.h (module 'lte'): void ns3::RadioBearerStatsConnector::EnableRlcStats(ns3::Ptr<ns3::RadioBearerStatsCalculator> rlcStats) [member function]
-    cls.add_method('EnableRlcStats', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::RadioBearerStatsCalculator >', 'rlcStats')])
-    ## radio-bearer-stats-connector.h (module 'lte'): void ns3::RadioBearerStatsConnector::EnsureConnected() [member function]
-    cls.add_method('EnsureConnected', 
-                   'void', 
-                   [])
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyConnectionReconfigurationEnb(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti) [member function]
-    cls.add_method('NotifyConnectionReconfigurationEnb', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyConnectionReconfigurationUe(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti) [member function]
-    cls.add_method('NotifyConnectionReconfigurationUe', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyConnectionSetupUe(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti) [member function]
-    cls.add_method('NotifyConnectionSetupUe', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyHandoverEndOkEnb(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti) [member function]
-    cls.add_method('NotifyHandoverEndOkEnb', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyHandoverEndOkUe(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti) [member function]
-    cls.add_method('NotifyHandoverEndOkUe', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyHandoverStartEnb(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti, uint16_t targetCellId) [member function]
-    cls.add_method('NotifyHandoverStartEnb', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti'), param('uint16_t', 'targetCellId')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyHandoverStartUe(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti, uint16_t targetCellId) [member function]
-    cls.add_method('NotifyHandoverStartUe', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti'), param('uint16_t', 'targetCellId')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyNewUeContextEnb(ns3::RadioBearerStatsConnector * c, std::string context, uint16_t cellid, uint16_t rnti) [member function]
-    cls.add_method('NotifyNewUeContextEnb', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti')], 
-                   is_static=True)
-    ## radio-bearer-stats-connector.h (module 'lte'): static void ns3::RadioBearerStatsConnector::NotifyRandomAccessSuccessfulUe(ns3::RadioBearerStatsConnector * c, std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti) [member function]
-    cls.add_method('NotifyRandomAccessSuccessfulUe', 
-                   'void', 
-                   [param('ns3::RadioBearerStatsConnector *', 'c'), param('std::string', 'context'), param('uint64_t', 'imsi'), param('uint16_t', 'cellid'), param('uint16_t', 'rnti')], 
-                   is_static=True)
-    return
-
-def register_Ns3RealProtocolRlcSapUser_methods(root_module, cls):
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::RealProtocolRlcSapUser::RealProtocolRlcSapUser(ns3::RealProtocolRlcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RealProtocolRlcSapUser const &', 'arg0')])
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::RealProtocolRlcSapUser::RealProtocolRlcSapUser(ns3::LteEnbRrcProtocolReal * pdcp, uint16_t rnti) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrcProtocolReal *', 'pdcp'), param('uint16_t', 'rnti')])
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::RealProtocolRlcSapUser::ReceivePdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('ReceivePdcpPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_virtual=True)
-    return
-
-def register_Ns3RlcPduListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::RlcPduListElement_s::RlcPduListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::RlcPduListElement_s::RlcPduListElement_s(ns3::RlcPduListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RlcPduListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::RlcPduListElement_s::m_logicalChannelIdentity [variable]
-    cls.add_instance_attribute('m_logicalChannelIdentity', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::RlcPduListElement_s::m_size [variable]
-    cls.add_instance_attribute('m_size', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3SbMeasResult_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::SbMeasResult_s::SbMeasResult_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::SbMeasResult_s::SbMeasResult_s(ns3::SbMeasResult_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SbMeasResult_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::SbMeasResult_s::m_bwPart [variable]
-    cls.add_instance_attribute('m_bwPart', 'ns3::BwPart_s', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SbMeasResult_s::m_higherLayerSelected [variable]
-    cls.add_instance_attribute('m_higherLayerSelected', 'std::vector< ns3::HigherLayerSelected_s >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SbMeasResult_s::m_ueSelected [variable]
-    cls.add_instance_attribute('m_ueSelected', 'ns3::UeSelected_s', is_const=False)
-    return
-
-def register_Ns3SequenceNumber10_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_numeric_operator('+', root_module['ns3::SequenceNumber10'], root_module['ns3::SequenceNumber10'], param('uint16_t', u'right'))
-    cls.add_binary_numeric_operator('-', root_module['ns3::SequenceNumber10'], root_module['ns3::SequenceNumber10'], param('uint16_t', u'right'))
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('<=')
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('>')
-    cls.add_binary_comparison_operator('>=')
-    ## lte-rlc-sequence-number.h (module 'lte'): ns3::SequenceNumber10::SequenceNumber10() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-sequence-number.h (module 'lte'): ns3::SequenceNumber10::SequenceNumber10(uint16_t value) [constructor]
-    cls.add_constructor([param('uint16_t', 'value')])
-    ## lte-rlc-sequence-number.h (module 'lte'): ns3::SequenceNumber10::SequenceNumber10(ns3::SequenceNumber10 const & value) [constructor]
-    cls.add_constructor([param('ns3::SequenceNumber10 const &', 'value')])
-    ## lte-rlc-sequence-number.h (module 'lte'): uint16_t ns3::SequenceNumber10::GetValue() const [member function]
-    cls.add_method('GetValue', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-sequence-number.h (module 'lte'): void ns3::SequenceNumber10::SetModulusBase(ns3::SequenceNumber10 modulusBase) [member function]
-    cls.add_method('SetModulusBase', 
-                   'void', 
-                   [param('ns3::SequenceNumber10', 'modulusBase')])
-    ## lte-rlc-sequence-number.h (module 'lte'): void ns3::SequenceNumber10::SetModulusBase(uint16_t modulusBase) [member function]
-    cls.add_method('SetModulusBase', 
-                   'void', 
-                   [param('uint16_t', 'modulusBase')])
-    return
-
-def register_Ns3SiConfiguration_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::SiConfiguration_s::SiConfiguration_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::SiConfiguration_s::SiConfiguration_s(ns3::SiConfiguration_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SiConfiguration_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::SiConfiguration_s::m_sfn [variable]
-    cls.add_instance_attribute('m_sfn', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SiConfiguration_s::m_siMessageList [variable]
-    cls.add_instance_attribute('m_siMessageList', 'std::vector< ns3::SiMessageListElement_s >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SiConfiguration_s::m_siWindowLength [variable]
-    cls.add_instance_attribute('m_siWindowLength', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SiConfiguration_s::m_sib1Length [variable]
-    cls.add_instance_attribute('m_sib1Length', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3SiMessageListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::SiMessageListElement_s::SiMessageListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::SiMessageListElement_s::SiMessageListElement_s(ns3::SiMessageListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SiMessageListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::SiMessageListElement_s::m_length [variable]
-    cls.add_instance_attribute('m_length', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SiMessageListElement_s::m_periodicity [variable]
-    cls.add_instance_attribute('m_periodicity', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter>::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter>::SimpleRefCount(ns3::SimpleRefCount<ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter> const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter > const &', 'o')])
-    return
-
-def register_Ns3Simulator_methods(root_module, cls):
-    ## simulator.h (module 'core'): ns3::Simulator::Simulator(ns3::Simulator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Simulator const &', 'arg0')])
-    ## simulator.h (module 'core'): static void ns3::Simulator::Cancel(ns3::EventId const & id) [member function]
-    cls.add_method('Cancel', 
-                   'void', 
-                   [param('ns3::EventId const &', 'id')], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static void ns3::Simulator::Destroy() [member function]
-    cls.add_method('Destroy', 
-                   'void', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static uint32_t ns3::Simulator::GetContext() [member function]
-    cls.add_method('GetContext', 
-                   'uint32_t', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static ns3::Time ns3::Simulator::GetDelayLeft(ns3::EventId const & id) [member function]
-    cls.add_method('GetDelayLeft', 
-                   'ns3::Time', 
-                   [param('ns3::EventId const &', 'id')], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static ns3::Ptr<ns3::SimulatorImpl> ns3::Simulator::GetImplementation() [member function]
-    cls.add_method('GetImplementation', 
-                   'ns3::Ptr< ns3::SimulatorImpl >', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static ns3::Time ns3::Simulator::GetMaximumSimulationTime() [member function]
-    cls.add_method('GetMaximumSimulationTime', 
-                   'ns3::Time', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static uint32_t ns3::Simulator::GetSystemId() [member function]
-    cls.add_method('GetSystemId', 
-                   'uint32_t', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static bool ns3::Simulator::IsExpired(ns3::EventId const & id) [member function]
-    cls.add_method('IsExpired', 
-                   'bool', 
-                   [param('ns3::EventId const &', 'id')], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static bool ns3::Simulator::IsFinished() [member function]
-    cls.add_method('IsFinished', 
-                   'bool', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static ns3::Time ns3::Simulator::Now() [member function]
-    cls.add_method('Now', 
-                   'ns3::Time', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static void ns3::Simulator::Remove(ns3::EventId const & id) [member function]
-    cls.add_method('Remove', 
-                   'void', 
-                   [param('ns3::EventId const &', 'id')], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static void ns3::Simulator::SetImplementation(ns3::Ptr<ns3::SimulatorImpl> impl) [member function]
-    cls.add_method('SetImplementation', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SimulatorImpl >', 'impl')], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static void ns3::Simulator::SetScheduler(ns3::ObjectFactory schedulerFactory) [member function]
-    cls.add_method('SetScheduler', 
-                   'void', 
-                   [param('ns3::ObjectFactory', 'schedulerFactory')], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static void ns3::Simulator::Stop() [member function]
-    cls.add_method('Stop', 
-                   'void', 
-                   [], 
-                   is_static=True)
-    ## simulator.h (module 'core'): static void ns3::Simulator::Stop(ns3::Time const & delay) [member function]
-    cls.add_method('Stop', 
-                   'void', 
-                   [param('ns3::Time const &', 'delay')], 
-                   is_static=True)
-    return
-
-def register_Ns3SpsConfig_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::SpsConfig_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::SpsConfig_s(ns3::SpsConfig_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SpsConfig_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::m_implicitReleaseAfter [variable]
-    cls.add_instance_attribute('m_implicitReleaseAfter', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::m_n1PucchAnPersistentList [variable]
-    cls.add_instance_attribute('m_n1PucchAnPersistentList', 'std::vector< unsigned short >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::m_n1PucchAnPersistentListSize [variable]
-    cls.add_instance_attribute('m_n1PucchAnPersistentListSize', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::m_numberOfConfSpsProcesses [variable]
-    cls.add_instance_attribute('m_numberOfConfSpsProcesses', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::m_semiPersistSchedIntervalDl [variable]
-    cls.add_instance_attribute('m_semiPersistSchedIntervalDl', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SpsConfig_s::m_semiPersistSchedIntervalUl [variable]
-    cls.add_instance_attribute('m_semiPersistSchedIntervalUl', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3SrConfig_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::SrConfig_s::SrConfig_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::SrConfig_s::SrConfig_s(ns3::SrConfig_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SrConfig_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::SrConfig_s::m_action [variable]
-    cls.add_instance_attribute('m_action', 'ns3::SetupRelease_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SrConfig_s::m_dsrTransMax [variable]
-    cls.add_instance_attribute('m_dsrTransMax', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::SrConfig_s::m_schedInterval [variable]
-    cls.add_instance_attribute('m_schedInterval', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3SrListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::SrListElement_s::SrListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::SrListElement_s::SrListElement_s(ns3::SrListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SrListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::SrListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3StatisticalSummary_methods(root_module, cls):
-    ## data-calculator.h (module 'stats'): ns3::StatisticalSummary::StatisticalSummary() [constructor]
-    cls.add_constructor([])
-    ## data-calculator.h (module 'stats'): ns3::StatisticalSummary::StatisticalSummary(ns3::StatisticalSummary const & arg0) [constructor]
-    cls.add_constructor([param('ns3::StatisticalSummary const &', 'arg0')])
-    ## data-calculator.h (module 'stats'): long int ns3::StatisticalSummary::getCount() const [member function]
-    cls.add_method('getCount', 
-                   'long int', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): double ns3::StatisticalSummary::getMax() const [member function]
-    cls.add_method('getMax', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): double ns3::StatisticalSummary::getMean() const [member function]
-    cls.add_method('getMean', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): double ns3::StatisticalSummary::getMin() const [member function]
-    cls.add_method('getMin', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): double ns3::StatisticalSummary::getSqrSum() const [member function]
-    cls.add_method('getSqrSum', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): double ns3::StatisticalSummary::getStddev() const [member function]
-    cls.add_method('getStddev', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): double ns3::StatisticalSummary::getSum() const [member function]
-    cls.add_method('getSum', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): double ns3::StatisticalSummary::getVariance() const [member function]
-    cls.add_method('getVariance', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3Tag_methods(root_module, cls):
-    ## tag.h (module 'network'): ns3::Tag::Tag() [constructor]
-    cls.add_constructor([])
-    ## tag.h (module 'network'): ns3::Tag::Tag(ns3::Tag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Tag const &', 'arg0')])
-    ## tag.h (module 'network'): void ns3::Tag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## tag.h (module 'network'): uint32_t ns3::Tag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## tag.h (module 'network'): static ns3::TypeId ns3::Tag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## tag.h (module 'network'): void ns3::Tag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## tag.h (module 'network'): void ns3::Tag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3TagBuffer_methods(root_module, cls):
-    ## tag-buffer.h (module 'network'): ns3::TagBuffer::TagBuffer(ns3::TagBuffer const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TagBuffer const &', 'arg0')])
-    ## tag-buffer.h (module 'network'): ns3::TagBuffer::TagBuffer(uint8_t * start, uint8_t * end) [constructor]
-    cls.add_constructor([param('uint8_t *', 'start'), param('uint8_t *', 'end')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::CopyFrom(ns3::TagBuffer o) [member function]
-    cls.add_method('CopyFrom', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'o')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::Read(uint8_t * buffer, uint32_t size) [member function]
-    cls.add_method('Read', 
-                   'void', 
-                   [param('uint8_t *', 'buffer'), param('uint32_t', 'size')])
-    ## tag-buffer.h (module 'network'): double ns3::TagBuffer::ReadDouble() [member function]
-    cls.add_method('ReadDouble', 
-                   'double', 
-                   [])
-    ## tag-buffer.h (module 'network'): uint16_t ns3::TagBuffer::ReadU16() [member function]
-    cls.add_method('ReadU16', 
-                   'uint16_t', 
-                   [])
-    ## tag-buffer.h (module 'network'): uint32_t ns3::TagBuffer::ReadU32() [member function]
-    cls.add_method('ReadU32', 
-                   'uint32_t', 
-                   [])
-    ## tag-buffer.h (module 'network'): uint64_t ns3::TagBuffer::ReadU64() [member function]
-    cls.add_method('ReadU64', 
-                   'uint64_t', 
-                   [])
-    ## tag-buffer.h (module 'network'): uint8_t ns3::TagBuffer::ReadU8() [member function]
-    cls.add_method('ReadU8', 
-                   'uint8_t', 
-                   [])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::TrimAtEnd(uint32_t trim) [member function]
-    cls.add_method('TrimAtEnd', 
-                   'void', 
-                   [param('uint32_t', 'trim')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::Write(uint8_t const * buffer, uint32_t size) [member function]
-    cls.add_method('Write', 
-                   'void', 
-                   [param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::WriteDouble(double v) [member function]
-    cls.add_method('WriteDouble', 
-                   'void', 
-                   [param('double', 'v')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::WriteU16(uint16_t v) [member function]
-    cls.add_method('WriteU16', 
-                   'void', 
-                   [param('uint16_t', 'v')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::WriteU32(uint32_t v) [member function]
-    cls.add_method('WriteU32', 
-                   'void', 
-                   [param('uint32_t', 'v')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::WriteU64(uint64_t v) [member function]
-    cls.add_method('WriteU64', 
-                   'void', 
-                   [param('uint64_t', 'v')])
-    ## tag-buffer.h (module 'network'): void ns3::TagBuffer::WriteU8(uint8_t v) [member function]
-    cls.add_method('WriteU8', 
-                   'void', 
-                   [param('uint8_t', 'v')])
-    return
-
-def register_Ns3TbId_t_methods(root_module, cls):
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('==')
-    ## lte-spectrum-phy.h (module 'lte'): ns3::TbId_t::TbId_t(ns3::TbId_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TbId_t const &', 'arg0')])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::TbId_t::TbId_t() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::TbId_t::TbId_t(uint16_t const a, uint8_t const b) [constructor]
-    cls.add_constructor([param('uint16_t const', 'a'), param('uint8_t const', 'b')])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::TbId_t::m_layer [variable]
-    cls.add_instance_attribute('m_layer', 'uint8_t', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::TbId_t::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3TbStats_t_methods(root_module, cls):
-    ## lte-mi-error-model.h (module 'lte'): ns3::TbStats_t::TbStats_t() [constructor]
-    cls.add_constructor([])
-    ## lte-mi-error-model.h (module 'lte'): ns3::TbStats_t::TbStats_t(ns3::TbStats_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TbStats_t const &', 'arg0')])
-    ## lte-mi-error-model.h (module 'lte'): ns3::TbStats_t::mi [variable]
-    cls.add_instance_attribute('mi', 'double', is_const=False)
-    ## lte-mi-error-model.h (module 'lte'): ns3::TbStats_t::tbler [variable]
-    cls.add_instance_attribute('tbler', 'double', is_const=False)
-    return
-
-def register_Ns3TimeWithUnit_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## nstime.h (module 'core'): ns3::TimeWithUnit::TimeWithUnit(ns3::TimeWithUnit const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TimeWithUnit const &', 'arg0')])
-    ## nstime.h (module 'core'): ns3::TimeWithUnit::TimeWithUnit(ns3::Time const time, ns3::Time::Unit const unit) [constructor]
-    cls.add_constructor([param('ns3::Time const', 'time'), param('ns3::Time::Unit const', 'unit')])
-    return
-
-def register_Ns3TransmissionModesLayers_methods(root_module, cls):
-    ## lte-common.h (module 'lte'): ns3::TransmissionModesLayers::TransmissionModesLayers() [constructor]
-    cls.add_constructor([])
-    ## lte-common.h (module 'lte'): ns3::TransmissionModesLayers::TransmissionModesLayers(ns3::TransmissionModesLayers const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TransmissionModesLayers const &', 'arg0')])
-    ## lte-common.h (module 'lte'): static uint8_t ns3::TransmissionModesLayers::TxMode2LayerNum(uint8_t txMode) [member function]
-    cls.add_method('TxMode2LayerNum', 
-                   'uint8_t', 
-                   [param('uint8_t', 'txMode')], 
-                   is_static=True)
-    return
-
-def register_Ns3TypeId_methods(root_module, cls):
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('<')
-    ## type-id.h (module 'core'): ns3::TypeId::TypeId(char const * name) [constructor]
-    cls.add_constructor([param('char const *', 'name')])
-    ## type-id.h (module 'core'): ns3::TypeId::TypeId() [constructor]
-    cls.add_constructor([])
-    ## type-id.h (module 'core'): ns3::TypeId::TypeId(ns3::TypeId const & o) [constructor]
-    cls.add_constructor([param('ns3::TypeId const &', 'o')])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddAttribute(std::string name, std::string help, ns3::AttributeValue const & initialValue, ns3::Ptr<const ns3::AttributeAccessor> accessor, ns3::Ptr<const ns3::AttributeChecker> checker, ns3::TypeId::SupportLevel supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, std::string const & supportMsg="") [member function]
-    cls.add_method('AddAttribute', 
-                   'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddAttribute(std::string name, std::string help, uint32_t flags, ns3::AttributeValue const & initialValue, ns3::Ptr<const ns3::AttributeAccessor> accessor, ns3::Ptr<const ns3::AttributeChecker> checker, ns3::TypeId::SupportLevel supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, std::string const & supportMsg="") [member function]
-    cls.add_method('AddAttribute', 
-                   'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('uint32_t', 'flags'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor) [member function]
-    cls.add_method('AddTraceSource', 
-                   'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::AddTraceSource(std::string name, std::string help, ns3::Ptr<const ns3::TraceSourceAccessor> accessor, std::string callback, ns3::TypeId::SupportLevel supportLevel=::ns3::TypeId::SupportLevel::SUPPORTED, std::string const & supportMsg="") [member function]
-    cls.add_method('AddTraceSource', 
-                   'ns3::TypeId', 
-                   [param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor'), param('std::string', 'callback'), param('ns3::TypeId::SupportLevel', 'supportLevel', default_value='::ns3::TypeId::SupportLevel::SUPPORTED'), param('std::string const &', 'supportMsg', default_value='""')])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation ns3::TypeId::GetAttribute(uint32_t i) const [member function]
-    cls.add_method('GetAttribute', 
-                   'ns3::TypeId::AttributeInformation', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetAttributeFullName(uint32_t i) const [member function]
-    cls.add_method('GetAttributeFullName', 
-                   'std::string', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetAttributeN() const [member function]
-    cls.add_method('GetAttributeN', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): ns3::Callback<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> ns3::TypeId::GetConstructor() const [member function]
-    cls.add_method('GetConstructor', 
-                   'ns3::Callback< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetGroupName() const [member function]
-    cls.add_method('GetGroupName', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId::hash_t ns3::TypeId::GetHash() const [member function]
-    cls.add_method('GetHash', 
-                   'ns3::TypeId::hash_t', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeId::GetName() const [member function]
-    cls.add_method('GetName', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::GetParent() const [member function]
-    cls.add_method('GetParent', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::GetRegistered(uint32_t i) [member function]
-    cls.add_method('GetRegistered', 
-                   'ns3::TypeId', 
-                   [param('uint32_t', 'i')], 
-                   is_static=True)
-    ## type-id.h (module 'core'): static uint32_t ns3::TypeId::GetRegisteredN() [member function]
-    cls.add_method('GetRegisteredN', 
-                   'uint32_t', 
-                   [], 
-                   is_static=True)
-    ## type-id.h (module 'core'): std::size_t ns3::TypeId::GetSize() const [member function]
-    cls.add_method('GetSize', 
-                   'std::size_t', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation ns3::TypeId::GetTraceSource(uint32_t i) const [member function]
-    cls.add_method('GetTraceSource', 
-                   'ns3::TypeId::TraceSourceInformation', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## type-id.h (module 'core'): uint32_t ns3::TypeId::GetTraceSourceN() const [member function]
-    cls.add_method('GetTraceSourceN', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): uint16_t ns3::TypeId::GetUid() const [member function]
-    cls.add_method('GetUid', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::HasConstructor() const [member function]
-    cls.add_method('HasConstructor', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::HasParent() const [member function]
-    cls.add_method('HasParent', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::HideFromDocumentation() [member function]
-    cls.add_method('HideFromDocumentation', 
-                   'ns3::TypeId', 
-                   [])
-    ## type-id.h (module 'core'): bool ns3::TypeId::IsChildOf(ns3::TypeId other) const [member function]
-    cls.add_method('IsChildOf', 
-                   'bool', 
-                   [param('ns3::TypeId', 'other')], 
-                   is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::LookupAttributeByName(std::string name, ns3::TypeId::AttributeInformation * info) const [member function]
-    cls.add_method('LookupAttributeByName', 
-                   'bool', 
-                   [param('std::string', 'name'), param('ns3::TypeId::AttributeInformation *', 'info', transfer_ownership=False)], 
-                   is_const=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::LookupByHash(ns3::TypeId::hash_t hash) [member function]
-    cls.add_method('LookupByHash', 
-                   'ns3::TypeId', 
-                   [param('uint32_t', 'hash')], 
-                   is_static=True)
-    ## type-id.h (module 'core'): static bool ns3::TypeId::LookupByHashFailSafe(ns3::TypeId::hash_t hash, ns3::TypeId * tid) [member function]
-    cls.add_method('LookupByHashFailSafe', 
-                   'bool', 
-                   [param('uint32_t', 'hash'), param('ns3::TypeId *', 'tid')], 
-                   is_static=True)
-    ## type-id.h (module 'core'): static ns3::TypeId ns3::TypeId::LookupByName(std::string name) [member function]
-    cls.add_method('LookupByName', 
-                   'ns3::TypeId', 
-                   [param('std::string', 'name')], 
-                   is_static=True)
-    ## type-id.h (module 'core'): ns3::Ptr<const ns3::TraceSourceAccessor> ns3::TypeId::LookupTraceSourceByName(std::string name) const [member function]
-    cls.add_method('LookupTraceSourceByName', 
-                   'ns3::Ptr< ns3::TraceSourceAccessor const >', 
-                   [param('std::string', 'name')], 
-                   is_const=True)
-    ## type-id.h (module 'core'): ns3::Ptr<const ns3::TraceSourceAccessor> ns3::TypeId::LookupTraceSourceByName(std::string name, ns3::TypeId::TraceSourceInformation * info) const [member function]
-    cls.add_method('LookupTraceSourceByName', 
-                   'ns3::Ptr< ns3::TraceSourceAccessor const >', 
-                   [param('std::string', 'name'), param('ns3::TypeId::TraceSourceInformation *', 'info')], 
-                   is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::MustHideFromDocumentation() const [member function]
-    cls.add_method('MustHideFromDocumentation', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): bool ns3::TypeId::SetAttributeInitialValue(uint32_t i, ns3::Ptr<const ns3::AttributeValue> initialValue) [member function]
-    cls.add_method('SetAttributeInitialValue', 
-                   'bool', 
-                   [param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetGroupName(std::string groupName) [member function]
-    cls.add_method('SetGroupName', 
-                   'ns3::TypeId', 
-                   [param('std::string', 'groupName')])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetParent(ns3::TypeId tid) [member function]
-    cls.add_method('SetParent', 
-                   'ns3::TypeId', 
-                   [param('ns3::TypeId', 'tid')])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetParent() [member function]
-    cls.add_method('SetParent', 
-                   'ns3::TypeId', 
-                   [], 
-                   template_parameters=[u'ns3::Object'])
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeId::SetSize(std::size_t size) [member function]
-    cls.add_method('SetSize', 
-                   'ns3::TypeId', 
-                   [param('std::size_t', 'size')])
-    ## type-id.h (module 'core'): void ns3::TypeId::SetUid(uint16_t uid) [member function]
-    cls.add_method('SetUid', 
-                   'void', 
-                   [param('uint16_t', 'uid')])
-    return
-
-def register_Ns3TypeIdAttributeInformation_methods(root_module, cls):
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::AttributeInformation() [constructor]
-    cls.add_constructor([])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::AttributeInformation(ns3::TypeId::AttributeInformation const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TypeId::AttributeInformation const &', 'arg0')])
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::accessor [variable]
-    cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::AttributeAccessor const >', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::checker [variable]
-    cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)
-    cls.add_instance_attribute('flags', 'uint32_t', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::help [variable]
-    cls.add_instance_attribute('help', 'std::string', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::initialValue [variable]
-    cls.add_instance_attribute('initialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::name [variable]
-    cls.add_instance_attribute('name', 'std::string', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::originalInitialValue [variable]
-    cls.add_instance_attribute('originalInitialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::supportLevel [variable]
-    cls.add_instance_attribute('supportLevel', 'ns3::TypeId::SupportLevel', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::AttributeInformation::supportMsg [variable]
-    cls.add_instance_attribute('supportMsg', 'std::string', is_const=False)
-    return
-
-def register_Ns3TypeIdTraceSourceInformation_methods(root_module, cls):
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::TraceSourceInformation() [constructor]
-    cls.add_constructor([])
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::TraceSourceInformation(ns3::TypeId::TraceSourceInformation const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TypeId::TraceSourceInformation const &', 'arg0')])
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::accessor [variable]
-    cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::TraceSourceAccessor const >', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::callback [variable]
-    cls.add_instance_attribute('callback', 'std::string', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::help [variable]
-    cls.add_instance_attribute('help', 'std::string', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::name [variable]
-    cls.add_instance_attribute('name', 'std::string', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::supportLevel [variable]
-    cls.add_instance_attribute('supportLevel', 'ns3::TypeId::SupportLevel', is_const=False)
-    ## type-id.h (module 'core'): ns3::TypeId::TraceSourceInformation::supportMsg [variable]
-    cls.add_instance_attribute('supportMsg', 'std::string', is_const=False)
-    return
-
-def register_Ns3UeCapabilities_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s::UeCapabilities_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s::UeCapabilities_s(ns3::UeCapabilities_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UeCapabilities_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s::m_halfDuplex [variable]
-    cls.add_instance_attribute('m_halfDuplex', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s::m_intraSfHopping [variable]
-    cls.add_instance_attribute('m_intraSfHopping', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s::m_resAllocType1 [variable]
-    cls.add_instance_attribute('m_resAllocType1', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s::m_type2Sb1 [variable]
-    cls.add_instance_attribute('m_type2Sb1', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UeCapabilities_s::m_ueCategory [variable]
-    cls.add_instance_attribute('m_ueCategory', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3UeSelected_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::UeSelected_s::UeSelected_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::UeSelected_s::UeSelected_s(ns3::UeSelected_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UeSelected_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::UeSelected_s::m_sbCqi [variable]
-    cls.add_instance_attribute('m_sbCqi', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UeSelected_s::m_sbList [variable]
-    cls.add_instance_attribute('m_sbList', 'std::vector< unsigned char >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UeSelected_s::m_sbPmi [variable]
-    cls.add_instance_attribute('m_sbPmi', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3UlCqi_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::UlCqi_s::UlCqi_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::UlCqi_s::UlCqi_s(ns3::UlCqi_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UlCqi_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::UlCqi_s::m_sinr [variable]
-    cls.add_instance_attribute('m_sinr', 'std::vector< unsigned short >', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlCqi_s::m_type [variable]
-    cls.add_instance_attribute('m_type', 'ns3::UlCqi_s::Type_e', is_const=False)
-    return
-
-def register_Ns3UlDciListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::UlDciListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::UlDciListElement_s(ns3::UlDciListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UlDciListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_aggrLevel [variable]
-    cls.add_instance_attribute('m_aggrLevel', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_cceIndex [variable]
-    cls.add_instance_attribute('m_cceIndex', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_cqiRequest [variable]
-    cls.add_instance_attribute('m_cqiRequest', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_dai [variable]
-    cls.add_instance_attribute('m_dai', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_freqHopping [variable]
-    cls.add_instance_attribute('m_freqHopping', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_hopping [variable]
-    cls.add_instance_attribute('m_hopping', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_mcs [variable]
-    cls.add_instance_attribute('m_mcs', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_n2Dmrs [variable]
-    cls.add_instance_attribute('m_n2Dmrs', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_ndi [variable]
-    cls.add_instance_attribute('m_ndi', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_pdcchPowerOffset [variable]
-    cls.add_instance_attribute('m_pdcchPowerOffset', 'int8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_rbLen [variable]
-    cls.add_instance_attribute('m_rbLen', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_rbStart [variable]
-    cls.add_instance_attribute('m_rbStart', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_tbSize [variable]
-    cls.add_instance_attribute('m_tbSize', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_tpc [variable]
-    cls.add_instance_attribute('m_tpc', 'int8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_ueTxAntennaSelection [variable]
-    cls.add_instance_attribute('m_ueTxAntennaSelection', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlDciListElement_s::m_ulIndex [variable]
-    cls.add_instance_attribute('m_ulIndex', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3UlGrant_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::UlGrant_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::UlGrant_s(ns3::UlGrant_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UlGrant_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_cqiRequest [variable]
-    cls.add_instance_attribute('m_cqiRequest', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_hopping [variable]
-    cls.add_instance_attribute('m_hopping', 'bool', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_mcs [variable]
-    cls.add_instance_attribute('m_mcs', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_rbLen [variable]
-    cls.add_instance_attribute('m_rbLen', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_rbStart [variable]
-    cls.add_instance_attribute('m_rbStart', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_tbSize [variable]
-    cls.add_instance_attribute('m_tbSize', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_tpc [variable]
-    cls.add_instance_attribute('m_tpc', 'int8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlGrant_s::m_ulDelay [variable]
-    cls.add_instance_attribute('m_ulDelay', 'bool', is_const=False)
-    return
-
-def register_Ns3UlInfoListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s::UlInfoListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s::UlInfoListElement_s(ns3::UlInfoListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UlInfoListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s::m_receptionStatus [variable]
-    cls.add_instance_attribute('m_receptionStatus', 'ns3::UlInfoListElement_s::ReceptionStatus_e', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s::m_tpc [variable]
-    cls.add_instance_attribute('m_tpc', 'uint8_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::UlInfoListElement_s::m_ulReception [variable]
-    cls.add_instance_attribute('m_ulReception', 'std::vector< unsigned short >', is_const=False)
-    return
-
-def register_Ns3UplinkLteGlobalPathlossDatabase_methods(root_module, cls):
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::UplinkLteGlobalPathlossDatabase::UplinkLteGlobalPathlossDatabase() [constructor]
-    cls.add_constructor([])
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::UplinkLteGlobalPathlossDatabase::UplinkLteGlobalPathlossDatabase(ns3::UplinkLteGlobalPathlossDatabase const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UplinkLteGlobalPathlossDatabase const &', 'arg0')])
-    ## lte-global-pathloss-database.h (module 'lte'): void ns3::UplinkLteGlobalPathlossDatabase::UpdatePathloss(std::string context, ns3::Ptr<ns3::SpectrumPhy> txPhy, ns3::Ptr<ns3::SpectrumPhy> rxPhy, double lossDb) [member function]
-    cls.add_method('UpdatePathloss', 
-                   'void', 
-                   [param('std::string', 'context'), param('ns3::Ptr< ns3::SpectrumPhy >', 'txPhy'), param('ns3::Ptr< ns3::SpectrumPhy >', 'rxPhy'), param('double', 'lossDb')], 
-                   is_virtual=True)
-    return
-
-def register_Ns3Vector2D_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_numeric_operator('-', root_module['ns3::Vector2D'], root_module['ns3::Vector2D'], param('ns3::Vector2D const &', u'right'))
-    cls.add_binary_numeric_operator('+', root_module['ns3::Vector2D'], root_module['ns3::Vector2D'], param('ns3::Vector2D const &', u'right'))
-    ## vector.h (module 'core'): ns3::Vector2D::Vector2D(ns3::Vector2D const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Vector2D const &', 'arg0')])
-    ## vector.h (module 'core'): ns3::Vector2D::Vector2D(double _x, double _y) [constructor]
-    cls.add_constructor([param('double', '_x'), param('double', '_y')])
-    ## vector.h (module 'core'): ns3::Vector2D::Vector2D() [constructor]
-    cls.add_constructor([])
-    ## vector.h (module 'core'): double ns3::Vector2D::GetLength() const [member function]
-    cls.add_method('GetLength', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## vector.h (module 'core'): ns3::Vector2D::x [variable]
-    cls.add_instance_attribute('x', 'double', is_const=False)
-    ## vector.h (module 'core'): ns3::Vector2D::y [variable]
-    cls.add_instance_attribute('y', 'double', is_const=False)
-    return
-
-def register_Ns3Vector3D_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_numeric_operator('-', root_module['ns3::Vector3D'], root_module['ns3::Vector3D'], param('ns3::Vector3D const &', u'right'))
-    cls.add_binary_numeric_operator('+', root_module['ns3::Vector3D'], root_module['ns3::Vector3D'], param('ns3::Vector3D const &', u'right'))
-    ## vector.h (module 'core'): ns3::Vector3D::Vector3D(ns3::Vector3D const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Vector3D const &', 'arg0')])
-    ## vector.h (module 'core'): ns3::Vector3D::Vector3D(double _x, double _y, double _z) [constructor]
-    cls.add_constructor([param('double', '_x'), param('double', '_y'), param('double', '_z')])
-    ## vector.h (module 'core'): ns3::Vector3D::Vector3D() [constructor]
-    cls.add_constructor([])
-    ## vector.h (module 'core'): double ns3::Vector3D::GetLength() const [member function]
-    cls.add_method('GetLength', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## vector.h (module 'core'): ns3::Vector3D::x [variable]
-    cls.add_instance_attribute('x', 'double', is_const=False)
-    ## vector.h (module 'core'): ns3::Vector3D::y [variable]
-    cls.add_instance_attribute('y', 'double', is_const=False)
-    ## vector.h (module 'core'): ns3::Vector3D::z [variable]
-    cls.add_instance_attribute('z', 'double', is_const=False)
-    return
-
-def register_Ns3VendorSpecificListElement_s_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificListElement_s::VendorSpecificListElement_s() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificListElement_s::VendorSpecificListElement_s(ns3::VendorSpecificListElement_s const & arg0) [constructor]
-    cls.add_constructor([param('ns3::VendorSpecificListElement_s const &', 'arg0')])
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificListElement_s::m_length [variable]
-    cls.add_instance_attribute('m_length', 'uint32_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificListElement_s::m_type [variable]
-    cls.add_instance_attribute('m_type', 'uint32_t', is_const=False)
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificListElement_s::m_value [variable]
-    cls.add_instance_attribute('m_value', 'ns3::Ptr< ns3::VendorSpecificValue >', is_const=False)
-    return
-
-def register_Ns3Empty_methods(root_module, cls):
-    ## empty.h (module 'core'): ns3::empty::empty() [constructor]
-    cls.add_constructor([])
-    ## empty.h (module 'core'): ns3::empty::empty(ns3::empty const & arg0) [constructor]
-    cls.add_constructor([param('ns3::empty const &', 'arg0')])
-    return
-
-def register_Ns3FdbetsFlowPerf_t_methods(root_module, cls):
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::fdbetsFlowPerf_t::fdbetsFlowPerf_t() [constructor]
-    cls.add_constructor([])
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::fdbetsFlowPerf_t::fdbetsFlowPerf_t(ns3::fdbetsFlowPerf_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::fdbetsFlowPerf_t const &', 'arg0')])
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::fdbetsFlowPerf_t::flowStart [variable]
-    cls.add_instance_attribute('flowStart', 'ns3::Time', is_const=False)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::fdbetsFlowPerf_t::lastAveragedThroughput [variable]
-    cls.add_instance_attribute('lastAveragedThroughput', 'double', is_const=False)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::fdbetsFlowPerf_t::lastTtiBytesTrasmitted [variable]
-    cls.add_instance_attribute('lastTtiBytesTrasmitted', 'unsigned int', is_const=False)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::fdbetsFlowPerf_t::totalBytesTransmitted [variable]
-    cls.add_instance_attribute('totalBytesTransmitted', 'long unsigned int', is_const=False)
-    return
-
-def register_Ns3FdtbfqsFlowPerf_t_methods(root_module, cls):
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::fdtbfqsFlowPerf_t() [constructor]
-    cls.add_constructor([])
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::fdtbfqsFlowPerf_t(ns3::fdtbfqsFlowPerf_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::fdtbfqsFlowPerf_t const &', 'arg0')])
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::burstCredit [variable]
-    cls.add_instance_attribute('burstCredit', 'uint32_t', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::counter [variable]
-    cls.add_instance_attribute('counter', 'int', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::creditableThreshold [variable]
-    cls.add_instance_attribute('creditableThreshold', 'uint32_t', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::debtLimit [variable]
-    cls.add_instance_attribute('debtLimit', 'int', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::flowStart [variable]
-    cls.add_instance_attribute('flowStart', 'ns3::Time', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::maxTokenPoolSize [variable]
-    cls.add_instance_attribute('maxTokenPoolSize', 'uint32_t', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::packetArrivalRate [variable]
-    cls.add_instance_attribute('packetArrivalRate', 'uint64_t', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::tokenGenerationRate [variable]
-    cls.add_instance_attribute('tokenGenerationRate', 'uint64_t', is_const=False)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::fdtbfqsFlowPerf_t::tokenPoolSize [variable]
-    cls.add_instance_attribute('tokenPoolSize', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3Int64x64_t_methods(root_module, cls):
-    cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', u'right'))
-    cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', u'right'))
-    cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', u'right'))
-    cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', u'right'))
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<=')
-    cls.add_binary_comparison_operator('>=')
-    cls.add_output_stream_operator()
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('>')
-    cls.add_inplace_numeric_operator('+=', param('ns3::int64x64_t const &', u'right'))
-    cls.add_inplace_numeric_operator('-=', param('ns3::int64x64_t const &', u'right'))
-    cls.add_inplace_numeric_operator('*=', param('ns3::int64x64_t const &', u'right'))
-    cls.add_inplace_numeric_operator('/=', param('ns3::int64x64_t const &', u'right'))
-    cls.add_unary_numeric_operator('-')
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t() [constructor]
-    cls.add_constructor([])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(double const value) [constructor]
-    cls.add_constructor([param('double const', 'value')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(long double const value) [constructor]
-    cls.add_constructor([param('long double const', 'value')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(int const v) [constructor]
-    cls.add_constructor([param('int const', 'v')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(long int const v) [constructor]
-    cls.add_constructor([param('long int const', 'v')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(long long int const v) [constructor]
-    cls.add_constructor([param('long long int const', 'v')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(unsigned int const v) [constructor]
-    cls.add_constructor([param('unsigned int const', 'v')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(long unsigned int const v) [constructor]
-    cls.add_constructor([param('long unsigned int const', 'v')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(long long unsigned int const v) [constructor]
-    cls.add_constructor([param('long long unsigned int const', 'v')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(int64_t const hi, uint64_t const lo) [constructor]
-    cls.add_constructor([param('int64_t const', 'hi'), param('uint64_t const', 'lo')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::int64x64_t(ns3::int64x64_t const & o) [constructor]
-    cls.add_constructor([param('ns3::int64x64_t const &', 'o')])
-    ## int64x64-128.h (module 'core'): double ns3::int64x64_t::GetDouble() const [member function]
-    cls.add_method('GetDouble', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## int64x64-128.h (module 'core'): int64_t ns3::int64x64_t::GetHigh() const [member function]
-    cls.add_method('GetHigh', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## int64x64-128.h (module 'core'): uint64_t ns3::int64x64_t::GetLow() const [member function]
-    cls.add_method('GetLow', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## int64x64-128.h (module 'core'): static ns3::int64x64_t ns3::int64x64_t::Invert(uint64_t const v) [member function]
-    cls.add_method('Invert', 
-                   'ns3::int64x64_t', 
-                   [param('uint64_t const', 'v')], 
-                   is_static=True)
-    ## int64x64-128.h (module 'core'): void ns3::int64x64_t::MulByInvert(ns3::int64x64_t const & o) [member function]
-    cls.add_method('MulByInvert', 
-                   'void', 
-                   [param('ns3::int64x64_t const &', 'o')])
-    ## int64x64-128.h (module 'core'): ns3::int64x64_t::implementation [variable]
-    cls.add_static_attribute('implementation', 'ns3::int64x64_t::impl_type const', is_const=True)
-    return
-
-def register_Ns3PfsFlowPerf_t_methods(root_module, cls):
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::pfsFlowPerf_t::pfsFlowPerf_t() [constructor]
-    cls.add_constructor([])
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::pfsFlowPerf_t::pfsFlowPerf_t(ns3::pfsFlowPerf_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::pfsFlowPerf_t const &', 'arg0')])
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::pfsFlowPerf_t::flowStart [variable]
-    cls.add_instance_attribute('flowStart', 'ns3::Time', is_const=False)
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::pfsFlowPerf_t::lastAveragedThroughput [variable]
-    cls.add_instance_attribute('lastAveragedThroughput', 'double', is_const=False)
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::pfsFlowPerf_t::lastTtiBytesTrasmitted [variable]
-    cls.add_instance_attribute('lastTtiBytesTrasmitted', 'unsigned int', is_const=False)
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::pfsFlowPerf_t::totalBytesTransmitted [variable]
-    cls.add_instance_attribute('totalBytesTransmitted', 'long unsigned int', is_const=False)
-    return
-
-def register_Ns3PssFlowPerf_t_methods(root_module, cls):
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::pssFlowPerf_t() [constructor]
-    cls.add_constructor([])
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::pssFlowPerf_t(ns3::pssFlowPerf_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::pssFlowPerf_t const &', 'arg0')])
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::flowStart [variable]
-    cls.add_instance_attribute('flowStart', 'ns3::Time', is_const=False)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::lastAveragedThroughput [variable]
-    cls.add_instance_attribute('lastAveragedThroughput', 'double', is_const=False)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::lastTtiBytesTransmitted [variable]
-    cls.add_instance_attribute('lastTtiBytesTransmitted', 'unsigned int', is_const=False)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::secondLastAveragedThroughput [variable]
-    cls.add_instance_attribute('secondLastAveragedThroughput', 'double', is_const=False)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::targetThroughput [variable]
-    cls.add_instance_attribute('targetThroughput', 'double', is_const=False)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::pssFlowPerf_t::totalBytesTransmitted [variable]
-    cls.add_instance_attribute('totalBytesTransmitted', 'long unsigned int', is_const=False)
-    return
-
-def register_Ns3TbInfo_t_methods(root_module, cls):
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::tbInfo_t() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::tbInfo_t(ns3::tbInfo_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::tbInfo_t const &', 'arg0')])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::corrupt [variable]
-    cls.add_instance_attribute('corrupt', 'bool', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::downlink [variable]
-    cls.add_instance_attribute('downlink', 'bool', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::harqFeedbackSent [variable]
-    cls.add_instance_attribute('harqFeedbackSent', 'bool', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::harqProcessId [variable]
-    cls.add_instance_attribute('harqProcessId', 'uint8_t', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::mcs [variable]
-    cls.add_instance_attribute('mcs', 'uint8_t', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::mi [variable]
-    cls.add_instance_attribute('mi', 'double', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::ndi [variable]
-    cls.add_instance_attribute('ndi', 'uint8_t', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::rbBitmap [variable]
-    cls.add_instance_attribute('rbBitmap', 'std::vector< int >', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::rv [variable]
-    cls.add_instance_attribute('rv', 'uint8_t', is_const=False)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::tbInfo_t::size [variable]
-    cls.add_instance_attribute('size', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3TdbetsFlowPerf_t_methods(root_module, cls):
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::tdbetsFlowPerf_t::tdbetsFlowPerf_t() [constructor]
-    cls.add_constructor([])
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::tdbetsFlowPerf_t::tdbetsFlowPerf_t(ns3::tdbetsFlowPerf_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::tdbetsFlowPerf_t const &', 'arg0')])
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::tdbetsFlowPerf_t::flowStart [variable]
-    cls.add_instance_attribute('flowStart', 'ns3::Time', is_const=False)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::tdbetsFlowPerf_t::lastAveragedThroughput [variable]
-    cls.add_instance_attribute('lastAveragedThroughput', 'double', is_const=False)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::tdbetsFlowPerf_t::lastTtiBytesTrasmitted [variable]
-    cls.add_instance_attribute('lastTtiBytesTrasmitted', 'unsigned int', is_const=False)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::tdbetsFlowPerf_t::totalBytesTransmitted [variable]
-    cls.add_instance_attribute('totalBytesTransmitted', 'long unsigned int', is_const=False)
-    return
-
-def register_Ns3TdtbfqsFlowPerf_t_methods(root_module, cls):
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::tdtbfqsFlowPerf_t() [constructor]
-    cls.add_constructor([])
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::tdtbfqsFlowPerf_t(ns3::tdtbfqsFlowPerf_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::tdtbfqsFlowPerf_t const &', 'arg0')])
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::burstCredit [variable]
-    cls.add_instance_attribute('burstCredit', 'uint32_t', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::counter [variable]
-    cls.add_instance_attribute('counter', 'int', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::creditableThreshold [variable]
-    cls.add_instance_attribute('creditableThreshold', 'uint32_t', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::debtLimit [variable]
-    cls.add_instance_attribute('debtLimit', 'int', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::flowStart [variable]
-    cls.add_instance_attribute('flowStart', 'ns3::Time', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::maxTokenPoolSize [variable]
-    cls.add_instance_attribute('maxTokenPoolSize', 'uint32_t', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::packetArrivalRate [variable]
-    cls.add_instance_attribute('packetArrivalRate', 'uint64_t', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::tokenGenerationRate [variable]
-    cls.add_instance_attribute('tokenGenerationRate', 'uint64_t', is_const=False)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::tdtbfqsFlowPerf_t::tokenPoolSize [variable]
-    cls.add_instance_attribute('tokenPoolSize', 'uint32_t', is_const=False)
-    return
-
-def register_Ns3Chunk_methods(root_module, cls):
-    ## chunk.h (module 'network'): ns3::Chunk::Chunk() [constructor]
-    cls.add_constructor([])
-    ## chunk.h (module 'network'): ns3::Chunk::Chunk(ns3::Chunk const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Chunk const &', 'arg0')])
-    ## chunk.h (module 'network'): uint32_t ns3::Chunk::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## chunk.h (module 'network'): static ns3::TypeId ns3::Chunk::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## chunk.h (module 'network'): void ns3::Chunk::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3DownlinkLteGlobalPathlossDatabase_methods(root_module, cls):
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::DownlinkLteGlobalPathlossDatabase::DownlinkLteGlobalPathlossDatabase() [constructor]
-    cls.add_constructor([])
-    ## lte-global-pathloss-database.h (module 'lte'): ns3::DownlinkLteGlobalPathlossDatabase::DownlinkLteGlobalPathlossDatabase(ns3::DownlinkLteGlobalPathlossDatabase const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DownlinkLteGlobalPathlossDatabase const &', 'arg0')])
-    ## lte-global-pathloss-database.h (module 'lte'): void ns3::DownlinkLteGlobalPathlossDatabase::UpdatePathloss(std::string context, ns3::Ptr<ns3::SpectrumPhy> txPhy, ns3::Ptr<ns3::SpectrumPhy> rxPhy, double lossDb) [member function]
-    cls.add_method('UpdatePathloss', 
-                   'void', 
-                   [param('std::string', 'context'), param('ns3::Ptr< ns3::SpectrumPhy >', 'txPhy'), param('ns3::Ptr< ns3::SpectrumPhy >', 'rxPhy'), param('double', 'lossDb')], 
-                   is_virtual=True)
-    return
-
-def register_Ns3EpsBearerTag_methods(root_module, cls):
-    ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag::EpsBearerTag(ns3::EpsBearerTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpsBearerTag const &', 'arg0')])
-    ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag::EpsBearerTag() [constructor]
-    cls.add_constructor([])
-    ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag::EpsBearerTag(uint16_t rnti, uint8_t bid) [constructor]
-    cls.add_constructor([param('uint16_t', 'rnti'), param('uint8_t', 'bid')])
-    ## eps-bearer-tag.h (module 'lte'): void ns3::EpsBearerTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## eps-bearer-tag.h (module 'lte'): uint8_t ns3::EpsBearerTag::GetBid() const [member function]
-    cls.add_method('GetBid', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## eps-bearer-tag.h (module 'lte'): ns3::TypeId ns3::EpsBearerTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## eps-bearer-tag.h (module 'lte'): uint16_t ns3::EpsBearerTag::GetRnti() const [member function]
-    cls.add_method('GetRnti', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## eps-bearer-tag.h (module 'lte'): uint32_t ns3::EpsBearerTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## eps-bearer-tag.h (module 'lte'): static ns3::TypeId ns3::EpsBearerTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## eps-bearer-tag.h (module 'lte'): void ns3::EpsBearerTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## eps-bearer-tag.h (module 'lte'): void ns3::EpsBearerTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## eps-bearer-tag.h (module 'lte'): void ns3::EpsBearerTag::SetBid(uint8_t bid) [member function]
-    cls.add_method('SetBid', 
-                   'void', 
-                   [param('uint8_t', 'bid')])
-    ## eps-bearer-tag.h (module 'lte'): void ns3::EpsBearerTag::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    return
-
-def register_Ns3Header_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## header.h (module 'network'): ns3::Header::Header() [constructor]
-    cls.add_constructor([])
-    ## header.h (module 'network'): ns3::Header::Header(ns3::Header const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Header const &', 'arg0')])
-    ## header.h (module 'network'): uint32_t ns3::Header::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## header.h (module 'network'): uint32_t ns3::Header::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## header.h (module 'network'): static ns3::TypeId ns3::Header::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## header.h (module 'network'): void ns3::Header::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## header.h (module 'network'): void ns3::Header::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3Ipv4Header_methods(root_module, cls):
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Header::Ipv4Header(ns3::Ipv4Header const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Header const &', 'arg0')])
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Header::Ipv4Header() [constructor]
-    cls.add_constructor([])
-    ## ipv4-header.h (module 'internet'): uint32_t ns3::Ipv4Header::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## ipv4-header.h (module 'internet'): std::string ns3::Ipv4Header::DscpTypeToString(ns3::Ipv4Header::DscpType dscp) const [member function]
-    cls.add_method('DscpTypeToString', 
-                   'std::string', 
-                   [param('ns3::Ipv4Header::DscpType', 'dscp')], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): std::string ns3::Ipv4Header::EcnTypeToString(ns3::Ipv4Header::EcnType ecn) const [member function]
-    cls.add_method('EcnTypeToString', 
-                   'std::string', 
-                   [param('ns3::Ipv4Header::EcnType', 'ecn')], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::EnableChecksum() [member function]
-    cls.add_method('EnableChecksum', 
-                   'void', 
-                   [])
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4Header::GetDestination() const [member function]
-    cls.add_method('GetDestination', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Header::DscpType ns3::Ipv4Header::GetDscp() const [member function]
-    cls.add_method('GetDscp', 
-                   'ns3::Ipv4Header::DscpType', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Header::EcnType ns3::Ipv4Header::GetEcn() const [member function]
-    cls.add_method('GetEcn', 
-                   'ns3::Ipv4Header::EcnType', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): uint16_t ns3::Ipv4Header::GetFragmentOffset() const [member function]
-    cls.add_method('GetFragmentOffset', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): uint16_t ns3::Ipv4Header::GetIdentification() const [member function]
-    cls.add_method('GetIdentification', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): ns3::TypeId ns3::Ipv4Header::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-header.h (module 'internet'): uint16_t ns3::Ipv4Header::GetPayloadSize() const [member function]
-    cls.add_method('GetPayloadSize', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): uint8_t ns3::Ipv4Header::GetProtocol() const [member function]
-    cls.add_method('GetProtocol', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): uint32_t ns3::Ipv4Header::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-header.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4Header::GetSource() const [member function]
-    cls.add_method('GetSource', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): uint8_t ns3::Ipv4Header::GetTos() const [member function]
-    cls.add_method('GetTos', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): uint8_t ns3::Ipv4Header::GetTtl() const [member function]
-    cls.add_method('GetTtl', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): static ns3::TypeId ns3::Ipv4Header::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## ipv4-header.h (module 'internet'): bool ns3::Ipv4Header::IsChecksumOk() const [member function]
-    cls.add_method('IsChecksumOk', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): bool ns3::Ipv4Header::IsDontFragment() const [member function]
-    cls.add_method('IsDontFragment', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): bool ns3::Ipv4Header::IsLastFragment() const [member function]
-    cls.add_method('IsLastFragment', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetDestination(ns3::Ipv4Address destination) [member function]
-    cls.add_method('SetDestination', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'destination')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetDontFragment() [member function]
-    cls.add_method('SetDontFragment', 
-                   'void', 
-                   [])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetDscp(ns3::Ipv4Header::DscpType dscp) [member function]
-    cls.add_method('SetDscp', 
-                   'void', 
-                   [param('ns3::Ipv4Header::DscpType', 'dscp')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetEcn(ns3::Ipv4Header::EcnType ecn) [member function]
-    cls.add_method('SetEcn', 
-                   'void', 
-                   [param('ns3::Ipv4Header::EcnType', 'ecn')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetFragmentOffset(uint16_t offsetBytes) [member function]
-    cls.add_method('SetFragmentOffset', 
-                   'void', 
-                   [param('uint16_t', 'offsetBytes')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetIdentification(uint16_t identification) [member function]
-    cls.add_method('SetIdentification', 
-                   'void', 
-                   [param('uint16_t', 'identification')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetLastFragment() [member function]
-    cls.add_method('SetLastFragment', 
-                   'void', 
-                   [])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetMayFragment() [member function]
-    cls.add_method('SetMayFragment', 
-                   'void', 
-                   [])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetMoreFragments() [member function]
-    cls.add_method('SetMoreFragments', 
-                   'void', 
-                   [])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetPayloadSize(uint16_t size) [member function]
-    cls.add_method('SetPayloadSize', 
-                   'void', 
-                   [param('uint16_t', 'size')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetProtocol(uint8_t num) [member function]
-    cls.add_method('SetProtocol', 
-                   'void', 
-                   [param('uint8_t', 'num')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetSource(ns3::Ipv4Address source) [member function]
-    cls.add_method('SetSource', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'source')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetTos(uint8_t tos) [member function]
-    cls.add_method('SetTos', 
-                   'void', 
-                   [param('uint8_t', 'tos')])
-    ## ipv4-header.h (module 'internet'): void ns3::Ipv4Header::SetTtl(uint8_t ttl) [member function]
-    cls.add_method('SetTtl', 
-                   'void', 
-                   [param('uint8_t', 'ttl')])
-    return
-
-def register_Ns3LteCcmMacSapUser_methods(root_module, cls):
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapUser::LteCcmMacSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapUser::LteCcmMacSapUser(ns3::LteCcmMacSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmMacSapUser const &', 'arg0')])
-    ## lte-ccm-mac-sap.h (module 'lte'): void ns3::LteCcmMacSapUser::NotifyPrbOccupancy(double prbOccupancy, uint8_t componentCarrierId) [member function]
-    cls.add_method('NotifyPrbOccupancy', 
-                   'void', 
-                   [param('double', 'prbOccupancy'), param('uint8_t', 'componentCarrierId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-mac-sap.h (module 'lte'): void ns3::LteCcmMacSapUser::UlReceiveMacCe(ns3::MacCeListElement_s bsr, uint8_t componentCarrierId) [member function]
-    cls.add_method('UlReceiveMacCe', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr'), param('uint8_t', 'componentCarrierId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbRrcSapProvider_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::LteEnbRrcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::LteEnbRrcSapProvider(ns3::LteEnbRrcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrcSapProvider const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::CompleteSetupUe(uint16_t rnti, ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters params) [member function]
-    cls.add_method('CompleteSetupUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvMeasurementReport(uint16_t rnti, ns3::LteRrcSap::MeasurementReport msg) [member function]
-    cls.add_method('RecvMeasurementReport', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasurementReport', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvRrcConnectionReconfigurationCompleted(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
-    cls.add_method('RecvRrcConnectionReconfigurationCompleted', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionReconfigurationCompleted', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentComplete(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReestablishmentComplete msg) [member function]
-    cls.add_method('RecvRrcConnectionReestablishmentComplete', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionReestablishmentComplete', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentRequest(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReestablishmentRequest msg) [member function]
-    cls.add_method('RecvRrcConnectionReestablishmentRequest', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionReestablishmentRequest', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvRrcConnectionRequest(uint16_t rnti, ns3::LteRrcSap::RrcConnectionRequest msg) [member function]
-    cls.add_method('RecvRrcConnectionRequest', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionRequest', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvRrcConnectionSetupCompleted(uint16_t rnti, ns3::LteRrcSap::RrcConnectionSetupCompleted msg) [member function]
-    cls.add_method('RecvRrcConnectionSetupCompleted', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbRrcSapProviderCompleteSetupUeParameters_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters::CompleteSetupUeParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters::CompleteSetupUeParameters(ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters::srb0SapUser [variable]
-    cls.add_instance_attribute('srb0SapUser', 'ns3::LteRlcSapUser *', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters::srb1SapUser [variable]
-    cls.add_instance_attribute('srb1SapUser', 'ns3::LtePdcpSapUser *', is_const=False)
-    return
-
-def register_Ns3LteEnbRrcSapUser_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser::LteEnbRrcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser::LteEnbRrcSapUser(ns3::LteEnbRrcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrcSapUser const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration ns3::LteEnbRrcSapUser::DecodeHandoverCommand(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DecodeHandoverCommand', 
-                   'ns3::LteRrcSap::RrcConnectionReconfiguration', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::HandoverPreparationInfo ns3::LteEnbRrcSapUser::DecodeHandoverPreparationInformation(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DecodeHandoverPreparationInformation', 
-                   'ns3::LteRrcSap::HandoverPreparationInfo', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): ns3::Ptr<ns3::Packet> ns3::LteEnbRrcSapUser::EncodeHandoverCommand(ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
-    cls.add_method('EncodeHandoverCommand', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [param('ns3::LteRrcSap::RrcConnectionReconfiguration', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): ns3::Ptr<ns3::Packet> ns3::LteEnbRrcSapUser::EncodeHandoverPreparationInformation(ns3::LteRrcSap::HandoverPreparationInfo msg) [member function]
-    cls.add_method('EncodeHandoverPreparationInformation', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [param('ns3::LteRrcSap::HandoverPreparationInfo', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::RemoveUe(uint16_t rnti) [member function]
-    cls.add_method('RemoveUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionReconfiguration(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
-    cls.add_method('SendRrcConnectionReconfiguration', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionReconfiguration', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionReestablishment(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReestablishment msg) [member function]
-    cls.add_method('SendRrcConnectionReestablishment', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionReestablishment', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionReestablishmentReject(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReestablishmentReject msg) [member function]
-    cls.add_method('SendRrcConnectionReestablishmentReject', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionReestablishmentReject', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionReject(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReject msg) [member function]
-    cls.add_method('SendRrcConnectionReject', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionReject', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionRelease(uint16_t rnti, ns3::LteRrcSap::RrcConnectionRelease msg) [member function]
-    cls.add_method('SendRrcConnectionRelease', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionRelease', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionSetup(uint16_t rnti, ns3::LteRrcSap::RrcConnectionSetup msg) [member function]
-    cls.add_method('SendRrcConnectionSetup', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendSystemInformation(uint16_t cellId, ns3::LteRrcSap::SystemInformation msg) [member function]
-    cls.add_method('SendSystemInformation', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::LteRrcSap::SystemInformation', 'msg')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SetupUe(uint16_t rnti, ns3::LteEnbRrcSapUser::SetupUeParameters params) [member function]
-    cls.add_method('SetupUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteEnbRrcSapUser::SetupUeParameters', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteEnbRrcSapUserSetupUeParameters_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser::SetupUeParameters::SetupUeParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser::SetupUeParameters::SetupUeParameters(ns3::LteEnbRrcSapUser::SetupUeParameters const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrcSapUser::SetupUeParameters const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser::SetupUeParameters::srb0SapProvider [variable]
-    cls.add_instance_attribute('srb0SapProvider', 'ns3::LteRlcSapProvider *', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapUser::SetupUeParameters::srb1SapProvider [variable]
-    cls.add_instance_attribute('srb1SapProvider', 'ns3::LtePdcpSapProvider *', is_const=False)
-    return
-
-def register_Ns3LtePdcpHeader_methods(root_module, cls):
-    ## lte-pdcp-header.h (module 'lte'): ns3::LtePdcpHeader::LtePdcpHeader(ns3::LtePdcpHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePdcpHeader const &', 'arg0')])
-    ## lte-pdcp-header.h (module 'lte'): ns3::LtePdcpHeader::LtePdcpHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp-header.h (module 'lte'): uint32_t ns3::LtePdcpHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## lte-pdcp-header.h (module 'lte'): uint8_t ns3::LtePdcpHeader::GetDcBit() const [member function]
-    cls.add_method('GetDcBit', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-pdcp-header.h (module 'lte'): ns3::TypeId ns3::LtePdcpHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-header.h (module 'lte'): uint16_t ns3::LtePdcpHeader::GetSequenceNumber() const [member function]
-    cls.add_method('GetSequenceNumber', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-pdcp-header.h (module 'lte'): uint32_t ns3::LtePdcpHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-header.h (module 'lte'): static ns3::TypeId ns3::LtePdcpHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-pdcp-header.h (module 'lte'): void ns3::LtePdcpHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-header.h (module 'lte'): void ns3::LtePdcpHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-header.h (module 'lte'): void ns3::LtePdcpHeader::SetDcBit(uint8_t dcBit) [member function]
-    cls.add_method('SetDcBit', 
-                   'void', 
-                   [param('uint8_t', 'dcBit')])
-    ## lte-pdcp-header.h (module 'lte'): void ns3::LtePdcpHeader::SetSequenceNumber(uint16_t sequenceNumber) [member function]
-    cls.add_method('SetSequenceNumber', 
-                   'void', 
-                   [param('uint16_t', 'sequenceNumber')])
-    return
-
-def register_Ns3LtePhyTag_methods(root_module, cls):
-    ## lte-phy-tag.h (module 'lte'): ns3::LtePhyTag::LtePhyTag(ns3::LtePhyTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePhyTag const &', 'arg0')])
-    ## lte-phy-tag.h (module 'lte'): ns3::LtePhyTag::LtePhyTag() [constructor]
-    cls.add_constructor([])
-    ## lte-phy-tag.h (module 'lte'): ns3::LtePhyTag::LtePhyTag(uint16_t cellId) [constructor]
-    cls.add_constructor([param('uint16_t', 'cellId')])
-    ## lte-phy-tag.h (module 'lte'): void ns3::LtePhyTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## lte-phy-tag.h (module 'lte'): uint16_t ns3::LtePhyTag::GetCellId() const [member function]
-    cls.add_method('GetCellId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-phy-tag.h (module 'lte'): ns3::TypeId ns3::LtePhyTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-phy-tag.h (module 'lte'): uint32_t ns3::LtePhyTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-phy-tag.h (module 'lte'): static ns3::TypeId ns3::LtePhyTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-phy-tag.h (module 'lte'): void ns3::LtePhyTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-phy-tag.h (module 'lte'): void ns3::LtePhyTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    return
-
-def register_Ns3LteRadioBearerTag_methods(root_module, cls):
-    ## lte-radio-bearer-tag.h (module 'lte'): ns3::LteRadioBearerTag::LteRadioBearerTag(ns3::LteRadioBearerTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRadioBearerTag const &', 'arg0')])
-    ## lte-radio-bearer-tag.h (module 'lte'): ns3::LteRadioBearerTag::LteRadioBearerTag() [constructor]
-    cls.add_constructor([])
-    ## lte-radio-bearer-tag.h (module 'lte'): ns3::LteRadioBearerTag::LteRadioBearerTag(uint16_t rnti, uint8_t lcId) [constructor]
-    cls.add_constructor([param('uint16_t', 'rnti'), param('uint8_t', 'lcId')])
-    ## lte-radio-bearer-tag.h (module 'lte'): ns3::LteRadioBearerTag::LteRadioBearerTag(uint16_t rnti, uint8_t lcId, uint8_t layer) [constructor]
-    cls.add_constructor([param('uint16_t', 'rnti'), param('uint8_t', 'lcId'), param('uint8_t', 'layer')])
-    ## lte-radio-bearer-tag.h (module 'lte'): void ns3::LteRadioBearerTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): ns3::TypeId ns3::LteRadioBearerTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): uint8_t ns3::LteRadioBearerTag::GetLayer() const [member function]
-    cls.add_method('GetLayer', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): uint8_t ns3::LteRadioBearerTag::GetLcid() const [member function]
-    cls.add_method('GetLcid', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): uint16_t ns3::LteRadioBearerTag::GetRnti() const [member function]
-    cls.add_method('GetRnti', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): uint32_t ns3::LteRadioBearerTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): static ns3::TypeId ns3::LteRadioBearerTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): void ns3::LteRadioBearerTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): void ns3::LteRadioBearerTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## lte-radio-bearer-tag.h (module 'lte'): void ns3::LteRadioBearerTag::SetLayer(uint8_t layer) [member function]
-    cls.add_method('SetLayer', 
-                   'void', 
-                   [param('uint8_t', 'layer')])
-    ## lte-radio-bearer-tag.h (module 'lte'): void ns3::LteRadioBearerTag::SetLcid(uint8_t lcid) [member function]
-    cls.add_method('SetLcid', 
-                   'void', 
-                   [param('uint8_t', 'lcid')])
-    ## lte-radio-bearer-tag.h (module 'lte'): void ns3::LteRadioBearerTag::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    return
-
-def register_Ns3LteRlcAmHeader_methods(root_module, cls):
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::LteRlcAmHeader(ns3::LteRlcAmHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcAmHeader const &', 'arg0')])
-    ## lte-rlc-am-header.h (module 'lte'): ns3::LteRlcAmHeader::LteRlcAmHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-am-header.h (module 'lte'): uint32_t ns3::LteRlcAmHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## lte-rlc-am-header.h (module 'lte'): ns3::SequenceNumber10 ns3::LteRlcAmHeader::GetAckSn() const [member function]
-    cls.add_method('GetAckSn', 
-                   'ns3::SequenceNumber10', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): uint8_t ns3::LteRlcAmHeader::GetFramingInfo() const [member function]
-    cls.add_method('GetFramingInfo', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): ns3::TypeId ns3::LteRlcAmHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-am-header.h (module 'lte'): uint16_t ns3::LteRlcAmHeader::GetLastOffset() const [member function]
-    cls.add_method('GetLastOffset', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): uint8_t ns3::LteRlcAmHeader::GetLastSegmentFlag() const [member function]
-    cls.add_method('GetLastSegmentFlag', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): uint8_t ns3::LteRlcAmHeader::GetPollingBit() const [member function]
-    cls.add_method('GetPollingBit', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): uint8_t ns3::LteRlcAmHeader::GetResegmentationFlag() const [member function]
-    cls.add_method('GetResegmentationFlag', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): uint16_t ns3::LteRlcAmHeader::GetSegmentOffset() const [member function]
-    cls.add_method('GetSegmentOffset', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): ns3::SequenceNumber10 ns3::LteRlcAmHeader::GetSequenceNumber() const [member function]
-    cls.add_method('GetSequenceNumber', 
-                   'ns3::SequenceNumber10', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): uint32_t ns3::LteRlcAmHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-am-header.h (module 'lte'): static ns3::TypeId ns3::LteRlcAmHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rlc-am-header.h (module 'lte'): bool ns3::LteRlcAmHeader::IsControlPdu() const [member function]
-    cls.add_method('IsControlPdu', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): bool ns3::LteRlcAmHeader::IsDataPdu() const [member function]
-    cls.add_method('IsDataPdu', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-am-header.h (module 'lte'): bool ns3::LteRlcAmHeader::IsNackPresent(ns3::SequenceNumber10 nack) [member function]
-    cls.add_method('IsNackPresent', 
-                   'bool', 
-                   [param('ns3::SequenceNumber10', 'nack')])
-    ## lte-rlc-am-header.h (module 'lte'): bool ns3::LteRlcAmHeader::OneMoreNackWouldFitIn(uint16_t bytes) [member function]
-    cls.add_method('OneMoreNackWouldFitIn', 
-                   'bool', 
-                   [param('uint16_t', 'bytes')])
-    ## lte-rlc-am-header.h (module 'lte'): uint8_t ns3::LteRlcAmHeader::PopExtensionBit() [member function]
-    cls.add_method('PopExtensionBit', 
-                   'uint8_t', 
-                   [])
-    ## lte-rlc-am-header.h (module 'lte'): uint16_t ns3::LteRlcAmHeader::PopLengthIndicator() [member function]
-    cls.add_method('PopLengthIndicator', 
-                   'uint16_t', 
-                   [])
-    ## lte-rlc-am-header.h (module 'lte'): int ns3::LteRlcAmHeader::PopNack() [member function]
-    cls.add_method('PopNack', 
-                   'int', 
-                   [])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::PushExtensionBit(uint8_t extensionBit) [member function]
-    cls.add_method('PushExtensionBit', 
-                   'void', 
-                   [param('uint8_t', 'extensionBit')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::PushLengthIndicator(uint16_t lengthIndicator) [member function]
-    cls.add_method('PushLengthIndicator', 
-                   'void', 
-                   [param('uint16_t', 'lengthIndicator')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::PushNack(int nack) [member function]
-    cls.add_method('PushNack', 
-                   'void', 
-                   [param('int', 'nack')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetAckSn(ns3::SequenceNumber10 ackSn) [member function]
-    cls.add_method('SetAckSn', 
-                   'void', 
-                   [param('ns3::SequenceNumber10', 'ackSn')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetControlPdu(uint8_t controlPduType) [member function]
-    cls.add_method('SetControlPdu', 
-                   'void', 
-                   [param('uint8_t', 'controlPduType')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetDataPdu() [member function]
-    cls.add_method('SetDataPdu', 
-                   'void', 
-                   [])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetFramingInfo(uint8_t framingInfo) [member function]
-    cls.add_method('SetFramingInfo', 
-                   'void', 
-                   [param('uint8_t', 'framingInfo')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetLastSegmentFlag(uint8_t lsf) [member function]
-    cls.add_method('SetLastSegmentFlag', 
-                   'void', 
-                   [param('uint8_t', 'lsf')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetPollingBit(uint8_t pollingBit) [member function]
-    cls.add_method('SetPollingBit', 
-                   'void', 
-                   [param('uint8_t', 'pollingBit')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetResegmentationFlag(uint8_t resegFlag) [member function]
-    cls.add_method('SetResegmentationFlag', 
-                   'void', 
-                   [param('uint8_t', 'resegFlag')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetSegmentOffset(uint16_t segmentOffset) [member function]
-    cls.add_method('SetSegmentOffset', 
-                   'void', 
-                   [param('uint16_t', 'segmentOffset')])
-    ## lte-rlc-am-header.h (module 'lte'): void ns3::LteRlcAmHeader::SetSequenceNumber(ns3::SequenceNumber10 sequenceNumber) [member function]
-    cls.add_method('SetSequenceNumber', 
-                   'void', 
-                   [param('ns3::SequenceNumber10', 'sequenceNumber')])
-    return
-
-def register_Ns3LteRlcHeader_methods(root_module, cls):
-    ## lte-rlc-header.h (module 'lte'): ns3::LteRlcHeader::LteRlcHeader(ns3::LteRlcHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcHeader const &', 'arg0')])
-    ## lte-rlc-header.h (module 'lte'): ns3::LteRlcHeader::LteRlcHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-header.h (module 'lte'): uint32_t ns3::LteRlcHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## lte-rlc-header.h (module 'lte'): uint8_t ns3::LteRlcHeader::GetFramingInfo() const [member function]
-    cls.add_method('GetFramingInfo', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-header.h (module 'lte'): ns3::TypeId ns3::LteRlcHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-header.h (module 'lte'): ns3::SequenceNumber10 ns3::LteRlcHeader::GetSequenceNumber() const [member function]
-    cls.add_method('GetSequenceNumber', 
-                   'ns3::SequenceNumber10', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-header.h (module 'lte'): uint32_t ns3::LteRlcHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-header.h (module 'lte'): static ns3::TypeId ns3::LteRlcHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rlc-header.h (module 'lte'): uint8_t ns3::LteRlcHeader::PopExtensionBit() [member function]
-    cls.add_method('PopExtensionBit', 
-                   'uint8_t', 
-                   [])
-    ## lte-rlc-header.h (module 'lte'): uint16_t ns3::LteRlcHeader::PopLengthIndicator() [member function]
-    cls.add_method('PopLengthIndicator', 
-                   'uint16_t', 
-                   [])
-    ## lte-rlc-header.h (module 'lte'): void ns3::LteRlcHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-header.h (module 'lte'): void ns3::LteRlcHeader::PushExtensionBit(uint8_t extensionBit) [member function]
-    cls.add_method('PushExtensionBit', 
-                   'void', 
-                   [param('uint8_t', 'extensionBit')])
-    ## lte-rlc-header.h (module 'lte'): void ns3::LteRlcHeader::PushLengthIndicator(uint16_t lengthIndicator) [member function]
-    cls.add_method('PushLengthIndicator', 
-                   'void', 
-                   [param('uint16_t', 'lengthIndicator')])
-    ## lte-rlc-header.h (module 'lte'): void ns3::LteRlcHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-header.h (module 'lte'): void ns3::LteRlcHeader::SetFramingInfo(uint8_t framingInfo) [member function]
-    cls.add_method('SetFramingInfo', 
-                   'void', 
-                   [param('uint8_t', 'framingInfo')])
-    ## lte-rlc-header.h (module 'lte'): void ns3::LteRlcHeader::SetSequenceNumber(ns3::SequenceNumber10 sequenceNumber) [member function]
-    cls.add_method('SetSequenceNumber', 
-                   'void', 
-                   [param('ns3::SequenceNumber10', 'sequenceNumber')])
-    return
-
-def register_Ns3LteRlcSduStatusTag_methods(root_module, cls):
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): ns3::LteRlcSduStatusTag::LteRlcSduStatusTag(ns3::LteRlcSduStatusTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcSduStatusTag const &', 'arg0')])
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): ns3::LteRlcSduStatusTag::LteRlcSduStatusTag() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): void ns3::LteRlcSduStatusTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): ns3::TypeId ns3::LteRlcSduStatusTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): uint32_t ns3::LteRlcSduStatusTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): uint8_t ns3::LteRlcSduStatusTag::GetStatus() const [member function]
-    cls.add_method('GetStatus', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): static ns3::TypeId ns3::LteRlcSduStatusTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): void ns3::LteRlcSduStatusTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): void ns3::LteRlcSduStatusTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-sdu-status-tag.h (module 'lte'): void ns3::LteRlcSduStatusTag::SetStatus(uint8_t status) [member function]
-    cls.add_method('SetStatus', 
-                   'void', 
-                   [param('uint8_t', 'status')])
-    return
-
-def register_Ns3Object_methods(root_module, cls):
-    ## object.h (module 'core'): ns3::Object::Object() [constructor]
-    cls.add_constructor([])
-    ## object.h (module 'core'): void ns3::Object::AggregateObject(ns3::Ptr<ns3::Object> other) [member function]
-    cls.add_method('AggregateObject', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Object >', 'other')])
-    ## object.h (module 'core'): void ns3::Object::Dispose() [member function]
-    cls.add_method('Dispose', 
-                   'void', 
-                   [])
-    ## object.h (module 'core'): ns3::Object::AggregateIterator ns3::Object::GetAggregateIterator() const [member function]
-    cls.add_method('GetAggregateIterator', 
-                   'ns3::Object::AggregateIterator', 
-                   [], 
-                   is_const=True)
-    ## object.h (module 'core'): ns3::TypeId ns3::Object::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## object.h (module 'core'): static ns3::TypeId ns3::Object::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## object.h (module 'core'): void ns3::Object::Initialize() [member function]
-    cls.add_method('Initialize', 
-                   'void', 
-                   [])
-    ## object.h (module 'core'): bool ns3::Object::IsInitialized() const [member function]
-    cls.add_method('IsInitialized', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## object.h (module 'core'): ns3::Object::Object(ns3::Object const & o) [constructor]
-    cls.add_constructor([param('ns3::Object const &', 'o')], 
-                        visibility='protected')
-    ## object.h (module 'core'): void ns3::Object::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## object.h (module 'core'): void ns3::Object::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## object.h (module 'core'): void ns3::Object::NotifyNewAggregate() [member function]
-    cls.add_method('NotifyNewAggregate', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ObjectAggregateIterator_methods(root_module, cls):
-    ## object.h (module 'core'): ns3::Object::AggregateIterator::AggregateIterator(ns3::Object::AggregateIterator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Object::AggregateIterator const &', 'arg0')])
-    ## object.h (module 'core'): ns3::Object::AggregateIterator::AggregateIterator() [constructor]
-    cls.add_constructor([])
-    ## object.h (module 'core'): bool ns3::Object::AggregateIterator::HasNext() const [member function]
-    cls.add_method('HasNext', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## object.h (module 'core'): ns3::Ptr<const ns3::Object> ns3::Object::AggregateIterator::Next() [member function]
-    cls.add_method('Next', 
-                   'ns3::Ptr< ns3::Object const >', 
-                   [])
-    return
-
-def register_Ns3PacketBurst_methods(root_module, cls):
-    ## packet-burst.h (module 'network'): ns3::PacketBurst::PacketBurst(ns3::PacketBurst const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PacketBurst const &', 'arg0')])
-    ## packet-burst.h (module 'network'): ns3::PacketBurst::PacketBurst() [constructor]
-    cls.add_constructor([])
-    ## packet-burst.h (module 'network'): void ns3::PacketBurst::AddPacket(ns3::Ptr<ns3::Packet> packet) [member function]
-    cls.add_method('AddPacket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet')])
-    ## packet-burst.h (module 'network'): std::list<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > >::const_iterator ns3::PacketBurst::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'std::list< ns3::Ptr< ns3::Packet > > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## packet-burst.h (module 'network'): ns3::Ptr<ns3::PacketBurst> ns3::PacketBurst::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::PacketBurst >', 
-                   [], 
-                   is_const=True)
-    ## packet-burst.h (module 'network'): std::list<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > >::const_iterator ns3::PacketBurst::End() const [member function]
-    cls.add_method('End', 
-                   'std::list< ns3::Ptr< ns3::Packet > > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## packet-burst.h (module 'network'): uint32_t ns3::PacketBurst::GetNPackets() const [member function]
-    cls.add_method('GetNPackets', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## packet-burst.h (module 'network'): std::list<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::PacketBurst::GetPackets() const [member function]
-    cls.add_method('GetPackets', 
-                   'std::list< ns3::Ptr< ns3::Packet > >', 
-                   [], 
-                   is_const=True)
-    ## packet-burst.h (module 'network'): uint32_t ns3::PacketBurst::GetSize() const [member function]
-    cls.add_method('GetSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## packet-burst.h (module 'network'): static ns3::TypeId ns3::PacketBurst::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## packet-burst.h (module 'network'): void ns3::PacketBurst::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='private', is_virtual=True)
-    return
-
-def register_Ns3PdcpTag_methods(root_module, cls):
-    ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag::PdcpTag(ns3::PdcpTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PdcpTag const &', 'arg0')])
-    ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag::PdcpTag() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag::PdcpTag(ns3::Time senderTimestamp) [constructor]
-    cls.add_constructor([param('ns3::Time', 'senderTimestamp')])
-    ## lte-pdcp-tag.h (module 'lte'): void ns3::PdcpTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## lte-pdcp-tag.h (module 'lte'): ns3::TypeId ns3::PdcpTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-tag.h (module 'lte'): ns3::Time ns3::PdcpTag::GetSenderTimestamp() const [member function]
-    cls.add_method('GetSenderTimestamp', 
-                   'ns3::Time', 
-                   [], 
-                   is_const=True)
-    ## lte-pdcp-tag.h (module 'lte'): uint32_t ns3::PdcpTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-tag.h (module 'lte'): static ns3::TypeId ns3::PdcpTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-pdcp-tag.h (module 'lte'): void ns3::PdcpTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-tag.h (module 'lte'): void ns3::PdcpTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## lte-pdcp-tag.h (module 'lte'): void ns3::PdcpTag::SetSenderTimestamp(ns3::Time senderTimestamp) [member function]
-    cls.add_method('SetSenderTimestamp', 
-                   'void', 
-                   [param('ns3::Time', 'senderTimestamp')])
-    return
-
-def register_Ns3RadioEnvironmentMapHelper_methods(root_module, cls):
-    ## radio-environment-map-helper.h (module 'lte'): ns3::RadioEnvironmentMapHelper::RadioEnvironmentMapHelper() [constructor]
-    cls.add_constructor([])
-    ## radio-environment-map-helper.h (module 'lte'): void ns3::RadioEnvironmentMapHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## radio-environment-map-helper.h (module 'lte'): uint8_t ns3::RadioEnvironmentMapHelper::GetBandwidth() const [member function]
-    cls.add_method('GetBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## radio-environment-map-helper.h (module 'lte'): static ns3::TypeId ns3::RadioEnvironmentMapHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## radio-environment-map-helper.h (module 'lte'): void ns3::RadioEnvironmentMapHelper::Install() [member function]
-    cls.add_method('Install', 
-                   'void', 
-                   [])
-    ## radio-environment-map-helper.h (module 'lte'): void ns3::RadioEnvironmentMapHelper::SetBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    return
-
-def register_Ns3RandomVariableStream_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::RandomVariableStream::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::RandomVariableStream::RandomVariableStream() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::RandomVariableStream::SetStream(int64_t stream) [member function]
-    cls.add_method('SetStream', 
-                   'void', 
-                   [param('int64_t', 'stream')])
-    ## random-variable-stream.h (module 'core'): int64_t ns3::RandomVariableStream::GetStream() const [member function]
-    cls.add_method('GetStream', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): void ns3::RandomVariableStream::SetAntithetic(bool isAntithetic) [member function]
-    cls.add_method('SetAntithetic', 
-                   'void', 
-                   [param('bool', 'isAntithetic')])
-    ## random-variable-stream.h (module 'core'): bool ns3::RandomVariableStream::IsAntithetic() const [member function]
-    cls.add_method('IsAntithetic', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::RandomVariableStream::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::RandomVariableStream::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## random-variable-stream.h (module 'core'): ns3::RngStream * ns3::RandomVariableStream::Peek() const [member function]
-    cls.add_method('Peek', 
-                   'ns3::RngStream *', 
-                   [], 
-                   is_const=True, visibility='protected')
-    return
-
-def register_Ns3RlcTag_methods(root_module, cls):
-    ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag::RlcTag(ns3::RlcTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RlcTag const &', 'arg0')])
-    ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag::RlcTag() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag::RlcTag(ns3::Time senderTimestamp) [constructor]
-    cls.add_constructor([param('ns3::Time', 'senderTimestamp')])
-    ## lte-rlc-tag.h (module 'lte'): void ns3::RlcTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## lte-rlc-tag.h (module 'lte'): ns3::TypeId ns3::RlcTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-tag.h (module 'lte'): ns3::Time ns3::RlcTag::GetSenderTimestamp() const [member function]
-    cls.add_method('GetSenderTimestamp', 
-                   'ns3::Time', 
-                   [], 
-                   is_const=True)
-    ## lte-rlc-tag.h (module 'lte'): uint32_t ns3::RlcTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-tag.h (module 'lte'): static ns3::TypeId ns3::RlcTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rlc-tag.h (module 'lte'): void ns3::RlcTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-tag.h (module 'lte'): void ns3::RlcTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rlc-tag.h (module 'lte'): void ns3::RlcTag::SetSenderTimestamp(ns3::Time senderTimestamp) [member function]
-    cls.add_method('SetSenderTimestamp', 
-                   'void', 
-                   [param('ns3::Time', 'senderTimestamp')])
-    return
-
-def register_Ns3SequentialRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::SequentialRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::SequentialRandomVariable::SequentialRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::SequentialRandomVariable::GetMin() const [member function]
-    cls.add_method('GetMin', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::SequentialRandomVariable::GetMax() const [member function]
-    cls.add_method('GetMax', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): ns3::Ptr<ns3::RandomVariableStream> ns3::SequentialRandomVariable::GetIncrement() const [member function]
-    cls.add_method('GetIncrement', 
-                   'ns3::Ptr< ns3::RandomVariableStream >', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::SequentialRandomVariable::GetConsecutive() const [member function]
-    cls.add_method('GetConsecutive', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::SequentialRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::SequentialRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >::SimpleRefCount(ns3::SimpleRefCount<ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter< ns3::AttributeAccessor > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >::SimpleRefCount(ns3::SimpleRefCount<ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter< ns3::AttributeChecker > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >::SimpleRefCount(ns3::SimpleRefCount<ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter< ns3::AttributeValue > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >::SimpleRefCount(ns3::SimpleRefCount<ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter< ns3::CallbackImplBase > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3EpcTft_Ns3Empty_Ns3DefaultDeleter__lt__ns3EpcTft__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EpcTft, ns3::empty, ns3::DefaultDeleter<ns3::EpcTft> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EpcTft, ns3::empty, ns3::DefaultDeleter<ns3::EpcTft> >::SimpleRefCount(ns3::SimpleRefCount<ns3::EpcTft, ns3::empty, ns3::DefaultDeleter<ns3::EpcTft> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::EpcTft, ns3::empty, ns3::DefaultDeleter< ns3::EpcTft > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3EpcTftClassifier_Ns3Empty_Ns3DefaultDeleter__lt__ns3EpcTftClassifier__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EpcTftClassifier, ns3::empty, ns3::DefaultDeleter<ns3::EpcTftClassifier> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EpcTftClassifier, ns3::empty, ns3::DefaultDeleter<ns3::EpcTftClassifier> >::SimpleRefCount(ns3::SimpleRefCount<ns3::EpcTftClassifier, ns3::empty, ns3::DefaultDeleter<ns3::EpcTftClassifier> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::EpcTftClassifier, ns3::empty, ns3::DefaultDeleter< ns3::EpcTftClassifier > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >::SimpleRefCount(ns3::SimpleRefCount<ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter< ns3::EventImpl > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3HashImplementation_Ns3Empty_Ns3DefaultDeleter__lt__ns3HashImplementation__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> >::SimpleRefCount(ns3::SimpleRefCount<ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter<ns3::Hash::Implementation> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::Hash::Implementation, ns3::empty, ns3::DefaultDeleter< ns3::Hash::Implementation > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3Ipv4MulticastRoute_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4MulticastRoute__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> >::SimpleRefCount(ns3::SimpleRefCount<ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4MulticastRoute> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::Ipv4MulticastRoute, ns3::empty, ns3::DefaultDeleter< ns3::Ipv4MulticastRoute > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3Ipv4Route_Ns3Empty_Ns3DefaultDeleter__lt__ns3Ipv4Route__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> >::SimpleRefCount(ns3::SimpleRefCount<ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter<ns3::Ipv4Route> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::Ipv4Route, ns3::empty, ns3::DefaultDeleter< ns3::Ipv4Route > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3LteChunkProcessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteChunkProcessor__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteChunkProcessor, ns3::empty, ns3::DefaultDeleter<ns3::LteChunkProcessor> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteChunkProcessor, ns3::empty, ns3::DefaultDeleter<ns3::LteChunkProcessor> >::SimpleRefCount(ns3::SimpleRefCount<ns3::LteChunkProcessor, ns3::empty, ns3::DefaultDeleter<ns3::LteChunkProcessor> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::LteChunkProcessor, ns3::empty, ns3::DefaultDeleter< ns3::LteChunkProcessor > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3LteControlMessage_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteControlMessage__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter<ns3::LteControlMessage> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter<ns3::LteControlMessage> >::SimpleRefCount(ns3::SimpleRefCount<ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter<ns3::LteControlMessage> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter< ns3::LteControlMessage > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3LteHarqPhy_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteHarqPhy__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> >::SimpleRefCount(ns3::SimpleRefCount<ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter< ns3::LteHarqPhy > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >::SimpleRefCount(ns3::SimpleRefCount<ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter< ns3::NixVector > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >::SimpleRefCount(ns3::SimpleRefCount<ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter< ns3::Packet > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >::SimpleRefCount(ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter< ns3::SpectrumModel > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >::SimpleRefCount(ns3::SimpleRefCount<ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter< ns3::SpectrumSignalParameters > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >::SimpleRefCount(ns3::SimpleRefCount<ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter< ns3::SpectrumValue > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >::SimpleRefCount(ns3::SimpleRefCount<ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter< ns3::TraceSourceAccessor > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3VendorSpecificValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3VendorSpecificValue__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::VendorSpecificValue, ns3::empty, ns3::DefaultDeleter<ns3::VendorSpecificValue> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::VendorSpecificValue, ns3::empty, ns3::DefaultDeleter<ns3::VendorSpecificValue> >::SimpleRefCount(ns3::SimpleRefCount<ns3::VendorSpecificValue, ns3::empty, ns3::DefaultDeleter<ns3::VendorSpecificValue> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::VendorSpecificValue, ns3::empty, ns3::DefaultDeleter< ns3::VendorSpecificValue > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3X2CellInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3X2CellInfo__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::X2CellInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2CellInfo> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::X2CellInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2CellInfo> >::SimpleRefCount(ns3::SimpleRefCount<ns3::X2CellInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2CellInfo> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::X2CellInfo, ns3::empty, ns3::DefaultDeleter< ns3::X2CellInfo > > const &', 'o')])
-    return
-
-def register_Ns3SimpleRefCount__Ns3X2IfaceInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3X2IfaceInfo__gt___methods(root_module, cls):
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::X2IfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2IfaceInfo> >::SimpleRefCount() [constructor]
-    cls.add_constructor([])
-    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::X2IfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2IfaceInfo> >::SimpleRefCount(ns3::SimpleRefCount<ns3::X2IfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::X2IfaceInfo> > const & o) [constructor]
-    cls.add_constructor([param('ns3::SimpleRefCount< ns3::X2IfaceInfo, ns3::empty, ns3::DefaultDeleter< ns3::X2IfaceInfo > > const &', 'o')])
-    return
-
-def register_Ns3Socket_methods(root_module, cls):
-    ## socket.h (module 'network'): ns3::Socket::Socket(ns3::Socket const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Socket const &', 'arg0')])
-    ## socket.h (module 'network'): ns3::Socket::Socket() [constructor]
-    cls.add_constructor([])
-    ## socket.h (module 'network'): int ns3::Socket::Bind(ns3::Address const & address) [member function]
-    cls.add_method('Bind', 
-                   'int', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::Bind() [member function]
-    cls.add_method('Bind', 
-                   'int', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::Bind6() [member function]
-    cls.add_method('Bind6', 
-                   'int', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::Socket::BindToNetDevice(ns3::Ptr<ns3::NetDevice> netdevice) [member function]
-    cls.add_method('BindToNetDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'netdevice')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::Close() [member function]
-    cls.add_method('Close', 
-                   'int', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::Connect(ns3::Address const & address) [member function]
-    cls.add_method('Connect', 
-                   'int', 
-                   [param('ns3::Address const &', 'address')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): static ns3::Ptr<ns3::Socket> ns3::Socket::CreateSocket(ns3::Ptr<ns3::Node> node, ns3::TypeId tid) [member function]
-    cls.add_method('CreateSocket', 
-                   'ns3::Ptr< ns3::Socket >', 
-                   [param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::TypeId', 'tid')], 
-                   is_static=True)
-    ## socket.h (module 'network'): bool ns3::Socket::GetAllowBroadcast() const [member function]
-    cls.add_method('GetAllowBroadcast', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::Socket::GetBoundNetDevice() [member function]
-    cls.add_method('GetBoundNetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [])
-    ## socket.h (module 'network'): ns3::Socket::SocketErrno ns3::Socket::GetErrno() const [member function]
-    cls.add_method('GetErrno', 
-                   'ns3::Socket::SocketErrno', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::Socket::GetIpTos() const [member function]
-    cls.add_method('GetIpTos', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): uint8_t ns3::Socket::GetIpTtl() const [member function]
-    cls.add_method('GetIpTtl', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::Socket::GetIpv6HopLimit() const [member function]
-    cls.add_method('GetIpv6HopLimit', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::Socket::GetIpv6Tclass() const [member function]
-    cls.add_method('GetIpv6Tclass', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): ns3::Ptr<ns3::Node> ns3::Socket::GetNode() const [member function]
-    cls.add_method('GetNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::GetPeerName(ns3::Address & address) const [member function]
-    cls.add_method('GetPeerName', 
-                   'int', 
-                   [param('ns3::Address &', 'address')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::Socket::GetPriority() const [member function]
-    cls.add_method('GetPriority', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): uint32_t ns3::Socket::GetRxAvailable() const [member function]
-    cls.add_method('GetRxAvailable', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::GetSockName(ns3::Address & address) const [member function]
-    cls.add_method('GetSockName', 
-                   'int', 
-                   [param('ns3::Address &', 'address')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): ns3::Socket::SocketType ns3::Socket::GetSocketType() const [member function]
-    cls.add_method('GetSocketType', 
-                   'ns3::Socket::SocketType', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint32_t ns3::Socket::GetTxAvailable() const [member function]
-    cls.add_method('GetTxAvailable', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): static ns3::TypeId ns3::Socket::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## socket.h (module 'network'): static uint8_t ns3::Socket::IpTos2Priority(uint8_t ipTos) [member function]
-    cls.add_method('IpTos2Priority', 
-                   'uint8_t', 
-                   [param('uint8_t', 'ipTos')], 
-                   is_static=True)
-    ## socket.h (module 'network'): void ns3::Socket::Ipv6JoinGroup(ns3::Ipv6Address address, ns3::Socket::Ipv6MulticastFilterMode filterMode, std::vector<ns3::Ipv6Address, std::allocator<ns3::Ipv6Address> > sourceAddresses) [member function]
-    cls.add_method('Ipv6JoinGroup', 
-                   'void', 
-                   [param('ns3::Ipv6Address', 'address'), param('ns3::Socket::Ipv6MulticastFilterMode', 'filterMode'), param('std::vector< ns3::Ipv6Address >', 'sourceAddresses')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): void ns3::Socket::Ipv6JoinGroup(ns3::Ipv6Address address) [member function]
-    cls.add_method('Ipv6JoinGroup', 
-                   'void', 
-                   [param('ns3::Ipv6Address', 'address')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): void ns3::Socket::Ipv6LeaveGroup() [member function]
-    cls.add_method('Ipv6LeaveGroup', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): bool ns3::Socket::IsIpRecvTos() const [member function]
-    cls.add_method('IsIpRecvTos', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): bool ns3::Socket::IsIpRecvTtl() const [member function]
-    cls.add_method('IsIpRecvTtl', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): bool ns3::Socket::IsIpv6RecvHopLimit() const [member function]
-    cls.add_method('IsIpv6RecvHopLimit', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): bool ns3::Socket::IsIpv6RecvTclass() const [member function]
-    cls.add_method('IsIpv6RecvTclass', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): bool ns3::Socket::IsRecvPktInfo() const [member function]
-    cls.add_method('IsRecvPktInfo', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): int ns3::Socket::Listen() [member function]
-    cls.add_method('Listen', 
-                   'int', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::Socket::Recv(uint32_t maxSize, uint32_t flags) [member function]
-    cls.add_method('Recv', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [param('uint32_t', 'maxSize'), param('uint32_t', 'flags')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::Socket::Recv() [member function]
-    cls.add_method('Recv', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [])
-    ## socket.h (module 'network'): int ns3::Socket::Recv(uint8_t * buf, uint32_t size, uint32_t flags) [member function]
-    cls.add_method('Recv', 
-                   'int', 
-                   [param('uint8_t *', 'buf'), param('uint32_t', 'size'), param('uint32_t', 'flags')])
-    ## socket.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::Socket::RecvFrom(uint32_t maxSize, uint32_t flags, ns3::Address & fromAddress) [member function]
-    cls.add_method('RecvFrom', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [param('uint32_t', 'maxSize'), param('uint32_t', 'flags'), param('ns3::Address &', 'fromAddress')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::Socket::RecvFrom(ns3::Address & fromAddress) [member function]
-    cls.add_method('RecvFrom', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [param('ns3::Address &', 'fromAddress')])
-    ## socket.h (module 'network'): int ns3::Socket::RecvFrom(uint8_t * buf, uint32_t size, uint32_t flags, ns3::Address & fromAddress) [member function]
-    cls.add_method('RecvFrom', 
-                   'int', 
-                   [param('uint8_t *', 'buf'), param('uint32_t', 'size'), param('uint32_t', 'flags'), param('ns3::Address &', 'fromAddress')])
-    ## socket.h (module 'network'): int ns3::Socket::Send(ns3::Ptr<ns3::Packet> p, uint32_t flags) [member function]
-    cls.add_method('Send', 
-                   'int', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint32_t', 'flags')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::Send(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('Send', 
-                   'int', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## socket.h (module 'network'): int ns3::Socket::Send(uint8_t const * buf, uint32_t size, uint32_t flags) [member function]
-    cls.add_method('Send', 
-                   'int', 
-                   [param('uint8_t const *', 'buf'), param('uint32_t', 'size'), param('uint32_t', 'flags')])
-    ## socket.h (module 'network'): int ns3::Socket::SendTo(ns3::Ptr<ns3::Packet> p, uint32_t flags, ns3::Address const & toAddress) [member function]
-    cls.add_method('SendTo', 
-                   'int', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint32_t', 'flags'), param('ns3::Address const &', 'toAddress')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::SendTo(uint8_t const * buf, uint32_t size, uint32_t flags, ns3::Address const & address) [member function]
-    cls.add_method('SendTo', 
-                   'int', 
-                   [param('uint8_t const *', 'buf'), param('uint32_t', 'size'), param('uint32_t', 'flags'), param('ns3::Address const &', 'address')])
-    ## socket.h (module 'network'): void ns3::Socket::SetAcceptCallback(ns3::Callback<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> connectionRequest, ns3::Callback<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> newConnectionCreated) [member function]
-    cls.add_method('SetAcceptCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::Socket >, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'connectionRequest'), param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'newConnectionCreated')])
-    ## socket.h (module 'network'): bool ns3::Socket::SetAllowBroadcast(bool allowBroadcast) [member function]
-    cls.add_method('SetAllowBroadcast', 
-                   'bool', 
-                   [param('bool', 'allowBroadcast')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::Socket::SetCloseCallbacks(ns3::Callback<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> normalClose, ns3::Callback<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> errorClose) [member function]
-    cls.add_method('SetCloseCallbacks', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'normalClose'), param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'errorClose')])
-    ## socket.h (module 'network'): void ns3::Socket::SetConnectCallback(ns3::Callback<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> connectionSucceeded, ns3::Callback<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> connectionFailed) [member function]
-    cls.add_method('SetConnectCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'connectionSucceeded'), param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'connectionFailed')])
-    ## socket.h (module 'network'): void ns3::Socket::SetDataSentCallback(ns3::Callback<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> dataSent) [member function]
-    cls.add_method('SetDataSentCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'dataSent')])
-    ## socket.h (module 'network'): void ns3::Socket::SetIpRecvTos(bool ipv4RecvTos) [member function]
-    cls.add_method('SetIpRecvTos', 
-                   'void', 
-                   [param('bool', 'ipv4RecvTos')])
-    ## socket.h (module 'network'): void ns3::Socket::SetIpRecvTtl(bool ipv4RecvTtl) [member function]
-    cls.add_method('SetIpRecvTtl', 
-                   'void', 
-                   [param('bool', 'ipv4RecvTtl')])
-    ## socket.h (module 'network'): void ns3::Socket::SetIpTos(uint8_t ipTos) [member function]
-    cls.add_method('SetIpTos', 
-                   'void', 
-                   [param('uint8_t', 'ipTos')])
-    ## socket.h (module 'network'): void ns3::Socket::SetIpTtl(uint8_t ipTtl) [member function]
-    cls.add_method('SetIpTtl', 
-                   'void', 
-                   [param('uint8_t', 'ipTtl')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): void ns3::Socket::SetIpv6HopLimit(uint8_t ipHopLimit) [member function]
-    cls.add_method('SetIpv6HopLimit', 
-                   'void', 
-                   [param('uint8_t', 'ipHopLimit')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): void ns3::Socket::SetIpv6RecvHopLimit(bool ipv6RecvHopLimit) [member function]
-    cls.add_method('SetIpv6RecvHopLimit', 
-                   'void', 
-                   [param('bool', 'ipv6RecvHopLimit')])
-    ## socket.h (module 'network'): void ns3::Socket::SetIpv6RecvTclass(bool ipv6RecvTclass) [member function]
-    cls.add_method('SetIpv6RecvTclass', 
-                   'void', 
-                   [param('bool', 'ipv6RecvTclass')])
-    ## socket.h (module 'network'): void ns3::Socket::SetIpv6Tclass(int ipTclass) [member function]
-    cls.add_method('SetIpv6Tclass', 
-                   'void', 
-                   [param('int', 'ipTclass')])
-    ## socket.h (module 'network'): void ns3::Socket::SetPriority(uint8_t priority) [member function]
-    cls.add_method('SetPriority', 
-                   'void', 
-                   [param('uint8_t', 'priority')])
-    ## socket.h (module 'network'): void ns3::Socket::SetRecvCallback(ns3::Callback<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> arg0) [member function]
-    cls.add_method('SetRecvCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'arg0')])
-    ## socket.h (module 'network'): void ns3::Socket::SetRecvPktInfo(bool flag) [member function]
-    cls.add_method('SetRecvPktInfo', 
-                   'void', 
-                   [param('bool', 'flag')])
-    ## socket.h (module 'network'): void ns3::Socket::SetSendCallback(ns3::Callback<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> sendCb) [member function]
-    cls.add_method('SetSendCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Socket >, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'sendCb')])
-    ## socket.h (module 'network'): int ns3::Socket::ShutdownRecv() [member function]
-    cls.add_method('ShutdownRecv', 
-                   'int', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): int ns3::Socket::ShutdownSend() [member function]
-    cls.add_method('ShutdownSend', 
-                   'int', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::Socket::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## socket.h (module 'network'): bool ns3::Socket::IsManualIpTtl() const [member function]
-    cls.add_method('IsManualIpTtl', 
-                   'bool', 
-                   [], 
-                   is_const=True, visibility='protected')
-    ## socket.h (module 'network'): bool ns3::Socket::IsManualIpv6HopLimit() const [member function]
-    cls.add_method('IsManualIpv6HopLimit', 
-                   'bool', 
-                   [], 
-                   is_const=True, visibility='protected')
-    ## socket.h (module 'network'): bool ns3::Socket::IsManualIpv6Tclass() const [member function]
-    cls.add_method('IsManualIpv6Tclass', 
-                   'bool', 
-                   [], 
-                   is_const=True, visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifyConnectionFailed() [member function]
-    cls.add_method('NotifyConnectionFailed', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## socket.h (module 'network'): bool ns3::Socket::NotifyConnectionRequest(ns3::Address const & from) [member function]
-    cls.add_method('NotifyConnectionRequest', 
-                   'bool', 
-                   [param('ns3::Address const &', 'from')], 
-                   visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifyConnectionSucceeded() [member function]
-    cls.add_method('NotifyConnectionSucceeded', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifyDataRecv() [member function]
-    cls.add_method('NotifyDataRecv', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifyDataSent(uint32_t size) [member function]
-    cls.add_method('NotifyDataSent', 
-                   'void', 
-                   [param('uint32_t', 'size')], 
-                   visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifyErrorClose() [member function]
-    cls.add_method('NotifyErrorClose', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifyNewConnectionCreated(ns3::Ptr<ns3::Socket> socket, ns3::Address const & from) [member function]
-    cls.add_method('NotifyNewConnectionCreated', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket'), param('ns3::Address const &', 'from')], 
-                   visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifyNormalClose() [member function]
-    cls.add_method('NotifyNormalClose', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## socket.h (module 'network'): void ns3::Socket::NotifySend(uint32_t spaceAvailable) [member function]
-    cls.add_method('NotifySend', 
-                   'void', 
-                   [param('uint32_t', 'spaceAvailable')], 
-                   visibility='protected')
-    return
-
-def register_Ns3SocketIpTosTag_methods(root_module, cls):
-    ## socket.h (module 'network'): ns3::SocketIpTosTag::SocketIpTosTag(ns3::SocketIpTosTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SocketIpTosTag const &', 'arg0')])
-    ## socket.h (module 'network'): ns3::SocketIpTosTag::SocketIpTosTag() [constructor]
-    cls.add_constructor([])
-    ## socket.h (module 'network'): void ns3::SocketIpTosTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): ns3::TypeId ns3::SocketIpTosTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint32_t ns3::SocketIpTosTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::SocketIpTosTag::GetTos() const [member function]
-    cls.add_method('GetTos', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): static ns3::TypeId ns3::SocketIpTosTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## socket.h (module 'network'): void ns3::SocketIpTosTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpTosTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpTosTag::SetTos(uint8_t tos) [member function]
-    cls.add_method('SetTos', 
-                   'void', 
-                   [param('uint8_t', 'tos')])
-    return
-
-def register_Ns3SocketIpTtlTag_methods(root_module, cls):
-    ## socket.h (module 'network'): ns3::SocketIpTtlTag::SocketIpTtlTag(ns3::SocketIpTtlTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SocketIpTtlTag const &', 'arg0')])
-    ## socket.h (module 'network'): ns3::SocketIpTtlTag::SocketIpTtlTag() [constructor]
-    cls.add_constructor([])
-    ## socket.h (module 'network'): void ns3::SocketIpTtlTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): ns3::TypeId ns3::SocketIpTtlTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint32_t ns3::SocketIpTtlTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::SocketIpTtlTag::GetTtl() const [member function]
-    cls.add_method('GetTtl', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): static ns3::TypeId ns3::SocketIpTtlTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## socket.h (module 'network'): void ns3::SocketIpTtlTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpTtlTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpTtlTag::SetTtl(uint8_t ttl) [member function]
-    cls.add_method('SetTtl', 
-                   'void', 
-                   [param('uint8_t', 'ttl')])
-    return
-
-def register_Ns3SocketIpv6HopLimitTag_methods(root_module, cls):
-    ## socket.h (module 'network'): ns3::SocketIpv6HopLimitTag::SocketIpv6HopLimitTag(ns3::SocketIpv6HopLimitTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SocketIpv6HopLimitTag const &', 'arg0')])
-    ## socket.h (module 'network'): ns3::SocketIpv6HopLimitTag::SocketIpv6HopLimitTag() [constructor]
-    cls.add_constructor([])
-    ## socket.h (module 'network'): void ns3::SocketIpv6HopLimitTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::SocketIpv6HopLimitTag::GetHopLimit() const [member function]
-    cls.add_method('GetHopLimit', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): ns3::TypeId ns3::SocketIpv6HopLimitTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint32_t ns3::SocketIpv6HopLimitTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): static ns3::TypeId ns3::SocketIpv6HopLimitTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## socket.h (module 'network'): void ns3::SocketIpv6HopLimitTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpv6HopLimitTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpv6HopLimitTag::SetHopLimit(uint8_t hopLimit) [member function]
-    cls.add_method('SetHopLimit', 
-                   'void', 
-                   [param('uint8_t', 'hopLimit')])
-    return
-
-def register_Ns3SocketIpv6TclassTag_methods(root_module, cls):
-    ## socket.h (module 'network'): ns3::SocketIpv6TclassTag::SocketIpv6TclassTag(ns3::SocketIpv6TclassTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SocketIpv6TclassTag const &', 'arg0')])
-    ## socket.h (module 'network'): ns3::SocketIpv6TclassTag::SocketIpv6TclassTag() [constructor]
-    cls.add_constructor([])
-    ## socket.h (module 'network'): void ns3::SocketIpv6TclassTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): ns3::TypeId ns3::SocketIpv6TclassTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint32_t ns3::SocketIpv6TclassTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::SocketIpv6TclassTag::GetTclass() const [member function]
-    cls.add_method('GetTclass', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): static ns3::TypeId ns3::SocketIpv6TclassTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## socket.h (module 'network'): void ns3::SocketIpv6TclassTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpv6TclassTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketIpv6TclassTag::SetTclass(uint8_t tclass) [member function]
-    cls.add_method('SetTclass', 
-                   'void', 
-                   [param('uint8_t', 'tclass')])
-    return
-
-def register_Ns3SocketPriorityTag_methods(root_module, cls):
-    ## socket.h (module 'network'): ns3::SocketPriorityTag::SocketPriorityTag(ns3::SocketPriorityTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SocketPriorityTag const &', 'arg0')])
-    ## socket.h (module 'network'): ns3::SocketPriorityTag::SocketPriorityTag() [constructor]
-    cls.add_constructor([])
-    ## socket.h (module 'network'): void ns3::SocketPriorityTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): ns3::TypeId ns3::SocketPriorityTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint8_t ns3::SocketPriorityTag::GetPriority() const [member function]
-    cls.add_method('GetPriority', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): uint32_t ns3::SocketPriorityTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): static ns3::TypeId ns3::SocketPriorityTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## socket.h (module 'network'): void ns3::SocketPriorityTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketPriorityTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketPriorityTag::SetPriority(uint8_t priority) [member function]
-    cls.add_method('SetPriority', 
-                   'void', 
-                   [param('uint8_t', 'priority')])
-    return
-
-def register_Ns3SocketSetDontFragmentTag_methods(root_module, cls):
-    ## socket.h (module 'network'): ns3::SocketSetDontFragmentTag::SocketSetDontFragmentTag(ns3::SocketSetDontFragmentTag const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SocketSetDontFragmentTag const &', 'arg0')])
-    ## socket.h (module 'network'): ns3::SocketSetDontFragmentTag::SocketSetDontFragmentTag() [constructor]
-    cls.add_constructor([])
-    ## socket.h (module 'network'): void ns3::SocketSetDontFragmentTag::Deserialize(ns3::TagBuffer i) [member function]
-    cls.add_method('Deserialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketSetDontFragmentTag::Disable() [member function]
-    cls.add_method('Disable', 
-                   'void', 
-                   [])
-    ## socket.h (module 'network'): void ns3::SocketSetDontFragmentTag::Enable() [member function]
-    cls.add_method('Enable', 
-                   'void', 
-                   [])
-    ## socket.h (module 'network'): ns3::TypeId ns3::SocketSetDontFragmentTag::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): uint32_t ns3::SocketSetDontFragmentTag::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): static ns3::TypeId ns3::SocketSetDontFragmentTag::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## socket.h (module 'network'): bool ns3::SocketSetDontFragmentTag::IsEnabled() const [member function]
-    cls.add_method('IsEnabled', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## socket.h (module 'network'): void ns3::SocketSetDontFragmentTag::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## socket.h (module 'network'): void ns3::SocketSetDontFragmentTag::Serialize(ns3::TagBuffer i) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::TagBuffer', 'i')], 
-                   is_const=True, is_virtual=True)
-    return
-
-def register_Ns3SpectrumInterference_methods(root_module, cls):
-    ## spectrum-interference.h (module 'spectrum'): ns3::SpectrumInterference::SpectrumInterference() [constructor]
-    cls.add_constructor([])
-    ## spectrum-interference.h (module 'spectrum'): static ns3::TypeId ns3::SpectrumInterference::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## spectrum-interference.h (module 'spectrum'): void ns3::SpectrumInterference::SetErrorModel(ns3::Ptr<ns3::SpectrumErrorModel> e) [member function]
-    cls.add_method('SetErrorModel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumErrorModel >', 'e')])
-    ## spectrum-interference.h (module 'spectrum'): void ns3::SpectrumInterference::StartRx(ns3::Ptr<const ns3::Packet> p, ns3::Ptr<const ns3::SpectrumValue> rxPsd) [member function]
-    cls.add_method('StartRx', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet const >', 'p'), param('ns3::Ptr< ns3::SpectrumValue const >', 'rxPsd')])
-    ## spectrum-interference.h (module 'spectrum'): void ns3::SpectrumInterference::AbortRx() [member function]
-    cls.add_method('AbortRx', 
-                   'void', 
-                   [])
-    ## spectrum-interference.h (module 'spectrum'): bool ns3::SpectrumInterference::EndRx() [member function]
-    cls.add_method('EndRx', 
-                   'bool', 
-                   [])
-    ## spectrum-interference.h (module 'spectrum'): void ns3::SpectrumInterference::AddSignal(ns3::Ptr<const ns3::SpectrumValue> spd, ns3::Time const duration) [member function]
-    cls.add_method('AddSignal', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'spd'), param('ns3::Time const', 'duration')])
-    ## spectrum-interference.h (module 'spectrum'): void ns3::SpectrumInterference::SetNoisePowerSpectralDensity(ns3::Ptr<const ns3::SpectrumValue> noisePsd) [member function]
-    cls.add_method('SetNoisePowerSpectralDensity', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'noisePsd')])
-    ## spectrum-interference.h (module 'spectrum'): ns3::SpectrumInterference::SpectrumInterference(ns3::SpectrumInterference const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SpectrumInterference const &', 'arg0')])
-    ## spectrum-interference.h (module 'spectrum'): void ns3::SpectrumInterference::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3SpectrumModel_methods(root_module, cls):
-    cls.add_binary_comparison_operator('==')
-    ## spectrum-model.h (module 'spectrum'): ns3::SpectrumModel::SpectrumModel(ns3::SpectrumModel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SpectrumModel const &', 'arg0')])
-    ## spectrum-model.h (module 'spectrum'): ns3::SpectrumModel::SpectrumModel(std::vector<double, std::allocator<double> > centerFreqs) [constructor]
-    cls.add_constructor([param('std::vector< double >', 'centerFreqs')])
-    ## spectrum-model.h (module 'spectrum'): ns3::SpectrumModel::SpectrumModel(ns3::Bands bands) [constructor]
-    cls.add_constructor([param('ns3::Bands', 'bands')])
-    ## spectrum-model.h (module 'spectrum'): std::vector<ns3::BandInfo, std::allocator<ns3::BandInfo> >::const_iterator ns3::SpectrumModel::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'std::vector< ns3::BandInfo > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## spectrum-model.h (module 'spectrum'): std::vector<ns3::BandInfo, std::allocator<ns3::BandInfo> >::const_iterator ns3::SpectrumModel::End() const [member function]
-    cls.add_method('End', 
-                   'std::vector< ns3::BandInfo > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## spectrum-model.h (module 'spectrum'): size_t ns3::SpectrumModel::GetNumBands() const [member function]
-    cls.add_method('GetNumBands', 
-                   'size_t', 
-                   [], 
-                   is_const=True)
-    ## spectrum-model.h (module 'spectrum'): ns3::SpectrumModelUid_t ns3::SpectrumModel::GetUid() const [member function]
-    cls.add_method('GetUid', 
-                   'ns3::SpectrumModelUid_t', 
-                   [], 
-                   is_const=True)
-    ## spectrum-model.h (module 'spectrum'): bool ns3::SpectrumModel::IsOrthogonal(ns3::SpectrumModel const & other) const [member function]
-    cls.add_method('IsOrthogonal', 
-                   'bool', 
-                   [param('ns3::SpectrumModel const &', 'other')], 
-                   is_const=True)
-    return
-
-def register_Ns3SpectrumPhy_methods(root_module, cls):
-    ## spectrum-phy.h (module 'spectrum'): ns3::SpectrumPhy::SpectrumPhy() [constructor]
-    cls.add_constructor([])
-    ## spectrum-phy.h (module 'spectrum'): static ns3::TypeId ns3::SpectrumPhy::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## spectrum-phy.h (module 'spectrum'): void ns3::SpectrumPhy::SetDevice(ns3::Ptr<ns3::NetDevice> d) [member function]
-    cls.add_method('SetDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'd')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-phy.h (module 'spectrum'): ns3::Ptr<ns3::NetDevice> ns3::SpectrumPhy::GetDevice() const [member function]
-    cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## spectrum-phy.h (module 'spectrum'): void ns3::SpectrumPhy::SetMobility(ns3::Ptr<ns3::MobilityModel> m) [member function]
-    cls.add_method('SetMobility', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::MobilityModel >', 'm')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-phy.h (module 'spectrum'): ns3::Ptr<ns3::MobilityModel> ns3::SpectrumPhy::GetMobility() [member function]
-    cls.add_method('GetMobility', 
-                   'ns3::Ptr< ns3::MobilityModel >', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-phy.h (module 'spectrum'): void ns3::SpectrumPhy::SetChannel(ns3::Ptr<ns3::SpectrumChannel> c) [member function]
-    cls.add_method('SetChannel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumChannel >', 'c')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-phy.h (module 'spectrum'): ns3::Ptr<const ns3::SpectrumModel> ns3::SpectrumPhy::GetRxSpectrumModel() const [member function]
-    cls.add_method('GetRxSpectrumModel', 
-                   'ns3::Ptr< ns3::SpectrumModel const >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## spectrum-phy.h (module 'spectrum'): ns3::Ptr<ns3::AntennaModel> ns3::SpectrumPhy::GetRxAntenna() [member function]
-    cls.add_method('GetRxAntenna', 
-                   'ns3::Ptr< ns3::AntennaModel >', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-phy.h (module 'spectrum'): void ns3::SpectrumPhy::StartRx(ns3::Ptr<ns3::SpectrumSignalParameters> params) [member function]
-    cls.add_method('StartRx', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumSignalParameters >', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3SpectrumPropagationLossModel_methods(root_module, cls):
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): ns3::SpectrumPropagationLossModel::SpectrumPropagationLossModel(ns3::SpectrumPropagationLossModel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SpectrumPropagationLossModel const &', 'arg0')])
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): ns3::SpectrumPropagationLossModel::SpectrumPropagationLossModel() [constructor]
-    cls.add_constructor([])
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): ns3::Ptr<ns3::SpectrumValue> ns3::SpectrumPropagationLossModel::CalcRxPowerSpectralDensity(ns3::Ptr<const ns3::SpectrumValue> txPsd, ns3::Ptr<const ns3::MobilityModel> a, ns3::Ptr<const ns3::MobilityModel> b) const [member function]
-    cls.add_method('CalcRxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'txPsd'), param('ns3::Ptr< ns3::MobilityModel const >', 'a'), param('ns3::Ptr< ns3::MobilityModel const >', 'b')], 
-                   is_const=True)
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): static ns3::TypeId ns3::SpectrumPropagationLossModel::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): void ns3::SpectrumPropagationLossModel::SetNext(ns3::Ptr<ns3::SpectrumPropagationLossModel> next) [member function]
-    cls.add_method('SetNext', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumPropagationLossModel >', 'next')])
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): void ns3::SpectrumPropagationLossModel::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## spectrum-propagation-loss-model.h (module 'spectrum'): ns3::Ptr<ns3::SpectrumValue> ns3::SpectrumPropagationLossModel::DoCalcRxPowerSpectralDensity(ns3::Ptr<const ns3::SpectrumValue> txPsd, ns3::Ptr<const ns3::MobilityModel> a, ns3::Ptr<const ns3::MobilityModel> b) const [member function]
-    cls.add_method('DoCalcRxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'txPsd'), param('ns3::Ptr< ns3::MobilityModel const >', 'a'), param('ns3::Ptr< ns3::MobilityModel const >', 'b')], 
-                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
-    return
-
-def register_Ns3SpectrumSignalParameters_methods(root_module, cls):
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::SpectrumSignalParameters::SpectrumSignalParameters() [constructor]
-    cls.add_constructor([])
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::SpectrumSignalParameters::SpectrumSignalParameters(ns3::SpectrumSignalParameters const & p) [constructor]
-    cls.add_constructor([param('ns3::SpectrumSignalParameters const &', 'p')])
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::Ptr<ns3::SpectrumSignalParameters> ns3::SpectrumSignalParameters::Copy() [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::SpectrumSignalParameters >', 
-                   [], 
-                   is_virtual=True)
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::SpectrumSignalParameters::psd [variable]
-    cls.add_instance_attribute('psd', 'ns3::Ptr< ns3::SpectrumValue >', is_const=False)
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::SpectrumSignalParameters::duration [variable]
-    cls.add_instance_attribute('duration', 'ns3::Time', is_const=False)
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::SpectrumSignalParameters::txPhy [variable]
-    cls.add_instance_attribute('txPhy', 'ns3::Ptr< ns3::SpectrumPhy >', is_const=False)
-    ## spectrum-signal-parameters.h (module 'spectrum'): ns3::SpectrumSignalParameters::txAntenna [variable]
-    cls.add_instance_attribute('txAntenna', 'ns3::Ptr< ns3::AntennaModel >', is_const=False)
-    return
-
-def register_Ns3SpectrumValue_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    cls.add_unary_numeric_operator('-')
-    cls.add_binary_numeric_operator('/', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('double', u'right'))
-    cls.add_binary_numeric_operator('/', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('ns3::SpectrumValue const &', u'right'))
-    cls.add_binary_numeric_operator('*', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('double', u'right'))
-    cls.add_binary_numeric_operator('*', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('ns3::SpectrumValue const &', u'right'))
-    cls.add_binary_numeric_operator('-', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('double', u'right'))
-    cls.add_binary_numeric_operator('-', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('ns3::SpectrumValue const &', u'right'))
-    cls.add_binary_numeric_operator('+', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('double', u'right'))
-    cls.add_binary_numeric_operator('+', root_module['ns3::SpectrumValue'], root_module['ns3::SpectrumValue'], param('ns3::SpectrumValue const &', u'right'))
-    cls.add_inplace_numeric_operator('*=', param('ns3::SpectrumValue const &', u'right'))
-    cls.add_inplace_numeric_operator('*=', param('double', u'right'))
-    cls.add_inplace_numeric_operator('+=', param('ns3::SpectrumValue const &', u'right'))
-    cls.add_inplace_numeric_operator('+=', param('double', u'right'))
-    cls.add_inplace_numeric_operator('-=', param('ns3::SpectrumValue const &', u'right'))
-    cls.add_inplace_numeric_operator('-=', param('double', u'right'))
-    cls.add_inplace_numeric_operator('/=', param('ns3::SpectrumValue const &', u'right'))
-    cls.add_inplace_numeric_operator('/=', param('double', u'right'))
-    ## spectrum-value.h (module 'spectrum'): ns3::SpectrumValue::SpectrumValue(ns3::SpectrumValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SpectrumValue const &', 'arg0')])
-    ## spectrum-value.h (module 'spectrum'): ns3::SpectrumValue::SpectrumValue(ns3::Ptr<const ns3::SpectrumModel> sm) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::SpectrumModel const >', 'sm')])
-    ## spectrum-value.h (module 'spectrum'): ns3::SpectrumValue::SpectrumValue() [constructor]
-    cls.add_constructor([])
-    ## spectrum-value.h (module 'spectrum'): std::vector<ns3::BandInfo, std::allocator<ns3::BandInfo> >::const_iterator ns3::SpectrumValue::ConstBandsBegin() const [member function]
-    cls.add_method('ConstBandsBegin', 
-                   'std::vector< ns3::BandInfo > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## spectrum-value.h (module 'spectrum'): std::vector<ns3::BandInfo, std::allocator<ns3::BandInfo> >::const_iterator ns3::SpectrumValue::ConstBandsEnd() const [member function]
-    cls.add_method('ConstBandsEnd', 
-                   'std::vector< ns3::BandInfo > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## spectrum-value.h (module 'spectrum'): std::vector<double, std::allocator<double> >::const_iterator ns3::SpectrumValue::ConstValuesBegin() const [member function]
-    cls.add_method('ConstValuesBegin', 
-                   'std::vector< double > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## spectrum-value.h (module 'spectrum'): std::vector<double, std::allocator<double> >::const_iterator ns3::SpectrumValue::ConstValuesEnd() const [member function]
-    cls.add_method('ConstValuesEnd', 
-                   'std::vector< double > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## spectrum-value.h (module 'spectrum'): ns3::Ptr<ns3::SpectrumValue> ns3::SpectrumValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [], 
-                   is_const=True)
-    ## spectrum-value.h (module 'spectrum'): ns3::Ptr<const ns3::SpectrumModel> ns3::SpectrumValue::GetSpectrumModel() const [member function]
-    cls.add_method('GetSpectrumModel', 
-                   'ns3::Ptr< ns3::SpectrumModel const >', 
-                   [], 
-                   is_const=True)
-    ## spectrum-value.h (module 'spectrum'): ns3::SpectrumModelUid_t ns3::SpectrumValue::GetSpectrumModelUid() const [member function]
-    cls.add_method('GetSpectrumModelUid', 
-                   'ns3::SpectrumModelUid_t', 
-                   [], 
-                   is_const=True)
-    ## spectrum-value.h (module 'spectrum'): std::vector<double, std::allocator<double> >::iterator ns3::SpectrumValue::ValuesBegin() [member function]
-    cls.add_method('ValuesBegin', 
-                   'std::vector< double > iterator', 
-                   [])
-    ## spectrum-value.h (module 'spectrum'): std::vector<double, std::allocator<double> >::iterator ns3::SpectrumValue::ValuesEnd() [member function]
-    cls.add_method('ValuesEnd', 
-                   'std::vector< double > iterator', 
-                   [])
-    return
-
-def register_Ns3Time_methods(root_module, cls):
-    cls.add_binary_comparison_operator('==')
-    cls.add_binary_comparison_operator('!=')
-    cls.add_binary_comparison_operator('<=')
-    cls.add_binary_comparison_operator('>=')
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('>')
-    cls.add_binary_numeric_operator('+', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', u'right'))
-    cls.add_binary_numeric_operator('-', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', u'right'))
-    cls.add_binary_numeric_operator('*', root_module['ns3::Time'], root_module['ns3::Time'], param('int64_t const &', u'right'))
-    cls.add_binary_numeric_operator('/', root_module['ns3::Time'], root_module['ns3::Time'], param('int64_t const &', u'right'))
-    cls.add_inplace_numeric_operator('+=', param('ns3::Time const &', u'right'))
-    cls.add_inplace_numeric_operator('-=', param('ns3::Time const &', u'right'))
-    cls.add_output_stream_operator()
-    ## nstime.h (module 'core'): ns3::Time::Time() [constructor]
-    cls.add_constructor([])
-    ## nstime.h (module 'core'): ns3::Time::Time(ns3::Time const & o) [constructor]
-    cls.add_constructor([param('ns3::Time const &', 'o')])
-    ## nstime.h (module 'core'): ns3::Time::Time(double v) [constructor]
-    cls.add_constructor([param('double', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(int v) [constructor]
-    cls.add_constructor([param('int', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(long int v) [constructor]
-    cls.add_constructor([param('long int', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(long long int v) [constructor]
-    cls.add_constructor([param('long long int', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(unsigned int v) [constructor]
-    cls.add_constructor([param('unsigned int', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(long unsigned int v) [constructor]
-    cls.add_constructor([param('long unsigned int', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(long long unsigned int v) [constructor]
-    cls.add_constructor([param('long long unsigned int', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(ns3::int64x64_t const & v) [constructor]
-    cls.add_constructor([param('ns3::int64x64_t const &', 'v')])
-    ## nstime.h (module 'core'): ns3::Time::Time(std::string const & s) [constructor]
-    cls.add_constructor([param('std::string const &', 's')])
-    ## nstime.h (module 'core'): ns3::TimeWithUnit ns3::Time::As(ns3::Time::Unit const unit) const [member function]
-    cls.add_method('As', 
-                   'ns3::TimeWithUnit', 
-                   [param('ns3::Time::Unit const', 'unit')], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int ns3::Time::Compare(ns3::Time const & o) const [member function]
-    cls.add_method('Compare', 
-                   'int', 
-                   [param('ns3::Time const &', 'o')], 
-                   is_const=True)
-    ## nstime.h (module 'core'): static ns3::Time ns3::Time::From(ns3::int64x64_t const & value) [member function]
-    cls.add_method('From', 
-                   'ns3::Time', 
-                   [param('ns3::int64x64_t const &', 'value')], 
-                   is_static=True)
-    ## nstime.h (module 'core'): static ns3::Time ns3::Time::From(ns3::int64x64_t const & value, ns3::Time::Unit unit) [member function]
-    cls.add_method('From', 
-                   'ns3::Time', 
-                   [param('ns3::int64x64_t const &', 'value'), param('ns3::Time::Unit', 'unit')], 
-                   is_static=True)
-    ## nstime.h (module 'core'): static ns3::Time ns3::Time::FromDouble(double value, ns3::Time::Unit unit) [member function]
-    cls.add_method('FromDouble', 
-                   'ns3::Time', 
-                   [param('double', 'value'), param('ns3::Time::Unit', 'unit')], 
-                   is_static=True)
-    ## nstime.h (module 'core'): static ns3::Time ns3::Time::FromInteger(uint64_t value, ns3::Time::Unit unit) [member function]
-    cls.add_method('FromInteger', 
-                   'ns3::Time', 
-                   [param('uint64_t', 'value'), param('ns3::Time::Unit', 'unit')], 
-                   is_static=True)
-    ## nstime.h (module 'core'): double ns3::Time::GetDays() const [member function]
-    cls.add_method('GetDays', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): double ns3::Time::GetDouble() const [member function]
-    cls.add_method('GetDouble', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::GetFemtoSeconds() const [member function]
-    cls.add_method('GetFemtoSeconds', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): double ns3::Time::GetHours() const [member function]
-    cls.add_method('GetHours', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::GetInteger() const [member function]
-    cls.add_method('GetInteger', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::GetMicroSeconds() const [member function]
-    cls.add_method('GetMicroSeconds', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::GetMilliSeconds() const [member function]
-    cls.add_method('GetMilliSeconds', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): double ns3::Time::GetMinutes() const [member function]
-    cls.add_method('GetMinutes', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::GetNanoSeconds() const [member function]
-    cls.add_method('GetNanoSeconds', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::GetPicoSeconds() const [member function]
-    cls.add_method('GetPicoSeconds', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): static ns3::Time::Unit ns3::Time::GetResolution() [member function]
-    cls.add_method('GetResolution', 
-                   'ns3::Time::Unit', 
-                   [], 
-                   is_static=True)
-    ## nstime.h (module 'core'): double ns3::Time::GetSeconds() const [member function]
-    cls.add_method('GetSeconds', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::GetTimeStep() const [member function]
-    cls.add_method('GetTimeStep', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): double ns3::Time::GetYears() const [member function]
-    cls.add_method('GetYears', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): bool ns3::Time::IsNegative() const [member function]
-    cls.add_method('IsNegative', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): bool ns3::Time::IsPositive() const [member function]
-    cls.add_method('IsPositive', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): bool ns3::Time::IsStrictlyNegative() const [member function]
-    cls.add_method('IsStrictlyNegative', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): bool ns3::Time::IsStrictlyPositive() const [member function]
-    cls.add_method('IsStrictlyPositive', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): bool ns3::Time::IsZero() const [member function]
-    cls.add_method('IsZero', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): static ns3::Time ns3::Time::Max() [member function]
-    cls.add_method('Max', 
-                   'ns3::Time', 
-                   [], 
-                   is_static=True)
-    ## nstime.h (module 'core'): static ns3::Time ns3::Time::Min() [member function]
-    cls.add_method('Min', 
-                   'ns3::Time', 
-                   [], 
-                   is_static=True)
-    ## nstime.h (module 'core'): static void ns3::Time::SetResolution(ns3::Time::Unit resolution) [member function]
-    cls.add_method('SetResolution', 
-                   'void', 
-                   [param('ns3::Time::Unit', 'resolution')], 
-                   is_static=True)
-    ## nstime.h (module 'core'): static bool ns3::Time::StaticInit() [member function]
-    cls.add_method('StaticInit', 
-                   'bool', 
-                   [], 
-                   is_static=True)
-    ## nstime.h (module 'core'): ns3::int64x64_t ns3::Time::To(ns3::Time::Unit unit) const [member function]
-    cls.add_method('To', 
-                   'ns3::int64x64_t', 
-                   [param('ns3::Time::Unit', 'unit')], 
-                   is_const=True)
-    ## nstime.h (module 'core'): double ns3::Time::ToDouble(ns3::Time::Unit unit) const [member function]
-    cls.add_method('ToDouble', 
-                   'double', 
-                   [param('ns3::Time::Unit', 'unit')], 
-                   is_const=True)
-    ## nstime.h (module 'core'): int64_t ns3::Time::ToInteger(ns3::Time::Unit unit) const [member function]
-    cls.add_method('ToInteger', 
-                   'int64_t', 
-                   [param('ns3::Time::Unit', 'unit')], 
-                   is_const=True)
-    return
-
-def register_Ns3TraceFadingLossModel_methods(root_module, cls):
-    ## trace-fading-loss-model.h (module 'lte'): ns3::TraceFadingLossModel::TraceFadingLossModel(ns3::TraceFadingLossModel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TraceFadingLossModel const &', 'arg0')])
-    ## trace-fading-loss-model.h (module 'lte'): ns3::TraceFadingLossModel::TraceFadingLossModel() [constructor]
-    cls.add_constructor([])
-    ## trace-fading-loss-model.h (module 'lte'): int64_t ns3::TraceFadingLossModel::AssignStreams(int64_t stream) [member function]
-    cls.add_method('AssignStreams', 
-                   'int64_t', 
-                   [param('int64_t', 'stream')])
-    ## trace-fading-loss-model.h (module 'lte'): void ns3::TraceFadingLossModel::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## trace-fading-loss-model.h (module 'lte'): static ns3::TypeId ns3::TraceFadingLossModel::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## trace-fading-loss-model.h (module 'lte'): ns3::Ptr<ns3::SpectrumValue> ns3::TraceFadingLossModel::DoCalcRxPowerSpectralDensity(ns3::Ptr<const ns3::SpectrumValue> txPsd, ns3::Ptr<const ns3::MobilityModel> a, ns3::Ptr<const ns3::MobilityModel> b) const [member function]
-    cls.add_method('DoCalcRxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'txPsd'), param('ns3::Ptr< ns3::MobilityModel const >', 'a'), param('ns3::Ptr< ns3::MobilityModel const >', 'b')], 
-                   is_const=True, visibility='private', is_virtual=True)
-    return
-
-def register_Ns3TraceSourceAccessor_methods(root_module, cls):
-    ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor::TraceSourceAccessor(ns3::TraceSourceAccessor const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TraceSourceAccessor const &', 'arg0')])
-    ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor::TraceSourceAccessor() [constructor]
-    cls.add_constructor([])
-    ## trace-source-accessor.h (module 'core'): bool ns3::TraceSourceAccessor::Connect(ns3::ObjectBase * obj, std::string context, ns3::CallbackBase const & cb) const [member function]
-    cls.add_method('Connect', 
-                   'bool', 
-                   [param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## trace-source-accessor.h (module 'core'): bool ns3::TraceSourceAccessor::ConnectWithoutContext(ns3::ObjectBase * obj, ns3::CallbackBase const & cb) const [member function]
-    cls.add_method('ConnectWithoutContext', 
-                   'bool', 
-                   [param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## trace-source-accessor.h (module 'core'): bool ns3::TraceSourceAccessor::Disconnect(ns3::ObjectBase * obj, std::string context, ns3::CallbackBase const & cb) const [member function]
-    cls.add_method('Disconnect', 
-                   'bool', 
-                   [param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## trace-source-accessor.h (module 'core'): bool ns3::TraceSourceAccessor::DisconnectWithoutContext(ns3::ObjectBase * obj, ns3::CallbackBase const & cb) const [member function]
-    cls.add_method('DisconnectWithoutContext', 
-                   'bool', 
-                   [param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3Trailer_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## trailer.h (module 'network'): ns3::Trailer::Trailer() [constructor]
-    cls.add_constructor([])
-    ## trailer.h (module 'network'): ns3::Trailer::Trailer(ns3::Trailer const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Trailer const &', 'arg0')])
-    ## trailer.h (module 'network'): uint32_t ns3::Trailer::Deserialize(ns3::Buffer::Iterator end) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'end')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## trailer.h (module 'network'): uint32_t ns3::Trailer::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## trailer.h (module 'network'): static ns3::TypeId ns3::Trailer::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## trailer.h (module 'network'): void ns3::Trailer::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## trailer.h (module 'network'): void ns3::Trailer::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3TriangularRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::TriangularRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::TriangularRandomVariable::TriangularRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::TriangularRandomVariable::GetMean() const [member function]
-    cls.add_method('GetMean', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::TriangularRandomVariable::GetMin() const [member function]
-    cls.add_method('GetMin', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::TriangularRandomVariable::GetMax() const [member function]
-    cls.add_method('GetMax', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::TriangularRandomVariable::GetValue(double mean, double min, double max) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'mean'), param('double', 'min'), param('double', 'max')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::TriangularRandomVariable::GetInteger(uint32_t mean, uint32_t min, uint32_t max) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'mean'), param('uint32_t', 'min'), param('uint32_t', 'max')])
-    ## random-variable-stream.h (module 'core'): double ns3::TriangularRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::TriangularRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3UeManager_methods(root_module, cls):
-    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::UeManager(ns3::UeManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UeManager const &', 'arg0')])
-    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::UeManager() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::UeManager(ns3::Ptr<ns3::LteEnbRrc> rrc, uint16_t rnti, ns3::UeManager::State s, uint8_t componentCarrierId) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::LteEnbRrc >', 'rrc'), param('uint16_t', 'rnti'), param('ns3::UeManager::State', 's'), param('uint8_t', 'componentCarrierId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::CmacUeConfigUpdateInd(ns3::LteEnbCmacSapUser::UeConfig cmacParams) [member function]
-    cls.add_method('CmacUeConfigUpdateInd', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapUser::UeConfig', 'cmacParams')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::CompleteSetupUe(ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters params) [member function]
-    cls.add_method('CompleteSetupUe', 
-                   'void', 
-                   [param('ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters', 'params')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::DoReceivePdcpSdu(ns3::LtePdcpSapUser::ReceivePdcpSduParameters params) [member function]
-    cls.add_method('DoReceivePdcpSdu', 
-                   'void', 
-                   [param('ns3::LtePdcpSapUser::ReceivePdcpSduParameters', 'params')])
-    ## lte-enb-rrc.h (module 'lte'): uint8_t ns3::UeManager::GetComponentCarrierId() const [member function]
-    cls.add_method('GetComponentCarrierId', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-rrc.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > ns3::UeManager::GetErabList() [member function]
-    cls.add_method('GetErabList', 
-                   'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): uint64_t ns3::UeManager::GetImsi() const [member function]
-    cls.add_method('GetImsi', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated ns3::UeManager::GetRadioResourceConfigForHandoverPreparationInfo() [member function]
-    cls.add_method('GetRadioResourceConfigForHandoverPreparationInfo', 
-                   'ns3::LteRrcSap::RadioResourceConfigDedicated', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::UeManager::GetRnti() const [member function]
-    cls.add_method('GetRnti', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration ns3::UeManager::GetRrcConnectionReconfigurationForHandover() [member function]
-    cls.add_method('GetRrcConnectionReconfigurationForHandover', 
-                   'ns3::LteRrcSap::RrcConnectionReconfiguration', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::UeManager::GetSrsConfigurationIndex() const [member function]
-    cls.add_method('GetSrsConfigurationIndex', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::State ns3::UeManager::GetState() const [member function]
-    cls.add_method('GetState', 
-                   'ns3::UeManager::State', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-rrc.h (module 'lte'): static ns3::TypeId ns3::UeManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::PrepareHandover(uint16_t cellId) [member function]
-    cls.add_method('PrepareHandover', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecordDataRadioBearersToBeStarted() [member function]
-    cls.add_method('RecordDataRadioBearersToBeStarted', 
-                   'void', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvHandoverPreparationFailure(uint16_t cellId) [member function]
-    cls.add_method('RecvHandoverPreparationFailure', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvHandoverRequestAck(ns3::EpcX2Sap::HandoverRequestAckParams params) [member function]
-    cls.add_method('RecvHandoverRequestAck', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestAckParams', 'params')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvMeasurementReport(ns3::LteRrcSap::MeasurementReport msg) [member function]
-    cls.add_method('RecvMeasurementReport', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MeasurementReport', 'msg')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcConnectionReconfigurationCompleted(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
-    cls.add_method('RecvRrcConnectionReconfigurationCompleted', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReconfigurationCompleted', 'msg')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcConnectionReestablishmentComplete(ns3::LteRrcSap::RrcConnectionReestablishmentComplete msg) [member function]
-    cls.add_method('RecvRrcConnectionReestablishmentComplete', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentComplete', 'msg')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcConnectionReestablishmentRequest(ns3::LteRrcSap::RrcConnectionReestablishmentRequest msg) [member function]
-    cls.add_method('RecvRrcConnectionReestablishmentRequest', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentRequest', 'msg')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcConnectionRequest(ns3::LteRrcSap::RrcConnectionRequest msg) [member function]
-    cls.add_method('RecvRrcConnectionRequest', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionRequest', 'msg')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcConnectionSetupCompleted(ns3::LteRrcSap::RrcConnectionSetupCompleted msg) [member function]
-    cls.add_method('RecvRrcConnectionSetupCompleted', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
-    cls.add_method('RecvSnStatusTransfer', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
-    cls.add_method('RecvUeContextRelease', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::UeContextReleaseParams', 'params')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::ReleaseDataRadioBearer(uint8_t drbid) [member function]
-    cls.add_method('ReleaseDataRadioBearer', 
-                   'void', 
-                   [param('uint8_t', 'drbid')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::ScheduleRrcConnectionReconfiguration() [member function]
-    cls.add_method('ScheduleRrcConnectionReconfiguration', 
-                   'void', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SendData(uint8_t bid, ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('SendData', 
-                   'void', 
-                   [param('uint8_t', 'bid'), param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SendUeContextRelease() [member function]
-    cls.add_method('SendUeContextRelease', 
-                   'void', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetImsi(uint64_t imsi) [member function]
-    cls.add_method('SetImsi', 
-                   'void', 
-                   [param('uint64_t', 'imsi')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetPdschConfigDedicated(ns3::LteRrcSap::PdschConfigDedicated pdschConfigDedicated) [member function]
-    cls.add_method('SetPdschConfigDedicated', 
-                   'void', 
-                   [param('ns3::LteRrcSap::PdschConfigDedicated', 'pdschConfigDedicated')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetSource(uint16_t sourceCellId, uint16_t sourceX2apId) [member function]
-    cls.add_method('SetSource', 
-                   'void', 
-                   [param('uint16_t', 'sourceCellId'), param('uint16_t', 'sourceX2apId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetSrsConfigurationIndex(uint16_t srsConfIndex) [member function]
-    cls.add_method('SetSrsConfigurationIndex', 
-                   'void', 
-                   [param('uint16_t', 'srsConfIndex')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetupDataRadioBearer(ns3::EpsBearer bearer, uint8_t bearerId, uint32_t gtpTeid, ns3::Ipv4Address transportLayerAddress) [member function]
-    cls.add_method('SetupDataRadioBearer', 
-                   'void', 
-                   [param('ns3::EpsBearer', 'bearer'), param('uint8_t', 'bearerId'), param('uint32_t', 'gtpTeid'), param('ns3::Ipv4Address', 'transportLayerAddress')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::StartDataRadioBearers() [member function]
-    cls.add_method('StartDataRadioBearers', 
-                   'void', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3UniformRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::UniformRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::UniformRandomVariable::UniformRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::UniformRandomVariable::GetMin() const [member function]
-    cls.add_method('GetMin', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::UniformRandomVariable::GetMax() const [member function]
-    cls.add_method('GetMax', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::UniformRandomVariable::GetValue(double min, double max) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'min'), param('double', 'max')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::UniformRandomVariable::GetInteger(uint32_t min, uint32_t max) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'min'), param('uint32_t', 'max')])
-    ## random-variable-stream.h (module 'core'): double ns3::UniformRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::UniformRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3VendorSpecificValue_methods(root_module, cls):
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificValue::VendorSpecificValue() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificValue::VendorSpecificValue(ns3::VendorSpecificValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::VendorSpecificValue const &', 'arg0')])
-    return
-
-def register_Ns3WeibullRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::WeibullRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::WeibullRandomVariable::WeibullRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::WeibullRandomVariable::GetScale() const [member function]
-    cls.add_method('GetScale', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::WeibullRandomVariable::GetShape() const [member function]
-    cls.add_method('GetShape', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::WeibullRandomVariable::GetBound() const [member function]
-    cls.add_method('GetBound', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::WeibullRandomVariable::GetValue(double scale, double shape, double bound) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'scale'), param('double', 'shape'), param('double', 'bound')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::WeibullRandomVariable::GetInteger(uint32_t scale, uint32_t shape, uint32_t bound) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'scale'), param('uint32_t', 'shape'), param('uint32_t', 'bound')])
-    ## random-variable-stream.h (module 'core'): double ns3::WeibullRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::WeibullRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3X2CellInfo_methods(root_module, cls):
-    ## epc-x2.h (module 'lte'): ns3::X2CellInfo::X2CellInfo(ns3::X2CellInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::X2CellInfo const &', 'arg0')])
-    ## epc-x2.h (module 'lte'): ns3::X2CellInfo::X2CellInfo(uint16_t localCellId, uint16_t remoteCellId) [constructor]
-    cls.add_constructor([param('uint16_t', 'localCellId'), param('uint16_t', 'remoteCellId')])
-    ## epc-x2.h (module 'lte'): ns3::X2CellInfo::m_localCellId [variable]
-    cls.add_instance_attribute('m_localCellId', 'uint16_t', is_const=False)
-    ## epc-x2.h (module 'lte'): ns3::X2CellInfo::m_remoteCellId [variable]
-    cls.add_instance_attribute('m_remoteCellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3X2IfaceInfo_methods(root_module, cls):
-    ## epc-x2.h (module 'lte'): ns3::X2IfaceInfo::X2IfaceInfo(ns3::X2IfaceInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::X2IfaceInfo const &', 'arg0')])
-    ## epc-x2.h (module 'lte'): ns3::X2IfaceInfo::X2IfaceInfo(ns3::Ipv4Address remoteIpAddr, ns3::Ptr<ns3::Socket> localCtrlPlaneSocket, ns3::Ptr<ns3::Socket> localUserPlaneSocket) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Address', 'remoteIpAddr'), param('ns3::Ptr< ns3::Socket >', 'localCtrlPlaneSocket'), param('ns3::Ptr< ns3::Socket >', 'localUserPlaneSocket')])
-    ## epc-x2.h (module 'lte'): ns3::X2IfaceInfo::m_localCtrlPlaneSocket [variable]
-    cls.add_instance_attribute('m_localCtrlPlaneSocket', 'ns3::Ptr< ns3::Socket >', is_const=False)
-    ## epc-x2.h (module 'lte'): ns3::X2IfaceInfo::m_localUserPlaneSocket [variable]
-    cls.add_instance_attribute('m_localUserPlaneSocket', 'ns3::Ptr< ns3::Socket >', is_const=False)
-    ## epc-x2.h (module 'lte'): ns3::X2IfaceInfo::m_remoteIpAddr [variable]
-    cls.add_instance_attribute('m_remoteIpAddr', 'ns3::Ipv4Address', is_const=False)
-    return
-
-def register_Ns3ZetaRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ZetaRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::ZetaRandomVariable::ZetaRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::ZetaRandomVariable::GetAlpha() const [member function]
-    cls.add_method('GetAlpha', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ZetaRandomVariable::GetValue(double alpha) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'alpha')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ZetaRandomVariable::GetInteger(uint32_t alpha) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'alpha')])
-    ## random-variable-stream.h (module 'core'): double ns3::ZetaRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ZetaRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3ZipfRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ZipfRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::ZipfRandomVariable::ZipfRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ZipfRandomVariable::GetN() const [member function]
-    cls.add_method('GetN', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ZipfRandomVariable::GetAlpha() const [member function]
-    cls.add_method('GetAlpha', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ZipfRandomVariable::GetValue(uint32_t n, double alpha) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('uint32_t', 'n'), param('double', 'alpha')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ZipfRandomVariable::GetInteger(uint32_t n, uint32_t alpha) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'n'), param('uint32_t', 'alpha')])
-    ## random-variable-stream.h (module 'core'): double ns3::ZipfRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ZipfRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3Application_methods(root_module, cls):
-    ## application.h (module 'network'): ns3::Application::Application(ns3::Application const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Application const &', 'arg0')])
-    ## application.h (module 'network'): ns3::Application::Application() [constructor]
-    cls.add_constructor([])
-    ## application.h (module 'network'): ns3::Ptr<ns3::Node> ns3::Application::GetNode() const [member function]
-    cls.add_method('GetNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_const=True)
-    ## application.h (module 'network'): static ns3::TypeId ns3::Application::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## application.h (module 'network'): void ns3::Application::SetNode(ns3::Ptr<ns3::Node> node) [member function]
-    cls.add_method('SetNode', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'node')])
-    ## application.h (module 'network'): void ns3::Application::SetStartTime(ns3::Time start) [member function]
-    cls.add_method('SetStartTime', 
-                   'void', 
-                   [param('ns3::Time', 'start')])
-    ## application.h (module 'network'): void ns3::Application::SetStopTime(ns3::Time stop) [member function]
-    cls.add_method('SetStopTime', 
-                   'void', 
-                   [param('ns3::Time', 'stop')])
-    ## application.h (module 'network'): void ns3::Application::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## application.h (module 'network'): void ns3::Application::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## application.h (module 'network'): void ns3::Application::StartApplication() [member function]
-    cls.add_method('StartApplication', 
-                   'void', 
-                   [], 
-                   visibility='private', is_virtual=True)
-    ## application.h (module 'network'): void ns3::Application::StopApplication() [member function]
-    cls.add_method('StopApplication', 
-                   'void', 
-                   [], 
-                   visibility='private', is_virtual=True)
-    return
-
-def register_Ns3Asn1Header_methods(root_module, cls):
-    ## lte-asn1-header.h (module 'lte'): ns3::Asn1Header::Asn1Header(ns3::Asn1Header const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Asn1Header const &', 'arg0')])
-    ## lte-asn1-header.h (module 'lte'): ns3::Asn1Header::Asn1Header() [constructor]
-    cls.add_constructor([])
-    ## lte-asn1-header.h (module 'lte'): uint32_t ns3::Asn1Header::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-asn1-header.h (module 'lte'): ns3::TypeId ns3::Asn1Header::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-asn1-header.h (module 'lte'): uint32_t ns3::Asn1Header::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-asn1-header.h (module 'lte'): static ns3::TypeId ns3::Asn1Header::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::Serialize(ns3::Buffer::Iterator bIterator) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_const=True, is_virtual=True)
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitset(std::bitset<8> * data, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitset', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 8 > *', 'data'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<1> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 1 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<2> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 2 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<8> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 8 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<10> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 10 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<16> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 16 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<27> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 27 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<28> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 28 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBitstring(std::bitset<32> * bitstring, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBitstring', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 32 > *', 'bitstring'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeBoolean(bool * value, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeBoolean', 
-                   'ns3::Buffer::Iterator', 
-                   [param('bool *', 'value'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeChoice(int numOptions, bool isExtensionMarkerPresent, int * selectedOption, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeChoice', 
-                   'ns3::Buffer::Iterator', 
-                   [param('int', 'numOptions'), param('bool', 'isExtensionMarkerPresent'), param('int *', 'selectedOption'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeEnum(int numElems, int * selectedElem, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeEnum', 
-                   'ns3::Buffer::Iterator', 
-                   [param('int', 'numElems'), param('int *', 'selectedElem'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeInteger(int * n, int nmin, int nmax, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeInteger', 
-                   'ns3::Buffer::Iterator', 
-                   [param('int *', 'n'), param('int', 'nmin'), param('int', 'nmax'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeNull(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeNull', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<0> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 0 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<1> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 1 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<2> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 2 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<3> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 3 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<4> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 4 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<5> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 5 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<6> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 6 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<7> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 7 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<9> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 9 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<10> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 10 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequence(std::bitset<11> * optionalOrDefaultMask, bool isExtensionMarkerPresent, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequence', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::bitset< 11 > *', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): ns3::Buffer::Iterator ns3::Asn1Header::DeserializeSequenceOf(int * numElems, int nMax, int nMin, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSequenceOf', 
-                   'ns3::Buffer::Iterator', 
-                   [param('int *', 'numElems'), param('int', 'nMax'), param('int', 'nMin'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::FinalizeSerialization() const [member function]
-    cls.add_method('FinalizeSerialization', 
-                   'void', 
-                   [], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<1> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 1 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<2> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 2 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<8> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 8 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<10> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 10 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<16> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 16 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<27> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 27 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<28> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 28 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBitstring(std::bitset<32> bitstring) const [member function]
-    cls.add_method('SerializeBitstring', 
-                   'void', 
-                   [param('std::bitset< 32 >', 'bitstring')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeBoolean(bool value) const [member function]
-    cls.add_method('SerializeBoolean', 
-                   'void', 
-                   [param('bool', 'value')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeChoice(int numOptions, int selectedOption, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeChoice', 
-                   'void', 
-                   [param('int', 'numOptions'), param('int', 'selectedOption'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeEnum(int numElems, int selectedElem) const [member function]
-    cls.add_method('SerializeEnum', 
-                   'void', 
-                   [param('int', 'numElems'), param('int', 'selectedElem')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeInteger(int n, int nmin, int nmax) const [member function]
-    cls.add_method('SerializeInteger', 
-                   'void', 
-                   [param('int', 'n'), param('int', 'nmin'), param('int', 'nmax')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeNull() const [member function]
-    cls.add_method('SerializeNull', 
-                   'void', 
-                   [], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<0> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 0 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<1> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 1 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<2> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 2 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<3> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 3 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<4> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 4 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<5> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 5 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<6> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 6 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<7> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 7 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<9> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 9 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<10> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 10 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequence(std::bitset<11> optionalOrDefaultMask, bool isExtensionMarkerPresent) const [member function]
-    cls.add_method('SerializeSequence', 
-                   'void', 
-                   [param('std::bitset< 11 >', 'optionalOrDefaultMask'), param('bool', 'isExtensionMarkerPresent')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::SerializeSequenceOf(int numElems, int nMax, int nMin) const [member function]
-    cls.add_method('SerializeSequenceOf', 
-                   'void', 
-                   [param('int', 'numElems'), param('int', 'nMax'), param('int', 'nMin')], 
-                   is_const=True, visibility='protected')
-    ## lte-asn1-header.h (module 'lte'): void ns3::Asn1Header::WriteOctet(uint8_t octet) const [member function]
-    cls.add_method('WriteOctet', 
-                   'void', 
-                   [param('uint8_t', 'octet')], 
-                   is_const=True, visibility='protected')
-    return
-
-def register_Ns3AttributeAccessor_methods(root_module, cls):
-    ## attribute.h (module 'core'): ns3::AttributeAccessor::AttributeAccessor(ns3::AttributeAccessor const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AttributeAccessor const &', 'arg0')])
-    ## attribute.h (module 'core'): ns3::AttributeAccessor::AttributeAccessor() [constructor]
-    cls.add_constructor([])
-    ## attribute.h (module 'core'): bool ns3::AttributeAccessor::Get(ns3::ObjectBase const * object, ns3::AttributeValue & attribute) const [member function]
-    cls.add_method('Get', 
-                   'bool', 
-                   [param('ns3::ObjectBase const *', 'object'), param('ns3::AttributeValue &', 'attribute')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::AttributeAccessor::HasGetter() const [member function]
-    cls.add_method('HasGetter', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::AttributeAccessor::HasSetter() const [member function]
-    cls.add_method('HasSetter', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::AttributeAccessor::Set(ns3::ObjectBase * object, ns3::AttributeValue const & value) const [member function]
-    cls.add_method('Set', 
-                   'bool', 
-                   [param('ns3::ObjectBase *', 'object', transfer_ownership=False), param('ns3::AttributeValue const &', 'value')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3AttributeChecker_methods(root_module, cls):
-    ## attribute.h (module 'core'): ns3::AttributeChecker::AttributeChecker(ns3::AttributeChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AttributeChecker const &', 'arg0')])
-    ## attribute.h (module 'core'): ns3::AttributeChecker::AttributeChecker() [constructor]
-    cls.add_constructor([])
-    ## attribute.h (module 'core'): bool ns3::AttributeChecker::Check(ns3::AttributeValue const & value) const [member function]
-    cls.add_method('Check', 
-                   'bool', 
-                   [param('ns3::AttributeValue const &', 'value')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::AttributeChecker::Copy(ns3::AttributeValue const & source, ns3::AttributeValue & destination) const [member function]
-    cls.add_method('Copy', 
-                   'bool', 
-                   [param('ns3::AttributeValue const &', 'source'), param('ns3::AttributeValue &', 'destination')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::AttributeChecker::Create() const [member function]
-    cls.add_method('Create', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::AttributeChecker::CreateValidValue(ns3::AttributeValue const & value) const [member function]
-    cls.add_method('CreateValidValue', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [param('ns3::AttributeValue const &', 'value')], 
-                   is_const=True)
-    ## attribute.h (module 'core'): std::string ns3::AttributeChecker::GetUnderlyingTypeInformation() const [member function]
-    cls.add_method('GetUnderlyingTypeInformation', 
-                   'std::string', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): std::string ns3::AttributeChecker::GetValueTypeName() const [member function]
-    cls.add_method('GetValueTypeName', 
-                   'std::string', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::AttributeChecker::HasUnderlyingTypeInformation() const [member function]
-    cls.add_method('HasUnderlyingTypeInformation', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3AttributeValue_methods(root_module, cls):
-    ## attribute.h (module 'core'): ns3::AttributeValue::AttributeValue(ns3::AttributeValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AttributeValue const &', 'arg0')])
-    ## attribute.h (module 'core'): ns3::AttributeValue::AttributeValue() [constructor]
-    cls.add_constructor([])
-    ## attribute.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::AttributeValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::AttributeValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## attribute.h (module 'core'): std::string ns3::AttributeValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3BooleanChecker_methods(root_module, cls):
-    ## boolean.h (module 'core'): ns3::BooleanChecker::BooleanChecker() [constructor]
-    cls.add_constructor([])
-    ## boolean.h (module 'core'): ns3::BooleanChecker::BooleanChecker(ns3::BooleanChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BooleanChecker const &', 'arg0')])
-    return
-
-def register_Ns3BooleanValue_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## boolean.h (module 'core'): ns3::BooleanValue::BooleanValue(ns3::BooleanValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BooleanValue const &', 'arg0')])
-    ## boolean.h (module 'core'): ns3::BooleanValue::BooleanValue() [constructor]
-    cls.add_constructor([])
-    ## boolean.h (module 'core'): ns3::BooleanValue::BooleanValue(bool value) [constructor]
-    cls.add_constructor([param('bool', 'value')])
-    ## boolean.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::BooleanValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## boolean.h (module 'core'): bool ns3::BooleanValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## boolean.h (module 'core'): bool ns3::BooleanValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## boolean.h (module 'core'): std::string ns3::BooleanValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## boolean.h (module 'core'): void ns3::BooleanValue::Set(bool value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('bool', 'value')])
-    return
-
-def register_Ns3CallbackChecker_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackChecker::CallbackChecker() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackChecker::CallbackChecker(ns3::CallbackChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackChecker const &', 'arg0')])
-    return
-
-def register_Ns3CallbackImplBase_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImplBase::CallbackImplBase() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImplBase::CallbackImplBase(ns3::CallbackImplBase const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImplBase const &', 'arg0')])
-    ## callback.h (module 'core'): std::string ns3::CallbackImplBase::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): bool ns3::CallbackImplBase::IsEqual(ns3::Ptr<const ns3::CallbackImplBase> other) const [member function]
-    cls.add_method('IsEqual', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::CallbackImplBase const >', 'other')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::Demangle(std::string const & mangled) [member function]
-    cls.add_method('Demangle', 
-                   'std::string', 
-                   [param('std::string const &', 'mangled')], 
-                   is_static=True, visibility='protected')
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::ObjectBase*'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'void'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::NetDevice> '])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet const> '])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned short'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Address const&'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::NetDevice::PacketType'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::MobilityModel const> '])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::PacketBurst const> '])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::PhyReceptionStatParameters'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'double'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned char'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::SpectrumValue> '])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::PhyTransmissionStatParameters'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::LteUePhy::State'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'bool'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Socket> '])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned int'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet> '])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::EpcUeNas::State'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::SpectrumValue const&'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned long long'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::UeManager::State'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::LteRrcSap::MeasurementReport'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::DlSchedulingCallbackInfo'])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
-    cls.add_method('GetCppTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::LteUeRrc::State'])
-    return
-
-def register_Ns3CallbackValue_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackValue::CallbackValue(ns3::CallbackValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackValue const &', 'arg0')])
-    ## callback.h (module 'core'): ns3::CallbackValue::CallbackValue() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackValue::CallbackValue(ns3::CallbackBase const & base) [constructor]
-    cls.add_constructor([param('ns3::CallbackBase const &', 'base')])
-    ## callback.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::CallbackValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): bool ns3::CallbackValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackValue::Set(ns3::CallbackBase base) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::CallbackBase', 'base')])
-    return
-
-def register_Ns3CcHelper_methods(root_module, cls):
-    ## cc-helper.h (module 'lte'): ns3::CcHelper::CcHelper(ns3::CcHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CcHelper const &', 'arg0')])
-    ## cc-helper.h (module 'lte'): ns3::CcHelper::CcHelper() [constructor]
-    cls.add_constructor([])
-    ## cc-helper.h (module 'lte'): ns3::ComponentCarrier ns3::CcHelper::DoCreateSingleCc(uint16_t ulBandwidth, uint16_t dlBandwidth, uint32_t ulEarfcn, uint32_t dlEarfcn, bool isPrimary) [member function]
-    cls.add_method('DoCreateSingleCc', 
-                   'ns3::ComponentCarrier', 
-                   [param('uint16_t', 'ulBandwidth'), param('uint16_t', 'dlBandwidth'), param('uint32_t', 'ulEarfcn'), param('uint32_t', 'dlEarfcn'), param('bool', 'isPrimary')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## cc-helper.h (module 'lte'): std::map<unsigned char, ns3::ComponentCarrier, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::ComponentCarrier> > > ns3::CcHelper::EquallySpacedCcs() [member function]
-    cls.add_method('EquallySpacedCcs', 
-                   'std::map< unsigned char, ns3::ComponentCarrier >', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint16_t ns3::CcHelper::GetDlBandwidth() [member function]
-    cls.add_method('GetDlBandwidth', 
-                   'uint16_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint32_t ns3::CcHelper::GetDlEarfcn() [member function]
-    cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint16_t ns3::CcHelper::GetNumberOfComponentCarriers() [member function]
-    cls.add_method('GetNumberOfComponentCarriers', 
-                   'uint16_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): static ns3::TypeId ns3::CcHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## cc-helper.h (module 'lte'): uint16_t ns3::CcHelper::GetUlBandwidth() [member function]
-    cls.add_method('GetUlBandwidth', 
-                   'uint16_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint32_t ns3::CcHelper::GetUlEarfcn() [member function]
-    cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetCcAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetCcAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetDlBandwidth(uint16_t dlBandwidth) [member function]
-    cls.add_method('SetDlBandwidth', 
-                   'void', 
-                   [param('uint16_t', 'dlBandwidth')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetDlEarfcn(uint32_t dlEarfcn) [member function]
-    cls.add_method('SetDlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'dlEarfcn')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetNumberOfComponentCarriers(uint16_t nCc) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint16_t', 'nCc')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetUlBandwidth(uint16_t ulBandwidth) [member function]
-    cls.add_method('SetUlBandwidth', 
-                   'void', 
-                   [param('uint16_t', 'ulBandwidth')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetUlEarfcn(uint32_t ulEarfcn) [member function]
-    cls.add_method('SetUlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'ulEarfcn')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3Channel_methods(root_module, cls):
-    ## channel.h (module 'network'): ns3::Channel::Channel(ns3::Channel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Channel const &', 'arg0')])
-    ## channel.h (module 'network'): ns3::Channel::Channel() [constructor]
-    cls.add_constructor([])
-    ## channel.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::Channel::GetDevice(uint32_t i) const [member function]
-    cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [param('uint32_t', 'i')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## channel.h (module 'network'): uint32_t ns3::Channel::GetId() const [member function]
-    cls.add_method('GetId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## channel.h (module 'network'): uint32_t ns3::Channel::GetNDevices() const [member function]
-    cls.add_method('GetNDevices', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## channel.h (module 'network'): static ns3::TypeId ns3::Channel::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    return
-
-def register_Ns3ComponentCarrier_methods(root_module, cls):
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::ComponentCarrier(ns3::ComponentCarrier const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ComponentCarrier const &', 'arg0')])
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::ComponentCarrier() [constructor]
-    cls.add_constructor([])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## component-carrier.h (module 'lte'): uint32_t ns3::ComponentCarrier::GetCsgId() const [member function]
-    cls.add_method('GetCsgId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): bool ns3::ComponentCarrier::GetCsgIndication() const [member function]
-    cls.add_method('GetCsgIndication', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): uint8_t ns3::ComponentCarrier::GetDlBandwidth() const [member function]
-    cls.add_method('GetDlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): uint32_t ns3::ComponentCarrier::GetDlEarfcn() const [member function]
-    cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): static ns3::TypeId ns3::ComponentCarrier::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## component-carrier.h (module 'lte'): uint8_t ns3::ComponentCarrier::GetUlBandwidth() const [member function]
-    cls.add_method('GetUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): uint32_t ns3::ComponentCarrier::GetUlEarfcn() const [member function]
-    cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): bool ns3::ComponentCarrier::IsPrimary() const [member function]
-    cls.add_method('IsPrimary', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetAsPrimary(bool primaryCarrier) [member function]
-    cls.add_method('SetAsPrimary', 
-                   'void', 
-                   [param('bool', 'primaryCarrier')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetCsgId(uint32_t csgId) [member function]
-    cls.add_method('SetCsgId', 
-                   'void', 
-                   [param('uint32_t', 'csgId')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetCsgIndication(bool csgIndication) [member function]
-    cls.add_method('SetCsgIndication', 
-                   'void', 
-                   [param('bool', 'csgIndication')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetDlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetDlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetDlEarfcn(uint32_t earfcn) [member function]
-    cls.add_method('SetDlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetUlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetUlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetUlEarfcn(uint32_t earfcn) [member function]
-    cls.add_method('SetUlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_dlBandwidth [variable]
-    cls.add_instance_attribute('m_dlBandwidth', 'uint8_t', is_const=False)
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_dlEarfcn [variable]
-    cls.add_instance_attribute('m_dlEarfcn', 'uint32_t', is_const=False)
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_ulBandwidth [variable]
-    cls.add_instance_attribute('m_ulBandwidth', 'uint8_t', is_const=False)
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_ulEarfcn [variable]
-    cls.add_instance_attribute('m_ulEarfcn', 'uint32_t', is_const=False)
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ComponentCarrierEnb_methods(root_module, cls):
-    ## component-carrier-enb.h (module 'lte'): ns3::ComponentCarrierEnb::ComponentCarrierEnb(ns3::ComponentCarrierEnb const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ComponentCarrierEnb const &', 'arg0')])
-    ## component-carrier-enb.h (module 'lte'): ns3::ComponentCarrierEnb::ComponentCarrierEnb() [constructor]
-    cls.add_constructor([])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## component-carrier-enb.h (module 'lte'): uint16_t ns3::ComponentCarrierEnb::GetCellId() [member function]
-    cls.add_method('GetCellId', 
-                   'uint16_t', 
-                   [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::FfMacScheduler> ns3::ComponentCarrierEnb::GetFfMacScheduler() [member function]
-    cls.add_method('GetFfMacScheduler', 
-                   'ns3::Ptr< ns3::FfMacScheduler >', 
-                   [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::LteFfrAlgorithm> ns3::ComponentCarrierEnb::GetFfrAlgorithm() [member function]
-    cls.add_method('GetFfrAlgorithm', 
-                   'ns3::Ptr< ns3::LteFfrAlgorithm >', 
-                   [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::LteEnbMac> ns3::ComponentCarrierEnb::GetMac() [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteEnbMac >', 
-                   [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::LteEnbPhy> ns3::ComponentCarrierEnb::GetPhy() [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteEnbPhy >', 
-                   [])
-    ## component-carrier-enb.h (module 'lte'): static ns3::TypeId ns3::ComponentCarrierEnb::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetFfMacScheduler(ns3::Ptr<ns3::FfMacScheduler> s) [member function]
-    cls.add_method('SetFfMacScheduler', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::FfMacScheduler >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetFfrAlgorithm(ns3::Ptr<ns3::LteFfrAlgorithm> s) [member function]
-    cls.add_method('SetFfrAlgorithm', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteFfrAlgorithm >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetMac(ns3::Ptr<ns3::LteEnbMac> s) [member function]
-    cls.add_method('SetMac', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteEnbMac >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetPhy(ns3::Ptr<ns3::LteEnbPhy> s) [member function]
-    cls.add_method('SetPhy', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteEnbPhy >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ComponentCarrierUe_methods(root_module, cls):
-    ## component-carrier-ue.h (module 'lte'): ns3::ComponentCarrierUe::ComponentCarrierUe(ns3::ComponentCarrierUe const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ComponentCarrierUe const &', 'arg0')])
-    ## component-carrier-ue.h (module 'lte'): ns3::ComponentCarrierUe::ComponentCarrierUe() [constructor]
-    cls.add_constructor([])
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## component-carrier-ue.h (module 'lte'): ns3::Ptr<ns3::LteUeMac> ns3::ComponentCarrierUe::GetMac() const [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteUeMac >', 
-                   [], 
-                   is_const=True)
-    ## component-carrier-ue.h (module 'lte'): ns3::Ptr<ns3::LteUePhy> ns3::ComponentCarrierUe::GetPhy() const [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteUePhy >', 
-                   [], 
-                   is_const=True)
-    ## component-carrier-ue.h (module 'lte'): static ns3::TypeId ns3::ComponentCarrierUe::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::SetMac(ns3::Ptr<ns3::LteUeMac> s) [member function]
-    cls.add_method('SetMac', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteUeMac >', 's')])
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::SetPhy(ns3::Ptr<ns3::LteUePhy> s) [member function]
-    cls.add_method('SetPhy', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteUePhy >', 's')])
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ConstantRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ConstantRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::ConstantRandomVariable::ConstantRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::ConstantRandomVariable::GetConstant() const [member function]
-    cls.add_method('GetConstant', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ConstantRandomVariable::GetValue(double constant) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'constant')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ConstantRandomVariable::GetInteger(uint32_t constant) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'constant')])
-    ## random-variable-stream.h (module 'core'): double ns3::ConstantRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ConstantRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3DataCalculator_methods(root_module, cls):
-    ## data-calculator.h (module 'stats'): ns3::DataCalculator::DataCalculator(ns3::DataCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DataCalculator const &', 'arg0')])
-    ## data-calculator.h (module 'stats'): ns3::DataCalculator::DataCalculator() [constructor]
-    cls.add_constructor([])
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::Disable() [member function]
-    cls.add_method('Disable', 
-                   'void', 
-                   [])
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::Enable() [member function]
-    cls.add_method('Enable', 
-                   'void', 
-                   [])
-    ## data-calculator.h (module 'stats'): std::string ns3::DataCalculator::GetContext() const [member function]
-    cls.add_method('GetContext', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## data-calculator.h (module 'stats'): bool ns3::DataCalculator::GetEnabled() const [member function]
-    cls.add_method('GetEnabled', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## data-calculator.h (module 'stats'): std::string ns3::DataCalculator::GetKey() const [member function]
-    cls.add_method('GetKey', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## data-calculator.h (module 'stats'): static ns3::TypeId ns3::DataCalculator::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::Output(ns3::DataOutputCallback & callback) const [member function]
-    cls.add_method('Output', 
-                   'void', 
-                   [param('ns3::DataOutputCallback &', 'callback')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::SetContext(std::string const context) [member function]
-    cls.add_method('SetContext', 
-                   'void', 
-                   [param('std::string const', 'context')])
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::SetKey(std::string const key) [member function]
-    cls.add_method('SetKey', 
-                   'void', 
-                   [param('std::string const', 'key')])
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::Start(ns3::Time const & startTime) [member function]
-    cls.add_method('Start', 
-                   'void', 
-                   [param('ns3::Time const &', 'startTime')], 
-                   is_virtual=True)
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::Stop(ns3::Time const & stopTime) [member function]
-    cls.add_method('Stop', 
-                   'void', 
-                   [param('ns3::Time const &', 'stopTime')], 
-                   is_virtual=True)
-    ## data-calculator.h (module 'stats'): void ns3::DataCalculator::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3DataOutputInterface_methods(root_module, cls):
-    ## data-output-interface.h (module 'stats'): ns3::DataOutputInterface::DataOutputInterface(ns3::DataOutputInterface const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DataOutputInterface const &', 'arg0')])
-    ## data-output-interface.h (module 'stats'): ns3::DataOutputInterface::DataOutputInterface() [constructor]
-    cls.add_constructor([])
-    ## data-output-interface.h (module 'stats'): std::string ns3::DataOutputInterface::GetFilePrefix() const [member function]
-    cls.add_method('GetFilePrefix', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## data-output-interface.h (module 'stats'): static ns3::TypeId ns3::DataOutputInterface::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputInterface::Output(ns3::DataCollector & dc) [member function]
-    cls.add_method('Output', 
-                   'void', 
-                   [param('ns3::DataCollector &', 'dc')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputInterface::SetFilePrefix(std::string const prefix) [member function]
-    cls.add_method('SetFilePrefix', 
-                   'void', 
-                   [param('std::string const', 'prefix')])
-    ## data-output-interface.h (module 'stats'): void ns3::DataOutputInterface::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3DataRateChecker_methods(root_module, cls):
-    ## data-rate.h (module 'network'): ns3::DataRateChecker::DataRateChecker() [constructor]
-    cls.add_constructor([])
-    ## data-rate.h (module 'network'): ns3::DataRateChecker::DataRateChecker(ns3::DataRateChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DataRateChecker const &', 'arg0')])
-    return
-
-def register_Ns3DataRateValue_methods(root_module, cls):
-    ## data-rate.h (module 'network'): ns3::DataRateValue::DataRateValue() [constructor]
-    cls.add_constructor([])
-    ## data-rate.h (module 'network'): ns3::DataRateValue::DataRateValue(ns3::DataRate const & value) [constructor]
-    cls.add_constructor([param('ns3::DataRate const &', 'value')])
-    ## data-rate.h (module 'network'): ns3::DataRateValue::DataRateValue(ns3::DataRateValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DataRateValue const &', 'arg0')])
-    ## data-rate.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::DataRateValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## data-rate.h (module 'network'): bool ns3::DataRateValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## data-rate.h (module 'network'): ns3::DataRate ns3::DataRateValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::DataRate', 
-                   [], 
-                   is_const=True)
-    ## data-rate.h (module 'network'): std::string ns3::DataRateValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## data-rate.h (module 'network'): void ns3::DataRateValue::Set(ns3::DataRate const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::DataRate const &', 'value')])
-    return
-
-def register_Ns3DeterministicRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::DeterministicRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::DeterministicRandomVariable::DeterministicRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::DeterministicRandomVariable::SetValueArray(double * values, uint64_t length) [member function]
-    cls.add_method('SetValueArray', 
-                   'void', 
-                   [param('double *', 'values'), param('uint64_t', 'length')])
-    ## random-variable-stream.h (module 'core'): double ns3::DeterministicRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::DeterministicRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3DoubleValue_methods(root_module, cls):
-    ## double.h (module 'core'): ns3::DoubleValue::DoubleValue() [constructor]
-    cls.add_constructor([])
-    ## double.h (module 'core'): ns3::DoubleValue::DoubleValue(double const & value) [constructor]
-    cls.add_constructor([param('double const &', 'value')])
-    ## double.h (module 'core'): ns3::DoubleValue::DoubleValue(ns3::DoubleValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DoubleValue const &', 'arg0')])
-    ## double.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::DoubleValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## double.h (module 'core'): bool ns3::DoubleValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## double.h (module 'core'): double ns3::DoubleValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## double.h (module 'core'): std::string ns3::DoubleValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## double.h (module 'core'): void ns3::DoubleValue::Set(double const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('double const &', 'value')])
-    return
-
-def register_Ns3EmpiricalRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): ns3::EmpiricalRandomVariable::EmpiricalRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): void ns3::EmpiricalRandomVariable::CDF(double v, double c) [member function]
-    cls.add_method('CDF', 
-                   'void', 
-                   [param('double', 'v'), param('double', 'c')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::EmpiricalRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::EmpiricalRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): double ns3::EmpiricalRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): double ns3::EmpiricalRandomVariable::Interpolate(double c1, double c2, double v1, double v2, double r) [member function]
-    cls.add_method('Interpolate', 
-                   'double', 
-                   [param('double', 'c1'), param('double', 'c2'), param('double', 'v1'), param('double', 'v2'), param('double', 'r')], 
-                   visibility='private', is_virtual=True)
-    ## random-variable-stream.h (module 'core'): void ns3::EmpiricalRandomVariable::Validate() [member function]
-    cls.add_method('Validate', 
-                   'void', 
-                   [], 
-                   visibility='private', is_virtual=True)
-    return
-
-def register_Ns3EmptyAttributeAccessor_methods(root_module, cls):
-    ## attribute.h (module 'core'): ns3::EmptyAttributeAccessor::EmptyAttributeAccessor(ns3::EmptyAttributeAccessor const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EmptyAttributeAccessor const &', 'arg0')])
-    ## attribute.h (module 'core'): ns3::EmptyAttributeAccessor::EmptyAttributeAccessor() [constructor]
-    cls.add_constructor([])
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeAccessor::Get(ns3::ObjectBase const * object, ns3::AttributeValue & attribute) const [member function]
-    cls.add_method('Get', 
-                   'bool', 
-                   [param('ns3::ObjectBase const *', 'object'), param('ns3::AttributeValue &', 'attribute')], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeAccessor::HasGetter() const [member function]
-    cls.add_method('HasGetter', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeAccessor::HasSetter() const [member function]
-    cls.add_method('HasSetter', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeAccessor::Set(ns3::ObjectBase * object, ns3::AttributeValue const & value) const [member function]
-    cls.add_method('Set', 
-                   'bool', 
-                   [param('ns3::ObjectBase *', 'object'), param('ns3::AttributeValue const &', 'value')], 
-                   is_const=True, is_virtual=True)
-    return
-
-def register_Ns3EmptyAttributeChecker_methods(root_module, cls):
-    ## attribute.h (module 'core'): ns3::EmptyAttributeChecker::EmptyAttributeChecker(ns3::EmptyAttributeChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EmptyAttributeChecker const &', 'arg0')])
-    ## attribute.h (module 'core'): ns3::EmptyAttributeChecker::EmptyAttributeChecker() [constructor]
-    cls.add_constructor([])
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeChecker::Check(ns3::AttributeValue const & value) const [member function]
-    cls.add_method('Check', 
-                   'bool', 
-                   [param('ns3::AttributeValue const &', 'value')], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeChecker::Copy(ns3::AttributeValue const & source, ns3::AttributeValue & destination) const [member function]
-    cls.add_method('Copy', 
-                   'bool', 
-                   [param('ns3::AttributeValue const &', 'source'), param('ns3::AttributeValue &', 'destination')], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::EmptyAttributeChecker::Create() const [member function]
-    cls.add_method('Create', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): std::string ns3::EmptyAttributeChecker::GetUnderlyingTypeInformation() const [member function]
-    cls.add_method('GetUnderlyingTypeInformation', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): std::string ns3::EmptyAttributeChecker::GetValueTypeName() const [member function]
-    cls.add_method('GetValueTypeName', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeChecker::HasUnderlyingTypeInformation() const [member function]
-    cls.add_method('HasUnderlyingTypeInformation', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    return
-
-def register_Ns3EmptyAttributeValue_methods(root_module, cls):
-    ## attribute.h (module 'core'): ns3::EmptyAttributeValue::EmptyAttributeValue(ns3::EmptyAttributeValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EmptyAttributeValue const &', 'arg0')])
-    ## attribute.h (module 'core'): ns3::EmptyAttributeValue::EmptyAttributeValue() [constructor]
-    cls.add_constructor([])
-    ## attribute.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::EmptyAttributeValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, visibility='private', is_virtual=True)
-    ## attribute.h (module 'core'): bool ns3::EmptyAttributeValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   visibility='private', is_virtual=True)
-    ## attribute.h (module 'core'): std::string ns3::EmptyAttributeValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, visibility='private', is_virtual=True)
-    return
-
-def register_Ns3EnumChecker_methods(root_module, cls):
-    ## enum.h (module 'core'): ns3::EnumChecker::EnumChecker(ns3::EnumChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EnumChecker const &', 'arg0')])
-    ## enum.h (module 'core'): ns3::EnumChecker::EnumChecker() [constructor]
-    cls.add_constructor([])
-    ## enum.h (module 'core'): void ns3::EnumChecker::Add(int value, std::string name) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('int', 'value'), param('std::string', 'name')])
-    ## enum.h (module 'core'): void ns3::EnumChecker::AddDefault(int value, std::string name) [member function]
-    cls.add_method('AddDefault', 
-                   'void', 
-                   [param('int', 'value'), param('std::string', 'name')])
-    ## enum.h (module 'core'): bool ns3::EnumChecker::Check(ns3::AttributeValue const & value) const [member function]
-    cls.add_method('Check', 
-                   'bool', 
-                   [param('ns3::AttributeValue const &', 'value')], 
-                   is_const=True, is_virtual=True)
-    ## enum.h (module 'core'): bool ns3::EnumChecker::Copy(ns3::AttributeValue const & src, ns3::AttributeValue & dst) const [member function]
-    cls.add_method('Copy', 
-                   'bool', 
-                   [param('ns3::AttributeValue const &', 'src'), param('ns3::AttributeValue &', 'dst')], 
-                   is_const=True, is_virtual=True)
-    ## enum.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::EnumChecker::Create() const [member function]
-    cls.add_method('Create', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## enum.h (module 'core'): std::string ns3::EnumChecker::GetUnderlyingTypeInformation() const [member function]
-    cls.add_method('GetUnderlyingTypeInformation', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## enum.h (module 'core'): std::string ns3::EnumChecker::GetValueTypeName() const [member function]
-    cls.add_method('GetValueTypeName', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## enum.h (module 'core'): bool ns3::EnumChecker::HasUnderlyingTypeInformation() const [member function]
-    cls.add_method('HasUnderlyingTypeInformation', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    return
-
-def register_Ns3EnumValue_methods(root_module, cls):
-    ## enum.h (module 'core'): ns3::EnumValue::EnumValue(ns3::EnumValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EnumValue const &', 'arg0')])
-    ## enum.h (module 'core'): ns3::EnumValue::EnumValue() [constructor]
-    cls.add_constructor([])
-    ## enum.h (module 'core'): ns3::EnumValue::EnumValue(int value) [constructor]
-    cls.add_constructor([param('int', 'value')])
-    ## enum.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::EnumValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## enum.h (module 'core'): bool ns3::EnumValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## enum.h (module 'core'): int ns3::EnumValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'int', 
-                   [], 
-                   is_const=True)
-    ## enum.h (module 'core'): std::string ns3::EnumValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## enum.h (module 'core'): void ns3::EnumValue::Set(int value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('int', 'value')])
-    return
-
-def register_Ns3EpcEnbApplication_methods(root_module, cls):
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpcEnbApplication(ns3::EpcEnbApplication const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbApplication const &', 'arg0')])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpcEnbApplication(ns3::Ptr<ns3::Socket> lteSocket, ns3::Ptr<ns3::Socket> s1uSocket, ns3::Ipv4Address enbS1uAddress, ns3::Ipv4Address sgwS1uAddress, uint16_t cellId) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::Socket >', 'lteSocket'), param('ns3::Ptr< ns3::Socket >', 's1uSocket'), param('ns3::Ipv4Address', 'enbS1uAddress'), param('ns3::Ipv4Address', 'sgwS1uAddress'), param('uint16_t', 'cellId')])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbS1SapProvider * ns3::EpcEnbApplication::GetS1SapProvider() [member function]
-    cls.add_method('GetS1SapProvider', 
-                   'ns3::EpcEnbS1SapProvider *', 
-                   [])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcS1apSapEnb * ns3::EpcEnbApplication::GetS1apSapEnb() [member function]
-    cls.add_method('GetS1apSapEnb', 
-                   'ns3::EpcS1apSapEnb *', 
-                   [])
-    ## epc-enb-application.h (module 'lte'): static ns3::TypeId ns3::EpcEnbApplication::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::RecvFromLteSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromLteSocket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::RecvFromS1uSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromS1uSocket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::SetS1SapUser(ns3::EpcEnbS1SapUser * s) [member function]
-    cls.add_method('SetS1SapUser', 
-                   'void', 
-                   [param('ns3::EpcEnbS1SapUser *', 's')])
-    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::SetS1apSapMme(ns3::EpcS1apSapMme * s) [member function]
-    cls.add_method('SetS1apSapMme', 
-                   'void', 
-                   [param('ns3::EpcS1apSapMme *', 's')])
-    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3EpcEnbApplicationEpsFlowId_t_methods(root_module, cls):
-    cls.add_binary_comparison_operator('<')
-    cls.add_binary_comparison_operator('==')
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpsFlowId_t::EpsFlowId_t(ns3::EpcEnbApplication::EpsFlowId_t const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcEnbApplication::EpsFlowId_t const &', 'arg0')])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpsFlowId_t::EpsFlowId_t() [constructor]
-    cls.add_constructor([])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpsFlowId_t::EpsFlowId_t(uint16_t const a, uint8_t const b) [constructor]
-    cls.add_constructor([param('uint16_t const', 'a'), param('uint8_t const', 'b')])
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpsFlowId_t::m_bid [variable]
-    cls.add_instance_attribute('m_bid', 'uint8_t', is_const=False)
-    ## epc-enb-application.h (module 'lte'): ns3::EpcEnbApplication::EpsFlowId_t::m_rnti [variable]
-    cls.add_instance_attribute('m_rnti', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcHelper_methods(root_module, cls):
-    ## epc-helper.h (module 'lte'): ns3::EpcHelper::EpcHelper(ns3::EpcHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcHelper const &', 'arg0')])
-    ## epc-helper.h (module 'lte'): ns3::EpcHelper::EpcHelper() [constructor]
-    cls.add_constructor([])
-    ## epc-helper.h (module 'lte'): uint8_t ns3::EpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
-    cls.add_method('ActivateEpsBearer', 
-                   'uint8_t', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-helper.h (module 'lte'): void ns3::EpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
-    cls.add_method('AddEnb', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'enbNode'), param('ns3::Ptr< ns3::NetDevice >', 'lteEnbNetDevice'), param('uint16_t', 'cellId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-helper.h (module 'lte'): void ns3::EpcHelper::AddUe(ns3::Ptr<ns3::NetDevice> ueLteDevice, uint64_t imsi) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-helper.h (module 'lte'): void ns3::EpcHelper::AddX2Interface(ns3::Ptr<ns3::Node> enbNode1, ns3::Ptr<ns3::Node> enbNode2) [member function]
-    cls.add_method('AddX2Interface', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'enbNode1'), param('ns3::Ptr< ns3::Node >', 'enbNode2')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-helper.h (module 'lte'): ns3::Ipv4InterfaceContainer ns3::EpcHelper::AssignUeIpv4Address(ns3::NetDeviceContainer ueDevices) [member function]
-    cls.add_method('AssignUeIpv4Address', 
-                   'ns3::Ipv4InterfaceContainer', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-helper.h (module 'lte'): void ns3::EpcHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## epc-helper.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::EpcHelper::GetPgwNode() [member function]
-    cls.add_method('GetPgwNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-helper.h (module 'lte'): static ns3::TypeId ns3::EpcHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-helper.h (module 'lte'): ns3::Ipv4Address ns3::EpcHelper::GetUeDefaultGatewayAddress() [member function]
-    cls.add_method('GetUeDefaultGatewayAddress', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3EpcMme_methods(root_module, cls):
-    ## epc-mme.h (module 'lte'): ns3::EpcMme::EpcMme(ns3::EpcMme const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcMme const &', 'arg0')])
-    ## epc-mme.h (module 'lte'): ns3::EpcMme::EpcMme() [constructor]
-    cls.add_constructor([])
-    ## epc-mme.h (module 'lte'): uint8_t ns3::EpcMme::AddBearer(uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
-    cls.add_method('AddBearer', 
-                   'uint8_t', 
-                   [param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')])
-    ## epc-mme.h (module 'lte'): void ns3::EpcMme::AddEnb(uint16_t ecgi, ns3::Ipv4Address enbS1UAddr, ns3::EpcS1apSapEnb * enbS1apSap) [member function]
-    cls.add_method('AddEnb', 
-                   'void', 
-                   [param('uint16_t', 'ecgi'), param('ns3::Ipv4Address', 'enbS1UAddr'), param('ns3::EpcS1apSapEnb *', 'enbS1apSap')])
-    ## epc-mme.h (module 'lte'): void ns3::EpcMme::AddUe(uint64_t imsi) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('uint64_t', 'imsi')])
-    ## epc-mme.h (module 'lte'): ns3::EpcS11SapMme * ns3::EpcMme::GetS11SapMme() [member function]
-    cls.add_method('GetS11SapMme', 
-                   'ns3::EpcS11SapMme *', 
-                   [])
-    ## epc-mme.h (module 'lte'): ns3::EpcS1apSapMme * ns3::EpcMme::GetS1apSapMme() [member function]
-    cls.add_method('GetS1apSapMme', 
-                   'ns3::EpcS1apSapMme *', 
-                   [])
-    ## epc-mme.h (module 'lte'): static ns3::TypeId ns3::EpcMme::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-mme.h (module 'lte'): void ns3::EpcMme::SetS11SapSgw(ns3::EpcS11SapSgw * s) [member function]
-    cls.add_method('SetS11SapSgw', 
-                   'void', 
-                   [param('ns3::EpcS11SapSgw *', 's')])
-    ## epc-mme.h (module 'lte'): void ns3::EpcMme::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3EpcSgwPgwApplication_methods(root_module, cls):
-    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication::EpcSgwPgwApplication(ns3::EpcSgwPgwApplication const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcSgwPgwApplication const &', 'arg0')])
-    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication::EpcSgwPgwApplication(ns3::Ptr<ns3::VirtualNetDevice> const tunDevice, ns3::Ptr<ns3::Socket> const s1uSocket) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::VirtualNetDevice > const', 'tunDevice'), param('ns3::Ptr< ns3::Socket > const', 's1uSocket')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::AddEnb(uint16_t cellId, ns3::Ipv4Address enbAddr, ns3::Ipv4Address sgwAddr) [member function]
-    cls.add_method('AddEnb', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::Ipv4Address', 'enbAddr'), param('ns3::Ipv4Address', 'sgwAddr')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::AddUe(uint64_t imsi) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('uint64_t', 'imsi')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcS11SapSgw * ns3::EpcSgwPgwApplication::GetS11SapSgw() [member function]
-    cls.add_method('GetS11SapSgw', 
-                   'ns3::EpcS11SapSgw *', 
-                   [])
-    ## epc-sgw-pgw-application.h (module 'lte'): static ns3::TypeId ns3::EpcSgwPgwApplication::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::RecvFromS1uSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromS1uSocket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-sgw-pgw-application.h (module 'lte'): bool ns3::EpcSgwPgwApplication::RecvFromTunDevice(ns3::Ptr<ns3::Packet> packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('RecvFromTunDevice', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SendToS1uSocket(ns3::Ptr<ns3::Packet> packet, ns3::Ipv4Address enbS1uAddress, uint32_t teid) [member function]
-    cls.add_method('SendToS1uSocket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Ipv4Address', 'enbS1uAddress'), param('uint32_t', 'teid')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SendToTunDevice(ns3::Ptr<ns3::Packet> packet, uint32_t teid) [member function]
-    cls.add_method('SendToTunDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('uint32_t', 'teid')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SetS11SapMme(ns3::EpcS11SapMme * s) [member function]
-    cls.add_method('SetS11SapMme', 
-                   'void', 
-                   [param('ns3::EpcS11SapMme *', 's')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SetUeAddress(uint64_t imsi, ns3::Ipv4Address ueAddr) [member function]
-    cls.add_method('SetUeAddress', 
-                   'void', 
-                   [param('uint64_t', 'imsi'), param('ns3::Ipv4Address', 'ueAddr')])
-    return
-
-def register_Ns3EpcTft_methods(root_module, cls):
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::EpcTft(ns3::EpcTft const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcTft const &', 'arg0')])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::EpcTft() [constructor]
-    cls.add_constructor([])
-    ## epc-tft.h (module 'lte'): uint8_t ns3::EpcTft::Add(ns3::EpcTft::PacketFilter f) [member function]
-    cls.add_method('Add', 
-                   'uint8_t', 
-                   [param('ns3::EpcTft::PacketFilter', 'f')])
-    ## epc-tft.h (module 'lte'): static ns3::Ptr<ns3::EpcTft> ns3::EpcTft::Default() [member function]
-    cls.add_method('Default', 
-                   'ns3::Ptr< ns3::EpcTft >', 
-                   [], 
-                   is_static=True)
-    ## epc-tft.h (module 'lte'): bool ns3::EpcTft::Matches(ns3::EpcTft::Direction direction, ns3::Ipv4Address remoteAddress, ns3::Ipv4Address localAddress, uint16_t remotePort, uint16_t localPort, uint8_t typeOfService) [member function]
-    cls.add_method('Matches', 
-                   'bool', 
-                   [param('ns3::EpcTft::Direction', 'direction'), param('ns3::Ipv4Address', 'remoteAddress'), param('ns3::Ipv4Address', 'localAddress'), param('uint16_t', 'remotePort'), param('uint16_t', 'localPort'), param('uint8_t', 'typeOfService')])
-    return
-
-def register_Ns3EpcTftPacketFilter_methods(root_module, cls):
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::PacketFilter(ns3::EpcTft::PacketFilter const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcTft::PacketFilter const &', 'arg0')])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::PacketFilter() [constructor]
-    cls.add_constructor([])
-    ## epc-tft.h (module 'lte'): bool ns3::EpcTft::PacketFilter::Matches(ns3::EpcTft::Direction d, ns3::Ipv4Address ra, ns3::Ipv4Address la, uint16_t rp, uint16_t lp, uint8_t tos) [member function]
-    cls.add_method('Matches', 
-                   'bool', 
-                   [param('ns3::EpcTft::Direction', 'd'), param('ns3::Ipv4Address', 'ra'), param('ns3::Ipv4Address', 'la'), param('uint16_t', 'rp'), param('uint16_t', 'lp'), param('uint8_t', 'tos')])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::direction [variable]
-    cls.add_instance_attribute('direction', 'ns3::EpcTft::Direction', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localAddress [variable]
-    cls.add_instance_attribute('localAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localMask [variable]
-    cls.add_instance_attribute('localMask', 'ns3::Ipv4Mask', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localPortEnd [variable]
-    cls.add_instance_attribute('localPortEnd', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localPortStart [variable]
-    cls.add_instance_attribute('localPortStart', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::precedence [variable]
-    cls.add_instance_attribute('precedence', 'uint8_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remoteAddress [variable]
-    cls.add_instance_attribute('remoteAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remoteMask [variable]
-    cls.add_instance_attribute('remoteMask', 'ns3::Ipv4Mask', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remotePortEnd [variable]
-    cls.add_instance_attribute('remotePortEnd', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remotePortStart [variable]
-    cls.add_instance_attribute('remotePortStart', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::typeOfService [variable]
-    cls.add_instance_attribute('typeOfService', 'uint8_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::typeOfServiceMask [variable]
-    cls.add_instance_attribute('typeOfServiceMask', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3EpcTftClassifier_methods(root_module, cls):
-    ## epc-tft-classifier.h (module 'lte'): ns3::EpcTftClassifier::EpcTftClassifier(ns3::EpcTftClassifier const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcTftClassifier const &', 'arg0')])
-    ## epc-tft-classifier.h (module 'lte'): ns3::EpcTftClassifier::EpcTftClassifier() [constructor]
-    cls.add_constructor([])
-    ## epc-tft-classifier.h (module 'lte'): void ns3::EpcTftClassifier::Add(ns3::Ptr<ns3::EpcTft> tft, uint32_t id) [member function]
-    cls.add_method('Add', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('uint32_t', 'id')])
-    ## epc-tft-classifier.h (module 'lte'): uint32_t ns3::EpcTftClassifier::Classify(ns3::Ptr<ns3::Packet> p, ns3::EpcTft::Direction direction) [member function]
-    cls.add_method('Classify', 
-                   'uint32_t', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('ns3::EpcTft::Direction', 'direction')])
-    ## epc-tft-classifier.h (module 'lte'): void ns3::EpcTftClassifier::Delete(uint32_t id) [member function]
-    cls.add_method('Delete', 
-                   'void', 
-                   [param('uint32_t', 'id')])
-    return
-
-def register_Ns3EpcUeNas_methods(root_module, cls):
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::EpcUeNas(ns3::EpcUeNas const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcUeNas const &', 'arg0')])
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::EpcUeNas() [constructor]
-    cls.add_constructor([])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::ActivateEpsBearer(ns3::EpsBearer bearer, ns3::Ptr<ns3::EpcTft> tft) [member function]
-    cls.add_method('ActivateEpsBearer', 
-                   'void', 
-                   [param('ns3::EpsBearer', 'bearer'), param('ns3::Ptr< ns3::EpcTft >', 'tft')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Connect() [member function]
-    cls.add_method('Connect', 
-                   'void', 
-                   [])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Connect(uint16_t cellId, uint32_t dlEarfcn) [member function]
-    cls.add_method('Connect', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Disconnect() [member function]
-    cls.add_method('Disconnect', 
-                   'void', 
-                   [])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## epc-ue-nas.h (module 'lte'): ns3::LteAsSapUser * ns3::EpcUeNas::GetAsSapUser() [member function]
-    cls.add_method('GetAsSapUser', 
-                   'ns3::LteAsSapUser *', 
-                   [])
-    ## epc-ue-nas.h (module 'lte'): uint32_t ns3::EpcUeNas::GetCsgId() const [member function]
-    cls.add_method('GetCsgId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::State ns3::EpcUeNas::GetState() const [member function]
-    cls.add_method('GetState', 
-                   'ns3::EpcUeNas::State', 
-                   [], 
-                   is_const=True)
-    ## epc-ue-nas.h (module 'lte'): static ns3::TypeId ns3::EpcUeNas::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-ue-nas.h (module 'lte'): bool ns3::EpcUeNas::Send(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('Send', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetAsSapProvider(ns3::LteAsSapProvider * s) [member function]
-    cls.add_method('SetAsSapProvider', 
-                   'void', 
-                   [param('ns3::LteAsSapProvider *', 's')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetCsgId(uint32_t csgId) [member function]
-    cls.add_method('SetCsgId', 
-                   'void', 
-                   [param('uint32_t', 'csgId')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetDevice(ns3::Ptr<ns3::NetDevice> dev) [member function]
-    cls.add_method('SetDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'dev')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetForwardUpCallback(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> cb) [member function]
-    cls.add_method('SetForwardUpCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetImsi(uint64_t imsi) [member function]
-    cls.add_method('SetImsi', 
-                   'void', 
-                   [param('uint64_t', 'imsi')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::StartCellSelection(uint32_t dlEarfcn) [member function]
-    cls.add_method('StartCellSelection', 
-                   'void', 
-                   [param('uint32_t', 'dlEarfcn')])
-    return
-
-def register_Ns3EpcX2_methods(root_module, cls):
-    ## epc-x2.h (module 'lte'): ns3::EpcX2::EpcX2(ns3::EpcX2 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2 const &', 'arg0')])
-    ## epc-x2.h (module 'lte'): ns3::EpcX2::EpcX2() [constructor]
-    cls.add_constructor([])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::AddX2Interface(uint16_t enb1CellId, ns3::Ipv4Address enb1X2Address, uint16_t enb2CellId, ns3::Ipv4Address enb2X2Address) [member function]
-    cls.add_method('AddX2Interface', 
-                   'void', 
-                   [param('uint16_t', 'enb1CellId'), param('ns3::Ipv4Address', 'enb1X2Address'), param('uint16_t', 'enb2CellId'), param('ns3::Ipv4Address', 'enb2X2Address')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## epc-x2.h (module 'lte'): ns3::EpcX2SapProvider * ns3::EpcX2::GetEpcX2SapProvider() [member function]
-    cls.add_method('GetEpcX2SapProvider', 
-                   'ns3::EpcX2SapProvider *', 
-                   [])
-    ## epc-x2.h (module 'lte'): static ns3::TypeId ns3::EpcX2::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::RecvFromX2cSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromX2cSocket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::RecvFromX2uSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromX2uSocket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::SetEpcX2SapUser(ns3::EpcX2SapUser * s) [member function]
-    cls.add_method('SetEpcX2SapUser', 
-                   'void', 
-                   [param('ns3::EpcX2SapUser *', 's')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
-    cls.add_method('DoSendHandoverPreparationFailure', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverPreparationFailureParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverRequest(ns3::EpcX2Sap::HandoverRequestParams params) [member function]
-    cls.add_method('DoSendHandoverRequest', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverRequestAck(ns3::EpcX2Sap::HandoverRequestAckParams params) [member function]
-    cls.add_method('DoSendHandoverRequestAck', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestAckParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoSendLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
-    cls.add_method('DoSendResourceStatusUpdate', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
-    cls.add_method('DoSendSnStatusTransfer', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
-    cls.add_method('DoSendUeContextRelease', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::UeContextReleaseParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeData(ns3::EpcX2Sap::UeDataParams params) [member function]
-    cls.add_method('DoSendUeData', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3EpcX2HandoverPreparationFailureHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader::EpcX2HandoverPreparationFailureHeader(ns3::EpcX2HandoverPreparationFailureHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2HandoverPreparationFailureHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader::EpcX2HandoverPreparationFailureHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetCause() const [member function]
-    cls.add_method('GetCause', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetCriticalityDiagnostics() const [member function]
-    cls.add_method('GetCriticalityDiagnostics', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverPreparationFailureHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetLengthOfIes() const [member function]
-    cls.add_method('GetLengthOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetNumberOfIes() const [member function]
-    cls.add_method('GetNumberOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverPreparationFailureHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetCause(uint16_t cause) [member function]
-    cls.add_method('SetCause', 
-                   'void', 
-                   [param('uint16_t', 'cause')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetCriticalityDiagnostics(uint16_t criticalityDiagnostics) [member function]
-    cls.add_method('SetCriticalityDiagnostics', 
-                   'void', 
-                   [param('uint16_t', 'criticalityDiagnostics')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    return
-
-def register_Ns3EpcX2HandoverRequestAckHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader::EpcX2HandoverRequestAckHeader(ns3::EpcX2HandoverRequestAckHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2HandoverRequestAckHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader::EpcX2HandoverRequestAckHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabAdmittedItem> > ns3::EpcX2HandoverRequestAckHeader::GetAdmittedBearers() const [member function]
-    cls.add_method('GetAdmittedBearers', 
-                   'std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverRequestAckHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetLengthOfIes() const [member function]
-    cls.add_method('GetLengthOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestAckHeader::GetNewEnbUeX2apId() const [member function]
-    cls.add_method('GetNewEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabNotAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabNotAdmittedItem> > ns3::EpcX2HandoverRequestAckHeader::GetNotAdmittedBearers() const [member function]
-    cls.add_method('GetNotAdmittedBearers', 
-                   'std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetNumberOfIes() const [member function]
-    cls.add_method('GetNumberOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestAckHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverRequestAckHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetAdmittedBearers(std::vector<ns3::EpcX2Sap::ErabAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabAdmittedItem> > bearers) [member function]
-    cls.add_method('SetAdmittedBearers', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 'bearers')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetNewEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetNewEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetNotAdmittedBearers(std::vector<ns3::EpcX2Sap::ErabNotAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabNotAdmittedItem> > bearers) [member function]
-    cls.add_method('SetNotAdmittedBearers', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 'bearers')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    return
-
-def register_Ns3EpcX2HandoverRequestHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader(ns3::EpcX2HandoverRequestHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2HandoverRequestHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > ns3::EpcX2HandoverRequestHeader::GetBearers() const [member function]
-    cls.add_method('GetBearers', 
-                   'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetCause() const [member function]
-    cls.add_method('GetCause', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverRequestHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetLengthOfIes() const [member function]
-    cls.add_method('GetLengthOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetMmeUeS1apId() const [member function]
-    cls.add_method('GetMmeUeS1apId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetNumberOfIes() const [member function]
-    cls.add_method('GetNumberOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetTargetCellId() const [member function]
-    cls.add_method('GetTargetCellId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverRequestHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateDownlink() const [member function]
-    cls.add_method('GetUeAggregateMaxBitRateDownlink', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateUplink() const [member function]
-    cls.add_method('GetUeAggregateMaxBitRateUplink', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetBearers(std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > bearers) [member function]
-    cls.add_method('SetBearers', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 'bearers')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetCause(uint16_t cause) [member function]
-    cls.add_method('SetCause', 
-                   'void', 
-                   [param('uint16_t', 'cause')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetMmeUeS1apId(uint32_t mmeUeS1apId) [member function]
-    cls.add_method('SetMmeUeS1apId', 
-                   'void', 
-                   [param('uint32_t', 'mmeUeS1apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetTargetCellId(uint16_t targetCellId) [member function]
-    cls.add_method('SetTargetCellId', 
-                   'void', 
-                   [param('uint16_t', 'targetCellId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateDownlink(uint64_t bitRate) [member function]
-    cls.add_method('SetUeAggregateMaxBitRateDownlink', 
-                   'void', 
-                   [param('uint64_t', 'bitRate')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateUplink(uint64_t bitRate) [member function]
-    cls.add_method('SetUeAggregateMaxBitRateUplink', 
-                   'void', 
-                   [param('uint64_t', 'bitRate')])
-    return
-
-def register_Ns3EpcX2Header_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::EpcX2Header(ns3::EpcX2Header const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Header const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::EpcX2Header() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2Header::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2Header::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2Header::GetMessageType() const [member function]
-    cls.add_method('GetMessageType', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2Header::GetProcedureCode() const [member function]
-    cls.add_method('GetProcedureCode', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2Header::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2Header::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetLengthOfIes(uint32_t lengthOfIes) [member function]
-    cls.add_method('SetLengthOfIes', 
-                   'void', 
-                   [param('uint32_t', 'lengthOfIes')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetMessageType(uint8_t messageType) [member function]
-    cls.add_method('SetMessageType', 
-                   'void', 
-                   [param('uint8_t', 'messageType')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetNumberOfIes(uint32_t numberOfIes) [member function]
-    cls.add_method('SetNumberOfIes', 
-                   'void', 
-                   [param('uint32_t', 'numberOfIes')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetProcedureCode(uint8_t procedureCode) [member function]
-    cls.add_method('SetProcedureCode', 
-                   'void', 
-                   [param('uint8_t', 'procedureCode')])
-    return
-
-def register_Ns3EpcX2LoadInformationHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader::EpcX2LoadInformationHeader(ns3::EpcX2LoadInformationHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2LoadInformationHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader::EpcX2LoadInformationHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::CellInformationItem, std::allocator<ns3::EpcX2Sap::CellInformationItem> > ns3::EpcX2LoadInformationHeader::GetCellInformationList() const [member function]
-    cls.add_method('GetCellInformationList', 
-                   'std::vector< ns3::EpcX2Sap::CellInformationItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2LoadInformationHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetLengthOfIes() const [member function]
-    cls.add_method('GetLengthOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetNumberOfIes() const [member function]
-    cls.add_method('GetNumberOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2LoadInformationHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::SetCellInformationList(std::vector<ns3::EpcX2Sap::CellInformationItem, std::allocator<ns3::EpcX2Sap::CellInformationItem> > cellInformationList) [member function]
-    cls.add_method('SetCellInformationList', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::CellInformationItem >', 'cellInformationList')])
-    return
-
-def register_Ns3EpcX2ResourceStatusUpdateHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader::EpcX2ResourceStatusUpdateHeader(ns3::EpcX2ResourceStatusUpdateHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2ResourceStatusUpdateHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader::EpcX2ResourceStatusUpdateHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::CellMeasurementResultItem, std::allocator<ns3::EpcX2Sap::CellMeasurementResultItem> > ns3::EpcX2ResourceStatusUpdateHeader::GetCellMeasurementResultList() const [member function]
-    cls.add_method('GetCellMeasurementResultList', 
-                   'std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ResourceStatusUpdateHeader::GetEnb1MeasurementId() const [member function]
-    cls.add_method('GetEnb1MeasurementId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ResourceStatusUpdateHeader::GetEnb2MeasurementId() const [member function]
-    cls.add_method('GetEnb2MeasurementId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2ResourceStatusUpdateHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetLengthOfIes() const [member function]
-    cls.add_method('GetLengthOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetNumberOfIes() const [member function]
-    cls.add_method('GetNumberOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2ResourceStatusUpdateHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetCellMeasurementResultList(std::vector<ns3::EpcX2Sap::CellMeasurementResultItem, std::allocator<ns3::EpcX2Sap::CellMeasurementResultItem> > cellMeasurementResultList) [member function]
-    cls.add_method('SetCellMeasurementResultList', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 'cellMeasurementResultList')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetEnb1MeasurementId(uint16_t enb1MeasurementId) [member function]
-    cls.add_method('SetEnb1MeasurementId', 
-                   'void', 
-                   [param('uint16_t', 'enb1MeasurementId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetEnb2MeasurementId(uint16_t enb2MeasurementId) [member function]
-    cls.add_method('SetEnb2MeasurementId', 
-                   'void', 
-                   [param('uint16_t', 'enb2MeasurementId')])
-    return
-
-def register_Ns3EpcX2SnStatusTransferHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SnStatusTransferHeader::EpcX2SnStatusTransferHeader(ns3::EpcX2SnStatusTransferHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2SnStatusTransferHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SnStatusTransferHeader::EpcX2SnStatusTransferHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SnStatusTransferHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem, std::allocator<ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem> > ns3::EpcX2SnStatusTransferHeader::GetErabsSubjectToStatusTransferList() const [member function]
-    cls.add_method('GetErabsSubjectToStatusTransferList', 
-                   'std::vector< ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2SnStatusTransferHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SnStatusTransferHeader::GetLengthOfIes() const [member function]
-    cls.add_method('GetLengthOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2SnStatusTransferHeader::GetNewEnbUeX2apId() const [member function]
-    cls.add_method('GetNewEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SnStatusTransferHeader::GetNumberOfIes() const [member function]
-    cls.add_method('GetNumberOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2SnStatusTransferHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SnStatusTransferHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2SnStatusTransferHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SnStatusTransferHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SnStatusTransferHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SnStatusTransferHeader::SetErabsSubjectToStatusTransferList(std::vector<ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem, std::allocator<ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem> > erabs) [member function]
-    cls.add_method('SetErabsSubjectToStatusTransferList', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem >', 'erabs')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SnStatusTransferHeader::SetNewEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetNewEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SnStatusTransferHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    return
-
-def register_Ns3EpcX2UeContextReleaseHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeContextReleaseHeader::EpcX2UeContextReleaseHeader(ns3::EpcX2UeContextReleaseHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2UeContextReleaseHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeContextReleaseHeader::EpcX2UeContextReleaseHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeContextReleaseHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2UeContextReleaseHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeContextReleaseHeader::GetLengthOfIes() const [member function]
-    cls.add_method('GetLengthOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2UeContextReleaseHeader::GetNewEnbUeX2apId() const [member function]
-    cls.add_method('GetNewEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeContextReleaseHeader::GetNumberOfIes() const [member function]
-    cls.add_method('GetNumberOfIes', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2UeContextReleaseHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeContextReleaseHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2UeContextReleaseHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeContextReleaseHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeContextReleaseHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeContextReleaseHeader::SetNewEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetNewEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeContextReleaseHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
-                   'void', 
-                   [param('uint16_t', 'x2apId')])
-    return
-
-def register_Ns3ErlangRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ErlangRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::ErlangRandomVariable::ErlangRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ErlangRandomVariable::GetK() const [member function]
-    cls.add_method('GetK', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ErlangRandomVariable::GetLambda() const [member function]
-    cls.add_method('GetLambda', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ErlangRandomVariable::GetValue(uint32_t k, double lambda) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('uint32_t', 'k'), param('double', 'lambda')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ErlangRandomVariable::GetInteger(uint32_t k, uint32_t lambda) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'k'), param('uint32_t', 'lambda')])
-    ## random-variable-stream.h (module 'core'): double ns3::ErlangRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ErlangRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3EventImpl_methods(root_module, cls):
-    ## event-impl.h (module 'core'): ns3::EventImpl::EventImpl(ns3::EventImpl const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EventImpl const &', 'arg0')])
-    ## event-impl.h (module 'core'): ns3::EventImpl::EventImpl() [constructor]
-    cls.add_constructor([])
-    ## event-impl.h (module 'core'): void ns3::EventImpl::Cancel() [member function]
-    cls.add_method('Cancel', 
-                   'void', 
-                   [])
-    ## event-impl.h (module 'core'): void ns3::EventImpl::Invoke() [member function]
-    cls.add_method('Invoke', 
-                   'void', 
-                   [])
-    ## event-impl.h (module 'core'): bool ns3::EventImpl::IsCancelled() [member function]
-    cls.add_method('IsCancelled', 
-                   'bool', 
-                   [])
-    ## event-impl.h (module 'core'): void ns3::EventImpl::Notify() [member function]
-    cls.add_method('Notify', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ExponentialRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ExponentialRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::ExponentialRandomVariable::ExponentialRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::ExponentialRandomVariable::GetMean() const [member function]
-    cls.add_method('GetMean', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ExponentialRandomVariable::GetBound() const [member function]
-    cls.add_method('GetBound', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ExponentialRandomVariable::GetValue(double mean, double bound) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'mean'), param('double', 'bound')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ExponentialRandomVariable::GetInteger(uint32_t mean, uint32_t bound) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'mean'), param('uint32_t', 'bound')])
-    ## random-variable-stream.h (module 'core'): double ns3::ExponentialRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ExponentialRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3FfMacScheduler_methods(root_module, cls):
-    ## ff-mac-scheduler.h (module 'lte'): ns3::FfMacScheduler::FfMacScheduler(ns3::FfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FfMacScheduler const &', 'arg0')])
-    ## ff-mac-scheduler.h (module 'lte'): ns3::FfMacScheduler::FfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## ff-mac-scheduler.h (module 'lte'): void ns3::FfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::FfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::FfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::FfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::FfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## ff-mac-scheduler.h (module 'lte'): void ns3::FfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-scheduler.h (module 'lte'): void ns3::FfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ff-mac-scheduler.h (module 'lte'): void ns3::FfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3GammaRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::GammaRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::GammaRandomVariable::GammaRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::GammaRandomVariable::GetAlpha() const [member function]
-    cls.add_method('GetAlpha', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::GammaRandomVariable::GetBeta() const [member function]
-    cls.add_method('GetBeta', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::GammaRandomVariable::GetValue(double alpha, double beta) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'alpha'), param('double', 'beta')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::GammaRandomVariable::GetInteger(uint32_t alpha, uint32_t beta) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'alpha'), param('uint32_t', 'beta')])
-    ## random-variable-stream.h (module 'core'): double ns3::GammaRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::GammaRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3GtpuHeader_methods(root_module, cls):
-    cls.add_binary_comparison_operator('==')
-    ## epc-gtpu-header.h (module 'lte'): ns3::GtpuHeader::GtpuHeader(ns3::GtpuHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::GtpuHeader const &', 'arg0')])
-    ## epc-gtpu-header.h (module 'lte'): ns3::GtpuHeader::GtpuHeader() [constructor]
-    cls.add_constructor([])
-    ## epc-gtpu-header.h (module 'lte'): uint32_t ns3::GtpuHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_virtual=True)
-    ## epc-gtpu-header.h (module 'lte'): bool ns3::GtpuHeader::GetExtensionHeaderFlag() const [member function]
-    cls.add_method('GetExtensionHeaderFlag', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): ns3::TypeId ns3::GtpuHeader::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-gtpu-header.h (module 'lte'): uint16_t ns3::GtpuHeader::GetLength() const [member function]
-    cls.add_method('GetLength', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): uint8_t ns3::GtpuHeader::GetMessageType() const [member function]
-    cls.add_method('GetMessageType', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): uint8_t ns3::GtpuHeader::GetNPduNumber() const [member function]
-    cls.add_method('GetNPduNumber', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): bool ns3::GtpuHeader::GetNPduNumberFlag() const [member function]
-    cls.add_method('GetNPduNumberFlag', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): uint8_t ns3::GtpuHeader::GetNextExtensionType() const [member function]
-    cls.add_method('GetNextExtensionType', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): bool ns3::GtpuHeader::GetProtocolType() const [member function]
-    cls.add_method('GetProtocolType', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): uint16_t ns3::GtpuHeader::GetSequenceNumber() const [member function]
-    cls.add_method('GetSequenceNumber', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): bool ns3::GtpuHeader::GetSequenceNumberFlag() const [member function]
-    cls.add_method('GetSequenceNumberFlag', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): uint32_t ns3::GtpuHeader::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## epc-gtpu-header.h (module 'lte'): uint32_t ns3::GtpuHeader::GetTeid() const [member function]
-    cls.add_method('GetTeid', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): static ns3::TypeId ns3::GtpuHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## epc-gtpu-header.h (module 'lte'): uint8_t ns3::GtpuHeader::GetVersion() const [member function]
-    cls.add_method('GetVersion', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
-    cls.add_method('Serialize', 
-                   'void', 
-                   [param('ns3::Buffer::Iterator', 'start')], 
-                   is_const=True, is_virtual=True)
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetExtensionHeaderFlag(bool extensionHeaderFlag) [member function]
-    cls.add_method('SetExtensionHeaderFlag', 
-                   'void', 
-                   [param('bool', 'extensionHeaderFlag')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetLength(uint16_t length) [member function]
-    cls.add_method('SetLength', 
-                   'void', 
-                   [param('uint16_t', 'length')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetMessageType(uint8_t messageType) [member function]
-    cls.add_method('SetMessageType', 
-                   'void', 
-                   [param('uint8_t', 'messageType')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetNPduNumber(uint8_t nPduNumber) [member function]
-    cls.add_method('SetNPduNumber', 
-                   'void', 
-                   [param('uint8_t', 'nPduNumber')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetNPduNumberFlag(bool nPduNumberFlag) [member function]
-    cls.add_method('SetNPduNumberFlag', 
-                   'void', 
-                   [param('bool', 'nPduNumberFlag')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetNextExtensionType(uint8_t nextExtensionType) [member function]
-    cls.add_method('SetNextExtensionType', 
-                   'void', 
-                   [param('uint8_t', 'nextExtensionType')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetProtocolType(bool protocolType) [member function]
-    cls.add_method('SetProtocolType', 
-                   'void', 
-                   [param('bool', 'protocolType')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetSequenceNumber(uint16_t sequenceNumber) [member function]
-    cls.add_method('SetSequenceNumber', 
-                   'void', 
-                   [param('uint16_t', 'sequenceNumber')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetSequenceNumberFlag(bool sequenceNumberFlag) [member function]
-    cls.add_method('SetSequenceNumberFlag', 
-                   'void', 
-                   [param('bool', 'sequenceNumberFlag')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetTeid(uint32_t teid) [member function]
-    cls.add_method('SetTeid', 
-                   'void', 
-                   [param('uint32_t', 'teid')])
-    ## epc-gtpu-header.h (module 'lte'): void ns3::GtpuHeader::SetVersion(uint8_t version) [member function]
-    cls.add_method('SetVersion', 
-                   'void', 
-                   [param('uint8_t', 'version')])
-    return
-
-def register_Ns3IntegerValue_methods(root_module, cls):
-    ## integer.h (module 'core'): ns3::IntegerValue::IntegerValue() [constructor]
-    cls.add_constructor([])
-    ## integer.h (module 'core'): ns3::IntegerValue::IntegerValue(int64_t const & value) [constructor]
-    cls.add_constructor([param('int64_t const &', 'value')])
-    ## integer.h (module 'core'): ns3::IntegerValue::IntegerValue(ns3::IntegerValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::IntegerValue const &', 'arg0')])
-    ## integer.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::IntegerValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## integer.h (module 'core'): bool ns3::IntegerValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## integer.h (module 'core'): int64_t ns3::IntegerValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'int64_t', 
-                   [], 
-                   is_const=True)
-    ## integer.h (module 'core'): std::string ns3::IntegerValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## integer.h (module 'core'): void ns3::IntegerValue::Set(int64_t const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('int64_t const &', 'value')])
-    return
-
-def register_Ns3Ipv4_methods(root_module, cls):
-    ## ipv4.h (module 'internet'): ns3::Ipv4::Ipv4(ns3::Ipv4 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4 const &', 'arg0')])
-    ## ipv4.h (module 'internet'): ns3::Ipv4::Ipv4() [constructor]
-    cls.add_constructor([])
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::AddAddress(uint32_t interface, ns3::Ipv4InterfaceAddress address) [member function]
-    cls.add_method('AddAddress', 
-                   'bool', 
-                   [param('uint32_t', 'interface'), param('ns3::Ipv4InterfaceAddress', 'address')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): uint32_t ns3::Ipv4::AddInterface(ns3::Ptr<ns3::NetDevice> device) [member function]
-    cls.add_method('AddInterface', 
-                   'uint32_t', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'device')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ptr<ns3::Socket> ns3::Ipv4::CreateRawSocket() [member function]
-    cls.add_method('CreateRawSocket', 
-                   'ns3::Ptr< ns3::Socket >', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::DeleteRawSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('DeleteRawSocket', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ipv4InterfaceAddress ns3::Ipv4::GetAddress(uint32_t interface, uint32_t addressIndex) const [member function]
-    cls.add_method('GetAddress', 
-                   'ns3::Ipv4InterfaceAddress', 
-                   [param('uint32_t', 'interface'), param('uint32_t', 'addressIndex')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): int32_t ns3::Ipv4::GetInterfaceForAddress(ns3::Ipv4Address address) const [member function]
-    cls.add_method('GetInterfaceForAddress', 
-                   'int32_t', 
-                   [param('ns3::Ipv4Address', 'address')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): int32_t ns3::Ipv4::GetInterfaceForDevice(ns3::Ptr<const ns3::NetDevice> device) const [member function]
-    cls.add_method('GetInterfaceForDevice', 
-                   'int32_t', 
-                   [param('ns3::Ptr< ns3::NetDevice const >', 'device')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): int32_t ns3::Ipv4::GetInterfaceForPrefix(ns3::Ipv4Address address, ns3::Ipv4Mask mask) const [member function]
-    cls.add_method('GetInterfaceForPrefix', 
-                   'int32_t', 
-                   [param('ns3::Ipv4Address', 'address'), param('ns3::Ipv4Mask', 'mask')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): uint16_t ns3::Ipv4::GetMetric(uint32_t interface) const [member function]
-    cls.add_method('GetMetric', 
-                   'uint16_t', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): uint16_t ns3::Ipv4::GetMtu(uint32_t interface) const [member function]
-    cls.add_method('GetMtu', 
-                   'uint16_t', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): uint32_t ns3::Ipv4::GetNAddresses(uint32_t interface) const [member function]
-    cls.add_method('GetNAddresses', 
-                   'uint32_t', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): uint32_t ns3::Ipv4::GetNInterfaces() const [member function]
-    cls.add_method('GetNInterfaces', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ptr<ns3::NetDevice> ns3::Ipv4::GetNetDevice(uint32_t interface) [member function]
-    cls.add_method('GetNetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ptr<ns3::IpL4Protocol> ns3::Ipv4::GetProtocol(int protocolNumber) const [member function]
-    cls.add_method('GetProtocol', 
-                   'ns3::Ptr< ns3::IpL4Protocol >', 
-                   [param('int', 'protocolNumber')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ptr<ns3::IpL4Protocol> ns3::Ipv4::GetProtocol(int protocolNumber, int32_t interfaceIndex) const [member function]
-    cls.add_method('GetProtocol', 
-                   'ns3::Ptr< ns3::IpL4Protocol >', 
-                   [param('int', 'protocolNumber'), param('int32_t', 'interfaceIndex')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ptr<ns3::Ipv4RoutingProtocol> ns3::Ipv4::GetRoutingProtocol() const [member function]
-    cls.add_method('GetRoutingProtocol', 
-                   'ns3::Ptr< ns3::Ipv4RoutingProtocol >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): static ns3::TypeId ns3::Ipv4::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::Insert(ns3::Ptr<ns3::IpL4Protocol> protocol) [member function]
-    cls.add_method('Insert', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::IpL4Protocol >', 'protocol')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::Insert(ns3::Ptr<ns3::IpL4Protocol> protocol, uint32_t interfaceIndex) [member function]
-    cls.add_method('Insert', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::IpL4Protocol >', 'protocol'), param('uint32_t', 'interfaceIndex')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::IsDestinationAddress(ns3::Ipv4Address address, uint32_t iif) const [member function]
-    cls.add_method('IsDestinationAddress', 
-                   'bool', 
-                   [param('ns3::Ipv4Address', 'address'), param('uint32_t', 'iif')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::IsForwarding(uint32_t interface) const [member function]
-    cls.add_method('IsForwarding', 
-                   'bool', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::IsUp(uint32_t interface) const [member function]
-    cls.add_method('IsUp', 
-                   'bool', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::Remove(ns3::Ptr<ns3::IpL4Protocol> protocol) [member function]
-    cls.add_method('Remove', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::IpL4Protocol >', 'protocol')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::Remove(ns3::Ptr<ns3::IpL4Protocol> protocol, uint32_t interfaceIndex) [member function]
-    cls.add_method('Remove', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::IpL4Protocol >', 'protocol'), param('uint32_t', 'interfaceIndex')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::RemoveAddress(uint32_t interface, uint32_t addressIndex) [member function]
-    cls.add_method('RemoveAddress', 
-                   'bool', 
-                   [param('uint32_t', 'interface'), param('uint32_t', 'addressIndex')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::RemoveAddress(uint32_t interface, ns3::Ipv4Address address) [member function]
-    cls.add_method('RemoveAddress', 
-                   'bool', 
-                   [param('uint32_t', 'interface'), param('ns3::Ipv4Address', 'address')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4::SelectSourceAddress(ns3::Ptr<const ns3::NetDevice> device, ns3::Ipv4Address dst, ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e scope) [member function]
-    cls.add_method('SelectSourceAddress', 
-                   'ns3::Ipv4Address', 
-                   [param('ns3::Ptr< ns3::NetDevice const >', 'device'), param('ns3::Ipv4Address', 'dst'), param('ns3::Ipv4InterfaceAddress::InterfaceAddressScope_e', 'scope')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::Send(ns3::Ptr<ns3::Packet> packet, ns3::Ipv4Address source, ns3::Ipv4Address destination, uint8_t protocol, ns3::Ptr<ns3::Ipv4Route> route) [member function]
-    cls.add_method('Send', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Ipv4Address', 'source'), param('ns3::Ipv4Address', 'destination'), param('uint8_t', 'protocol'), param('ns3::Ptr< ns3::Ipv4Route >', 'route')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SendWithHeader(ns3::Ptr<ns3::Packet> packet, ns3::Ipv4Header ipHeader, ns3::Ptr<ns3::Ipv4Route> route) [member function]
-    cls.add_method('SendWithHeader', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Ipv4Header', 'ipHeader'), param('ns3::Ptr< ns3::Ipv4Route >', 'route')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SetDown(uint32_t interface) [member function]
-    cls.add_method('SetDown', 
-                   'void', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SetForwarding(uint32_t interface, bool val) [member function]
-    cls.add_method('SetForwarding', 
-                   'void', 
-                   [param('uint32_t', 'interface'), param('bool', 'val')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SetMetric(uint32_t interface, uint16_t metric) [member function]
-    cls.add_method('SetMetric', 
-                   'void', 
-                   [param('uint32_t', 'interface'), param('uint16_t', 'metric')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SetRoutingProtocol(ns3::Ptr<ns3::Ipv4RoutingProtocol> routingProtocol) [member function]
-    cls.add_method('SetRoutingProtocol', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Ipv4RoutingProtocol >', 'routingProtocol')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SetUp(uint32_t interface) [member function]
-    cls.add_method('SetUp', 
-                   'void', 
-                   [param('uint32_t', 'interface')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4::SourceAddressSelection(uint32_t interface, ns3::Ipv4Address dest) [member function]
-    cls.add_method('SourceAddressSelection', 
-                   'ns3::Ipv4Address', 
-                   [param('uint32_t', 'interface'), param('ns3::Ipv4Address', 'dest')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## ipv4.h (module 'internet'): ns3::Ipv4::IF_ANY [variable]
-    cls.add_static_attribute('IF_ANY', 'uint32_t const', is_const=True)
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::GetIpForward() const [member function]
-    cls.add_method('GetIpForward', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
-    ## ipv4.h (module 'internet'): bool ns3::Ipv4::GetWeakEsModel() const [member function]
-    cls.add_method('GetWeakEsModel', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SetIpForward(bool forward) [member function]
-    cls.add_method('SetIpForward', 
-                   'void', 
-                   [param('bool', 'forward')], 
-                   is_pure_virtual=True, visibility='private', is_virtual=True)
-    ## ipv4.h (module 'internet'): void ns3::Ipv4::SetWeakEsModel(bool model) [member function]
-    cls.add_method('SetWeakEsModel', 
-                   'void', 
-                   [param('bool', 'model')], 
-                   is_pure_virtual=True, visibility='private', is_virtual=True)
-    return
-
-def register_Ns3Ipv4AddressChecker_methods(root_module, cls):
-    ## ipv4-address.h (module 'network'): ns3::Ipv4AddressChecker::Ipv4AddressChecker() [constructor]
-    cls.add_constructor([])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4AddressChecker::Ipv4AddressChecker(ns3::Ipv4AddressChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4AddressChecker const &', 'arg0')])
-    return
-
-def register_Ns3Ipv4AddressValue_methods(root_module, cls):
-    ## ipv4-address.h (module 'network'): ns3::Ipv4AddressValue::Ipv4AddressValue() [constructor]
-    cls.add_constructor([])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4AddressValue::Ipv4AddressValue(ns3::Ipv4Address const & value) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Address const &', 'value')])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4AddressValue::Ipv4AddressValue(ns3::Ipv4AddressValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4AddressValue const &', 'arg0')])
-    ## ipv4-address.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::Ipv4AddressValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4AddressValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Address ns3::Ipv4AddressValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): std::string ns3::Ipv4AddressValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4AddressValue::Set(ns3::Ipv4Address const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Ipv4Address const &', 'value')])
-    return
-
-def register_Ns3Ipv4MaskChecker_methods(root_module, cls):
-    ## ipv4-address.h (module 'network'): ns3::Ipv4MaskChecker::Ipv4MaskChecker() [constructor]
-    cls.add_constructor([])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4MaskChecker::Ipv4MaskChecker(ns3::Ipv4MaskChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4MaskChecker const &', 'arg0')])
-    return
-
-def register_Ns3Ipv4MaskValue_methods(root_module, cls):
-    ## ipv4-address.h (module 'network'): ns3::Ipv4MaskValue::Ipv4MaskValue() [constructor]
-    cls.add_constructor([])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4MaskValue::Ipv4MaskValue(ns3::Ipv4Mask const & value) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Mask const &', 'value')])
-    ## ipv4-address.h (module 'network'): ns3::Ipv4MaskValue::Ipv4MaskValue(ns3::Ipv4MaskValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4MaskValue const &', 'arg0')])
-    ## ipv4-address.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::Ipv4MaskValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-address.h (module 'network'): bool ns3::Ipv4MaskValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## ipv4-address.h (module 'network'): ns3::Ipv4Mask ns3::Ipv4MaskValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Ipv4Mask', 
-                   [], 
-                   is_const=True)
-    ## ipv4-address.h (module 'network'): std::string ns3::Ipv4MaskValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## ipv4-address.h (module 'network'): void ns3::Ipv4MaskValue::Set(ns3::Ipv4Mask const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Ipv4Mask const &', 'value')])
-    return
-
-def register_Ns3Ipv4MulticastRoute_methods(root_module, cls):
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4MulticastRoute::Ipv4MulticastRoute(ns3::Ipv4MulticastRoute const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4MulticastRoute const &', 'arg0')])
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4MulticastRoute::Ipv4MulticastRoute() [constructor]
-    cls.add_constructor([])
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4MulticastRoute::GetGroup() const [member function]
-    cls.add_method('GetGroup', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4MulticastRoute::GetOrigin() const [member function]
-    cls.add_method('GetOrigin', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): std::map<unsigned int, unsigned int, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, unsigned int> > > ns3::Ipv4MulticastRoute::GetOutputTtlMap() const [member function]
-    cls.add_method('GetOutputTtlMap', 
-                   'std::map< unsigned int, unsigned int >', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): uint32_t ns3::Ipv4MulticastRoute::GetParent() const [member function]
-    cls.add_method('GetParent', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4MulticastRoute::SetGroup(ns3::Ipv4Address const group) [member function]
-    cls.add_method('SetGroup', 
-                   'void', 
-                   [param('ns3::Ipv4Address const', 'group')])
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4MulticastRoute::SetOrigin(ns3::Ipv4Address const origin) [member function]
-    cls.add_method('SetOrigin', 
-                   'void', 
-                   [param('ns3::Ipv4Address const', 'origin')])
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4MulticastRoute::SetOutputTtl(uint32_t oif, uint32_t ttl) [member function]
-    cls.add_method('SetOutputTtl', 
-                   'void', 
-                   [param('uint32_t', 'oif'), param('uint32_t', 'ttl')])
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4MulticastRoute::SetParent(uint32_t iif) [member function]
-    cls.add_method('SetParent', 
-                   'void', 
-                   [param('uint32_t', 'iif')])
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4MulticastRoute::MAX_INTERFACES [variable]
-    cls.add_static_attribute('MAX_INTERFACES', 'uint32_t const', is_const=True)
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4MulticastRoute::MAX_TTL [variable]
-    cls.add_static_attribute('MAX_TTL', 'uint32_t const', is_const=True)
-    return
-
-def register_Ns3Ipv4Route_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Route::Ipv4Route(ns3::Ipv4Route const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv4Route const &', 'arg0')])
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Route::Ipv4Route() [constructor]
-    cls.add_constructor([])
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4Route::GetDestination() const [member function]
-    cls.add_method('GetDestination', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4Route::GetGateway() const [member function]
-    cls.add_method('GetGateway', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): ns3::Ptr<ns3::NetDevice> ns3::Ipv4Route::GetOutputDevice() const [member function]
-    cls.add_method('GetOutputDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): ns3::Ipv4Address ns3::Ipv4Route::GetSource() const [member function]
-    cls.add_method('GetSource', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_const=True)
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4Route::SetDestination(ns3::Ipv4Address dest) [member function]
-    cls.add_method('SetDestination', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'dest')])
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4Route::SetGateway(ns3::Ipv4Address gw) [member function]
-    cls.add_method('SetGateway', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'gw')])
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4Route::SetOutputDevice(ns3::Ptr<ns3::NetDevice> outputDevice) [member function]
-    cls.add_method('SetOutputDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'outputDevice')])
-    ## ipv4-route.h (module 'internet'): void ns3::Ipv4Route::SetSource(ns3::Ipv4Address src) [member function]
-    cls.add_method('SetSource', 
-                   'void', 
-                   [param('ns3::Ipv4Address', 'src')])
-    return
-
-def register_Ns3Ipv6AddressChecker_methods(root_module, cls):
-    ## ipv6-address.h (module 'network'): ns3::Ipv6AddressChecker::Ipv6AddressChecker() [constructor]
-    cls.add_constructor([])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6AddressChecker::Ipv6AddressChecker(ns3::Ipv6AddressChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv6AddressChecker const &', 'arg0')])
-    return
-
-def register_Ns3Ipv6AddressValue_methods(root_module, cls):
-    ## ipv6-address.h (module 'network'): ns3::Ipv6AddressValue::Ipv6AddressValue() [constructor]
-    cls.add_constructor([])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6AddressValue::Ipv6AddressValue(ns3::Ipv6Address const & value) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Address const &', 'value')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6AddressValue::Ipv6AddressValue(ns3::Ipv6AddressValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv6AddressValue const &', 'arg0')])
-    ## ipv6-address.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::Ipv6AddressValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6AddressValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Address ns3::Ipv6AddressValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Ipv6Address', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): std::string ns3::Ipv6AddressValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6AddressValue::Set(ns3::Ipv6Address const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Ipv6Address const &', 'value')])
-    return
-
-def register_Ns3Ipv6PrefixChecker_methods(root_module, cls):
-    ## ipv6-address.h (module 'network'): ns3::Ipv6PrefixChecker::Ipv6PrefixChecker() [constructor]
-    cls.add_constructor([])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6PrefixChecker::Ipv6PrefixChecker(ns3::Ipv6PrefixChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv6PrefixChecker const &', 'arg0')])
-    return
-
-def register_Ns3Ipv6PrefixValue_methods(root_module, cls):
-    ## ipv6-address.h (module 'network'): ns3::Ipv6PrefixValue::Ipv6PrefixValue() [constructor]
-    cls.add_constructor([])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6PrefixValue::Ipv6PrefixValue(ns3::Ipv6Prefix const & value) [constructor]
-    cls.add_constructor([param('ns3::Ipv6Prefix const &', 'value')])
-    ## ipv6-address.h (module 'network'): ns3::Ipv6PrefixValue::Ipv6PrefixValue(ns3::Ipv6PrefixValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Ipv6PrefixValue const &', 'arg0')])
-    ## ipv6-address.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::Ipv6PrefixValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## ipv6-address.h (module 'network'): bool ns3::Ipv6PrefixValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## ipv6-address.h (module 'network'): ns3::Ipv6Prefix ns3::Ipv6PrefixValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Ipv6Prefix', 
-                   [], 
-                   is_const=True)
-    ## ipv6-address.h (module 'network'): std::string ns3::Ipv6PrefixValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## ipv6-address.h (module 'network'): void ns3::Ipv6PrefixValue::Set(ns3::Ipv6Prefix const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Ipv6Prefix const &', 'value')])
-    return
-
-def register_Ns3LogNormalRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::LogNormalRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::LogNormalRandomVariable::LogNormalRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::LogNormalRandomVariable::GetMu() const [member function]
-    cls.add_method('GetMu', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::LogNormalRandomVariable::GetSigma() const [member function]
-    cls.add_method('GetSigma', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::LogNormalRandomVariable::GetValue(double mu, double sigma) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'mu'), param('double', 'sigma')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::LogNormalRandomVariable::GetInteger(uint32_t mu, uint32_t sigma) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'mu'), param('uint32_t', 'sigma')])
-    ## random-variable-stream.h (module 'core'): double ns3::LogNormalRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::LogNormalRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3LteAmc_methods(root_module, cls):
-    ## lte-amc.h (module 'lte'): ns3::LteAmc::LteAmc(ns3::LteAmc const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteAmc const &', 'arg0')])
-    ## lte-amc.h (module 'lte'): ns3::LteAmc::LteAmc() [constructor]
-    cls.add_constructor([])
-    ## lte-amc.h (module 'lte'): std::vector<int, std::allocator<int> > ns3::LteAmc::CreateCqiFeedbacks(ns3::SpectrumValue const & sinr, uint8_t rbgSize=0) [member function]
-    cls.add_method('CreateCqiFeedbacks', 
-                   'std::vector< int >', 
-                   [param('ns3::SpectrumValue const &', 'sinr'), param('uint8_t', 'rbgSize', default_value='0')])
-    ## lte-amc.h (module 'lte'): int ns3::LteAmc::GetCqiFromSpectralEfficiency(double s) [member function]
-    cls.add_method('GetCqiFromSpectralEfficiency', 
-                   'int', 
-                   [param('double', 's')])
-    ## lte-amc.h (module 'lte'): int ns3::LteAmc::GetMcsFromCqi(int cqi) [member function]
-    cls.add_method('GetMcsFromCqi', 
-                   'int', 
-                   [param('int', 'cqi')])
-    ## lte-amc.h (module 'lte'): double ns3::LteAmc::GetSpectralEfficiencyFromCqi(int cqi) [member function]
-    cls.add_method('GetSpectralEfficiencyFromCqi', 
-                   'double', 
-                   [param('int', 'cqi')])
-    ## lte-amc.h (module 'lte'): int ns3::LteAmc::GetTbSizeFromMcs(int mcs, int nprb) [member function]
-    cls.add_method('GetTbSizeFromMcs', 
-                   'int', 
-                   [param('int', 'mcs'), param('int', 'nprb')])
-    ## lte-amc.h (module 'lte'): static ns3::TypeId ns3::LteAmc::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    return
-
-def register_Ns3LteAnr_methods(root_module, cls):
-    ## lte-anr.h (module 'lte'): ns3::LteAnr::LteAnr(ns3::LteAnr const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteAnr const &', 'arg0')])
-    ## lte-anr.h (module 'lte'): ns3::LteAnr::LteAnr(uint16_t servingCellId) [constructor]
-    cls.add_constructor([param('uint16_t', 'servingCellId')])
-    ## lte-anr.h (module 'lte'): void ns3::LteAnr::AddNeighbourRelation(uint16_t cellId) [member function]
-    cls.add_method('AddNeighbourRelation', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-anr.h (module 'lte'): ns3::LteAnrSapProvider * ns3::LteAnr::GetLteAnrSapProvider() [member function]
-    cls.add_method('GetLteAnrSapProvider', 
-                   'ns3::LteAnrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-anr.h (module 'lte'): static ns3::TypeId ns3::LteAnr::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-anr.h (module 'lte'): void ns3::LteAnr::RemoveNeighbourRelation(uint16_t cellId) [member function]
-    cls.add_method('RemoveNeighbourRelation', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-anr.h (module 'lte'): void ns3::LteAnr::SetLteAnrSapUser(ns3::LteAnrSapUser * s) [member function]
-    cls.add_method('SetLteAnrSapUser', 
-                   'void', 
-                   [param('ns3::LteAnrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-anr.h (module 'lte'): void ns3::LteAnr::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-anr.h (module 'lte'): void ns3::LteAnr::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteChunkProcessor_methods(root_module, cls):
-    ## lte-chunk-processor.h (module 'lte'): ns3::LteChunkProcessor::LteChunkProcessor(ns3::LteChunkProcessor const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteChunkProcessor const &', 'arg0')])
-    ## lte-chunk-processor.h (module 'lte'): ns3::LteChunkProcessor::LteChunkProcessor() [constructor]
-    cls.add_constructor([])
-    ## lte-chunk-processor.h (module 'lte'): void ns3::LteChunkProcessor::AddCallback(ns3::LteChunkProcessorCallback c) [member function]
-    cls.add_method('AddCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')], 
-                   is_virtual=True)
-    ## lte-chunk-processor.h (module 'lte'): void ns3::LteChunkProcessor::End() [member function]
-    cls.add_method('End', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-chunk-processor.h (module 'lte'): void ns3::LteChunkProcessor::EvaluateChunk(ns3::SpectrumValue const & sinr, ns3::Time duration) [member function]
-    cls.add_method('EvaluateChunk', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr'), param('ns3::Time', 'duration')], 
-                   is_virtual=True)
-    ## lte-chunk-processor.h (module 'lte'): void ns3::LteChunkProcessor::Start() [member function]
-    cls.add_method('Start', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3LteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::LteControlMessage::LteControlMessage(ns3::LteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::LteControlMessage::LteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::LteControlMessage::MessageType ns3::LteControlMessage::GetMessageType() [member function]
-    cls.add_method('GetMessageType', 
-                   'ns3::LteControlMessage::MessageType', 
-                   [])
-    ## lte-control-messages.h (module 'lte'): void ns3::LteControlMessage::SetMessageType(ns3::LteControlMessage::MessageType type) [member function]
-    cls.add_method('SetMessageType', 
-                   'void', 
-                   [param('ns3::LteControlMessage::MessageType', 'type')])
-    return
-
-def register_Ns3LteEnbComponentCarrierManager_methods(root_module, cls):
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteEnbComponentCarrierManager::LteEnbComponentCarrierManager(ns3::LteEnbComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbComponentCarrierManager const &', 'arg0')])
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteEnbComponentCarrierManager::LteEnbComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteCcmMacSapUser * ns3::LteEnbComponentCarrierManager::GetLteCcmMacSapUser() [member function]
-    cls.add_method('GetLteCcmMacSapUser', 
-                   'ns3::LteCcmMacSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteCcmRrcSapProvider * ns3::LteEnbComponentCarrierManager::GetLteCcmRrcSapProvider() [member function]
-    cls.add_method('GetLteCcmRrcSapProvider', 
-                   'ns3::LteCcmRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteMacSapProvider * ns3::LteEnbComponentCarrierManager::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::LteEnbComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): bool ns3::LteEnbComponentCarrierManager::SetCcmMacSapProviders(uint8_t componentCarrierId, ns3::LteCcmMacSapProvider * sap) [member function]
-    cls.add_method('SetCcmMacSapProviders', 
-                   'bool', 
-                   [param('uint8_t', 'componentCarrierId'), param('ns3::LteCcmMacSapProvider *', 'sap')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::SetLteCcmRrcSapUser(ns3::LteCcmRrcSapUser * s) [member function]
-    cls.add_method('SetLteCcmRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteCcmRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): bool ns3::LteEnbComponentCarrierManager::SetMacSapProvider(uint8_t componentCarrierId, ns3::LteMacSapProvider * sap) [member function]
-    cls.add_method('SetMacSapProvider', 
-                   'bool', 
-                   [param('uint8_t', 'componentCarrierId'), param('ns3::LteMacSapProvider *', 'sap')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::SetNumberOfComponentCarriers(uint16_t noOfComponentCarriers) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint16_t', 'noOfComponentCarriers')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::SetRrc(ns3::Ptr<ns3::LteEnbRrc> const rrc) [member function]
-    cls.add_method('SetRrc', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteEnbRrc > const', 'rrc')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteEnbMac_methods(root_module, cls):
-    ## lte-enb-mac.h (module 'lte'): ns3::LteEnbMac::LteEnbMac(ns3::LteEnbMac const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbMac const &', 'arg0')])
-    ## lte-enb-mac.h (module 'lte'): ns3::LteEnbMac::LteEnbMac() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::DoReceivePhyPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoReceivePhyPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## lte-enb-mac.h (module 'lte'): ns3::FfMacCschedSapUser * ns3::LteEnbMac::GetFfMacCschedSapUser() [member function]
-    cls.add_method('GetFfMacCschedSapUser', 
-                   'ns3::FfMacCschedSapUser *', 
-                   [])
-    ## lte-enb-mac.h (module 'lte'): ns3::FfMacSchedSapUser * ns3::LteEnbMac::GetFfMacSchedSapUser() [member function]
-    cls.add_method('GetFfMacSchedSapUser', 
-                   'ns3::FfMacSchedSapUser *', 
-                   [])
-    ## lte-enb-mac.h (module 'lte'): ns3::LteCcmMacSapProvider * ns3::LteEnbMac::GetLteCcmMacSapProvider() [member function]
-    cls.add_method('GetLteCcmMacSapProvider', 
-                   'ns3::LteCcmMacSapProvider *', 
-                   [])
-    ## lte-enb-mac.h (module 'lte'): ns3::LteEnbCmacSapProvider * ns3::LteEnbMac::GetLteEnbCmacSapProvider() [member function]
-    cls.add_method('GetLteEnbCmacSapProvider', 
-                   'ns3::LteEnbCmacSapProvider *', 
-                   [])
-    ## lte-enb-mac.h (module 'lte'): ns3::LteEnbPhySapUser * ns3::LteEnbMac::GetLteEnbPhySapUser() [member function]
-    cls.add_method('GetLteEnbPhySapUser', 
-                   'ns3::LteEnbPhySapUser *', 
-                   [])
-    ## lte-enb-mac.h (module 'lte'): ns3::LteMacSapProvider * ns3::LteEnbMac::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [])
-    ## lte-enb-mac.h (module 'lte'): static ns3::TypeId ns3::LteEnbMac::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetComponentCarrierId(uint8_t index) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'index')])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetFfMacCschedSapProvider(ns3::FfMacCschedSapProvider * s) [member function]
-    cls.add_method('SetFfMacCschedSapProvider', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapProvider *', 's')])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetFfMacSchedSapProvider(ns3::FfMacSchedSapProvider * s) [member function]
-    cls.add_method('SetFfMacSchedSapProvider', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider *', 's')])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetLteCcmMacSapUser(ns3::LteCcmMacSapUser * s) [member function]
-    cls.add_method('SetLteCcmMacSapUser', 
-                   'void', 
-                   [param('ns3::LteCcmMacSapUser *', 's')])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetLteEnbCmacSapUser(ns3::LteEnbCmacSapUser * s) [member function]
-    cls.add_method('SetLteEnbCmacSapUser', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapUser *', 's')])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetLteEnbPhySapProvider(ns3::LteEnbPhySapProvider * s) [member function]
-    cls.add_method('SetLteEnbPhySapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbPhySapProvider *', 's')])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetLteMacSapUser(ns3::LteMacSapUser * s) [member function]
-    cls.add_method('SetLteMacSapUser', 
-                   'void', 
-                   [param('ns3::LteMacSapUser *', 's')])
-    return
-
-def register_Ns3LteEnbRrc_methods(root_module, cls):
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::LteEnbRrc(ns3::LteEnbRrc const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrc const &', 'arg0')])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::LteEnbRrc() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-rrc.h (module 'lte'): uint8_t ns3::LteEnbRrc::AddUeMeasReportConfig(ns3::LteRrcSap::ReportConfigEutra config) [member function]
-    cls.add_method('AddUeMeasReportConfig', 
-                   'uint8_t', 
-                   [param('ns3::LteRrcSap::ReportConfigEutra', 'config')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::AddX2Neighbour(uint16_t cellId) [member function]
-    cls.add_method('AddX2Neighbour', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-enb-rrc.h (module 'lte'): uint8_t ns3::LteEnbRrc::CellToComponentCarrierId(uint16_t cellId) [member function]
-    cls.add_method('CellToComponentCarrierId', 
-                   'uint8_t', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::LteEnbRrc::ComponentCarrierToCellId(uint8_t componentCarrierId) [member function]
-    cls.add_method('ComponentCarrierToCellId', 
-                   'uint16_t', 
-                   [param('uint8_t', 'componentCarrierId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConfigureCarriers(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ccPhyConf) [member function]
-    cls.add_method('ConfigureCarriers', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 'ccPhyConf')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConfigureCell(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ccPhyConf) [member function]
-    cls.add_method('ConfigureCell', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 'ccPhyConf')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConnectionRejectedTimeout(uint16_t rnti) [member function]
-    cls.add_method('ConnectionRejectedTimeout', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConnectionRequestTimeout(uint16_t rnti) [member function]
-    cls.add_method('ConnectionRequestTimeout', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConnectionSetupTimeout(uint16_t rnti) [member function]
-    cls.add_method('ConnectionSetupTimeout', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::DoSendReleaseDataRadioBearer(uint64_t imsi, uint16_t rnti, uint8_t bearerId) [member function]
-    cls.add_method('DoSendReleaseDataRadioBearer', 
-                   'void', 
-                   [param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'bearerId')])
-    ## lte-enb-rrc.h (module 'lte'): ns3::EpcX2SapUser * ns3::LteEnbRrc::GetEpcX2SapUser() [member function]
-    cls.add_method('GetEpcX2SapUser', 
-                   'ns3::EpcX2SapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteAnrSapUser * ns3::LteEnbRrc::GetLteAnrSapUser() [member function]
-    cls.add_method('GetLteAnrSapUser', 
-                   'ns3::LteAnrSapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteCcmRrcSapUser * ns3::LteEnbRrc::GetLteCcmRrcSapUser() [member function]
-    cls.add_method('GetLteCcmRrcSapUser', 
-                   'ns3::LteCcmRrcSapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCmacSapUser * ns3::LteEnbRrc::GetLteEnbCmacSapUser() [member function]
-    cls.add_method('GetLteEnbCmacSapUser', 
-                   'ns3::LteEnbCmacSapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCmacSapUser * ns3::LteEnbRrc::GetLteEnbCmacSapUser(uint8_t pos) [member function]
-    cls.add_method('GetLteEnbCmacSapUser', 
-                   'ns3::LteEnbCmacSapUser *', 
-                   [param('uint8_t', 'pos')])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCphySapUser * ns3::LteEnbRrc::GetLteEnbCphySapUser() [member function]
-    cls.add_method('GetLteEnbCphySapUser', 
-                   'ns3::LteEnbCphySapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCphySapUser * ns3::LteEnbRrc::GetLteEnbCphySapUser(uint8_t pos) [member function]
-    cls.add_method('GetLteEnbCphySapUser', 
-                   'ns3::LteEnbCphySapUser *', 
-                   [param('uint8_t', 'pos')])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrcSapProvider * ns3::LteEnbRrc::GetLteEnbRrcSapProvider() [member function]
-    cls.add_method('GetLteEnbRrcSapProvider', 
-                   'ns3::LteEnbRrcSapProvider *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteFfrRrcSapUser * ns3::LteEnbRrc::GetLteFfrRrcSapUser() [member function]
-    cls.add_method('GetLteFfrRrcSapUser', 
-                   'ns3::LteFfrRrcSapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteFfrRrcSapUser * ns3::LteEnbRrc::GetLteFfrRrcSapUser(uint8_t index) [member function]
-    cls.add_method('GetLteFfrRrcSapUser', 
-                   'ns3::LteFfrRrcSapUser *', 
-                   [param('uint8_t', 'index')])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteHandoverManagementSapUser * ns3::LteEnbRrc::GetLteHandoverManagementSapUser() [member function]
-    cls.add_method('GetLteHandoverManagementSapUser', 
-                   'ns3::LteHandoverManagementSapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::EpcEnbS1SapUser * ns3::LteEnbRrc::GetS1SapUser() [member function]
-    cls.add_method('GetS1SapUser', 
-                   'ns3::EpcEnbS1SapUser *', 
-                   [])
-    ## lte-enb-rrc.h (module 'lte'): uint32_t ns3::LteEnbRrc::GetSrsPeriodicity() const [member function]
-    cls.add_method('GetSrsPeriodicity', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-rrc.h (module 'lte'): static ns3::TypeId ns3::LteEnbRrc::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-enb-rrc.h (module 'lte'): ns3::Ptr<ns3::UeManager> ns3::LteEnbRrc::GetUeManager(uint16_t rnti) [member function]
-    cls.add_method('GetUeManager', 
-                   'ns3::Ptr< ns3::UeManager >', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::HandoverJoiningTimeout(uint16_t rnti) [member function]
-    cls.add_method('HandoverJoiningTimeout', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::HandoverLeavingTimeout(uint16_t rnti) [member function]
-    cls.add_method('HandoverLeavingTimeout', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-enb-rrc.h (module 'lte'): bool ns3::LteEnbRrc::HasUeManager(uint16_t rnti) const [member function]
-    cls.add_method('HasUeManager', 
-                   'bool', 
-                   [param('uint16_t', 'rnti')], 
-                   is_const=True)
-    ## lte-enb-rrc.h (module 'lte'): bool ns3::LteEnbRrc::SendData(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('SendData', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SendHandoverRequest(uint16_t rnti, uint16_t cellId) [member function]
-    cls.add_method('SendHandoverRequest', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint16_t', 'cellId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetCellId(uint16_t m_cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'm_cellId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetCellId(uint16_t m_cellId, uint8_t ccIndex) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'm_cellId'), param('uint8_t', 'ccIndex')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetCsgId(uint32_t csgId, bool csgIndication) [member function]
-    cls.add_method('SetCsgId', 
-                   'void', 
-                   [param('uint32_t', 'csgId'), param('bool', 'csgIndication')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetEpcX2SapProvider(ns3::EpcX2SapProvider * s) [member function]
-    cls.add_method('SetEpcX2SapProvider', 
-                   'void', 
-                   [param('ns3::EpcX2SapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetForwardUpCallback(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> cb) [member function]
-    cls.add_method('SetForwardUpCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteAnrSapProvider(ns3::LteAnrSapProvider * s) [member function]
-    cls.add_method('SetLteAnrSapProvider', 
-                   'void', 
-                   [param('ns3::LteAnrSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteCcmRrcSapProvider(ns3::LteCcmRrcSapProvider * s) [member function]
-    cls.add_method('SetLteCcmRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteCcmRrcSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCmacSapProvider(ns3::LteEnbCmacSapProvider * s) [member function]
-    cls.add_method('SetLteEnbCmacSapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCmacSapProvider(ns3::LteEnbCmacSapProvider * s, uint8_t pos) [member function]
-    cls.add_method('SetLteEnbCmacSapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider *', 's'), param('uint8_t', 'pos')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCphySapProvider(ns3::LteEnbCphySapProvider * s) [member function]
-    cls.add_method('SetLteEnbCphySapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbCphySapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCphySapProvider(ns3::LteEnbCphySapProvider * s, uint8_t pos) [member function]
-    cls.add_method('SetLteEnbCphySapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbCphySapProvider *', 's'), param('uint8_t', 'pos')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbRrcSapUser(ns3::LteEnbRrcSapUser * s) [member function]
-    cls.add_method('SetLteEnbRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteEnbRrcSapUser *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteFfrRrcSapProvider(ns3::LteFfrRrcSapProvider * s) [member function]
-    cls.add_method('SetLteFfrRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteFfrRrcSapProvider(ns3::LteFfrRrcSapProvider * s, uint8_t index) [member function]
-    cls.add_method('SetLteFfrRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapProvider *', 's'), param('uint8_t', 'index')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteHandoverManagementSapProvider(ns3::LteHandoverManagementSapProvider * s) [member function]
-    cls.add_method('SetLteHandoverManagementSapProvider', 
-                   'void', 
-                   [param('ns3::LteHandoverManagementSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteMacSapProvider(ns3::LteMacSapProvider * s) [member function]
-    cls.add_method('SetLteMacSapProvider', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetNumberOfComponentCarriers(uint16_t numberOfComponentCarriers) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint16_t', 'numberOfComponentCarriers')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetS1SapProvider(ns3::EpcEnbS1SapProvider * s) [member function]
-    cls.add_method('SetS1SapProvider', 
-                   'void', 
-                   [param('ns3::EpcEnbS1SapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetSrsPeriodicity(uint32_t p) [member function]
-    cls.add_method('SetSrsPeriodicity', 
-                   'void', 
-                   [param('uint32_t', 'p')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteEnbRrcProtocolIdeal_methods(root_module, cls):
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcProtocolIdeal::LteEnbRrcProtocolIdeal(ns3::LteEnbRrcProtocolIdeal const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrcProtocolIdeal const &', 'arg0')])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcProtocolIdeal::LteEnbRrcProtocolIdeal() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): void ns3::LteEnbRrcProtocolIdeal::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcSapUser * ns3::LteEnbRrcProtocolIdeal::GetLteEnbRrcSapUser() [member function]
-    cls.add_method('GetLteEnbRrcSapUser', 
-                   'ns3::LteEnbRrcSapUser *', 
-                   [])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): static ns3::TypeId ns3::LteEnbRrcProtocolIdeal::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteUeRrcSapProvider * ns3::LteEnbRrcProtocolIdeal::GetUeRrcSapProvider(uint16_t rnti) [member function]
-    cls.add_method('GetUeRrcSapProvider', 
-                   'ns3::LteUeRrcSapProvider *', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): void ns3::LteEnbRrcProtocolIdeal::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): void ns3::LteEnbRrcProtocolIdeal::SetLteEnbRrcSapProvider(ns3::LteEnbRrcSapProvider * p) [member function]
-    cls.add_method('SetLteEnbRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbRrcSapProvider *', 'p')])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): void ns3::LteEnbRrcProtocolIdeal::SetUeRrcSapProvider(uint16_t rnti, ns3::LteUeRrcSapProvider * p) [member function]
-    cls.add_method('SetUeRrcSapProvider', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteUeRrcSapProvider *', 'p')])
-    return
-
-def register_Ns3LteEnbRrcProtocolReal_methods(root_module, cls):
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteEnbRrcProtocolReal::LteEnbRrcProtocolReal(ns3::LteEnbRrcProtocolReal const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbRrcProtocolReal const &', 'arg0')])
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteEnbRrcProtocolReal::LteEnbRrcProtocolReal() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::LteEnbRrcProtocolReal::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteEnbRrcSapUser * ns3::LteEnbRrcProtocolReal::GetLteEnbRrcSapUser() [member function]
-    cls.add_method('GetLteEnbRrcSapUser', 
-                   'ns3::LteEnbRrcSapUser *', 
-                   [])
-    ## lte-rrc-protocol-real.h (module 'lte'): static ns3::TypeId ns3::LteEnbRrcProtocolReal::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteUeRrcSapProvider * ns3::LteEnbRrcProtocolReal::GetUeRrcSapProvider(uint16_t rnti) [member function]
-    cls.add_method('GetUeRrcSapProvider', 
-                   'ns3::LteUeRrcSapProvider *', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::LteEnbRrcProtocolReal::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::LteEnbRrcProtocolReal::SetLteEnbRrcSapProvider(ns3::LteEnbRrcSapProvider * p) [member function]
-    cls.add_method('SetLteEnbRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbRrcSapProvider *', 'p')])
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::LteEnbRrcProtocolReal::SetUeRrcSapProvider(uint16_t rnti, ns3::LteUeRrcSapProvider * p) [member function]
-    cls.add_method('SetUeRrcSapProvider', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteUeRrcSapProvider *', 'p')])
-    return
-
-def register_Ns3LteFfrAlgorithm_methods(root_module, cls):
-    ## lte-ffr-algorithm.h (module 'lte'): ns3::LteFfrAlgorithm::LteFfrAlgorithm(ns3::LteFfrAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrAlgorithm const &', 'arg0')])
-    ## lte-ffr-algorithm.h (module 'lte'): ns3::LteFfrAlgorithm::LteFfrAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-algorithm.h (module 'lte'): uint8_t ns3::LteFfrAlgorithm::GetDlBandwidth() const [member function]
-    cls.add_method('GetDlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ffr-algorithm.h (module 'lte'): uint8_t ns3::LteFfrAlgorithm::GetFrCellTypeId() const [member function]
-    cls.add_method('GetFrCellTypeId', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ffr-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFfrAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFfrAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFfrAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ffr-algorithm.h (module 'lte'): uint8_t ns3::LteFfrAlgorithm::GetUlBandwidth() const [member function]
-    cls.add_method('GetUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::SetDlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetDlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::SetFrCellTypeId(uint8_t cellTypeId) [member function]
-    cls.add_method('SetFrCellTypeId', 
-                   'void', 
-                   [param('uint8_t', 'cellTypeId')])
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::SetUlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetUlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): uint8_t ns3::LteFfrAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): uint8_t ns3::LteFfrAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): bool ns3::LteFfrAlgorithm::DoIsDlRbgAvailableForUe(int rbId, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'rbId'), param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): bool ns3::LteFfrAlgorithm::DoIsUlRbgAvailableForUe(int rbId, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'rbId'), param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoSetBandwidth(uint8_t ulBandwidth, uint8_t dlBandwidth) [member function]
-    cls.add_method('DoSetBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'ulBandwidth'), param('uint8_t', 'dlBandwidth')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::DoSetCellId(uint16_t cellId) [member function]
-    cls.add_method('DoSetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-algorithm.h (module 'lte'): int ns3::LteFfrAlgorithm::GetRbgSize(int dlbandwidth) [member function]
-    cls.add_method('GetRbgSize', 
-                   'int', 
-                   [param('int', 'dlbandwidth')], 
-                   visibility='protected')
-    ## lte-ffr-algorithm.h (module 'lte'): void ns3::LteFfrAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteFfrDistributedAlgorithm_methods(root_module, cls):
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): ns3::LteFfrDistributedAlgorithm::LteFfrDistributedAlgorithm(ns3::LteFfrDistributedAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrDistributedAlgorithm const &', 'arg0')])
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): ns3::LteFfrDistributedAlgorithm::LteFfrDistributedAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFfrDistributedAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFfrDistributedAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFfrDistributedAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrDistributedAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrDistributedAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): uint8_t ns3::LteFfrDistributedAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): uint8_t ns3::LteFfrDistributedAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): bool ns3::LteFfrDistributedAlgorithm::DoIsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): bool ns3::LteFfrDistributedAlgorithm::DoIsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-distributed-algorithm.h (module 'lte'): void ns3::LteFfrDistributedAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteFfrEnhancedAlgorithm_methods(root_module, cls):
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): ns3::LteFfrEnhancedAlgorithm::LteFfrEnhancedAlgorithm(ns3::LteFfrEnhancedAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrEnhancedAlgorithm const &', 'arg0')])
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): ns3::LteFfrEnhancedAlgorithm::LteFfrEnhancedAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFfrEnhancedAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFfrEnhancedAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFfrEnhancedAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrEnhancedAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrEnhancedAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): uint8_t ns3::LteFfrEnhancedAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): uint8_t ns3::LteFfrEnhancedAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): bool ns3::LteFfrEnhancedAlgorithm::DoIsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): bool ns3::LteFfrEnhancedAlgorithm::DoIsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-enhanced-algorithm.h (module 'lte'): void ns3::LteFfrEnhancedAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteFfrSoftAlgorithm_methods(root_module, cls):
-    ## lte-ffr-soft-algorithm.h (module 'lte'): ns3::LteFfrSoftAlgorithm::LteFfrSoftAlgorithm(ns3::LteFfrSoftAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFfrSoftAlgorithm const &', 'arg0')])
-    ## lte-ffr-soft-algorithm.h (module 'lte'): ns3::LteFfrSoftAlgorithm::LteFfrSoftAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-ffr-soft-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFfrSoftAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFfrSoftAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFfrSoftAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrSoftAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFfrSoftAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): uint8_t ns3::LteFfrSoftAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): uint8_t ns3::LteFfrSoftAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): bool ns3::LteFfrSoftAlgorithm::DoIsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): bool ns3::LteFfrSoftAlgorithm::DoIsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-ffr-soft-algorithm.h (module 'lte'): void ns3::LteFfrSoftAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteFrHardAlgorithm_methods(root_module, cls):
-    ## lte-fr-hard-algorithm.h (module 'lte'): ns3::LteFrHardAlgorithm::LteFrHardAlgorithm(ns3::LteFrHardAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFrHardAlgorithm const &', 'arg0')])
-    ## lte-fr-hard-algorithm.h (module 'lte'): ns3::LteFrHardAlgorithm::LteFrHardAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-fr-hard-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFrHardAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFrHardAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFrHardAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrHardAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrHardAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): uint8_t ns3::LteFrHardAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): uint8_t ns3::LteFrHardAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): bool ns3::LteFrHardAlgorithm::DoIsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): bool ns3::LteFrHardAlgorithm::DoIsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-hard-algorithm.h (module 'lte'): void ns3::LteFrHardAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteFrNoOpAlgorithm_methods(root_module, cls):
-    ## lte-fr-no-op-algorithm.h (module 'lte'): ns3::LteFrNoOpAlgorithm::LteFrNoOpAlgorithm(ns3::LteFrNoOpAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFrNoOpAlgorithm const &', 'arg0')])
-    ## lte-fr-no-op-algorithm.h (module 'lte'): ns3::LteFrNoOpAlgorithm::LteFrNoOpAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-fr-no-op-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFrNoOpAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFrNoOpAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFrNoOpAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrNoOpAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrNoOpAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): uint8_t ns3::LteFrNoOpAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): uint8_t ns3::LteFrNoOpAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): bool ns3::LteFrNoOpAlgorithm::DoIsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): bool ns3::LteFrNoOpAlgorithm::DoIsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-no-op-algorithm.h (module 'lte'): void ns3::LteFrNoOpAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteFrSoftAlgorithm_methods(root_module, cls):
-    ## lte-fr-soft-algorithm.h (module 'lte'): ns3::LteFrSoftAlgorithm::LteFrSoftAlgorithm(ns3::LteFrSoftAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFrSoftAlgorithm const &', 'arg0')])
-    ## lte-fr-soft-algorithm.h (module 'lte'): ns3::LteFrSoftAlgorithm::LteFrSoftAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-fr-soft-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFrSoftAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFrSoftAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFrSoftAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrSoftAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrSoftAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): uint8_t ns3::LteFrSoftAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): uint8_t ns3::LteFrSoftAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): bool ns3::LteFrSoftAlgorithm::DoIsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): bool ns3::LteFrSoftAlgorithm::DoIsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-soft-algorithm.h (module 'lte'): void ns3::LteFrSoftAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteFrStrictAlgorithm_methods(root_module, cls):
-    ## lte-fr-strict-algorithm.h (module 'lte'): ns3::LteFrStrictAlgorithm::LteFrStrictAlgorithm(ns3::LteFrStrictAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteFrStrictAlgorithm const &', 'arg0')])
-    ## lte-fr-strict-algorithm.h (module 'lte'): ns3::LteFrStrictAlgorithm::LteFrStrictAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-fr-strict-algorithm.h (module 'lte'): ns3::LteFfrRrcSapProvider * ns3::LteFrStrictAlgorithm::GetLteFfrRrcSapProvider() [member function]
-    cls.add_method('GetLteFfrRrcSapProvider', 
-                   'ns3::LteFfrRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): ns3::LteFfrSapProvider * ns3::LteFrStrictAlgorithm::GetLteFfrSapProvider() [member function]
-    cls.add_method('GetLteFfrSapProvider', 
-                   'ns3::LteFfrSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteFrStrictAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::SetLteFfrRrcSapUser(ns3::LteFfrRrcSapUser * s) [member function]
-    cls.add_method('SetLteFfrRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::SetLteFfrSapUser(ns3::LteFfrSapUser * s) [member function]
-    cls.add_method('SetLteFfrSapUser', 
-                   'void', 
-                   [param('ns3::LteFfrSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrStrictAlgorithm::DoGetAvailableDlRbg() [member function]
-    cls.add_method('DoGetAvailableDlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): std::vector<bool, std::allocator<bool> > ns3::LteFrStrictAlgorithm::DoGetAvailableUlRbg() [member function]
-    cls.add_method('DoGetAvailableUlRbg', 
-                   'std::vector< bool >', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): uint8_t ns3::LteFrStrictAlgorithm::DoGetMinContinuousUlBandwidth() [member function]
-    cls.add_method('DoGetMinContinuousUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): uint8_t ns3::LteFrStrictAlgorithm::DoGetTpc(uint16_t rnti) [member function]
-    cls.add_method('DoGetTpc', 
-                   'uint8_t', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): bool ns3::LteFrStrictAlgorithm::DoIsDlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsDlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): bool ns3::LteFrStrictAlgorithm::DoIsUlRbgAvailableForUe(int i, uint16_t rnti) [member function]
-    cls.add_method('DoIsUlRbgAvailableForUe', 
-                   'bool', 
-                   [param('int', 'i'), param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::DoRecvLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoRecvLoadInformation', 
-                   'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::DoReportDlCqiInfo(ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportDlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedDlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::DoReportUlCqiInfo(ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const & params) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters const &', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::DoReportUlCqiInfo(std::map<unsigned short, std::vector<double, std::allocator<double> >, std::less<unsigned short>, std::allocator<std::pair<const unsigned short, std::vector<double, std::allocator<double> > > > > ulCqiMap) [member function]
-    cls.add_method('DoReportUlCqiInfo', 
-                   'void', 
-                   [param('std::map< unsigned short, std::vector< double > >', 'ulCqiMap')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-fr-strict-algorithm.h (module 'lte'): void ns3::LteFrStrictAlgorithm::Reconfigure() [member function]
-    cls.add_method('Reconfigure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteHandoverAlgorithm_methods(root_module, cls):
-    ## lte-handover-algorithm.h (module 'lte'): ns3::LteHandoverAlgorithm::LteHandoverAlgorithm(ns3::LteHandoverAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteHandoverAlgorithm const &', 'arg0')])
-    ## lte-handover-algorithm.h (module 'lte'): ns3::LteHandoverAlgorithm::LteHandoverAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## lte-handover-algorithm.h (module 'lte'): ns3::LteHandoverManagementSapProvider * ns3::LteHandoverAlgorithm::GetLteHandoverManagementSapProvider() [member function]
-    cls.add_method('GetLteHandoverManagementSapProvider', 
-                   'ns3::LteHandoverManagementSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-handover-algorithm.h (module 'lte'): static ns3::TypeId ns3::LteHandoverAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-handover-algorithm.h (module 'lte'): void ns3::LteHandoverAlgorithm::SetLteHandoverManagementSapUser(ns3::LteHandoverManagementSapUser * s) [member function]
-    cls.add_method('SetLteHandoverManagementSapUser', 
-                   'void', 
-                   [param('ns3::LteHandoverManagementSapUser *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-handover-algorithm.h (module 'lte'): void ns3::LteHandoverAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-handover-algorithm.h (module 'lte'): void ns3::LteHandoverAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteHarqPhy_methods(root_module, cls):
-    ## lte-harq-phy.h (module 'lte'): ns3::LteHarqPhy::LteHarqPhy(ns3::LteHarqPhy const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteHarqPhy const &', 'arg0')])
-    ## lte-harq-phy.h (module 'lte'): ns3::LteHarqPhy::LteHarqPhy() [constructor]
-    cls.add_constructor([])
-    ## lte-harq-phy.h (module 'lte'): double ns3::LteHarqPhy::GetAccumulatedMiDl(uint8_t harqProcId, uint8_t layer) [member function]
-    cls.add_method('GetAccumulatedMiDl', 
-                   'double', 
-                   [param('uint8_t', 'harqProcId'), param('uint8_t', 'layer')])
-    ## lte-harq-phy.h (module 'lte'): double ns3::LteHarqPhy::GetAccumulatedMiUl(uint16_t rnti) [member function]
-    cls.add_method('GetAccumulatedMiUl', 
-                   'double', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoList_t ns3::LteHarqPhy::GetHarqProcessInfoDl(uint8_t harqProcId, uint8_t layer) [member function]
-    cls.add_method('GetHarqProcessInfoDl', 
-                   'ns3::HarqProcessInfoList_t', 
-                   [param('uint8_t', 'harqProcId'), param('uint8_t', 'layer')])
-    ## lte-harq-phy.h (module 'lte'): ns3::HarqProcessInfoList_t ns3::LteHarqPhy::GetHarqProcessInfoUl(uint16_t rnti, uint8_t harqProcId) [member function]
-    cls.add_method('GetHarqProcessInfoUl', 
-                   'ns3::HarqProcessInfoList_t', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'harqProcId')])
-    ## lte-harq-phy.h (module 'lte'): void ns3::LteHarqPhy::ResetDlHarqProcessStatus(uint8_t id) [member function]
-    cls.add_method('ResetDlHarqProcessStatus', 
-                   'void', 
-                   [param('uint8_t', 'id')])
-    ## lte-harq-phy.h (module 'lte'): void ns3::LteHarqPhy::ResetUlHarqProcessStatus(uint16_t rnti, uint8_t id) [member function]
-    cls.add_method('ResetUlHarqProcessStatus', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'id')])
-    ## lte-harq-phy.h (module 'lte'): void ns3::LteHarqPhy::SubframeIndication(uint32_t frameNo, uint32_t subframeNo) [member function]
-    cls.add_method('SubframeIndication', 
-                   'void', 
-                   [param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo')])
-    ## lte-harq-phy.h (module 'lte'): void ns3::LteHarqPhy::UpdateDlHarqProcessStatus(uint8_t id, uint8_t layer, double mi, uint16_t infoBytes, uint16_t codeBytes) [member function]
-    cls.add_method('UpdateDlHarqProcessStatus', 
-                   'void', 
-                   [param('uint8_t', 'id'), param('uint8_t', 'layer'), param('double', 'mi'), param('uint16_t', 'infoBytes'), param('uint16_t', 'codeBytes')])
-    ## lte-harq-phy.h (module 'lte'): void ns3::LteHarqPhy::UpdateUlHarqProcessStatus(uint16_t rnti, double mi, uint16_t infoBytes, uint16_t codeBytes) [member function]
-    cls.add_method('UpdateUlHarqProcessStatus', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('double', 'mi'), param('uint16_t', 'infoBytes'), param('uint16_t', 'codeBytes')])
-    return
-
-def register_Ns3LteHelper_methods(root_module, cls):
-    ## lte-helper.h (module 'lte'): ns3::LteHelper::LteHelper(ns3::LteHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteHelper const &', 'arg0')])
-    ## lte-helper.h (module 'lte'): ns3::LteHelper::LteHelper() [constructor]
-    cls.add_constructor([])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::ActivateDataRadioBearer(ns3::NetDeviceContainer ueDevices, ns3::EpsBearer bearer) [member function]
-    cls.add_method('ActivateDataRadioBearer', 
-                   'void', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices'), param('ns3::EpsBearer', 'bearer')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::ActivateDataRadioBearer(ns3::Ptr<ns3::NetDevice> ueDevice, ns3::EpsBearer bearer) [member function]
-    cls.add_method('ActivateDataRadioBearer', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueDevice'), param('ns3::EpsBearer', 'bearer')])
-    ## lte-helper.h (module 'lte'): uint8_t ns3::LteHelper::ActivateDedicatedEpsBearer(ns3::NetDeviceContainer ueDevices, ns3::EpsBearer bearer, ns3::Ptr<ns3::EpcTft> tft) [member function]
-    cls.add_method('ActivateDedicatedEpsBearer', 
-                   'uint8_t', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices'), param('ns3::EpsBearer', 'bearer'), param('ns3::Ptr< ns3::EpcTft >', 'tft')])
-    ## lte-helper.h (module 'lte'): uint8_t ns3::LteHelper::ActivateDedicatedEpsBearer(ns3::Ptr<ns3::NetDevice> ueDevice, ns3::EpsBearer bearer, ns3::Ptr<ns3::EpcTft> tft) [member function]
-    cls.add_method('ActivateDedicatedEpsBearer', 
-                   'uint8_t', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueDevice'), param('ns3::EpsBearer', 'bearer'), param('ns3::Ptr< ns3::EpcTft >', 'tft')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::AddX2Interface(ns3::NodeContainer enbNodes) [member function]
-    cls.add_method('AddX2Interface', 
-                   'void', 
-                   [param('ns3::NodeContainer', 'enbNodes')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::AddX2Interface(ns3::Ptr<ns3::Node> enbNode1, ns3::Ptr<ns3::Node> enbNode2) [member function]
-    cls.add_method('AddX2Interface', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'enbNode1'), param('ns3::Ptr< ns3::Node >', 'enbNode2')])
-    ## lte-helper.h (module 'lte'): int64_t ns3::LteHelper::AssignStreams(ns3::NetDeviceContainer c, int64_t stream) [member function]
-    cls.add_method('AssignStreams', 
-                   'int64_t', 
-                   [param('ns3::NetDeviceContainer', 'c'), param('int64_t', 'stream')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::Attach(ns3::NetDeviceContainer ueDevices) [member function]
-    cls.add_method('Attach', 
-                   'void', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::Attach(ns3::Ptr<ns3::NetDevice> ueDevice) [member function]
-    cls.add_method('Attach', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueDevice')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::Attach(ns3::NetDeviceContainer ueDevices, ns3::Ptr<ns3::NetDevice> enbDevice) [member function]
-    cls.add_method('Attach', 
-                   'void', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices'), param('ns3::Ptr< ns3::NetDevice >', 'enbDevice')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::Attach(ns3::Ptr<ns3::NetDevice> ueDevice, ns3::Ptr<ns3::NetDevice> enbDevice) [member function]
-    cls.add_method('Attach', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueDevice'), param('ns3::Ptr< ns3::NetDevice >', 'enbDevice')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::AttachToClosestEnb(ns3::NetDeviceContainer ueDevices, ns3::NetDeviceContainer enbDevices) [member function]
-    cls.add_method('AttachToClosestEnb', 
-                   'void', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices'), param('ns3::NetDeviceContainer', 'enbDevices')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::AttachToClosestEnb(ns3::Ptr<ns3::NetDevice> ueDevice, ns3::NetDeviceContainer enbDevices) [member function]
-    cls.add_method('AttachToClosestEnb', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueDevice'), param('ns3::NetDeviceContainer', 'enbDevices')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::DeActivateDedicatedEpsBearer(ns3::Ptr<ns3::NetDevice> ueDevice, ns3::Ptr<ns3::NetDevice> enbDevice, uint8_t bearerId) [member function]
-    cls.add_method('DeActivateDedicatedEpsBearer', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueDevice'), param('ns3::Ptr< ns3::NetDevice >', 'enbDevice'), param('uint8_t', 'bearerId')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableDlMacTraces() [member function]
-    cls.add_method('EnableDlMacTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableDlPhyTraces() [member function]
-    cls.add_method('EnableDlPhyTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableDlRxPhyTraces() [member function]
-    cls.add_method('EnableDlRxPhyTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableDlTxPhyTraces() [member function]
-    cls.add_method('EnableDlTxPhyTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableLogComponents() [member function]
-    cls.add_method('EnableLogComponents', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableMacTraces() [member function]
-    cls.add_method('EnableMacTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnablePdcpTraces() [member function]
-    cls.add_method('EnablePdcpTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnablePhyTraces() [member function]
-    cls.add_method('EnablePhyTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableRlcTraces() [member function]
-    cls.add_method('EnableRlcTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableTraces() [member function]
-    cls.add_method('EnableTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableUlMacTraces() [member function]
-    cls.add_method('EnableUlMacTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableUlPhyTraces() [member function]
-    cls.add_method('EnableUlPhyTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableUlRxPhyTraces() [member function]
-    cls.add_method('EnableUlRxPhyTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::EnableUlTxPhyTraces() [member function]
-    cls.add_method('EnableUlTxPhyTraces', 
-                   'void', 
-                   [])
-    ## lte-helper.h (module 'lte'): ns3::Ptr<ns3::SpectrumChannel> ns3::LteHelper::GetDownlinkSpectrumChannel() const [member function]
-    cls.add_method('GetDownlinkSpectrumChannel', 
-                   'ns3::Ptr< ns3::SpectrumChannel >', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetEnbComponentCarrierManagerType() const [member function]
-    cls.add_method('GetEnbComponentCarrierManagerType', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetFfrAlgorithmType() const [member function]
-    cls.add_method('GetFfrAlgorithmType', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetHandoverAlgorithmType() const [member function]
-    cls.add_method('GetHandoverAlgorithmType', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): ns3::Ptr<ns3::RadioBearerStatsCalculator> ns3::LteHelper::GetPdcpStats() [member function]
-    cls.add_method('GetPdcpStats', 
-                   'ns3::Ptr< ns3::RadioBearerStatsCalculator >', 
-                   [])
-    ## lte-helper.h (module 'lte'): ns3::Ptr<ns3::RadioBearerStatsCalculator> ns3::LteHelper::GetRlcStats() [member function]
-    cls.add_method('GetRlcStats', 
-                   'ns3::Ptr< ns3::RadioBearerStatsCalculator >', 
-                   [])
-    ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetSchedulerType() const [member function]
-    cls.add_method('GetSchedulerType', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): static ns3::TypeId ns3::LteHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetUeComponentCarrierManagerType() const [member function]
-    cls.add_method('GetUeComponentCarrierManagerType', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): ns3::Ptr<ns3::SpectrumChannel> ns3::LteHelper::GetUplinkSpectrumChannel() const [member function]
-    cls.add_method('GetUplinkSpectrumChannel', 
-                   'ns3::Ptr< ns3::SpectrumChannel >', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::HandoverRequest(ns3::Time hoTime, ns3::Ptr<ns3::NetDevice> ueDev, ns3::Ptr<ns3::NetDevice> sourceEnbDev, ns3::Ptr<ns3::NetDevice> targetEnbDev) [member function]
-    cls.add_method('HandoverRequest', 
-                   'void', 
-                   [param('ns3::Time', 'hoTime'), param('ns3::Ptr< ns3::NetDevice >', 'ueDev'), param('ns3::Ptr< ns3::NetDevice >', 'sourceEnbDev'), param('ns3::Ptr< ns3::NetDevice >', 'targetEnbDev')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::HandoverRequest(ns3::Time hoTime, ns3::Ptr<ns3::NetDevice> ueDev, ns3::Ptr<ns3::NetDevice> sourceEnbDev, uint16_t targetCellId) [member function]
-    cls.add_method('HandoverRequest', 
-                   'void', 
-                   [param('ns3::Time', 'hoTime'), param('ns3::Ptr< ns3::NetDevice >', 'ueDev'), param('ns3::Ptr< ns3::NetDevice >', 'sourceEnbDev'), param('uint16_t', 'targetCellId')])
-    ## lte-helper.h (module 'lte'): ns3::NetDeviceContainer ns3::LteHelper::InstallEnbDevice(ns3::NodeContainer c) [member function]
-    cls.add_method('InstallEnbDevice', 
-                   'ns3::NetDeviceContainer', 
-                   [param('ns3::NodeContainer', 'c')])
-    ## lte-helper.h (module 'lte'): ns3::NetDeviceContainer ns3::LteHelper::InstallUeDevice(ns3::NodeContainer c) [member function]
-    cls.add_method('InstallUeDevice', 
-                   'ns3::NetDeviceContainer', 
-                   [param('ns3::NodeContainer', 'c')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetCcPhyParams(std::map<unsigned char, ns3::ComponentCarrier, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::ComponentCarrier> > > ccmap) [member function]
-    cls.add_method('SetCcPhyParams', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::ComponentCarrier >', 'ccmap')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbAntennaModelAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetEnbAntennaModelAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbAntennaModelType(std::string type) [member function]
-    cls.add_method('SetEnbAntennaModelType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbComponentCarrierManagerAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetEnbComponentCarrierManagerAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbComponentCarrierManagerType(std::string type) [member function]
-    cls.add_method('SetEnbComponentCarrierManagerType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbDeviceAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetEnbDeviceAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEpcHelper(ns3::Ptr<ns3::EpcHelper> h) [member function]
-    cls.add_method('SetEpcHelper', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::EpcHelper >', 'h')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetFadingModel(std::string type) [member function]
-    cls.add_method('SetFadingModel', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetFadingModelAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetFadingModelAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetFfrAlgorithmAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetFfrAlgorithmAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetFfrAlgorithmType(std::string type) [member function]
-    cls.add_method('SetFfrAlgorithmType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetHandoverAlgorithmAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetHandoverAlgorithmAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetHandoverAlgorithmType(std::string type) [member function]
-    cls.add_method('SetHandoverAlgorithmType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetPathlossModelAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetPathlossModelAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetPathlossModelType(ns3::TypeId type) [member function]
-    cls.add_method('SetPathlossModelType', 
-                   'void', 
-                   [param('ns3::TypeId', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetSchedulerAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetSchedulerAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetSchedulerType(std::string type) [member function]
-    cls.add_method('SetSchedulerType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetSpectrumChannelAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetSpectrumChannelAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetSpectrumChannelType(std::string type) [member function]
-    cls.add_method('SetSpectrumChannelType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeAntennaModelAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetUeAntennaModelAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeAntennaModelType(std::string type) [member function]
-    cls.add_method('SetUeAntennaModelType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeComponentCarrierManagerAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetUeComponentCarrierManagerAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeComponentCarrierManagerType(std::string type) [member function]
-    cls.add_method('SetUeComponentCarrierManagerType', 
-                   'void', 
-                   [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeDeviceAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetUeDeviceAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteHexGridEnbTopologyHelper_methods(root_module, cls):
-    ## lte-hex-grid-enb-topology-helper.h (module 'lte'): ns3::LteHexGridEnbTopologyHelper::LteHexGridEnbTopologyHelper(ns3::LteHexGridEnbTopologyHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteHexGridEnbTopologyHelper const &', 'arg0')])
-    ## lte-hex-grid-enb-topology-helper.h (module 'lte'): ns3::LteHexGridEnbTopologyHelper::LteHexGridEnbTopologyHelper() [constructor]
-    cls.add_constructor([])
-    ## lte-hex-grid-enb-topology-helper.h (module 'lte'): void ns3::LteHexGridEnbTopologyHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-hex-grid-enb-topology-helper.h (module 'lte'): static ns3::TypeId ns3::LteHexGridEnbTopologyHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-hex-grid-enb-topology-helper.h (module 'lte'): void ns3::LteHexGridEnbTopologyHelper::SetLteHelper(ns3::Ptr<ns3::LteHelper> h) [member function]
-    cls.add_method('SetLteHelper', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteHelper >', 'h')])
-    ## lte-hex-grid-enb-topology-helper.h (module 'lte'): ns3::NetDeviceContainer ns3::LteHexGridEnbTopologyHelper::SetPositionAndInstallEnbDevice(ns3::NodeContainer c) [member function]
-    cls.add_method('SetPositionAndInstallEnbDevice', 
-                   'ns3::NetDeviceContainer', 
-                   [param('ns3::NodeContainer', 'c')])
-    return
-
-def register_Ns3LteInterference_methods(root_module, cls):
-    ## lte-interference.h (module 'lte'): ns3::LteInterference::LteInterference(ns3::LteInterference const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteInterference const &', 'arg0')])
-    ## lte-interference.h (module 'lte'): ns3::LteInterference::LteInterference() [constructor]
-    cls.add_constructor([])
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::AddInterferenceChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddInterferenceChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::AddRsPowerChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddRsPowerChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::AddSignal(ns3::Ptr<const ns3::SpectrumValue> spd, ns3::Time const duration) [member function]
-    cls.add_method('AddSignal', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'spd'), param('ns3::Time const', 'duration')])
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::AddSinrChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddSinrChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::EndRx() [member function]
-    cls.add_method('EndRx', 
-                   'void', 
-                   [])
-    ## lte-interference.h (module 'lte'): static ns3::TypeId ns3::LteInterference::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::SetNoisePowerSpectralDensity(ns3::Ptr<const ns3::SpectrumValue> noisePsd) [member function]
-    cls.add_method('SetNoisePowerSpectralDensity', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'noisePsd')])
-    ## lte-interference.h (module 'lte'): void ns3::LteInterference::StartRx(ns3::Ptr<const ns3::SpectrumValue> rxPsd) [member function]
-    cls.add_method('StartRx', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'rxPsd')])
-    return
-
-def register_Ns3LtePdcp_methods(root_module, cls):
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::LtePdcp(ns3::LtePdcp const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePdcp const &', 'arg0')])
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::LtePdcp() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcpSapProvider * ns3::LtePdcp::GetLtePdcpSapProvider() [member function]
-    cls.add_method('GetLtePdcpSapProvider', 
-                   'ns3::LtePdcpSapProvider *', 
-                   [])
-    ## lte-pdcp.h (module 'lte'): ns3::LteRlcSapUser * ns3::LtePdcp::GetLteRlcSapUser() [member function]
-    cls.add_method('GetLteRlcSapUser', 
-                   'ns3::LteRlcSapUser *', 
-                   [])
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::Status ns3::LtePdcp::GetStatus() [member function]
-    cls.add_method('GetStatus', 
-                   'ns3::LtePdcp::Status', 
-                   [])
-    ## lte-pdcp.h (module 'lte'): static ns3::TypeId ns3::LtePdcp::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::SetLcId(uint8_t lcId) [member function]
-    cls.add_method('SetLcId', 
-                   'void', 
-                   [param('uint8_t', 'lcId')])
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::SetLtePdcpSapUser(ns3::LtePdcpSapUser * s) [member function]
-    cls.add_method('SetLtePdcpSapUser', 
-                   'void', 
-                   [param('ns3::LtePdcpSapUser *', 's')])
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::SetLteRlcSapProvider(ns3::LteRlcSapProvider * s) [member function]
-    cls.add_method('SetLteRlcSapProvider', 
-                   'void', 
-                   [param('ns3::LteRlcSapProvider *', 's')])
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::SetStatus(ns3::LtePdcp::Status s) [member function]
-    cls.add_method('SetStatus', 
-                   'void', 
-                   [param('ns3::LtePdcp::Status', 's')])
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::MAX_PDCP_SN [variable]
-    cls.add_static_attribute('MAX_PDCP_SN', 'uint16_t const', is_const=True)
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   visibility='protected', is_virtual=True)
-    ## lte-pdcp.h (module 'lte'): void ns3::LtePdcp::DoTransmitPdcpSdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoTransmitPdcpSdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LtePdcpStatus_methods(root_module, cls):
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::Status::Status() [constructor]
-    cls.add_constructor([])
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::Status::Status(ns3::LtePdcp::Status const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePdcp::Status const &', 'arg0')])
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::Status::rxSn [variable]
-    cls.add_instance_attribute('rxSn', 'uint16_t', is_const=False)
-    ## lte-pdcp.h (module 'lte'): ns3::LtePdcp::Status::txSn [variable]
-    cls.add_instance_attribute('txSn', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LtePhy_methods(root_module, cls):
-    ## lte-phy.h (module 'lte'): ns3::LtePhy::LtePhy(ns3::LtePhy const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LtePhy const &', 'arg0')])
-    ## lte-phy.h (module 'lte'): ns3::LtePhy::LtePhy() [constructor]
-    cls.add_constructor([])
-    ## lte-phy.h (module 'lte'): ns3::LtePhy::LtePhy(ns3::Ptr<ns3::LteSpectrumPhy> dlPhy, ns3::Ptr<ns3::LteSpectrumPhy> ulPhy) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::LteSpectrumPhy >', 'dlPhy'), param('ns3::Ptr< ns3::LteSpectrumPhy >', 'ulPhy')])
-    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::SpectrumValue> ns3::LtePhy::CreateTxPowerSpectralDensity() [member function]
-    cls.add_method('CreateTxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::DoSendMacPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoSendMacPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::DoSetCellId(uint16_t cellId) [member function]
-    cls.add_method('DoSetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::GenerateCtrlCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GenerateCtrlCqiReport', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::GenerateDataCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GenerateDataCqiReport', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): uint8_t ns3::LtePhy::GetComponentCarrierId() [member function]
-    cls.add_method('GetComponentCarrierId', 
-                   'uint8_t', 
-                   [])
-    ## lte-phy.h (module 'lte'): std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > ns3::LtePhy::GetControlMessages() [member function]
-    cls.add_method('GetControlMessages', 
-                   'std::list< ns3::Ptr< ns3::LteControlMessage > >', 
-                   [])
-    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::LteNetDevice> ns3::LtePhy::GetDevice() const [member function]
-    cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::LteNetDevice >', 
-                   [], 
-                   is_const=True)
-    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LtePhy::GetDownlinkSpectrumPhy() [member function]
-    cls.add_method('GetDownlinkSpectrumPhy', 
-                   'ns3::Ptr< ns3::LteSpectrumPhy >', 
-                   [])
-    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::PacketBurst> ns3::LtePhy::GetPacketBurst() [member function]
-    cls.add_method('GetPacketBurst', 
-                   'ns3::Ptr< ns3::PacketBurst >', 
-                   [])
-    ## lte-phy.h (module 'lte'): uint8_t ns3::LtePhy::GetRbgSize() const [member function]
-    cls.add_method('GetRbgSize', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-phy.h (module 'lte'): uint16_t ns3::LtePhy::GetSrsPeriodicity(uint16_t srcCi) const [member function]
-    cls.add_method('GetSrsPeriodicity', 
-                   'uint16_t', 
-                   [param('uint16_t', 'srcCi')], 
-                   is_const=True)
-    ## lte-phy.h (module 'lte'): uint16_t ns3::LtePhy::GetSrsSubframeOffset(uint16_t srcCi) const [member function]
-    cls.add_method('GetSrsSubframeOffset', 
-                   'uint16_t', 
-                   [param('uint16_t', 'srcCi')], 
-                   is_const=True)
-    ## lte-phy.h (module 'lte'): double ns3::LtePhy::GetTti() const [member function]
-    cls.add_method('GetTti', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## lte-phy.h (module 'lte'): static ns3::TypeId ns3::LtePhy::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LtePhy::GetUplinkSpectrumPhy() [member function]
-    cls.add_method('GetUplinkSpectrumPhy', 
-                   'ns3::Ptr< ns3::LteSpectrumPhy >', 
-                   [])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::ReportInterference(ns3::SpectrumValue const & interf) [member function]
-    cls.add_method('ReportInterference', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'interf')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::ReportRsReceivedPower(ns3::SpectrumValue const & power) [member function]
-    cls.add_method('ReportRsReceivedPower', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'power')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetComponentCarrierId(uint8_t index) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'index')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetControlMessages(ns3::Ptr<ns3::LteControlMessage> m) [member function]
-    cls.add_method('SetControlMessages', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteControlMessage >', 'm')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDevice(ns3::Ptr<ns3::LteNetDevice> d) [member function]
-    cls.add_method('SetDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteNetDevice >', 'd')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDownlinkChannel(ns3::Ptr<ns3::SpectrumChannel> c) [member function]
-    cls.add_method('SetDownlinkChannel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumChannel >', 'c')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetMacPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('SetMacPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetTti(double tti) [member function]
-    cls.add_method('SetTti', 
-                   'void', 
-                   [param('double', 'tti')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetUplinkChannel(ns3::Ptr<ns3::SpectrumChannel> c) [member function]
-    cls.add_method('SetUplinkChannel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumChannel >', 'c')])
-    return
-
-def register_Ns3LteRadioBearerInfo_methods(root_module, cls):
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteRadioBearerInfo::LteRadioBearerInfo(ns3::LteRadioBearerInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRadioBearerInfo const &', 'arg0')])
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteRadioBearerInfo::LteRadioBearerInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-radio-bearer-info.h (module 'lte'): static ns3::TypeId ns3::LteRadioBearerInfo::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteRadioBearerInfo::m_pdcp [variable]
-    cls.add_instance_attribute('m_pdcp', 'ns3::Ptr< ns3::LtePdcp >', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteRadioBearerInfo::m_rlc [variable]
-    cls.add_instance_attribute('m_rlc', 'ns3::Ptr< ns3::LteRlc >', is_const=False)
-    return
-
-def register_Ns3LteRlc_methods(root_module, cls):
-    ## lte-rlc.h (module 'lte'): ns3::LteRlc::LteRlc(ns3::LteRlc const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlc const &', 'arg0')])
-    ## lte-rlc.h (module 'lte'): ns3::LteRlc::LteRlc() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc.h (module 'lte'): ns3::LteMacSapUser * ns3::LteRlc::GetLteMacSapUser() [member function]
-    cls.add_method('GetLteMacSapUser', 
-                   'ns3::LteMacSapUser *', 
-                   [])
-    ## lte-rlc.h (module 'lte'): ns3::LteRlcSapProvider * ns3::LteRlc::GetLteRlcSapProvider() [member function]
-    cls.add_method('GetLteRlcSapProvider', 
-                   'ns3::LteRlcSapProvider *', 
-                   [])
-    ## lte-rlc.h (module 'lte'): static ns3::TypeId ns3::LteRlc::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetLcId(uint8_t lcId) [member function]
-    cls.add_method('SetLcId', 
-                   'void', 
-                   [param('uint8_t', 'lcId')])
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetLteMacSapProvider(ns3::LteMacSapProvider * s) [member function]
-    cls.add_method('SetLteMacSapProvider', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider *', 's')])
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetLteRlcSapUser(ns3::LteRlcSapUser * s) [member function]
-    cls.add_method('SetLteRlcSapUser', 
-                   'void', 
-                   [param('ns3::LteRlcSapUser *', 's')])
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoTransmitPdcpPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteRlcAm_methods(root_module, cls):
-    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::LteRlcAm(ns3::LteRlcAm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcAm const &', 'arg0')])
-    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::LteRlcAm() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoTransmitPdcpPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_virtual=True)
-    ## lte-rlc-am.h (module 'lte'): static ns3::TypeId ns3::LteRlcAm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    return
-
-def register_Ns3LteRlcSm_methods(root_module, cls):
-    ## lte-rlc.h (module 'lte'): ns3::LteRlcSm::LteRlcSm(ns3::LteRlcSm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcSm const &', 'arg0')])
-    ## lte-rlc.h (module 'lte'): ns3::LteRlcSm::LteRlcSm() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoTransmitPdcpPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_virtual=True)
-    ## lte-rlc.h (module 'lte'): static ns3::TypeId ns3::LteRlcSm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    return
-
-def register_Ns3LteRlcTm_methods(root_module, cls):
-    ## lte-rlc-tm.h (module 'lte'): ns3::LteRlcTm::LteRlcTm(ns3::LteRlcTm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcTm const &', 'arg0')])
-    ## lte-rlc-tm.h (module 'lte'): ns3::LteRlcTm::LteRlcTm() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoTransmitPdcpPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_virtual=True)
-    ## lte-rlc-tm.h (module 'lte'): static ns3::TypeId ns3::LteRlcTm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    return
-
-def register_Ns3LteRlcUm_methods(root_module, cls):
-    ## lte-rlc-um.h (module 'lte'): ns3::LteRlcUm::LteRlcUm(ns3::LteRlcUm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcUm const &', 'arg0')])
-    ## lte-rlc-um.h (module 'lte'): ns3::LteRlcUm::LteRlcUm() [constructor]
-    cls.add_constructor([])
-    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_virtual=True)
-    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoTransmitPdcpPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   is_virtual=True)
-    ## lte-rlc-um.h (module 'lte'): static ns3::TypeId ns3::LteRlcUm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    return
-
-def register_Ns3LteSignalingRadioBearerInfo_methods(root_module, cls):
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo::LteSignalingRadioBearerInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo::LteSignalingRadioBearerInfo(ns3::LteSignalingRadioBearerInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteSignalingRadioBearerInfo const &', 'arg0')])
-    ## lte-radio-bearer-info.h (module 'lte'): static ns3::TypeId ns3::LteSignalingRadioBearerInfo::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo::m_logicalChannelConfig [variable]
-    cls.add_instance_attribute('m_logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo::m_srbIdentity [variable]
-    cls.add_instance_attribute('m_srbIdentity', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3LteSpectrumPhy_methods(root_module, cls):
-    ## lte-spectrum-phy.h (module 'lte'): ns3::LteSpectrumPhy::LteSpectrumPhy() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-phy.h (module 'lte'): static ns3::TypeId ns3::LteSpectrumPhy::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetChannel(ns3::Ptr<ns3::SpectrumChannel> c) [member function]
-    cls.add_method('SetChannel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumChannel >', 'c')], 
-                   is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetMobility(ns3::Ptr<ns3::MobilityModel> m) [member function]
-    cls.add_method('SetMobility', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::MobilityModel >', 'm')], 
-                   is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetDevice(ns3::Ptr<ns3::NetDevice> d) [member function]
-    cls.add_method('SetDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'd')], 
-                   is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::Ptr<ns3::MobilityModel> ns3::LteSpectrumPhy::GetMobility() [member function]
-    cls.add_method('GetMobility', 
-                   'ns3::Ptr< ns3::MobilityModel >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::Ptr<ns3::NetDevice> ns3::LteSpectrumPhy::GetDevice() const [member function]
-    cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::Ptr<const ns3::SpectrumModel> ns3::LteSpectrumPhy::GetRxSpectrumModel() const [member function]
-    cls.add_method('GetRxSpectrumModel', 
-                   'ns3::Ptr< ns3::SpectrumModel const >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): ns3::Ptr<ns3::AntennaModel> ns3::LteSpectrumPhy::GetRxAntenna() [member function]
-    cls.add_method('GetRxAntenna', 
-                   'ns3::Ptr< ns3::AntennaModel >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::StartRx(ns3::Ptr<ns3::SpectrumSignalParameters> params) [member function]
-    cls.add_method('StartRx', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumSignalParameters >', 'params')], 
-                   is_virtual=True)
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::StartRxData(ns3::Ptr<ns3::LteSpectrumSignalParametersDataFrame> params) [member function]
-    cls.add_method('StartRxData', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteSpectrumSignalParametersDataFrame >', 'params')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::StartRxDlCtrl(ns3::Ptr<ns3::LteSpectrumSignalParametersDlCtrlFrame> lteDlCtrlRxParams) [member function]
-    cls.add_method('StartRxDlCtrl', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteSpectrumSignalParametersDlCtrlFrame >', 'lteDlCtrlRxParams')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::StartRxUlSrs(ns3::Ptr<ns3::LteSpectrumSignalParametersUlSrsFrame> lteUlSrsRxParams) [member function]
-    cls.add_method('StartRxUlSrs', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteSpectrumSignalParametersUlSrsFrame >', 'lteUlSrsRxParams')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetHarqPhyModule(ns3::Ptr<ns3::LteHarqPhy> harq) [member function]
-    cls.add_method('SetHarqPhyModule', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteHarqPhy >', 'harq')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetTxPowerSpectralDensity(ns3::Ptr<ns3::SpectrumValue> txPsd) [member function]
-    cls.add_method('SetTxPowerSpectralDensity', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumValue >', 'txPsd')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetNoisePowerSpectralDensity(ns3::Ptr<const ns3::SpectrumValue> noisePsd) [member function]
-    cls.add_method('SetNoisePowerSpectralDensity', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumValue const >', 'noisePsd')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::Reset() [member function]
-    cls.add_method('Reset', 
-                   'void', 
-                   [])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetAntenna(ns3::Ptr<ns3::AntennaModel> a) [member function]
-    cls.add_method('SetAntenna', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::AntennaModel >', 'a')])
-    ## lte-spectrum-phy.h (module 'lte'): bool ns3::LteSpectrumPhy::StartTxDataFrame(ns3::Ptr<ns3::PacketBurst> pb, std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > ctrlMsgList, ns3::Time duration) [member function]
-    cls.add_method('StartTxDataFrame', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::PacketBurst >', 'pb'), param('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'ctrlMsgList'), param('ns3::Time', 'duration')])
-    ## lte-spectrum-phy.h (module 'lte'): bool ns3::LteSpectrumPhy::StartTxDlCtrlFrame(std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > ctrlMsgList, bool pss) [member function]
-    cls.add_method('StartTxDlCtrlFrame', 
-                   'bool', 
-                   [param('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'ctrlMsgList'), param('bool', 'pss')])
-    ## lte-spectrum-phy.h (module 'lte'): bool ns3::LteSpectrumPhy::StartTxUlSrsFrame() [member function]
-    cls.add_method('StartTxUlSrsFrame', 
-                   'bool', 
-                   [])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyRxDataEndErrorCallback(ns3::LtePhyRxDataEndErrorCallback c) [member function]
-    cls.add_method('SetLtePhyRxDataEndErrorCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyRxDataEndOkCallback(ns3::LtePhyRxDataEndOkCallback c) [member function]
-    cls.add_method('SetLtePhyRxDataEndOkCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyRxCtrlEndOkCallback(ns3::LtePhyRxCtrlEndOkCallback c) [member function]
-    cls.add_method('SetLtePhyRxCtrlEndOkCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, std::list< ns3::Ptr< ns3::LteControlMessage > >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyRxCtrlEndErrorCallback(ns3::LtePhyRxCtrlEndErrorCallback c) [member function]
-    cls.add_method('SetLtePhyRxCtrlEndErrorCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyRxPssCallback(ns3::LtePhyRxPssCallback c) [member function]
-    cls.add_method('SetLtePhyRxPssCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, unsigned short, ns3::Ptr< ns3::SpectrumValue >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyDlHarqFeedbackCallback(ns3::LtePhyDlHarqFeedbackCallback c) [member function]
-    cls.add_method('SetLtePhyDlHarqFeedbackCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::DlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyUlHarqFeedbackCallback(ns3::LtePhyUlHarqFeedbackCallback c) [member function]
-    cls.add_method('SetLtePhyUlHarqFeedbackCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::UlInfoListElement_s, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetState(ns3::LteSpectrumPhy::State newState) [member function]
-    cls.add_method('SetState', 
-                   'void', 
-                   [param('ns3::LteSpectrumPhy::State', 'newState')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetComponentCarrierId(uint8_t componentCarrierId) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'componentCarrierId')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddRsPowerChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddRsPowerChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddDataPowerChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddDataPowerChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddDataSinrChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddDataSinrChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddInterferenceCtrlChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddInterferenceCtrlChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddInterferenceDataChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddInterferenceDataChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddCtrlSinrChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
-    cls.add_method('AddCtrlSinrChunkProcessor', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteChunkProcessor >', 'p')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddExpectedTb(uint16_t rnti, uint8_t ndi, uint16_t size, uint8_t mcs, std::vector<int, std::allocator<int> > map, uint8_t layer, uint8_t harqId, uint8_t rv, bool downlink) [member function]
-    cls.add_method('AddExpectedTb', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'ndi'), param('uint16_t', 'size'), param('uint8_t', 'mcs'), param('std::vector< int >', 'map'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'rv'), param('bool', 'downlink')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::UpdateSinrPerceived(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('UpdateSinrPerceived', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetTransmissionMode(uint8_t txMode) [member function]
-    cls.add_method('SetTransmissionMode', 
-                   'void', 
-                   [param('uint8_t', 'txMode')])
-    ## lte-spectrum-phy.h (module 'lte'): ns3::Ptr<ns3::SpectrumChannel> ns3::LteSpectrumPhy::GetChannel() [member function]
-    cls.add_method('GetChannel', 
-                   'ns3::Ptr< ns3::SpectrumChannel >', 
-                   [])
-    ## lte-spectrum-phy.h (module 'lte'): int64_t ns3::LteSpectrumPhy::AssignStreams(int64_t stream) [member function]
-    cls.add_method('AssignStreams', 
-                   'int64_t', 
-                   [param('int64_t', 'stream')])
-    return
-
-def register_Ns3LteSpectrumSignalParameters_methods(root_module, cls):
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::Ptr<ns3::SpectrumSignalParameters> ns3::LteSpectrumSignalParameters::Copy() [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::SpectrumSignalParameters >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParameters::LteSpectrumSignalParameters() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParameters::LteSpectrumSignalParameters(ns3::LteSpectrumSignalParameters const & p) [constructor]
-    cls.add_constructor([param('ns3::LteSpectrumSignalParameters const &', 'p')])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParameters::packetBurst [variable]
-    cls.add_instance_attribute('packetBurst', 'ns3::Ptr< ns3::PacketBurst >', is_const=False)
-    return
-
-def register_Ns3LteSpectrumSignalParametersDataFrame_methods(root_module, cls):
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::Ptr<ns3::SpectrumSignalParameters> ns3::LteSpectrumSignalParametersDataFrame::Copy() [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::SpectrumSignalParameters >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDataFrame::LteSpectrumSignalParametersDataFrame() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDataFrame::LteSpectrumSignalParametersDataFrame(ns3::LteSpectrumSignalParametersDataFrame const & p) [constructor]
-    cls.add_constructor([param('ns3::LteSpectrumSignalParametersDataFrame const &', 'p')])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDataFrame::packetBurst [variable]
-    cls.add_instance_attribute('packetBurst', 'ns3::Ptr< ns3::PacketBurst >', is_const=False)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDataFrame::ctrlMsgList [variable]
-    cls.add_instance_attribute('ctrlMsgList', 'std::list< ns3::Ptr< ns3::LteControlMessage > >', is_const=False)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDataFrame::cellId [variable]
-    cls.add_instance_attribute('cellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteSpectrumSignalParametersDlCtrlFrame_methods(root_module, cls):
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::Ptr<ns3::SpectrumSignalParameters> ns3::LteSpectrumSignalParametersDlCtrlFrame::Copy() [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::SpectrumSignalParameters >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDlCtrlFrame::LteSpectrumSignalParametersDlCtrlFrame() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDlCtrlFrame::LteSpectrumSignalParametersDlCtrlFrame(ns3::LteSpectrumSignalParametersDlCtrlFrame const & p) [constructor]
-    cls.add_constructor([param('ns3::LteSpectrumSignalParametersDlCtrlFrame const &', 'p')])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDlCtrlFrame::ctrlMsgList [variable]
-    cls.add_instance_attribute('ctrlMsgList', 'std::list< ns3::Ptr< ns3::LteControlMessage > >', is_const=False)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDlCtrlFrame::cellId [variable]
-    cls.add_instance_attribute('cellId', 'uint16_t', is_const=False)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersDlCtrlFrame::pss [variable]
-    cls.add_instance_attribute('pss', 'bool', is_const=False)
-    return
-
-def register_Ns3LteSpectrumSignalParametersUlSrsFrame_methods(root_module, cls):
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::Ptr<ns3::SpectrumSignalParameters> ns3::LteSpectrumSignalParametersUlSrsFrame::Copy() [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::SpectrumSignalParameters >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersUlSrsFrame::LteSpectrumSignalParametersUlSrsFrame() [constructor]
-    cls.add_constructor([])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersUlSrsFrame::LteSpectrumSignalParametersUlSrsFrame(ns3::LteSpectrumSignalParametersUlSrsFrame const & p) [constructor]
-    cls.add_constructor([param('ns3::LteSpectrumSignalParametersUlSrsFrame const &', 'p')])
-    ## lte-spectrum-signal-parameters.h (module 'lte'): ns3::LteSpectrumSignalParametersUlSrsFrame::cellId [variable]
-    cls.add_instance_attribute('cellId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteStatsCalculator_methods(root_module, cls):
-    ## lte-stats-calculator.h (module 'lte'): ns3::LteStatsCalculator::LteStatsCalculator(ns3::LteStatsCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteStatsCalculator const &', 'arg0')])
-    ## lte-stats-calculator.h (module 'lte'): ns3::LteStatsCalculator::LteStatsCalculator() [constructor]
-    cls.add_constructor([])
-    ## lte-stats-calculator.h (module 'lte'): bool ns3::LteStatsCalculator::ExistsCellIdPath(std::string path) [member function]
-    cls.add_method('ExistsCellIdPath', 
-                   'bool', 
-                   [param('std::string', 'path')])
-    ## lte-stats-calculator.h (module 'lte'): bool ns3::LteStatsCalculator::ExistsImsiPath(std::string path) [member function]
-    cls.add_method('ExistsImsiPath', 
-                   'bool', 
-                   [param('std::string', 'path')])
-    ## lte-stats-calculator.h (module 'lte'): uint16_t ns3::LteStatsCalculator::GetCellIdPath(std::string path) [member function]
-    cls.add_method('GetCellIdPath', 
-                   'uint16_t', 
-                   [param('std::string', 'path')])
-    ## lte-stats-calculator.h (module 'lte'): std::string ns3::LteStatsCalculator::GetDlOutputFilename() [member function]
-    cls.add_method('GetDlOutputFilename', 
-                   'std::string', 
-                   [])
-    ## lte-stats-calculator.h (module 'lte'): uint64_t ns3::LteStatsCalculator::GetImsiPath(std::string path) [member function]
-    cls.add_method('GetImsiPath', 
-                   'uint64_t', 
-                   [param('std::string', 'path')])
-    ## lte-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::LteStatsCalculator::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-stats-calculator.h (module 'lte'): std::string ns3::LteStatsCalculator::GetUlOutputFilename() [member function]
-    cls.add_method('GetUlOutputFilename', 
-                   'std::string', 
-                   [])
-    ## lte-stats-calculator.h (module 'lte'): void ns3::LteStatsCalculator::SetCellIdPath(std::string path, uint16_t cellId) [member function]
-    cls.add_method('SetCellIdPath', 
-                   'void', 
-                   [param('std::string', 'path'), param('uint16_t', 'cellId')])
-    ## lte-stats-calculator.h (module 'lte'): void ns3::LteStatsCalculator::SetDlOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetDlOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## lte-stats-calculator.h (module 'lte'): void ns3::LteStatsCalculator::SetImsiPath(std::string path, uint64_t imsi) [member function]
-    cls.add_method('SetImsiPath', 
-                   'void', 
-                   [param('std::string', 'path'), param('uint64_t', 'imsi')])
-    ## lte-stats-calculator.h (module 'lte'): void ns3::LteStatsCalculator::SetUlOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetUlOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## lte-stats-calculator.h (module 'lte'): static uint16_t ns3::LteStatsCalculator::FindCellIdFromEnbMac(std::string path, uint16_t rnti) [member function]
-    cls.add_method('FindCellIdFromEnbMac', 
-                   'uint16_t', 
-                   [param('std::string', 'path'), param('uint16_t', 'rnti')], 
-                   is_static=True, visibility='protected')
-    ## lte-stats-calculator.h (module 'lte'): static uint16_t ns3::LteStatsCalculator::FindCellIdFromEnbRlcPath(std::string path) [member function]
-    cls.add_method('FindCellIdFromEnbRlcPath', 
-                   'uint16_t', 
-                   [param('std::string', 'path')], 
-                   is_static=True, visibility='protected')
-    ## lte-stats-calculator.h (module 'lte'): static uint64_t ns3::LteStatsCalculator::FindImsiForEnb(std::string path, uint16_t rnti) [member function]
-    cls.add_method('FindImsiForEnb', 
-                   'uint64_t', 
-                   [param('std::string', 'path'), param('uint16_t', 'rnti')], 
-                   is_static=True, visibility='protected')
-    ## lte-stats-calculator.h (module 'lte'): static uint64_t ns3::LteStatsCalculator::FindImsiForUe(std::string path, uint16_t rnti) [member function]
-    cls.add_method('FindImsiForUe', 
-                   'uint64_t', 
-                   [param('std::string', 'path'), param('uint16_t', 'rnti')], 
-                   is_static=True, visibility='protected')
-    ## lte-stats-calculator.h (module 'lte'): static uint64_t ns3::LteStatsCalculator::FindImsiFromEnbMac(std::string path, uint16_t rnti) [member function]
-    cls.add_method('FindImsiFromEnbMac', 
-                   'uint64_t', 
-                   [param('std::string', 'path'), param('uint16_t', 'rnti')], 
-                   is_static=True, visibility='protected')
-    ## lte-stats-calculator.h (module 'lte'): static uint64_t ns3::LteStatsCalculator::FindImsiFromEnbRlcPath(std::string path) [member function]
-    cls.add_method('FindImsiFromEnbRlcPath', 
-                   'uint64_t', 
-                   [param('std::string', 'path')], 
-                   is_static=True, visibility='protected')
-    ## lte-stats-calculator.h (module 'lte'): static uint64_t ns3::LteStatsCalculator::FindImsiFromLteNetDevice(std::string path) [member function]
-    cls.add_method('FindImsiFromLteNetDevice', 
-                   'uint64_t', 
-                   [param('std::string', 'path')], 
-                   is_static=True, visibility='protected')
-    ## lte-stats-calculator.h (module 'lte'): static uint64_t ns3::LteStatsCalculator::FindImsiFromUePhy(std::string path) [member function]
-    cls.add_method('FindImsiFromUePhy', 
-                   'uint64_t', 
-                   [param('std::string', 'path')], 
-                   is_static=True, visibility='protected')
-    return
-
-def register_Ns3LteUeComponentCarrierManager_methods(root_module, cls):
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeComponentCarrierManager::LteUeComponentCarrierManager(ns3::LteUeComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeComponentCarrierManager const &', 'arg0')])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeComponentCarrierManager::LteUeComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeCcmRrcSapProvider * ns3::LteUeComponentCarrierManager::GetLteCcmRrcSapProvider() [member function]
-    cls.add_method('GetLteCcmRrcSapProvider', 
-                   'ns3::LteUeCcmRrcSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteMacSapProvider * ns3::LteUeComponentCarrierManager::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::LteUeComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): bool ns3::LteUeComponentCarrierManager::SetComponentCarrierMacSapProviders(uint8_t componentCarrierId, ns3::LteMacSapProvider * sap) [member function]
-    cls.add_method('SetComponentCarrierMacSapProviders', 
-                   'bool', 
-                   [param('uint8_t', 'componentCarrierId'), param('ns3::LteMacSapProvider *', 'sap')])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): void ns3::LteUeComponentCarrierManager::SetLteCcmRrcSapUser(ns3::LteUeCcmRrcSapUser * s) [member function]
-    cls.add_method('SetLteCcmRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteUeCcmRrcSapUser *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): void ns3::LteUeComponentCarrierManager::SetNumberOfComponentCarriers(uint8_t noOfComponentCarriers) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint8_t', 'noOfComponentCarriers')])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): void ns3::LteUeComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3LteUeMac_methods(root_module, cls):
-    ## lte-ue-mac.h (module 'lte'): ns3::LteUeMac::LteUeMac(ns3::LteUeMac const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeMac const &', 'arg0')])
-    ## lte-ue-mac.h (module 'lte'): ns3::LteUeMac::LteUeMac() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-mac.h (module 'lte'): int64_t ns3::LteUeMac::AssignStreams(int64_t stream) [member function]
-    cls.add_method('AssignStreams', 
-                   'int64_t', 
-                   [param('int64_t', 'stream')])
-    ## lte-ue-mac.h (module 'lte'): void ns3::LteUeMac::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ue-mac.h (module 'lte'): void ns3::LteUeMac::DoSubframeIndication(uint32_t frameNo, uint32_t subframeNo) [member function]
-    cls.add_method('DoSubframeIndication', 
-                   'void', 
-                   [param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo')])
-    ## lte-ue-mac.h (module 'lte'): ns3::LteMacSapProvider * ns3::LteUeMac::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [])
-    ## lte-ue-mac.h (module 'lte'): ns3::LteUeCmacSapProvider * ns3::LteUeMac::GetLteUeCmacSapProvider() [member function]
-    cls.add_method('GetLteUeCmacSapProvider', 
-                   'ns3::LteUeCmacSapProvider *', 
-                   [])
-    ## lte-ue-mac.h (module 'lte'): ns3::LteUePhySapUser * ns3::LteUeMac::GetLteUePhySapUser() [member function]
-    cls.add_method('GetLteUePhySapUser', 
-                   'ns3::LteUePhySapUser *', 
-                   [])
-    ## lte-ue-mac.h (module 'lte'): static ns3::TypeId ns3::LteUeMac::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ue-mac.h (module 'lte'): void ns3::LteUeMac::SetComponentCarrierId(uint8_t index) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'index')])
-    ## lte-ue-mac.h (module 'lte'): void ns3::LteUeMac::SetLteUeCmacSapUser(ns3::LteUeCmacSapUser * s) [member function]
-    cls.add_method('SetLteUeCmacSapUser', 
-                   'void', 
-                   [param('ns3::LteUeCmacSapUser *', 's')])
-    ## lte-ue-mac.h (module 'lte'): void ns3::LteUeMac::SetLteUePhySapProvider(ns3::LteUePhySapProvider * s) [member function]
-    cls.add_method('SetLteUePhySapProvider', 
-                   'void', 
-                   [param('ns3::LteUePhySapProvider *', 's')])
-    return
-
-def register_Ns3LteUePhy_methods(root_module, cls):
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUePhy::LteUePhy(ns3::LteUePhy const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUePhy const &', 'arg0')])
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUePhy::LteUePhy() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUePhy::LteUePhy(ns3::Ptr<ns3::LteSpectrumPhy> dlPhy, ns3::Ptr<ns3::LteSpectrumPhy> ulPhy) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::LteSpectrumPhy >', 'dlPhy'), param('ns3::Ptr< ns3::LteSpectrumPhy >', 'ulPhy')])
-    ## lte-ue-phy.h (module 'lte'): ns3::Ptr<ns3::DlCqiLteControlMessage> ns3::LteUePhy::CreateDlCqiFeedbackMessage(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('CreateDlCqiFeedbackMessage', 
-                   'ns3::Ptr< ns3::DlCqiLteControlMessage >', 
-                   [param('ns3::SpectrumValue const &', 'sinr')])
-    ## lte-ue-phy.h (module 'lte'): ns3::Ptr<ns3::SpectrumValue> ns3::LteUePhy::CreateTxPowerSpectralDensity() [member function]
-    cls.add_method('CreateTxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::GenerateCtrlCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GenerateCtrlCqiReport', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::GenerateDataCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GenerateDataCqiReport', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::GenerateMixedCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GenerateMixedCqiReport', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LteUePhy::GetDlSpectrumPhy() const [member function]
-    cls.add_method('GetDlSpectrumPhy', 
-                   'ns3::Ptr< ns3::LteSpectrumPhy >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUeCphySapProvider * ns3::LteUePhy::GetLteUeCphySapProvider() [member function]
-    cls.add_method('GetLteUeCphySapProvider', 
-                   'ns3::LteUeCphySapProvider *', 
-                   [])
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUePhySapProvider * ns3::LteUePhy::GetLteUePhySapProvider() [member function]
-    cls.add_method('GetLteUePhySapProvider', 
-                   'ns3::LteUePhySapProvider *', 
-                   [])
-    ## lte-ue-phy.h (module 'lte'): uint8_t ns3::LteUePhy::GetMacChDelay() const [member function]
-    cls.add_method('GetMacChDelay', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-phy.h (module 'lte'): double ns3::LteUePhy::GetNoiseFigure() const [member function]
-    cls.add_method('GetNoiseFigure', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-phy.h (module 'lte'): ns3::LteUePhy::State ns3::LteUePhy::GetState() const [member function]
-    cls.add_method('GetState', 
-                   'ns3::LteUePhy::State', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-phy.h (module 'lte'): std::vector<int, std::allocator<int> > ns3::LteUePhy::GetSubChannelsForReception() [member function]
-    cls.add_method('GetSubChannelsForReception', 
-                   'std::vector< int >', 
-                   [])
-    ## lte-ue-phy.h (module 'lte'): std::vector<int, std::allocator<int> > ns3::LteUePhy::GetSubChannelsForTransmission() [member function]
-    cls.add_method('GetSubChannelsForTransmission', 
-                   'std::vector< int >', 
-                   [])
-    ## lte-ue-phy.h (module 'lte'): double ns3::LteUePhy::GetTxPower() const [member function]
-    cls.add_method('GetTxPower', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-phy.h (module 'lte'): static ns3::TypeId ns3::LteUePhy::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ue-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LteUePhy::GetUlSpectrumPhy() const [member function]
-    cls.add_method('GetUlSpectrumPhy', 
-                   'ns3::Ptr< ns3::LteSpectrumPhy >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-phy.h (module 'lte'): ns3::Ptr<ns3::LteUePowerControl> ns3::LteUePhy::GetUplinkPowerControl() const [member function]
-    cls.add_method('GetUplinkPowerControl', 
-                   'ns3::Ptr< ns3::LteUePowerControl >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::PhyPduReceived(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('PhyPduReceived', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReceiveLteControlMessageList(std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > msgList) [member function]
-    cls.add_method('ReceiveLteControlMessageList', 
-                   'void', 
-                   [param('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'msgList')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReceiveLteDlHarqFeedback(ns3::DlInfoListElement_s mes) [member function]
-    cls.add_method('ReceiveLteDlHarqFeedback', 
-                   'void', 
-                   [param('ns3::DlInfoListElement_s', 'mes')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReceivePss(uint16_t cellId, ns3::Ptr<ns3::SpectrumValue> p) [member function]
-    cls.add_method('ReceivePss', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::Ptr< ns3::SpectrumValue >', 'p')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReportDataInterference(ns3::SpectrumValue const & interf) [member function]
-    cls.add_method('ReportDataInterference', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'interf')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReportInterference(ns3::SpectrumValue const & interf) [member function]
-    cls.add_method('ReportInterference', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'interf')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReportRsReceivedPower(ns3::SpectrumValue const & power) [member function]
-    cls.add_method('ReportRsReceivedPower', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'power')], 
-                   is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SendSrs() [member function]
-    cls.add_method('SendSrs', 
-                   'void', 
-                   [])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SetHarqPhyModule(ns3::Ptr<ns3::LteHarqPhy> harq) [member function]
-    cls.add_method('SetHarqPhyModule', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteHarqPhy >', 'harq')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SetLteUeCphySapUser(ns3::LteUeCphySapUser * s) [member function]
-    cls.add_method('SetLteUeCphySapUser', 
-                   'void', 
-                   [param('ns3::LteUeCphySapUser *', 's')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SetLteUePhySapUser(ns3::LteUePhySapUser * s) [member function]
-    cls.add_method('SetLteUePhySapUser', 
-                   'void', 
-                   [param('ns3::LteUePhySapUser *', 's')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SetNoiseFigure(double nf) [member function]
-    cls.add_method('SetNoiseFigure', 
-                   'void', 
-                   [param('double', 'nf')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SetSubChannelsForReception(std::vector<int, std::allocator<int> > mask) [member function]
-    cls.add_method('SetSubChannelsForReception', 
-                   'void', 
-                   [param('std::vector< int >', 'mask')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SetSubChannelsForTransmission(std::vector<int, std::allocator<int> > mask) [member function]
-    cls.add_method('SetSubChannelsForTransmission', 
-                   'void', 
-                   [param('std::vector< int >', 'mask')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SetTxPower(double pow) [member function]
-    cls.add_method('SetTxPower', 
-                   'void', 
-                   [param('double', 'pow')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::SubframeIndication(uint32_t frameNo, uint32_t subframeNo) [member function]
-    cls.add_method('SubframeIndication', 
-                   'void', 
-                   [param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::DoSendLteControlMessage(ns3::Ptr<ns3::LteControlMessage> msg) [member function]
-    cls.add_method('DoSendLteControlMessage', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteControlMessage >', 'msg')], 
-                   visibility='private', is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::DoSendMacPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoSendMacPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   visibility='private', is_virtual=True)
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::DoSendRachPreamble(uint32_t prachId, uint32_t raRnti) [member function]
-    cls.add_method('DoSendRachPreamble', 
-                   'void', 
-                   [param('uint32_t', 'prachId'), param('uint32_t', 'raRnti')], 
-                   visibility='private', is_virtual=True)
-    return
-
-def register_Ns3LteUePowerControl_methods(root_module, cls):
-    ## lte-ue-power-control.h (module 'lte'): ns3::LteUePowerControl::LteUePowerControl(ns3::LteUePowerControl const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUePowerControl const &', 'arg0')])
-    ## lte-ue-power-control.h (module 'lte'): ns3::LteUePowerControl::LteUePowerControl() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::CalculatePucchTxPower() [member function]
-    cls.add_method('CalculatePucchTxPower', 
-                   'void', 
-                   [])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::CalculatePuschTxPower() [member function]
-    cls.add_method('CalculatePuschTxPower', 
-                   'void', 
-                   [])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::CalculateSrsTxPower() [member function]
-    cls.add_method('CalculateSrsTxPower', 
-                   'void', 
-                   [])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::ConfigureReferenceSignalPower(int8_t referenceSignalPower) [member function]
-    cls.add_method('ConfigureReferenceSignalPower', 
-                   'void', 
-                   [param('int8_t', 'referenceSignalPower')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ue-power-control.h (module 'lte'): double ns3::LteUePowerControl::GetPcmax() [member function]
-    cls.add_method('GetPcmax', 
-                   'double', 
-                   [])
-    ## lte-ue-power-control.h (module 'lte'): double ns3::LteUePowerControl::GetPucchTxPower(std::vector<int, std::allocator<int> > rb) [member function]
-    cls.add_method('GetPucchTxPower', 
-                   'double', 
-                   [param('std::vector< int >', 'rb')])
-    ## lte-ue-power-control.h (module 'lte'): double ns3::LteUePowerControl::GetPuschTxPower(std::vector<int, std::allocator<int> > rb) [member function]
-    cls.add_method('GetPuschTxPower', 
-                   'double', 
-                   [param('std::vector< int >', 'rb')])
-    ## lte-ue-power-control.h (module 'lte'): double ns3::LteUePowerControl::GetSrsTxPower(std::vector<int, std::allocator<int> > rb) [member function]
-    cls.add_method('GetSrsTxPower', 
-                   'double', 
-                   [param('std::vector< int >', 'rb')])
-    ## lte-ue-power-control.h (module 'lte'): static ns3::TypeId ns3::LteUePowerControl::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::ReportTpc(uint8_t tpc) [member function]
-    cls.add_method('ReportTpc', 
-                   'void', 
-                   [param('uint8_t', 'tpc')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetAlpha(double value) [member function]
-    cls.add_method('SetAlpha', 
-                   'void', 
-                   [param('double', 'value')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetPcmax(double value) [member function]
-    cls.add_method('SetPcmax', 
-                   'void', 
-                   [param('double', 'value')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetPoNominalPusch(int16_t value) [member function]
-    cls.add_method('SetPoNominalPusch', 
-                   'void', 
-                   [param('int16_t', 'value')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetPoUePusch(int16_t value) [member function]
-    cls.add_method('SetPoUePusch', 
-                   'void', 
-                   [param('int16_t', 'value')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetRsrp(double value) [member function]
-    cls.add_method('SetRsrp', 
-                   'void', 
-                   [param('double', 'value')])
-    ## lte-ue-power-control.h (module 'lte'): void ns3::LteUePowerControl::SetTxPower(double value) [member function]
-    cls.add_method('SetTxPower', 
-                   'void', 
-                   [param('double', 'value')])
-    return
-
-def register_Ns3LteUeRrc_methods(root_module, cls):
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::LteUeRrc(ns3::LteUeRrc const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeRrc const &', 'arg0')])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::LteUeRrc() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteAsSapProvider * ns3::LteUeRrc::GetAsSapProvider() [member function]
-    cls.add_method('GetAsSapProvider', 
-                   'ns3::LteAsSapProvider *', 
-                   [])
-    ## lte-ue-rrc.h (module 'lte'): uint16_t ns3::LteUeRrc::GetCellId() const [member function]
-    cls.add_method('GetCellId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): uint8_t ns3::LteUeRrc::GetDlBandwidth() const [member function]
-    cls.add_method('GetDlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): uint32_t ns3::LteUeRrc::GetDlEarfcn() const [member function]
-    cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): uint64_t ns3::LteUeRrc::GetImsi() const [member function]
-    cls.add_method('GetImsi', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCcmRrcSapUser * ns3::LteUeRrc::GetLteCcmRrcSapUser() [member function]
-    cls.add_method('GetLteCcmRrcSapUser', 
-                   'ns3::LteUeCcmRrcSapUser *', 
-                   [])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCmacSapUser * ns3::LteUeRrc::GetLteUeCmacSapUser() [member function]
-    cls.add_method('GetLteUeCmacSapUser', 
-                   'ns3::LteUeCmacSapUser *', 
-                   [])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCmacSapUser * ns3::LteUeRrc::GetLteUeCmacSapUser(uint8_t index) [member function]
-    cls.add_method('GetLteUeCmacSapUser', 
-                   'ns3::LteUeCmacSapUser *', 
-                   [param('uint8_t', 'index')])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCphySapUser * ns3::LteUeRrc::GetLteUeCphySapUser() [member function]
-    cls.add_method('GetLteUeCphySapUser', 
-                   'ns3::LteUeCphySapUser *', 
-                   [])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCphySapUser * ns3::LteUeRrc::GetLteUeCphySapUser(uint8_t index) [member function]
-    cls.add_method('GetLteUeCphySapUser', 
-                   'ns3::LteUeCphySapUser *', 
-                   [param('uint8_t', 'index')])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrcSapProvider * ns3::LteUeRrc::GetLteUeRrcSapProvider() [member function]
-    cls.add_method('GetLteUeRrcSapProvider', 
-                   'ns3::LteUeRrcSapProvider *', 
-                   [])
-    ## lte-ue-rrc.h (module 'lte'): uint16_t ns3::LteUeRrc::GetRnti() const [member function]
-    cls.add_method('GetRnti', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::State ns3::LteUeRrc::GetState() const [member function]
-    cls.add_method('GetState', 
-                   'ns3::LteUeRrc::State', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): static ns3::TypeId ns3::LteUeRrc::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ue-rrc.h (module 'lte'): uint8_t ns3::LteUeRrc::GetUlBandwidth() const [member function]
-    cls.add_method('GetUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): uint32_t ns3::LteUeRrc::GetUlEarfcn() const [member function]
-    cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::InitializeSap() [member function]
-    cls.add_method('InitializeSap', 
-                   'void', 
-                   [])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetAsSapUser(ns3::LteAsSapUser * s) [member function]
-    cls.add_method('SetAsSapUser', 
-                   'void', 
-                   [param('ns3::LteAsSapUser *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetImsi(uint64_t imsi) [member function]
-    cls.add_method('SetImsi', 
-                   'void', 
-                   [param('uint64_t', 'imsi')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteCcmRrcSapProvider(ns3::LteUeCcmRrcSapProvider * s) [member function]
-    cls.add_method('SetLteCcmRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCcmRrcSapProvider *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteMacSapProvider(ns3::LteMacSapProvider * s) [member function]
-    cls.add_method('SetLteMacSapProvider', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeCmacSapProvider(ns3::LteUeCmacSapProvider * s) [member function]
-    cls.add_method('SetLteUeCmacSapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCmacSapProvider *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeCmacSapProvider(ns3::LteUeCmacSapProvider * s, uint8_t index) [member function]
-    cls.add_method('SetLteUeCmacSapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCmacSapProvider *', 's'), param('uint8_t', 'index')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeCphySapProvider(ns3::LteUeCphySapProvider * s) [member function]
-    cls.add_method('SetLteUeCphySapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCphySapProvider *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeCphySapProvider(ns3::LteUeCphySapProvider * s, uint8_t index) [member function]
-    cls.add_method('SetLteUeCphySapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCphySapProvider *', 's'), param('uint8_t', 'index')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeRrcSapUser(ns3::LteUeRrcSapUser * s) [member function]
-    cls.add_method('SetLteUeRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteUeRrcSapUser *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetUseRlcSm(bool val) [member function]
-    cls.add_method('SetUseRlcSm', 
-                   'void', 
-                   [param('bool', 'val')])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::m_numberOfComponentCarriers [variable]
-    cls.add_instance_attribute('m_numberOfComponentCarriers', 'uint16_t', is_const=False)
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='private', is_virtual=True)
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='private', is_virtual=True)
-    return
-
-def register_Ns3LteUeRrcProtocolIdeal_methods(root_module, cls):
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteUeRrcProtocolIdeal::LteUeRrcProtocolIdeal(ns3::LteUeRrcProtocolIdeal const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeRrcProtocolIdeal const &', 'arg0')])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteUeRrcProtocolIdeal::LteUeRrcProtocolIdeal() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): void ns3::LteUeRrcProtocolIdeal::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteUeRrcSapUser * ns3::LteUeRrcProtocolIdeal::GetLteUeRrcSapUser() [member function]
-    cls.add_method('GetLteUeRrcSapUser', 
-                   'ns3::LteUeRrcSapUser *', 
-                   [])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): static ns3::TypeId ns3::LteUeRrcProtocolIdeal::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rrc-protocol-ideal.h (module 'lte'): void ns3::LteUeRrcProtocolIdeal::SetLteUeRrcSapProvider(ns3::LteUeRrcSapProvider * p) [member function]
-    cls.add_method('SetLteUeRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteUeRrcSapProvider *', 'p')])
-    ## lte-rrc-protocol-ideal.h (module 'lte'): void ns3::LteUeRrcProtocolIdeal::SetUeRrc(ns3::Ptr<ns3::LteUeRrc> rrc) [member function]
-    cls.add_method('SetUeRrc', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteUeRrc >', 'rrc')])
-    return
-
-def register_Ns3LteUeRrcProtocolReal_methods(root_module, cls):
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteUeRrcProtocolReal::LteUeRrcProtocolReal(ns3::LteUeRrcProtocolReal const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeRrcProtocolReal const &', 'arg0')])
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteUeRrcProtocolReal::LteUeRrcProtocolReal() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::LteUeRrcProtocolReal::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteUeRrcSapUser * ns3::LteUeRrcProtocolReal::GetLteUeRrcSapUser() [member function]
-    cls.add_method('GetLteUeRrcSapUser', 
-                   'ns3::LteUeRrcSapUser *', 
-                   [])
-    ## lte-rrc-protocol-real.h (module 'lte'): static ns3::TypeId ns3::LteUeRrcProtocolReal::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::LteUeRrcProtocolReal::SetLteUeRrcSapProvider(ns3::LteUeRrcSapProvider * p) [member function]
-    cls.add_method('SetLteUeRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteUeRrcSapProvider *', 'p')])
-    ## lte-rrc-protocol-real.h (module 'lte'): void ns3::LteUeRrcProtocolReal::SetUeRrc(ns3::Ptr<ns3::LteUeRrc> rrc) [member function]
-    cls.add_method('SetUeRrc', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteUeRrc >', 'rrc')])
-    return
-
-def register_Ns3Mac48AddressChecker_methods(root_module, cls):
-    ## mac48-address.h (module 'network'): ns3::Mac48AddressChecker::Mac48AddressChecker() [constructor]
-    cls.add_constructor([])
-    ## mac48-address.h (module 'network'): ns3::Mac48AddressChecker::Mac48AddressChecker(ns3::Mac48AddressChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Mac48AddressChecker const &', 'arg0')])
-    return
-
-def register_Ns3Mac48AddressValue_methods(root_module, cls):
-    ## mac48-address.h (module 'network'): ns3::Mac48AddressValue::Mac48AddressValue() [constructor]
-    cls.add_constructor([])
-    ## mac48-address.h (module 'network'): ns3::Mac48AddressValue::Mac48AddressValue(ns3::Mac48Address const & value) [constructor]
-    cls.add_constructor([param('ns3::Mac48Address const &', 'value')])
-    ## mac48-address.h (module 'network'): ns3::Mac48AddressValue::Mac48AddressValue(ns3::Mac48AddressValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Mac48AddressValue const &', 'arg0')])
-    ## mac48-address.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::Mac48AddressValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## mac48-address.h (module 'network'): bool ns3::Mac48AddressValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## mac48-address.h (module 'network'): ns3::Mac48Address ns3::Mac48AddressValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Mac48Address', 
-                   [], 
-                   is_const=True)
-    ## mac48-address.h (module 'network'): std::string ns3::Mac48AddressValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## mac48-address.h (module 'network'): void ns3::Mac48AddressValue::Set(ns3::Mac48Address const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Mac48Address const &', 'value')])
-    return
-
-def register_Ns3MacStatsCalculator_methods(root_module, cls):
-    ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator::MacStatsCalculator(ns3::MacStatsCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MacStatsCalculator const &', 'arg0')])
-    ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator::MacStatsCalculator() [constructor]
-    cls.add_constructor([])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::DlScheduling(uint16_t cellId, uint64_t imsi, ns3::DlSchedulingCallbackInfo dlSchedulingCallbackInfo) [member function]
-    cls.add_method('DlScheduling', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('ns3::DlSchedulingCallbackInfo', 'dlSchedulingCallbackInfo')])
-    ## mac-stats-calculator.h (module 'lte'): static void ns3::MacStatsCalculator::DlSchedulingCallback(ns3::Ptr<ns3::MacStatsCalculator> macStats, std::string path, ns3::DlSchedulingCallbackInfo dlSchedulingCallbackInfo) [member function]
-    cls.add_method('DlSchedulingCallback', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::MacStatsCalculator >', 'macStats'), param('std::string', 'path'), param('ns3::DlSchedulingCallbackInfo', 'dlSchedulingCallbackInfo')], 
-                   is_static=True)
-    ## mac-stats-calculator.h (module 'lte'): std::string ns3::MacStatsCalculator::GetDlOutputFilename() [member function]
-    cls.add_method('GetDlOutputFilename', 
-                   'std::string', 
-                   [])
-    ## mac-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::MacStatsCalculator::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## mac-stats-calculator.h (module 'lte'): std::string ns3::MacStatsCalculator::GetUlOutputFilename() [member function]
-    cls.add_method('GetUlOutputFilename', 
-                   'std::string', 
-                   [])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::SetDlOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetDlOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::SetUlOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetUlOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::UlScheduling(uint16_t cellId, uint64_t imsi, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcsTb, uint16_t sizeTb, uint8_t componentCarrierId) [member function]
-    cls.add_method('UlScheduling', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcsTb'), param('uint16_t', 'sizeTb'), param('uint8_t', 'componentCarrierId')])
-    ## mac-stats-calculator.h (module 'lte'): static void ns3::MacStatsCalculator::UlSchedulingCallback(ns3::Ptr<ns3::MacStatsCalculator> macStats, std::string path, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcs, uint16_t size, uint8_t componentCarrierId) [member function]
-    cls.add_method('UlSchedulingCallback', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::MacStatsCalculator >', 'macStats'), param('std::string', 'path'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcs'), param('uint16_t', 'size'), param('uint8_t', 'componentCarrierId')], 
-                   is_static=True)
-    return
-
-def register_Ns3MibLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::MibLteControlMessage::MibLteControlMessage(ns3::MibLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MibLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::MibLteControlMessage::MibLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::LteRrcSap::MasterInformationBlock ns3::MibLteControlMessage::GetMib() const [member function]
-    cls.add_method('GetMib', 
-                   'ns3::LteRrcSap::MasterInformationBlock', 
-                   [], 
-                   is_const=True)
-    ## lte-control-messages.h (module 'lte'): void ns3::MibLteControlMessage::SetMib(ns3::LteRrcSap::MasterInformationBlock mib) [member function]
-    cls.add_method('SetMib', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MasterInformationBlock', 'mib')])
-    return
-
-def register_Ns3MinMaxAvgTotalCalculator__Unsigned_int_methods(root_module, cls):
-    ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned int>::MinMaxAvgTotalCalculator(ns3::MinMaxAvgTotalCalculator<unsigned int> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MinMaxAvgTotalCalculator< unsigned int > const &', 'arg0')])
-    ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned int>::MinMaxAvgTotalCalculator() [constructor]
-    cls.add_constructor([])
-    ## basic-data-calculators.h (module 'stats'): static ns3::TypeId ns3::MinMaxAvgTotalCalculator<unsigned int>::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned int>::Output(ns3::DataOutputCallback & callback) const [member function]
-    cls.add_method('Output', 
-                   'void', 
-                   [param('ns3::DataOutputCallback &', 'callback')], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned int>::Reset() [member function]
-    cls.add_method('Reset', 
-                   'void', 
-                   [])
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned int>::Update(unsigned int const i) [member function]
-    cls.add_method('Update', 
-                   'void', 
-                   [param('unsigned int const', 'i')])
-    ## basic-data-calculators.h (module 'stats'): long int ns3::MinMaxAvgTotalCalculator<unsigned int>::getCount() const [member function]
-    cls.add_method('getCount', 
-                   'long int', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned int>::getMax() const [member function]
-    cls.add_method('getMax', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned int>::getMean() const [member function]
-    cls.add_method('getMean', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned int>::getMin() const [member function]
-    cls.add_method('getMin', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned int>::getSqrSum() const [member function]
-    cls.add_method('getSqrSum', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned int>::getStddev() const [member function]
-    cls.add_method('getStddev', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned int>::getSum() const [member function]
-    cls.add_method('getSum', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned int>::getVariance() const [member function]
-    cls.add_method('getVariance', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned int>::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3MinMaxAvgTotalCalculator__Unsigned_long_methods(root_module, cls):
-    ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned long long>::MinMaxAvgTotalCalculator(ns3::MinMaxAvgTotalCalculator<unsigned long long> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MinMaxAvgTotalCalculator< unsigned long long > const &', 'arg0')])
-    ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned long long>::MinMaxAvgTotalCalculator() [constructor]
-    cls.add_constructor([])
-    ## basic-data-calculators.h (module 'stats'): static ns3::TypeId ns3::MinMaxAvgTotalCalculator<unsigned long long>::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned long long>::Output(ns3::DataOutputCallback & callback) const [member function]
-    cls.add_method('Output', 
-                   'void', 
-                   [param('ns3::DataOutputCallback &', 'callback')], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned long long>::Reset() [member function]
-    cls.add_method('Reset', 
-                   'void', 
-                   [])
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned long long>::Update(long unsigned int const i) [member function]
-    cls.add_method('Update', 
-                   'void', 
-                   [param('long unsigned int const', 'i')])
-    ## basic-data-calculators.h (module 'stats'): long int ns3::MinMaxAvgTotalCalculator<unsigned long long>::getCount() const [member function]
-    cls.add_method('getCount', 
-                   'long int', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned long long>::getMax() const [member function]
-    cls.add_method('getMax', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned long long>::getMean() const [member function]
-    cls.add_method('getMean', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned long long>::getMin() const [member function]
-    cls.add_method('getMin', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned long long>::getSqrSum() const [member function]
-    cls.add_method('getSqrSum', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned long long>::getStddev() const [member function]
-    cls.add_method('getStddev', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned long long>::getSum() const [member function]
-    cls.add_method('getSum', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): double ns3::MinMaxAvgTotalCalculator<unsigned long long>::getVariance() const [member function]
-    cls.add_method('getVariance', 
-                   'double', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## basic-data-calculators.h (module 'stats'): void ns3::MinMaxAvgTotalCalculator<unsigned long long>::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3MobilityModel_methods(root_module, cls):
-    ## mobility-model.h (module 'mobility'): ns3::MobilityModel::MobilityModel(ns3::MobilityModel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MobilityModel const &', 'arg0')])
-    ## mobility-model.h (module 'mobility'): ns3::MobilityModel::MobilityModel() [constructor]
-    cls.add_constructor([])
-    ## mobility-model.h (module 'mobility'): int64_t ns3::MobilityModel::AssignStreams(int64_t stream) [member function]
-    cls.add_method('AssignStreams', 
-                   'int64_t', 
-                   [param('int64_t', 'stream')])
-    ## mobility-model.h (module 'mobility'): double ns3::MobilityModel::GetDistanceFrom(ns3::Ptr<const ns3::MobilityModel> position) const [member function]
-    cls.add_method('GetDistanceFrom', 
-                   'double', 
-                   [param('ns3::Ptr< ns3::MobilityModel const >', 'position')], 
-                   is_const=True)
-    ## mobility-model.h (module 'mobility'): ns3::Vector ns3::MobilityModel::GetPosition() const [member function]
-    cls.add_method('GetPosition', 
-                   'ns3::Vector', 
-                   [], 
-                   is_const=True)
-    ## mobility-model.h (module 'mobility'): double ns3::MobilityModel::GetRelativeSpeed(ns3::Ptr<const ns3::MobilityModel> other) const [member function]
-    cls.add_method('GetRelativeSpeed', 
-                   'double', 
-                   [param('ns3::Ptr< ns3::MobilityModel const >', 'other')], 
-                   is_const=True)
-    ## mobility-model.h (module 'mobility'): static ns3::TypeId ns3::MobilityModel::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## mobility-model.h (module 'mobility'): ns3::Vector ns3::MobilityModel::GetVelocity() const [member function]
-    cls.add_method('GetVelocity', 
-                   'ns3::Vector', 
-                   [], 
-                   is_const=True)
-    ## mobility-model.h (module 'mobility'): void ns3::MobilityModel::SetPosition(ns3::Vector const & position) [member function]
-    cls.add_method('SetPosition', 
-                   'void', 
-                   [param('ns3::Vector const &', 'position')])
-    ## mobility-model.h (module 'mobility'): void ns3::MobilityModel::NotifyCourseChange() const [member function]
-    cls.add_method('NotifyCourseChange', 
-                   'void', 
-                   [], 
-                   is_const=True, visibility='protected')
-    ## mobility-model.h (module 'mobility'): int64_t ns3::MobilityModel::DoAssignStreams(int64_t start) [member function]
-    cls.add_method('DoAssignStreams', 
-                   'int64_t', 
-                   [param('int64_t', 'start')], 
-                   visibility='private', is_virtual=True)
-    ## mobility-model.h (module 'mobility'): ns3::Vector ns3::MobilityModel::DoGetPosition() const [member function]
-    cls.add_method('DoGetPosition', 
-                   'ns3::Vector', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
-    ## mobility-model.h (module 'mobility'): ns3::Vector ns3::MobilityModel::DoGetVelocity() const [member function]
-    cls.add_method('DoGetVelocity', 
-                   'ns3::Vector', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
-    ## mobility-model.h (module 'mobility'): void ns3::MobilityModel::DoSetPosition(ns3::Vector const & position) [member function]
-    cls.add_method('DoSetPosition', 
-                   'void', 
-                   [param('ns3::Vector const &', 'position')], 
-                   is_pure_virtual=True, visibility='private', is_virtual=True)
-    return
-
-def register_Ns3NetDevice_methods(root_module, cls):
-    ## net-device.h (module 'network'): ns3::NetDevice::NetDevice() [constructor]
-    cls.add_constructor([])
-    ## net-device.h (module 'network'): ns3::NetDevice::NetDevice(ns3::NetDevice const & arg0) [constructor]
-    cls.add_constructor([param('ns3::NetDevice const &', 'arg0')])
-    ## net-device.h (module 'network'): void ns3::NetDevice::AddLinkChangeCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> callback) [member function]
-    cls.add_method('AddLinkChangeCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): ns3::Address ns3::NetDevice::GetAddress() const [member function]
-    cls.add_method('GetAddress', 
-                   'ns3::Address', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): ns3::Address ns3::NetDevice::GetBroadcast() const [member function]
-    cls.add_method('GetBroadcast', 
-                   'ns3::Address', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): ns3::Ptr<ns3::Channel> ns3::NetDevice::GetChannel() const [member function]
-    cls.add_method('GetChannel', 
-                   'ns3::Ptr< ns3::Channel >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): uint32_t ns3::NetDevice::GetIfIndex() const [member function]
-    cls.add_method('GetIfIndex', 
-                   'uint32_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): uint16_t ns3::NetDevice::GetMtu() const [member function]
-    cls.add_method('GetMtu', 
-                   'uint16_t', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): ns3::Address ns3::NetDevice::GetMulticast(ns3::Ipv4Address multicastGroup) const [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Address', 
-                   [param('ns3::Ipv4Address', 'multicastGroup')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): ns3::Address ns3::NetDevice::GetMulticast(ns3::Ipv6Address addr) const [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Address', 
-                   [param('ns3::Ipv6Address', 'addr')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): ns3::Ptr<ns3::Node> ns3::NetDevice::GetNode() const [member function]
-    cls.add_method('GetNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): static ns3::TypeId ns3::NetDevice::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::IsBridge() const [member function]
-    cls.add_method('IsBridge', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::IsBroadcast() const [member function]
-    cls.add_method('IsBroadcast', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::IsLinkUp() const [member function]
-    cls.add_method('IsLinkUp', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::IsMulticast() const [member function]
-    cls.add_method('IsMulticast', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::IsPointToPoint() const [member function]
-    cls.add_method('IsPointToPoint', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::NeedsArp() const [member function]
-    cls.add_method('NeedsArp', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::Send(ns3::Ptr<ns3::Packet> packet, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('Send', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::SendFrom(ns3::Ptr<ns3::Packet> packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('SendFrom', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): void ns3::NetDevice::SetAddress(ns3::Address address) [member function]
-    cls.add_method('SetAddress', 
-                   'void', 
-                   [param('ns3::Address', 'address')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): void ns3::NetDevice::SetIfIndex(uint32_t const index) [member function]
-    cls.add_method('SetIfIndex', 
-                   'void', 
-                   [param('uint32_t const', 'index')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::SetMtu(uint16_t const mtu) [member function]
-    cls.add_method('SetMtu', 
-                   'bool', 
-                   [param('uint16_t const', 'mtu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): void ns3::NetDevice::SetNode(ns3::Ptr<ns3::Node> node) [member function]
-    cls.add_method('SetNode', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'node')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): void ns3::NetDevice::SetPromiscReceiveCallback(ns3::NetDevice::PromiscReceiveCallback cb) [member function]
-    cls.add_method('SetPromiscReceiveCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): void ns3::NetDevice::SetReceiveCallback(ns3::NetDevice::ReceiveCallback cb) [member function]
-    cls.add_method('SetReceiveCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## net-device.h (module 'network'): bool ns3::NetDevice::SupportsSendFrom() const [member function]
-    cls.add_method('SupportsSendFrom', 
-                   'bool', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3NixVector_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## nix-vector.h (module 'network'): ns3::NixVector::NixVector() [constructor]
-    cls.add_constructor([])
-    ## nix-vector.h (module 'network'): ns3::NixVector::NixVector(ns3::NixVector const & o) [constructor]
-    cls.add_constructor([param('ns3::NixVector const &', 'o')])
-    ## nix-vector.h (module 'network'): void ns3::NixVector::AddNeighborIndex(uint32_t newBits, uint32_t numberOfBits) [member function]
-    cls.add_method('AddNeighborIndex', 
-                   'void', 
-                   [param('uint32_t', 'newBits'), param('uint32_t', 'numberOfBits')])
-    ## nix-vector.h (module 'network'): uint32_t ns3::NixVector::BitCount(uint32_t numberOfNeighbors) const [member function]
-    cls.add_method('BitCount', 
-                   'uint32_t', 
-                   [param('uint32_t', 'numberOfNeighbors')], 
-                   is_const=True)
-    ## nix-vector.h (module 'network'): ns3::Ptr<ns3::NixVector> ns3::NixVector::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::NixVector >', 
-                   [], 
-                   is_const=True)
-    ## nix-vector.h (module 'network'): uint32_t ns3::NixVector::Deserialize(uint32_t const * buffer, uint32_t size) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('uint32_t const *', 'buffer'), param('uint32_t', 'size')])
-    ## nix-vector.h (module 'network'): uint32_t ns3::NixVector::ExtractNeighborIndex(uint32_t numberOfBits) [member function]
-    cls.add_method('ExtractNeighborIndex', 
-                   'uint32_t', 
-                   [param('uint32_t', 'numberOfBits')])
-    ## nix-vector.h (module 'network'): uint32_t ns3::NixVector::GetRemainingBits() [member function]
-    cls.add_method('GetRemainingBits', 
-                   'uint32_t', 
-                   [])
-    ## nix-vector.h (module 'network'): uint32_t ns3::NixVector::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## nix-vector.h (module 'network'): uint32_t ns3::NixVector::Serialize(uint32_t * buffer, uint32_t maxSize) const [member function]
-    cls.add_method('Serialize', 
-                   'uint32_t', 
-                   [param('uint32_t *', 'buffer'), param('uint32_t', 'maxSize')], 
-                   is_const=True)
-    return
-
-def register_Ns3NoOpComponentCarrierManager_methods(root_module, cls):
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::NoOpComponentCarrierManager::NoOpComponentCarrierManager(ns3::NoOpComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::NoOpComponentCarrierManager const &', 'arg0')])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::NoOpComponentCarrierManager::NoOpComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## no-op-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::NoOpComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoAddLc(ns3::LteEnbCmacSapProvider::LcInfo lcInfo, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoAddLc', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoAddUe(uint16_t rnti, uint8_t state) [member function]
-    cls.add_method('DoAddUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'state')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::LteMacSapUser * ns3::NoOpComponentCarrierManager::DoConfigureSignalBearer(ns3::LteEnbCmacSapProvider::LcInfo lcinfo, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcinfo'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoNotifyPrbOccupancy(double prbOccupancy, uint8_t componentCarrierId) [member function]
-    cls.add_method('DoNotifyPrbOccupancy', 
-                   'void', 
-                   [param('double', 'prbOccupancy'), param('uint8_t', 'componentCarrierId')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): std::vector<unsigned char, std::allocator<unsigned char> > ns3::NoOpComponentCarrierManager::DoReleaseDataRadioBearer(uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReleaseDataRadioBearer', 
-                   'std::vector< unsigned char >', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoRemoveUe(uint16_t rnti) [member function]
-    cls.add_method('DoRemoveUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoReportBufferStatus(ns3::LteMacSapProvider::ReportBufferStatusParameters params) [member function]
-    cls.add_method('DoReportBufferStatus', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::ReportBufferStatusParameters', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): std::vector<ns3::LteCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteCcmRrcSapProvider::LcsConfig> > ns3::NoOpComponentCarrierManager::DoSetupDataRadioBearer(ns3::EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoSetupDataRadioBearer', 
-                   'std::vector< ns3::LteCcmRrcSapProvider::LcsConfig >', 
-                   [param('ns3::EpsBearer', 'bearer'), param('uint8_t', 'bearerId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint8_t', 'lcGroup'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoTransmitPdu(ns3::LteMacSapProvider::TransmitPduParameters params) [member function]
-    cls.add_method('DoTransmitPdu', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::TransmitPduParameters', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoUlReceiveMacCe(ns3::MacCeListElement_s bsr, uint8_t componentCarrierId) [member function]
-    cls.add_method('DoUlReceiveMacCe', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr'), param('uint8_t', 'componentCarrierId')], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3NoOpHandoverAlgorithm_methods(root_module, cls):
-    ## no-op-handover-algorithm.h (module 'lte'): ns3::NoOpHandoverAlgorithm::NoOpHandoverAlgorithm(ns3::NoOpHandoverAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::NoOpHandoverAlgorithm const &', 'arg0')])
-    ## no-op-handover-algorithm.h (module 'lte'): ns3::NoOpHandoverAlgorithm::NoOpHandoverAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## no-op-handover-algorithm.h (module 'lte'): ns3::LteHandoverManagementSapProvider * ns3::NoOpHandoverAlgorithm::GetLteHandoverManagementSapProvider() [member function]
-    cls.add_method('GetLteHandoverManagementSapProvider', 
-                   'ns3::LteHandoverManagementSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## no-op-handover-algorithm.h (module 'lte'): static ns3::TypeId ns3::NoOpHandoverAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## no-op-handover-algorithm.h (module 'lte'): void ns3::NoOpHandoverAlgorithm::SetLteHandoverManagementSapUser(ns3::LteHandoverManagementSapUser * s) [member function]
-    cls.add_method('SetLteHandoverManagementSapUser', 
-                   'void', 
-                   [param('ns3::LteHandoverManagementSapUser *', 's')], 
-                   is_virtual=True)
-    ## no-op-handover-algorithm.h (module 'lte'): void ns3::NoOpHandoverAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-handover-algorithm.h (module 'lte'): void ns3::NoOpHandoverAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-handover-algorithm.h (module 'lte'): void ns3::NoOpHandoverAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3Node_methods(root_module, cls):
-    ## node.h (module 'network'): ns3::Node::Node(ns3::Node const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Node const &', 'arg0')])
-    ## node.h (module 'network'): ns3::Node::Node() [constructor]
-    cls.add_constructor([])
-    ## node.h (module 'network'): ns3::Node::Node(uint32_t systemId) [constructor]
-    cls.add_constructor([param('uint32_t', 'systemId')])
-    ## node.h (module 'network'): uint32_t ns3::Node::AddApplication(ns3::Ptr<ns3::Application> application) [member function]
-    cls.add_method('AddApplication', 
-                   'uint32_t', 
-                   [param('ns3::Ptr< ns3::Application >', 'application')])
-    ## node.h (module 'network'): uint32_t ns3::Node::AddDevice(ns3::Ptr<ns3::NetDevice> device) [member function]
-    cls.add_method('AddDevice', 
-                   'uint32_t', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'device')])
-    ## node.h (module 'network'): static bool ns3::Node::ChecksumEnabled() [member function]
-    cls.add_method('ChecksumEnabled', 
-                   'bool', 
-                   [], 
-                   is_static=True)
-    ## node.h (module 'network'): ns3::Ptr<ns3::Application> ns3::Node::GetApplication(uint32_t index) const [member function]
-    cls.add_method('GetApplication', 
-                   'ns3::Ptr< ns3::Application >', 
-                   [param('uint32_t', 'index')], 
-                   is_const=True)
-    ## node.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::Node::GetDevice(uint32_t index) const [member function]
-    cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [param('uint32_t', 'index')], 
-                   is_const=True)
-    ## node.h (module 'network'): uint32_t ns3::Node::GetId() const [member function]
-    cls.add_method('GetId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## node.h (module 'network'): ns3::Time ns3::Node::GetLocalTime() const [member function]
-    cls.add_method('GetLocalTime', 
-                   'ns3::Time', 
-                   [], 
-                   is_const=True)
-    ## node.h (module 'network'): uint32_t ns3::Node::GetNApplications() const [member function]
-    cls.add_method('GetNApplications', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## node.h (module 'network'): uint32_t ns3::Node::GetNDevices() const [member function]
-    cls.add_method('GetNDevices', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## node.h (module 'network'): uint32_t ns3::Node::GetSystemId() const [member function]
-    cls.add_method('GetSystemId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## node.h (module 'network'): static ns3::TypeId ns3::Node::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## node.h (module 'network'): void ns3::Node::RegisterDeviceAdditionListener(ns3::Node::DeviceAdditionListener listener) [member function]
-    cls.add_method('RegisterDeviceAdditionListener', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])
-    ## node.h (module 'network'): void ns3::Node::RegisterProtocolHandler(ns3::Node::ProtocolHandler handler, uint16_t protocolType, ns3::Ptr<ns3::NetDevice> device, bool promiscuous=false) [member function]
-    cls.add_method('RegisterProtocolHandler', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler'), param('uint16_t', 'protocolType'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'promiscuous', default_value='false')])
-    ## node.h (module 'network'): void ns3::Node::UnregisterDeviceAdditionListener(ns3::Node::DeviceAdditionListener listener) [member function]
-    cls.add_method('UnregisterDeviceAdditionListener', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])
-    ## node.h (module 'network'): void ns3::Node::UnregisterProtocolHandler(ns3::Node::ProtocolHandler handler) [member function]
-    cls.add_method('UnregisterProtocolHandler', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler')])
-    ## node.h (module 'network'): void ns3::Node::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## node.h (module 'network'): void ns3::Node::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3NormalRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): ns3::NormalRandomVariable::INFINITE_VALUE [variable]
-    cls.add_static_attribute('INFINITE_VALUE', 'double const', is_const=True)
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::NormalRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::NormalRandomVariable::NormalRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::NormalRandomVariable::GetMean() const [member function]
-    cls.add_method('GetMean', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::NormalRandomVariable::GetVariance() const [member function]
-    cls.add_method('GetVariance', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::NormalRandomVariable::GetBound() const [member function]
-    cls.add_method('GetBound', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::NormalRandomVariable::GetValue(double mean, double variance, double bound=ns3::NormalRandomVariable::INFINITE_VALUE) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'mean'), param('double', 'variance'), param('double', 'bound', default_value='ns3::NormalRandomVariable::INFINITE_VALUE')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::NormalRandomVariable::GetInteger(uint32_t mean, uint32_t variance, uint32_t bound) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'mean'), param('uint32_t', 'variance'), param('uint32_t', 'bound')])
-    ## random-variable-stream.h (module 'core'): double ns3::NormalRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::NormalRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3ObjectFactoryChecker_methods(root_module, cls):
-    ## object-factory.h (module 'core'): ns3::ObjectFactoryChecker::ObjectFactoryChecker() [constructor]
-    cls.add_constructor([])
-    ## object-factory.h (module 'core'): ns3::ObjectFactoryChecker::ObjectFactoryChecker(ns3::ObjectFactoryChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ObjectFactoryChecker const &', 'arg0')])
-    return
-
-def register_Ns3ObjectFactoryValue_methods(root_module, cls):
-    ## object-factory.h (module 'core'): ns3::ObjectFactoryValue::ObjectFactoryValue() [constructor]
-    cls.add_constructor([])
-    ## object-factory.h (module 'core'): ns3::ObjectFactoryValue::ObjectFactoryValue(ns3::ObjectFactory const & value) [constructor]
-    cls.add_constructor([param('ns3::ObjectFactory const &', 'value')])
-    ## object-factory.h (module 'core'): ns3::ObjectFactoryValue::ObjectFactoryValue(ns3::ObjectFactoryValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ObjectFactoryValue const &', 'arg0')])
-    ## object-factory.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::ObjectFactoryValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## object-factory.h (module 'core'): bool ns3::ObjectFactoryValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## object-factory.h (module 'core'): ns3::ObjectFactory ns3::ObjectFactoryValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::ObjectFactory', 
-                   [], 
-                   is_const=True)
-    ## object-factory.h (module 'core'): std::string ns3::ObjectFactoryValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## object-factory.h (module 'core'): void ns3::ObjectFactoryValue::Set(ns3::ObjectFactory const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::ObjectFactory const &', 'value')])
-    return
-
-def register_Ns3Packet_methods(root_module, cls):
-    cls.add_output_stream_operator()
-    ## packet.h (module 'network'): ns3::Packet::Packet() [constructor]
-    cls.add_constructor([])
-    ## packet.h (module 'network'): ns3::Packet::Packet(ns3::Packet const & o) [constructor]
-    cls.add_constructor([param('ns3::Packet const &', 'o')])
-    ## packet.h (module 'network'): ns3::Packet::Packet(uint32_t size) [constructor]
-    cls.add_constructor([param('uint32_t', 'size')])
-    ## packet.h (module 'network'): ns3::Packet::Packet(uint8_t const * buffer, uint32_t size, bool magic) [constructor]
-    cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size'), param('bool', 'magic')])
-    ## packet.h (module 'network'): ns3::Packet::Packet(uint8_t const * buffer, uint32_t size) [constructor]
-    cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
-    ## packet.h (module 'network'): void ns3::Packet::AddAtEnd(ns3::Ptr<const ns3::Packet> packet) [member function]
-    cls.add_method('AddAtEnd', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet const >', 'packet')])
-    ## packet.h (module 'network'): void ns3::Packet::AddByteTag(ns3::Tag const & tag) const [member function]
-    cls.add_method('AddByteTag', 
-                   'void', 
-                   [param('ns3::Tag const &', 'tag')], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::Packet::AddHeader(ns3::Header const & header) [member function]
-    cls.add_method('AddHeader', 
-                   'void', 
-                   [param('ns3::Header const &', 'header')])
-    ## packet.h (module 'network'): void ns3::Packet::AddPacketTag(ns3::Tag const & tag) const [member function]
-    cls.add_method('AddPacketTag', 
-                   'void', 
-                   [param('ns3::Tag const &', 'tag')], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::Packet::AddPaddingAtEnd(uint32_t size) [member function]
-    cls.add_method('AddPaddingAtEnd', 
-                   'void', 
-                   [param('uint32_t', 'size')])
-    ## packet.h (module 'network'): void ns3::Packet::AddTrailer(ns3::Trailer const & trailer) [member function]
-    cls.add_method('AddTrailer', 
-                   'void', 
-                   [param('ns3::Trailer const &', 'trailer')])
-    ## packet.h (module 'network'): ns3::PacketMetadata::ItemIterator ns3::Packet::BeginItem() const [member function]
-    cls.add_method('BeginItem', 
-                   'ns3::PacketMetadata::ItemIterator', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::Packet::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): uint32_t ns3::Packet::CopyData(uint8_t * buffer, uint32_t size) const [member function]
-    cls.add_method('CopyData', 
-                   'uint32_t', 
-                   [param('uint8_t *', 'buffer'), param('uint32_t', 'size')], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::Packet::CopyData(std::ostream * os, uint32_t size) const [member function]
-    cls.add_method('CopyData', 
-                   'void', 
-                   [param('std::ostream *', 'os'), param('uint32_t', 'size')], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::Packet::CreateFragment(uint32_t start, uint32_t length) const [member function]
-    cls.add_method('CreateFragment', 
-                   'ns3::Ptr< ns3::Packet >', 
-                   [param('uint32_t', 'start'), param('uint32_t', 'length')], 
-                   is_const=True)
-    ## packet.h (module 'network'): static void ns3::Packet::EnableChecking() [member function]
-    cls.add_method('EnableChecking', 
-                   'void', 
-                   [], 
-                   is_static=True)
-    ## packet.h (module 'network'): static void ns3::Packet::EnablePrinting() [member function]
-    cls.add_method('EnablePrinting', 
-                   'void', 
-                   [], 
-                   is_static=True)
-    ## packet.h (module 'network'): bool ns3::Packet::FindFirstMatchingByteTag(ns3::Tag & tag) const [member function]
-    cls.add_method('FindFirstMatchingByteTag', 
-                   'bool', 
-                   [param('ns3::Tag &', 'tag')], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::ByteTagIterator ns3::Packet::GetByteTagIterator() const [member function]
-    cls.add_method('GetByteTagIterator', 
-                   'ns3::ByteTagIterator', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::Ptr<ns3::NixVector> ns3::Packet::GetNixVector() const [member function]
-    cls.add_method('GetNixVector', 
-                   'ns3::Ptr< ns3::NixVector >', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): ns3::PacketTagIterator ns3::Packet::GetPacketTagIterator() const [member function]
-    cls.add_method('GetPacketTagIterator', 
-                   'ns3::PacketTagIterator', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): uint32_t ns3::Packet::GetSerializedSize() const [member function]
-    cls.add_method('GetSerializedSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): uint32_t ns3::Packet::GetSize() const [member function]
-    cls.add_method('GetSize', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): uint64_t ns3::Packet::GetUid() const [member function]
-    cls.add_method('GetUid', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## packet.h (module 'network'): uint32_t ns3::Packet::PeekHeader(ns3::Header & header) const [member function]
-    cls.add_method('PeekHeader', 
-                   'uint32_t', 
-                   [param('ns3::Header &', 'header')], 
-                   is_const=True)
-    ## packet.h (module 'network'): bool ns3::Packet::PeekPacketTag(ns3::Tag & tag) const [member function]
-    cls.add_method('PeekPacketTag', 
-                   'bool', 
-                   [param('ns3::Tag &', 'tag')], 
-                   is_const=True)
-    ## packet.h (module 'network'): uint32_t ns3::Packet::PeekTrailer(ns3::Trailer & trailer) [member function]
-    cls.add_method('PeekTrailer', 
-                   'uint32_t', 
-                   [param('ns3::Trailer &', 'trailer')])
-    ## packet.h (module 'network'): void ns3::Packet::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::Packet::PrintByteTags(std::ostream & os) const [member function]
-    cls.add_method('PrintByteTags', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::Packet::PrintPacketTags(std::ostream & os) const [member function]
-    cls.add_method('PrintPacketTags', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::Packet::RemoveAllByteTags() [member function]
-    cls.add_method('RemoveAllByteTags', 
-                   'void', 
-                   [])
-    ## packet.h (module 'network'): void ns3::Packet::RemoveAllPacketTags() [member function]
-    cls.add_method('RemoveAllPacketTags', 
-                   'void', 
-                   [])
-    ## packet.h (module 'network'): void ns3::Packet::RemoveAtEnd(uint32_t size) [member function]
-    cls.add_method('RemoveAtEnd', 
-                   'void', 
-                   [param('uint32_t', 'size')])
-    ## packet.h (module 'network'): void ns3::Packet::RemoveAtStart(uint32_t size) [member function]
-    cls.add_method('RemoveAtStart', 
-                   'void', 
-                   [param('uint32_t', 'size')])
-    ## packet.h (module 'network'): uint32_t ns3::Packet::RemoveHeader(ns3::Header & header) [member function]
-    cls.add_method('RemoveHeader', 
-                   'uint32_t', 
-                   [param('ns3::Header &', 'header')])
-    ## packet.h (module 'network'): bool ns3::Packet::RemovePacketTag(ns3::Tag & tag) [member function]
-    cls.add_method('RemovePacketTag', 
-                   'bool', 
-                   [param('ns3::Tag &', 'tag')])
-    ## packet.h (module 'network'): uint32_t ns3::Packet::RemoveTrailer(ns3::Trailer & trailer) [member function]
-    cls.add_method('RemoveTrailer', 
-                   'uint32_t', 
-                   [param('ns3::Trailer &', 'trailer')])
-    ## packet.h (module 'network'): bool ns3::Packet::ReplacePacketTag(ns3::Tag & tag) [member function]
-    cls.add_method('ReplacePacketTag', 
-                   'bool', 
-                   [param('ns3::Tag &', 'tag')])
-    ## packet.h (module 'network'): uint32_t ns3::Packet::Serialize(uint8_t * buffer, uint32_t maxSize) const [member function]
-    cls.add_method('Serialize', 
-                   'uint32_t', 
-                   [param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')], 
-                   is_const=True)
-    ## packet.h (module 'network'): void ns3::Packet::SetNixVector(ns3::Ptr<ns3::NixVector> nixVector) [member function]
-    cls.add_method('SetNixVector', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NixVector >', 'nixVector')])
-    ## packet.h (module 'network'): std::string ns3::Packet::ToString() const [member function]
-    cls.add_method('ToString', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    return
-
-def register_Ns3ParetoRandomVariable_methods(root_module, cls):
-    ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ParetoRandomVariable::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## random-variable-stream.h (module 'core'): ns3::ParetoRandomVariable::ParetoRandomVariable() [constructor]
-    cls.add_constructor([])
-    ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetMean() const [member function]
-    cls.add_method('GetMean', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetScale() const [member function]
-    cls.add_method('GetScale', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetShape() const [member function]
-    cls.add_method('GetShape', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetBound() const [member function]
-    cls.add_method('GetBound', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetValue(double scale, double shape, double bound) [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [param('double', 'scale'), param('double', 'shape'), param('double', 'bound')])
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ParetoRandomVariable::GetInteger(uint32_t scale, uint32_t shape, uint32_t bound) [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [param('uint32_t', 'scale'), param('uint32_t', 'shape'), param('uint32_t', 'bound')])
-    ## random-variable-stream.h (module 'core'): double ns3::ParetoRandomVariable::GetValue() [member function]
-    cls.add_method('GetValue', 
-                   'double', 
-                   [], 
-                   is_virtual=True)
-    ## random-variable-stream.h (module 'core'): uint32_t ns3::ParetoRandomVariable::GetInteger() [member function]
-    cls.add_method('GetInteger', 
-                   'uint32_t', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3PfFfMacScheduler_methods(root_module, cls):
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::PfFfMacScheduler::PfFfMacScheduler(ns3::PfFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PfFfMacScheduler const &', 'arg0')])
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::PfFfMacScheduler::PfFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## pf-ff-mac-scheduler.h (module 'lte'): void ns3::PfFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::PfFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::PfFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::PfFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::PfFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): void ns3::PfFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): void ns3::PfFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): void ns3::PfFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## pf-ff-mac-scheduler.h (module 'lte'): void ns3::PfFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3PhyRxStatsCalculator_methods(root_module, cls):
-    ## phy-rx-stats-calculator.h (module 'lte'): ns3::PhyRxStatsCalculator::PhyRxStatsCalculator(ns3::PhyRxStatsCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PhyRxStatsCalculator const &', 'arg0')])
-    ## phy-rx-stats-calculator.h (module 'lte'): ns3::PhyRxStatsCalculator::PhyRxStatsCalculator() [constructor]
-    cls.add_constructor([])
-    ## phy-rx-stats-calculator.h (module 'lte'): void ns3::PhyRxStatsCalculator::DlPhyReception(ns3::PhyReceptionStatParameters params) [member function]
-    cls.add_method('DlPhyReception', 
-                   'void', 
-                   [param('ns3::PhyReceptionStatParameters', 'params')])
-    ## phy-rx-stats-calculator.h (module 'lte'): static void ns3::PhyRxStatsCalculator::DlPhyReceptionCallback(ns3::Ptr<ns3::PhyRxStatsCalculator> phyRxStats, std::string path, ns3::PhyReceptionStatParameters params) [member function]
-    cls.add_method('DlPhyReceptionCallback', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PhyRxStatsCalculator >', 'phyRxStats'), param('std::string', 'path'), param('ns3::PhyReceptionStatParameters', 'params')], 
-                   is_static=True)
-    ## phy-rx-stats-calculator.h (module 'lte'): std::string ns3::PhyRxStatsCalculator::GetDlRxOutputFilename() [member function]
-    cls.add_method('GetDlRxOutputFilename', 
-                   'std::string', 
-                   [])
-    ## phy-rx-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::PhyRxStatsCalculator::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## phy-rx-stats-calculator.h (module 'lte'): std::string ns3::PhyRxStatsCalculator::GetUlRxOutputFilename() [member function]
-    cls.add_method('GetUlRxOutputFilename', 
-                   'std::string', 
-                   [])
-    ## phy-rx-stats-calculator.h (module 'lte'): void ns3::PhyRxStatsCalculator::SetDlRxOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetDlRxOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## phy-rx-stats-calculator.h (module 'lte'): void ns3::PhyRxStatsCalculator::SetUlRxOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetUlRxOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## phy-rx-stats-calculator.h (module 'lte'): void ns3::PhyRxStatsCalculator::UlPhyReception(ns3::PhyReceptionStatParameters params) [member function]
-    cls.add_method('UlPhyReception', 
-                   'void', 
-                   [param('ns3::PhyReceptionStatParameters', 'params')])
-    ## phy-rx-stats-calculator.h (module 'lte'): static void ns3::PhyRxStatsCalculator::UlPhyReceptionCallback(ns3::Ptr<ns3::PhyRxStatsCalculator> phyRxStats, std::string path, ns3::PhyReceptionStatParameters params) [member function]
-    cls.add_method('UlPhyReceptionCallback', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PhyRxStatsCalculator >', 'phyRxStats'), param('std::string', 'path'), param('ns3::PhyReceptionStatParameters', 'params')], 
-                   is_static=True)
-    return
-
-def register_Ns3PhyStatsCalculator_methods(root_module, cls):
-    ## phy-stats-calculator.h (module 'lte'): ns3::PhyStatsCalculator::PhyStatsCalculator(ns3::PhyStatsCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PhyStatsCalculator const &', 'arg0')])
-    ## phy-stats-calculator.h (module 'lte'): ns3::PhyStatsCalculator::PhyStatsCalculator() [constructor]
-    cls.add_constructor([])
-    ## phy-stats-calculator.h (module 'lte'): std::string ns3::PhyStatsCalculator::GetCurrentCellRsrpSinrFilename() [member function]
-    cls.add_method('GetCurrentCellRsrpSinrFilename', 
-                   'std::string', 
-                   [])
-    ## phy-stats-calculator.h (module 'lte'): std::string ns3::PhyStatsCalculator::GetInterferenceFilename() [member function]
-    cls.add_method('GetInterferenceFilename', 
-                   'std::string', 
-                   [])
-    ## phy-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::PhyStatsCalculator::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## phy-stats-calculator.h (module 'lte'): std::string ns3::PhyStatsCalculator::GetUeSinrFilename() [member function]
-    cls.add_method('GetUeSinrFilename', 
-                   'std::string', 
-                   [])
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportCurrentCellRsrpSinr(uint16_t cellId, uint64_t imsi, uint16_t rnti, double rsrp, double sinr, uint8_t componentCarrierId) [member function]
-    cls.add_method('ReportCurrentCellRsrpSinr', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('double', 'rsrp'), param('double', 'sinr'), param('uint8_t', 'componentCarrierId')])
-    ## phy-stats-calculator.h (module 'lte'): static void ns3::PhyStatsCalculator::ReportCurrentCellRsrpSinrCallback(ns3::Ptr<ns3::PhyStatsCalculator> phyStats, std::string path, uint16_t cellId, uint16_t rnti, double rsrp, double sinr, uint8_t componentCarrierId) [member function]
-    cls.add_method('ReportCurrentCellRsrpSinrCallback', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('double', 'rsrp'), param('double', 'sinr'), param('uint8_t', 'componentCarrierId')], 
-                   is_static=True)
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportInterference(uint16_t cellId, ns3::Ptr<ns3::SpectrumValue> interference) [member function]
-    cls.add_method('ReportInterference', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::Ptr< ns3::SpectrumValue >', 'interference')])
-    ## phy-stats-calculator.h (module 'lte'): static void ns3::PhyStatsCalculator::ReportInterference(ns3::Ptr<ns3::PhyStatsCalculator> phyStats, std::string path, uint16_t cellId, ns3::Ptr<ns3::SpectrumValue> interference) [member function]
-    cls.add_method('ReportInterference', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('ns3::Ptr< ns3::SpectrumValue >', 'interference')], 
-                   is_static=True)
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportUeSinr(uint16_t cellId, uint64_t imsi, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId) [member function]
-    cls.add_method('ReportUeSinr', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('double', 'sinrLinear'), param('uint8_t', 'componentCarrierId')])
-    ## phy-stats-calculator.h (module 'lte'): static void ns3::PhyStatsCalculator::ReportUeSinr(ns3::Ptr<ns3::PhyStatsCalculator> phyStats, std::string path, uint16_t cellId, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId) [member function]
-    cls.add_method('ReportUeSinr', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('double', 'sinrLinear'), param('uint8_t', 'componentCarrierId')], 
-                   is_static=True)
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::SetCurrentCellRsrpSinrFilename(std::string filename) [member function]
-    cls.add_method('SetCurrentCellRsrpSinrFilename', 
-                   'void', 
-                   [param('std::string', 'filename')])
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::SetInterferenceFilename(std::string filename) [member function]
-    cls.add_method('SetInterferenceFilename', 
-                   'void', 
-                   [param('std::string', 'filename')])
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::SetUeSinrFilename(std::string filename) [member function]
-    cls.add_method('SetUeSinrFilename', 
-                   'void', 
-                   [param('std::string', 'filename')])
-    return
-
-def register_Ns3PhyTxStatsCalculator_methods(root_module, cls):
-    ## phy-tx-stats-calculator.h (module 'lte'): ns3::PhyTxStatsCalculator::PhyTxStatsCalculator(ns3::PhyTxStatsCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PhyTxStatsCalculator const &', 'arg0')])
-    ## phy-tx-stats-calculator.h (module 'lte'): ns3::PhyTxStatsCalculator::PhyTxStatsCalculator() [constructor]
-    cls.add_constructor([])
-    ## phy-tx-stats-calculator.h (module 'lte'): void ns3::PhyTxStatsCalculator::DlPhyTransmission(ns3::PhyTransmissionStatParameters params) [member function]
-    cls.add_method('DlPhyTransmission', 
-                   'void', 
-                   [param('ns3::PhyTransmissionStatParameters', 'params')])
-    ## phy-tx-stats-calculator.h (module 'lte'): static void ns3::PhyTxStatsCalculator::DlPhyTransmissionCallback(ns3::Ptr<ns3::PhyTxStatsCalculator> phyTxStats, std::string path, ns3::PhyTransmissionStatParameters params) [member function]
-    cls.add_method('DlPhyTransmissionCallback', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PhyTxStatsCalculator >', 'phyTxStats'), param('std::string', 'path'), param('ns3::PhyTransmissionStatParameters', 'params')], 
-                   is_static=True)
-    ## phy-tx-stats-calculator.h (module 'lte'): std::string ns3::PhyTxStatsCalculator::GetDlTxOutputFilename() [member function]
-    cls.add_method('GetDlTxOutputFilename', 
-                   'std::string', 
-                   [])
-    ## phy-tx-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::PhyTxStatsCalculator::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## phy-tx-stats-calculator.h (module 'lte'): std::string ns3::PhyTxStatsCalculator::GetUlTxOutputFilename() [member function]
-    cls.add_method('GetUlTxOutputFilename', 
-                   'std::string', 
-                   [])
-    ## phy-tx-stats-calculator.h (module 'lte'): void ns3::PhyTxStatsCalculator::SetDlTxOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetDlTxOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## phy-tx-stats-calculator.h (module 'lte'): void ns3::PhyTxStatsCalculator::SetUlTxOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetUlTxOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## phy-tx-stats-calculator.h (module 'lte'): void ns3::PhyTxStatsCalculator::UlPhyTransmission(ns3::PhyTransmissionStatParameters params) [member function]
-    cls.add_method('UlPhyTransmission', 
-                   'void', 
-                   [param('ns3::PhyTransmissionStatParameters', 'params')])
-    ## phy-tx-stats-calculator.h (module 'lte'): static void ns3::PhyTxStatsCalculator::UlPhyTransmissionCallback(ns3::Ptr<ns3::PhyTxStatsCalculator> phyTxStats, std::string path, ns3::PhyTransmissionStatParameters params) [member function]
-    cls.add_method('UlPhyTransmissionCallback', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PhyTxStatsCalculator >', 'phyTxStats'), param('std::string', 'path'), param('ns3::PhyTransmissionStatParameters', 'params')], 
-                   is_static=True)
-    return
-
-def register_Ns3PointToPointEpcHelper_methods(root_module, cls):
-    ## point-to-point-epc-helper.h (module 'lte'): ns3::PointToPointEpcHelper::PointToPointEpcHelper(ns3::PointToPointEpcHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PointToPointEpcHelper const &', 'arg0')])
-    ## point-to-point-epc-helper.h (module 'lte'): ns3::PointToPointEpcHelper::PointToPointEpcHelper() [constructor]
-    cls.add_constructor([])
-    ## point-to-point-epc-helper.h (module 'lte'): uint8_t ns3::PointToPointEpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
-    cls.add_method('ActivateEpsBearer', 
-                   'uint8_t', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
-                   is_virtual=True)
-    ## point-to-point-epc-helper.h (module 'lte'): void ns3::PointToPointEpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
-    cls.add_method('AddEnb', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'enbNode'), param('ns3::Ptr< ns3::NetDevice >', 'lteEnbNetDevice'), param('uint16_t', 'cellId')], 
-                   is_virtual=True)
-    ## point-to-point-epc-helper.h (module 'lte'): void ns3::PointToPointEpcHelper::AddUe(ns3::Ptr<ns3::NetDevice> ueLteDevice, uint64_t imsi) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi')], 
-                   is_virtual=True)
-    ## point-to-point-epc-helper.h (module 'lte'): void ns3::PointToPointEpcHelper::AddX2Interface(ns3::Ptr<ns3::Node> enbNode1, ns3::Ptr<ns3::Node> enbNode2) [member function]
-    cls.add_method('AddX2Interface', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'enbNode1'), param('ns3::Ptr< ns3::Node >', 'enbNode2')], 
-                   is_virtual=True)
-    ## point-to-point-epc-helper.h (module 'lte'): ns3::Ipv4InterfaceContainer ns3::PointToPointEpcHelper::AssignUeIpv4Address(ns3::NetDeviceContainer ueDevices) [member function]
-    cls.add_method('AssignUeIpv4Address', 
-                   'ns3::Ipv4InterfaceContainer', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices')], 
-                   is_virtual=True)
-    ## point-to-point-epc-helper.h (module 'lte'): void ns3::PointToPointEpcHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## point-to-point-epc-helper.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::PointToPointEpcHelper::GetPgwNode() [member function]
-    cls.add_method('GetPgwNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_virtual=True)
-    ## point-to-point-epc-helper.h (module 'lte'): static ns3::TypeId ns3::PointToPointEpcHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## point-to-point-epc-helper.h (module 'lte'): ns3::Ipv4Address ns3::PointToPointEpcHelper::GetUeDefaultGatewayAddress() [member function]
-    cls.add_method('GetUeDefaultGatewayAddress', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3PointerChecker_methods(root_module, cls):
-    ## pointer.h (module 'core'): ns3::PointerChecker::PointerChecker() [constructor]
-    cls.add_constructor([])
-    ## pointer.h (module 'core'): ns3::PointerChecker::PointerChecker(ns3::PointerChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PointerChecker const &', 'arg0')])
-    ## pointer.h (module 'core'): ns3::TypeId ns3::PointerChecker::GetPointeeTypeId() const [member function]
-    cls.add_method('GetPointeeTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    return
-
-def register_Ns3PointerValue_methods(root_module, cls):
-    ## pointer.h (module 'core'): ns3::PointerValue::PointerValue(ns3::PointerValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PointerValue const &', 'arg0')])
-    ## pointer.h (module 'core'): ns3::PointerValue::PointerValue() [constructor]
-    cls.add_constructor([])
-    ## pointer.h (module 'core'): ns3::PointerValue::PointerValue(ns3::Ptr<ns3::Object> object) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::Object >', 'object')])
-    ## pointer.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::PointerValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## pointer.h (module 'core'): bool ns3::PointerValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## pointer.h (module 'core'): ns3::Ptr<ns3::Object> ns3::PointerValue::GetObject() const [member function]
-    cls.add_method('GetObject', 
-                   'ns3::Ptr< ns3::Object >', 
-                   [], 
-                   is_const=True)
-    ## pointer.h (module 'core'): std::string ns3::PointerValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## pointer.h (module 'core'): void ns3::PointerValue::SetObject(ns3::Ptr<ns3::Object> object) [member function]
-    cls.add_method('SetObject', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Object >', 'object')])
-    return
-
-def register_Ns3PssFfMacScheduler_methods(root_module, cls):
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::PssFfMacScheduler::PssFfMacScheduler(ns3::PssFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::PssFfMacScheduler const &', 'arg0')])
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::PssFfMacScheduler::PssFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## pss-ff-mac-scheduler.h (module 'lte'): void ns3::PssFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::PssFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::PssFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::PssFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::PssFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): void ns3::PssFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): void ns3::PssFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): void ns3::PssFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## pss-ff-mac-scheduler.h (module 'lte'): void ns3::PssFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3RachPreambleLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::RachPreambleLteControlMessage::RachPreambleLteControlMessage(ns3::RachPreambleLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RachPreambleLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::RachPreambleLteControlMessage::RachPreambleLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): uint32_t ns3::RachPreambleLteControlMessage::GetRapId() const [member function]
-    cls.add_method('GetRapId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-control-messages.h (module 'lte'): void ns3::RachPreambleLteControlMessage::SetRapId(uint32_t rapid) [member function]
-    cls.add_method('SetRapId', 
-                   'void', 
-                   [param('uint32_t', 'rapid')])
-    return
-
-def register_Ns3RadioBearerStatsCalculator_methods(root_module, cls):
-    ## radio-bearer-stats-calculator.h (module 'lte'): ns3::RadioBearerStatsCalculator::RadioBearerStatsCalculator(ns3::RadioBearerStatsCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RadioBearerStatsCalculator const &', 'arg0')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): ns3::RadioBearerStatsCalculator::RadioBearerStatsCalculator() [constructor]
-    cls.add_constructor([])
-    ## radio-bearer-stats-calculator.h (module 'lte'): ns3::RadioBearerStatsCalculator::RadioBearerStatsCalculator(std::string protocolType) [constructor]
-    cls.add_constructor([param('std::string', 'protocolType')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::DlRxPdu(uint16_t cellId, uint64_t imsi, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint64_t delay) [member function]
-    cls.add_method('DlRxPdu', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize'), param('uint64_t', 'delay')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::DlTxPdu(uint16_t cellId, uint64_t imsi, uint16_t rnti, uint8_t lcid, uint32_t packetSize) [member function]
-    cls.add_method('DlTxPdu', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint32_t ns3::RadioBearerStatsCalculator::GetDlCellId(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlCellId', 
-                   'uint32_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): double ns3::RadioBearerStatsCalculator::GetDlDelay(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlDelay', 
-                   'double', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::vector<double, std::allocator<double> > ns3::RadioBearerStatsCalculator::GetDlDelayStats(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlDelayStats', 
-                   'std::vector< double >', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::string ns3::RadioBearerStatsCalculator::GetDlOutputFilename() [member function]
-    cls.add_method('GetDlOutputFilename', 
-                   'std::string', 
-                   [])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::string ns3::RadioBearerStatsCalculator::GetDlPdcpOutputFilename() [member function]
-    cls.add_method('GetDlPdcpOutputFilename', 
-                   'std::string', 
-                   [])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::vector<double, std::allocator<double> > ns3::RadioBearerStatsCalculator::GetDlPduSizeStats(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlPduSizeStats', 
-                   'std::vector< double >', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint64_t ns3::RadioBearerStatsCalculator::GetDlRxData(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlRxData', 
-                   'uint64_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint32_t ns3::RadioBearerStatsCalculator::GetDlRxPackets(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlRxPackets', 
-                   'uint32_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint64_t ns3::RadioBearerStatsCalculator::GetDlTxData(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlTxData', 
-                   'uint64_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint32_t ns3::RadioBearerStatsCalculator::GetDlTxPackets(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetDlTxPackets', 
-                   'uint32_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): ns3::Time ns3::RadioBearerStatsCalculator::GetEpoch() const [member function]
-    cls.add_method('GetEpoch', 
-                   'ns3::Time', 
-                   [], 
-                   is_const=True)
-    ## radio-bearer-stats-calculator.h (module 'lte'): ns3::Time ns3::RadioBearerStatsCalculator::GetStartTime() const [member function]
-    cls.add_method('GetStartTime', 
-                   'ns3::Time', 
-                   [], 
-                   is_const=True)
-    ## radio-bearer-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::RadioBearerStatsCalculator::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint32_t ns3::RadioBearerStatsCalculator::GetUlCellId(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlCellId', 
-                   'uint32_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): double ns3::RadioBearerStatsCalculator::GetUlDelay(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlDelay', 
-                   'double', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::vector<double, std::allocator<double> > ns3::RadioBearerStatsCalculator::GetUlDelayStats(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlDelayStats', 
-                   'std::vector< double >', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::string ns3::RadioBearerStatsCalculator::GetUlOutputFilename() [member function]
-    cls.add_method('GetUlOutputFilename', 
-                   'std::string', 
-                   [])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::string ns3::RadioBearerStatsCalculator::GetUlPdcpOutputFilename() [member function]
-    cls.add_method('GetUlPdcpOutputFilename', 
-                   'std::string', 
-                   [])
-    ## radio-bearer-stats-calculator.h (module 'lte'): std::vector<double, std::allocator<double> > ns3::RadioBearerStatsCalculator::GetUlPduSizeStats(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlPduSizeStats', 
-                   'std::vector< double >', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint64_t ns3::RadioBearerStatsCalculator::GetUlRxData(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlRxData', 
-                   'uint64_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint32_t ns3::RadioBearerStatsCalculator::GetUlRxPackets(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlRxPackets', 
-                   'uint32_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint64_t ns3::RadioBearerStatsCalculator::GetUlTxData(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlTxData', 
-                   'uint64_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): uint32_t ns3::RadioBearerStatsCalculator::GetUlTxPackets(uint64_t imsi, uint8_t lcid) [member function]
-    cls.add_method('GetUlTxPackets', 
-                   'uint32_t', 
-                   [param('uint64_t', 'imsi'), param('uint8_t', 'lcid')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::SetDlPdcpOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetDlPdcpOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::SetEpoch(ns3::Time e) [member function]
-    cls.add_method('SetEpoch', 
-                   'void', 
-                   [param('ns3::Time', 'e')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::SetStartTime(ns3::Time t) [member function]
-    cls.add_method('SetStartTime', 
-                   'void', 
-                   [param('ns3::Time', 't')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::SetUlPdcpOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetUlPdcpOutputFilename', 
-                   'void', 
-                   [param('std::string', 'outputFilename')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::UlRxPdu(uint16_t cellId, uint64_t imsi, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint64_t delay) [member function]
-    cls.add_method('UlRxPdu', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize'), param('uint64_t', 'delay')])
-    ## radio-bearer-stats-calculator.h (module 'lte'): void ns3::RadioBearerStatsCalculator::UlTxPdu(uint16_t cellId, uint64_t imsi, uint16_t rnti, uint8_t lcid, uint32_t packetSize) [member function]
-    cls.add_method('UlTxPdu', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize')])
-    return
-
-def register_Ns3RarLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage::RarLteControlMessage(ns3::RarLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RarLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage::RarLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): void ns3::RarLteControlMessage::AddRar(ns3::RarLteControlMessage::Rar rar) [member function]
-    cls.add_method('AddRar', 
-                   'void', 
-                   [param('ns3::RarLteControlMessage::Rar', 'rar')])
-    ## lte-control-messages.h (module 'lte'): uint16_t ns3::RarLteControlMessage::GetRaRnti() const [member function]
-    cls.add_method('GetRaRnti', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-control-messages.h (module 'lte'): std::list<ns3::RarLteControlMessage::Rar, std::allocator<ns3::RarLteControlMessage::Rar> >::const_iterator ns3::RarLteControlMessage::RarListBegin() const [member function]
-    cls.add_method('RarListBegin', 
-                   'std::list< ns3::RarLteControlMessage::Rar > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## lte-control-messages.h (module 'lte'): std::list<ns3::RarLteControlMessage::Rar, std::allocator<ns3::RarLteControlMessage::Rar> >::const_iterator ns3::RarLteControlMessage::RarListEnd() const [member function]
-    cls.add_method('RarListEnd', 
-                   'std::list< ns3::RarLteControlMessage::Rar > const_iterator', 
-                   [], 
-                   is_const=True)
-    ## lte-control-messages.h (module 'lte'): void ns3::RarLteControlMessage::SetRaRnti(uint16_t raRnti) [member function]
-    cls.add_method('SetRaRnti', 
-                   'void', 
-                   [param('uint16_t', 'raRnti')])
-    return
-
-def register_Ns3RarLteControlMessageRar_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage::Rar::Rar() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage::Rar::Rar(ns3::RarLteControlMessage::Rar const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RarLteControlMessage::Rar const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage::Rar::rapId [variable]
-    cls.add_instance_attribute('rapId', 'uint8_t', is_const=False)
-    ## lte-control-messages.h (module 'lte'): ns3::RarLteControlMessage::Rar::rarPayload [variable]
-    cls.add_instance_attribute('rarPayload', 'ns3::BuildRarListElement_s', is_const=False)
-    return
-
-def register_Ns3RemSpectrumPhy_methods(root_module, cls):
-    ## rem-spectrum-phy.h (module 'lte'): ns3::RemSpectrumPhy::RemSpectrumPhy() [constructor]
-    cls.add_constructor([])
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): static ns3::TypeId ns3::RemSpectrumPhy::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::SetChannel(ns3::Ptr<ns3::SpectrumChannel> c) [member function]
-    cls.add_method('SetChannel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumChannel >', 'c')], 
-                   is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::SetMobility(ns3::Ptr<ns3::MobilityModel> m) [member function]
-    cls.add_method('SetMobility', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::MobilityModel >', 'm')], 
-                   is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::SetDevice(ns3::Ptr<ns3::NetDevice> d) [member function]
-    cls.add_method('SetDevice', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'd')], 
-                   is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): ns3::Ptr<ns3::MobilityModel> ns3::RemSpectrumPhy::GetMobility() [member function]
-    cls.add_method('GetMobility', 
-                   'ns3::Ptr< ns3::MobilityModel >', 
-                   [], 
-                   is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): ns3::Ptr<ns3::NetDevice> ns3::RemSpectrumPhy::GetDevice() const [member function]
-    cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): ns3::Ptr<const ns3::SpectrumModel> ns3::RemSpectrumPhy::GetRxSpectrumModel() const [member function]
-    cls.add_method('GetRxSpectrumModel', 
-                   'ns3::Ptr< ns3::SpectrumModel const >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): ns3::Ptr<ns3::AntennaModel> ns3::RemSpectrumPhy::GetRxAntenna() [member function]
-    cls.add_method('GetRxAntenna', 
-                   'ns3::Ptr< ns3::AntennaModel >', 
-                   [], 
-                   is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::StartRx(ns3::Ptr<ns3::SpectrumSignalParameters> params) [member function]
-    cls.add_method('StartRx', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumSignalParameters >', 'params')], 
-                   is_virtual=True)
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::SetRxSpectrumModel(ns3::Ptr<const ns3::SpectrumModel> m) [member function]
-    cls.add_method('SetRxSpectrumModel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumModel const >', 'm')])
-    ## rem-spectrum-phy.h (module 'lte'): double ns3::RemSpectrumPhy::GetSinr(double noisePower) [member function]
-    cls.add_method('GetSinr', 
-                   'double', 
-                   [param('double', 'noisePower')])
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::Deactivate() [member function]
-    cls.add_method('Deactivate', 
-                   'void', 
-                   [])
-    ## rem-spectrum-phy.h (module 'lte'): bool ns3::RemSpectrumPhy::IsActive() [member function]
-    cls.add_method('IsActive', 
-                   'bool', 
-                   [])
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::Reset() [member function]
-    cls.add_method('Reset', 
-                   'void', 
-                   [])
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::SetUseDataChannel(bool value) [member function]
-    cls.add_method('SetUseDataChannel', 
-                   'void', 
-                   [param('bool', 'value')])
-    ## rem-spectrum-phy.h (module 'lte'): void ns3::RemSpectrumPhy::SetRbId(int32_t rbId) [member function]
-    cls.add_method('SetRbId', 
-                   'void', 
-                   [param('int32_t', 'rbId')])
-    return
-
-def register_Ns3RrComponentCarrierManager_methods(root_module, cls):
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::RrComponentCarrierManager::RrComponentCarrierManager(ns3::RrComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrComponentCarrierManager const &', 'arg0')])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::RrComponentCarrierManager::RrComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## no-op-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::RrComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::RrComponentCarrierManager::DoReportBufferStatus(ns3::LteMacSapProvider::ReportBufferStatusParameters params) [member function]
-    cls.add_method('DoReportBufferStatus', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::ReportBufferStatusParameters', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::RrComponentCarrierManager::DoUlReceiveMacCe(ns3::MacCeListElement_s bsr, uint8_t componentCarrierId) [member function]
-    cls.add_method('DoUlReceiveMacCe', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr'), param('uint8_t', 'componentCarrierId')], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3RrFfMacScheduler_methods(root_module, cls):
-    ## rr-ff-mac-scheduler.h (module 'lte'): ns3::RrFfMacScheduler::RrFfMacScheduler(ns3::RrFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrFfMacScheduler const &', 'arg0')])
-    ## rr-ff-mac-scheduler.h (module 'lte'): ns3::RrFfMacScheduler::RrFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## rr-ff-mac-scheduler.h (module 'lte'): void ns3::RrFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::RrFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::RrFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::RrFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::RrFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): void ns3::RrFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): void ns3::RrFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): void ns3::RrFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## rr-ff-mac-scheduler.h (module 'lte'): void ns3::RrFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3RrcAsn1Header_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcAsn1Header::RrcAsn1Header(ns3::RrcAsn1Header const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcAsn1Header const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcAsn1Header::RrcAsn1Header() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): int ns3::RrcAsn1Header::GetMessageType() [member function]
-    cls.add_method('GetMessageType', 
-                   'int', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcAsn1Header::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeCellIdentification(ns3::LteRrcSap::CellIdentification * ci, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeCellIdentification', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::CellIdentification *', 'ci'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeDrbToAddModList(std::list<ns3::LteRrcSap::DrbToAddMod, std::allocator<ns3::LteRrcSap::DrbToAddMod> > * drbToAddModLis, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeDrbToAddModList', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::list< ns3::LteRrcSap::DrbToAddMod > *', 'drbToAddModLis'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeLogicalChannelConfig(ns3::LteRrcSap::LogicalChannelConfig * logicalChannelConfig, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeLogicalChannelConfig', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::LogicalChannelConfig *', 'logicalChannelConfig'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeMeasConfig(ns3::LteRrcSap::MeasConfig * measConfig, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeMeasConfig', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::MeasConfig *', 'measConfig'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeMeasResults(ns3::LteRrcSap::MeasResults * measResults, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeMeasResults', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::MeasResults *', 'measResults'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeNonCriticalExtensionConfig(ns3::LteRrcSap::NonCriticalExtensionConfiguration * nonCriticalExtension, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeNonCriticalExtensionConfig', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::NonCriticalExtensionConfiguration *', 'nonCriticalExtension'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializePhysicalConfigDedicated(ns3::LteRrcSap::PhysicalConfigDedicated * physicalConfigDedicated, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializePhysicalConfigDedicated', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::PhysicalConfigDedicated *', 'physicalConfigDedicated'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializePhysicalConfigDedicatedSCell(ns3::LteRrcSap::PhysicalConfigDedicatedSCell * pcdsc, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializePhysicalConfigDedicatedSCell', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::PhysicalConfigDedicatedSCell *', 'pcdsc'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializePlmnIdentity(uint32_t * plmnId, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializePlmnIdentity', 
-                   'ns3::Buffer::Iterator', 
-                   [param('uint32_t *', 'plmnId'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeQoffsetRange(int8_t * qOffsetRange, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeQoffsetRange', 
-                   'ns3::Buffer::Iterator', 
-                   [param('int8_t *', 'qOffsetRange'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRachConfigCommon(ns3::LteRrcSap::RachConfigCommon * rachConfigCommon, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRachConfigCommon', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RachConfigCommon *', 'rachConfigCommon'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigCommon(ns3::LteRrcSap::RadioResourceConfigCommon * radioResourceConfigCommon, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRadioResourceConfigCommon', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommon *', 'radioResourceConfigCommon'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigCommonSCell(ns3::LteRrcSap::RadioResourceConfigCommonSCell * rrccsc, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRadioResourceConfigCommonSCell', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommonSCell *', 'rrccsc'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigCommonSib(ns3::LteRrcSap::RadioResourceConfigCommonSib * radioResourceConfigCommonSib, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRadioResourceConfigCommonSib', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommonSib *', 'radioResourceConfigCommonSib'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigDedicated(ns3::LteRrcSap::RadioResourceConfigDedicated * radioResourceConfigDedicated, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRadioResourceConfigDedicated', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigDedicated *', 'radioResourceConfigDedicated'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigDedicatedSCell(ns3::LteRrcSap::RadioResourceConfigDedicatedSCell * rrcdsc, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRadioResourceConfigDedicatedSCell', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigDedicatedSCell *', 'rrcdsc'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeSrbToAddModList(std::list<ns3::LteRrcSap::SrbToAddMod, std::allocator<ns3::LteRrcSap::SrbToAddMod> > * srbToAddModList, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSrbToAddModList', 
-                   'ns3::Buffer::Iterator', 
-                   [param('std::list< ns3::LteRrcSap::SrbToAddMod > *', 'srbToAddModList'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeSystemInformationBlockType1(ns3::LteRrcSap::SystemInformationBlockType1 * systemInformationBlockType1, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSystemInformationBlockType1', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::SystemInformationBlockType1 *', 'systemInformationBlockType1'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeSystemInformationBlockType2(ns3::LteRrcSap::SystemInformationBlockType2 * systemInformationBlockType2, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeSystemInformationBlockType2', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::SystemInformationBlockType2 *', 'systemInformationBlockType2'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeThresholdEutra(ns3::LteRrcSap::ThresholdEutra * thresholdEutra, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeThresholdEutra', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::ThresholdEutra *', 'thresholdEutra'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::TypeId ns3::RrcAsn1Header::GetInstanceTypeId() const [member function]
-    cls.add_method('GetInstanceTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True, visibility='protected', is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcAsn1Header::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_const=True, visibility='protected', is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, visibility='protected', is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::Print(std::ostream & os, ns3::LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os'), param('ns3::LteRrcSap::RadioResourceConfigDedicated', 'radioResourceConfigDedicated')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeDrbToAddModList(std::list<ns3::LteRrcSap::DrbToAddMod, std::allocator<ns3::LteRrcSap::DrbToAddMod> > drbToAddModList) const [member function]
-    cls.add_method('SerializeDrbToAddModList', 
-                   'void', 
-                   [param('std::list< ns3::LteRrcSap::DrbToAddMod >', 'drbToAddModList')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeLogicalChannelConfig(ns3::LteRrcSap::LogicalChannelConfig logicalChannelConfig) const [member function]
-    cls.add_method('SerializeLogicalChannelConfig', 
-                   'void', 
-                   [param('ns3::LteRrcSap::LogicalChannelConfig', 'logicalChannelConfig')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeMeasConfig(ns3::LteRrcSap::MeasConfig measConfig) const [member function]
-    cls.add_method('SerializeMeasConfig', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MeasConfig', 'measConfig')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeMeasResults(ns3::LteRrcSap::MeasResults measResults) const [member function]
-    cls.add_method('SerializeMeasResults', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeNonCriticalExtensionConfiguration(ns3::LteRrcSap::NonCriticalExtensionConfiguration nonCriticalExtensionConfiguration) const [member function]
-    cls.add_method('SerializeNonCriticalExtensionConfiguration', 
-                   'void', 
-                   [param('ns3::LteRrcSap::NonCriticalExtensionConfiguration', 'nonCriticalExtensionConfiguration')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializePhysicalConfigDedicated(ns3::LteRrcSap::PhysicalConfigDedicated physicalConfigDedicated) const [member function]
-    cls.add_method('SerializePhysicalConfigDedicated', 
-                   'void', 
-                   [param('ns3::LteRrcSap::PhysicalConfigDedicated', 'physicalConfigDedicated')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializePhysicalConfigDedicatedSCell(ns3::LteRrcSap::PhysicalConfigDedicatedSCell pcdsc) const [member function]
-    cls.add_method('SerializePhysicalConfigDedicatedSCell', 
-                   'void', 
-                   [param('ns3::LteRrcSap::PhysicalConfigDedicatedSCell', 'pcdsc')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializePlmnIdentity(uint32_t plmnId) const [member function]
-    cls.add_method('SerializePlmnIdentity', 
-                   'void', 
-                   [param('uint32_t', 'plmnId')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeQoffsetRange(int8_t qOffsetRange) const [member function]
-    cls.add_method('SerializeQoffsetRange', 
-                   'void', 
-                   [param('int8_t', 'qOffsetRange')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRachConfigCommon(ns3::LteRrcSap::RachConfigCommon rachConfigCommon) const [member function]
-    cls.add_method('SerializeRachConfigCommon', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RachConfigCommon', 'rachConfigCommon')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceConfigCommon(ns3::LteRrcSap::RadioResourceConfigCommon radioResourceConfigCommon) const [member function]
-    cls.add_method('SerializeRadioResourceConfigCommon', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommon', 'radioResourceConfigCommon')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceConfigCommonSCell(ns3::LteRrcSap::RadioResourceConfigCommonSCell rrccsc) const [member function]
-    cls.add_method('SerializeRadioResourceConfigCommonSCell', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommonSCell', 'rrccsc')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceConfigCommonSib(ns3::LteRrcSap::RadioResourceConfigCommonSib radioResourceConfigCommonSib) const [member function]
-    cls.add_method('SerializeRadioResourceConfigCommonSib', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommonSib', 'radioResourceConfigCommonSib')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceConfigDedicated(ns3::LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) const [member function]
-    cls.add_method('SerializeRadioResourceConfigDedicated', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigDedicated', 'radioResourceConfigDedicated')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceDedicatedSCell(ns3::LteRrcSap::RadioResourceConfigDedicatedSCell rrcdsc) const [member function]
-    cls.add_method('SerializeRadioResourceDedicatedSCell', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigDedicatedSCell', 'rrcdsc')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeSrbToAddModList(std::list<ns3::LteRrcSap::SrbToAddMod, std::allocator<ns3::LteRrcSap::SrbToAddMod> > srbToAddModList) const [member function]
-    cls.add_method('SerializeSrbToAddModList', 
-                   'void', 
-                   [param('std::list< ns3::LteRrcSap::SrbToAddMod >', 'srbToAddModList')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeSystemInformationBlockType1(ns3::LteRrcSap::SystemInformationBlockType1 systemInformationBlockType1) const [member function]
-    cls.add_method('SerializeSystemInformationBlockType1', 
-                   'void', 
-                   [param('ns3::LteRrcSap::SystemInformationBlockType1', 'systemInformationBlockType1')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeSystemInformationBlockType2(ns3::LteRrcSap::SystemInformationBlockType2 systemInformationBlockType2) const [member function]
-    cls.add_method('SerializeSystemInformationBlockType2', 
-                   'void', 
-                   [param('ns3::LteRrcSap::SystemInformationBlockType2', 'systemInformationBlockType2')], 
-                   is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeThresholdEutra(ns3::LteRrcSap::ThresholdEutra thresholdEutra) const [member function]
-    cls.add_method('SerializeThresholdEutra', 
-                   'void', 
-                   [param('ns3::LteRrcSap::ThresholdEutra', 'thresholdEutra')], 
-                   is_const=True, visibility='protected')
-    return
-
-def register_Ns3RrcDlCcchMessage_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcDlCcchMessage::RrcDlCcchMessage(ns3::RrcDlCcchMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcDlCcchMessage const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcDlCcchMessage::RrcDlCcchMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcDlCcchMessage::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcDlCcchMessage::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcDlCcchMessage::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcDlCcchMessage::DeserializeDlCcchMessage(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeDlCcchMessage', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcDlCcchMessage::SerializeDlCcchMessage(int msgType) const [member function]
-    cls.add_method('SerializeDlCcchMessage', 
-                   'void', 
-                   [param('int', 'msgType')], 
-                   is_const=True, visibility='protected')
-    return
-
-def register_Ns3RrcDlDcchMessage_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcDlDcchMessage::RrcDlDcchMessage(ns3::RrcDlDcchMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcDlDcchMessage const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcDlDcchMessage::RrcDlDcchMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcDlDcchMessage::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcDlDcchMessage::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcDlDcchMessage::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcDlDcchMessage::DeserializeDlDcchMessage(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeDlDcchMessage', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcDlDcchMessage::SerializeDlDcchMessage(int msgType) const [member function]
-    cls.add_method('SerializeDlDcchMessage', 
-                   'void', 
-                   [param('int', 'msgType')], 
-                   is_const=True, visibility='protected')
-    return
-
-def register_Ns3RrcUlCcchMessage_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcUlCcchMessage::RrcUlCcchMessage(ns3::RrcUlCcchMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcUlCcchMessage const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcUlCcchMessage::RrcUlCcchMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcUlCcchMessage::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcUlCcchMessage::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcUlCcchMessage::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcUlCcchMessage::DeserializeUlCcchMessage(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeUlCcchMessage', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcUlCcchMessage::SerializeUlCcchMessage(int msgType) const [member function]
-    cls.add_method('SerializeUlCcchMessage', 
-                   'void', 
-                   [param('int', 'msgType')], 
-                   is_const=True, visibility='protected')
-    return
-
-def register_Ns3RrcUlDcchMessage_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcUlDcchMessage::RrcUlDcchMessage(ns3::RrcUlDcchMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcUlDcchMessage const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcUlDcchMessage::RrcUlDcchMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcUlDcchMessage::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcUlDcchMessage::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcUlDcchMessage::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcUlDcchMessage::DeserializeUlDcchMessage(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeUlDcchMessage', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcUlDcchMessage::SerializeUlDcchMessage(int msgType) const [member function]
-    cls.add_method('SerializeUlDcchMessage', 
-                   'void', 
-                   [param('int', 'msgType')], 
-                   is_const=True, visibility='protected')
-    return
-
-def register_Ns3Sib1LteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::Sib1LteControlMessage::Sib1LteControlMessage(ns3::Sib1LteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Sib1LteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::Sib1LteControlMessage::Sib1LteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::LteRrcSap::SystemInformationBlockType1 ns3::Sib1LteControlMessage::GetSib1() const [member function]
-    cls.add_method('GetSib1', 
-                   'ns3::LteRrcSap::SystemInformationBlockType1', 
-                   [], 
-                   is_const=True)
-    ## lte-control-messages.h (module 'lte'): void ns3::Sib1LteControlMessage::SetSib1(ns3::LteRrcSap::SystemInformationBlockType1 sib1) [member function]
-    cls.add_method('SetSib1', 
-                   'void', 
-                   [param('ns3::LteRrcSap::SystemInformationBlockType1', 'sib1')])
-    return
-
-def register_Ns3SimpleUeComponentCarrierManager_methods(root_module, cls):
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::SimpleUeComponentCarrierManager::SimpleUeComponentCarrierManager(ns3::SimpleUeComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SimpleUeComponentCarrierManager const &', 'arg0')])
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::SimpleUeComponentCarrierManager::SimpleUeComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeCcmRrcSapProvider * ns3::SimpleUeComponentCarrierManager::GetLteCcmRrcSapProvider() [member function]
-    cls.add_method('GetLteCcmRrcSapProvider', 
-                   'ns3::LteUeCcmRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::LteMacSapProvider * ns3::SimpleUeComponentCarrierManager::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::SimpleUeComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::SetLteCcmRrcSapUser(ns3::LteUeCcmRrcSapUser * s) [member function]
-    cls.add_method('SetLteCcmRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteUeCcmRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): std::vector<ns3::LteUeCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteUeCcmRrcSapProvider::LcsConfig> > ns3::SimpleUeComponentCarrierManager::DoAddLc(uint8_t lcId, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoAddLc', 
-                   'std::vector< ns3::LteUeCcmRrcSapProvider::LcsConfig >', 
-                   [param('uint8_t', 'lcId'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::LteMacSapUser * ns3::SimpleUeComponentCarrierManager::DoConfigureSignalBearer(uint8_t lcId, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('uint8_t', 'lcId'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoNotifyConnectionReconfigurationMsg() [member function]
-    cls.add_method('DoNotifyConnectionReconfigurationMsg', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): std::vector<unsigned short, std::allocator<unsigned short> > ns3::SimpleUeComponentCarrierManager::DoRemoveLc(uint8_t lcid) [member function]
-    cls.add_method('DoRemoveLc', 
-                   'std::vector< unsigned short >', 
-                   [param('uint8_t', 'lcid')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoReportBufferStatus(ns3::LteMacSapProvider::ReportBufferStatusParameters params) [member function]
-    cls.add_method('DoReportBufferStatus', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::ReportBufferStatusParameters', 'params')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoTransmitPdu(ns3::LteMacSapProvider::TransmitPduParameters params) [member function]
-    cls.add_method('DoTransmitPdu', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::TransmitPduParameters', 'params')], 
-                   visibility='protected')
-    return
-
-def register_Ns3SpectrumChannel_methods(root_module, cls):
-    ## spectrum-channel.h (module 'spectrum'): ns3::SpectrumChannel::SpectrumChannel() [constructor]
-    cls.add_constructor([])
-    ## spectrum-channel.h (module 'spectrum'): ns3::SpectrumChannel::SpectrumChannel(ns3::SpectrumChannel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SpectrumChannel const &', 'arg0')])
-    ## spectrum-channel.h (module 'spectrum'): void ns3::SpectrumChannel::AddPropagationLossModel(ns3::Ptr<ns3::PropagationLossModel> loss) [member function]
-    cls.add_method('AddPropagationLossModel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PropagationLossModel >', 'loss')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-channel.h (module 'spectrum'): void ns3::SpectrumChannel::AddRx(ns3::Ptr<ns3::SpectrumPhy> phy) [member function]
-    cls.add_method('AddRx', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumPhy >', 'phy')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-channel.h (module 'spectrum'): void ns3::SpectrumChannel::AddSpectrumPropagationLossModel(ns3::Ptr<ns3::SpectrumPropagationLossModel> loss) [member function]
-    cls.add_method('AddSpectrumPropagationLossModel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumPropagationLossModel >', 'loss')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-channel.h (module 'spectrum'): static ns3::TypeId ns3::SpectrumChannel::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## spectrum-channel.h (module 'spectrum'): void ns3::SpectrumChannel::SetPropagationDelayModel(ns3::Ptr<ns3::PropagationDelayModel> delay) [member function]
-    cls.add_method('SetPropagationDelayModel', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PropagationDelayModel >', 'delay')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## spectrum-channel.h (module 'spectrum'): void ns3::SpectrumChannel::StartTx(ns3::Ptr<ns3::SpectrumSignalParameters> params) [member function]
-    cls.add_method('StartTx', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::SpectrumSignalParameters >', 'params')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3SrsCqiRntiVsp_methods(root_module, cls):
-    ## lte-vendor-specific-parameters.h (module 'lte'): ns3::SrsCqiRntiVsp::SrsCqiRntiVsp(ns3::SrsCqiRntiVsp const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SrsCqiRntiVsp const &', 'arg0')])
-    ## lte-vendor-specific-parameters.h (module 'lte'): ns3::SrsCqiRntiVsp::SrsCqiRntiVsp(uint16_t rnti) [constructor]
-    cls.add_constructor([param('uint16_t', 'rnti')])
-    ## lte-vendor-specific-parameters.h (module 'lte'): uint16_t ns3::SrsCqiRntiVsp::GetRnti() [member function]
-    cls.add_method('GetRnti', 
-                   'uint16_t', 
-                   [])
-    return
-
-def register_Ns3StringChecker_methods(root_module, cls):
-    ## string.h (module 'core'): ns3::StringChecker::StringChecker() [constructor]
-    cls.add_constructor([])
-    ## string.h (module 'core'): ns3::StringChecker::StringChecker(ns3::StringChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::StringChecker const &', 'arg0')])
-    return
-
-def register_Ns3StringValue_methods(root_module, cls):
-    ## string.h (module 'core'): ns3::StringValue::StringValue() [constructor]
-    cls.add_constructor([])
-    ## string.h (module 'core'): ns3::StringValue::StringValue(std::string const & value) [constructor]
-    cls.add_constructor([param('std::string const &', 'value')])
-    ## string.h (module 'core'): ns3::StringValue::StringValue(ns3::StringValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::StringValue const &', 'arg0')])
-    ## string.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::StringValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## string.h (module 'core'): bool ns3::StringValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## string.h (module 'core'): std::string ns3::StringValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## string.h (module 'core'): std::string ns3::StringValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## string.h (module 'core'): void ns3::StringValue::Set(std::string const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('std::string const &', 'value')])
-    return
-
-def register_Ns3TdBetFfMacScheduler_methods(root_module, cls):
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::TdBetFfMacScheduler::TdBetFfMacScheduler(ns3::TdBetFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TdBetFfMacScheduler const &', 'arg0')])
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::TdBetFfMacScheduler::TdBetFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): void ns3::TdBetFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::TdBetFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::TdBetFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::TdBetFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::TdBetFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): void ns3::TdBetFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): void ns3::TdBetFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): void ns3::TdBetFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## tdbet-ff-mac-scheduler.h (module 'lte'): void ns3::TdBetFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3TdMtFfMacScheduler_methods(root_module, cls):
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): ns3::TdMtFfMacScheduler::TdMtFfMacScheduler(ns3::TdMtFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TdMtFfMacScheduler const &', 'arg0')])
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): ns3::TdMtFfMacScheduler::TdMtFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): void ns3::TdMtFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::TdMtFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::TdMtFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::TdMtFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::TdMtFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): void ns3::TdMtFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): void ns3::TdMtFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): void ns3::TdMtFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## tdmt-ff-mac-scheduler.h (module 'lte'): void ns3::TdMtFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3TdTbfqFfMacScheduler_methods(root_module, cls):
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::TdTbfqFfMacScheduler::TdTbfqFfMacScheduler(ns3::TdTbfqFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TdTbfqFfMacScheduler const &', 'arg0')])
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::TdTbfqFfMacScheduler::TdTbfqFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::TdTbfqFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::TdTbfqFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::TdTbfqFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::TdTbfqFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::TdTbfqFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::TdTbfqFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::TdTbfqFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::TdTbfqFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## tdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::TdTbfqFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3TimeValue_methods(root_module, cls):
-    ## nstime.h (module 'core'): ns3::TimeValue::TimeValue() [constructor]
-    cls.add_constructor([])
-    ## nstime.h (module 'core'): ns3::TimeValue::TimeValue(ns3::Time const & value) [constructor]
-    cls.add_constructor([param('ns3::Time const &', 'value')])
-    ## nstime.h (module 'core'): ns3::TimeValue::TimeValue(ns3::TimeValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TimeValue const &', 'arg0')])
-    ## nstime.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::TimeValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## nstime.h (module 'core'): bool ns3::TimeValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## nstime.h (module 'core'): ns3::Time ns3::TimeValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Time', 
-                   [], 
-                   is_const=True)
-    ## nstime.h (module 'core'): std::string ns3::TimeValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## nstime.h (module 'core'): void ns3::TimeValue::Set(ns3::Time const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Time const &', 'value')])
-    return
-
-def register_Ns3TtaFfMacScheduler_methods(root_module, cls):
-    ## tta-ff-mac-scheduler.h (module 'lte'): ns3::TtaFfMacScheduler::TtaFfMacScheduler(ns3::TtaFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TtaFfMacScheduler const &', 'arg0')])
-    ## tta-ff-mac-scheduler.h (module 'lte'): ns3::TtaFfMacScheduler::TtaFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## tta-ff-mac-scheduler.h (module 'lte'): void ns3::TtaFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::TtaFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::TtaFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::TtaFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::TtaFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): void ns3::TtaFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): void ns3::TtaFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): void ns3::TtaFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## tta-ff-mac-scheduler.h (module 'lte'): void ns3::TtaFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3TypeIdChecker_methods(root_module, cls):
-    ## type-id.h (module 'core'): ns3::TypeIdChecker::TypeIdChecker() [constructor]
-    cls.add_constructor([])
-    ## type-id.h (module 'core'): ns3::TypeIdChecker::TypeIdChecker(ns3::TypeIdChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TypeIdChecker const &', 'arg0')])
-    return
-
-def register_Ns3TypeIdValue_methods(root_module, cls):
-    ## type-id.h (module 'core'): ns3::TypeIdValue::TypeIdValue() [constructor]
-    cls.add_constructor([])
-    ## type-id.h (module 'core'): ns3::TypeIdValue::TypeIdValue(ns3::TypeId const & value) [constructor]
-    cls.add_constructor([param('ns3::TypeId const &', 'value')])
-    ## type-id.h (module 'core'): ns3::TypeIdValue::TypeIdValue(ns3::TypeIdValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::TypeIdValue const &', 'arg0')])
-    ## type-id.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::TypeIdValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## type-id.h (module 'core'): bool ns3::TypeIdValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## type-id.h (module 'core'): ns3::TypeId ns3::TypeIdValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_const=True)
-    ## type-id.h (module 'core'): std::string ns3::TypeIdValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## type-id.h (module 'core'): void ns3::TypeIdValue::Set(ns3::TypeId const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::TypeId const &', 'value')])
-    return
-
-def register_Ns3UintegerValue_methods(root_module, cls):
-    ## uinteger.h (module 'core'): ns3::UintegerValue::UintegerValue() [constructor]
-    cls.add_constructor([])
-    ## uinteger.h (module 'core'): ns3::UintegerValue::UintegerValue(uint64_t const & value) [constructor]
-    cls.add_constructor([param('uint64_t const &', 'value')])
-    ## uinteger.h (module 'core'): ns3::UintegerValue::UintegerValue(ns3::UintegerValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UintegerValue const &', 'arg0')])
-    ## uinteger.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::UintegerValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## uinteger.h (module 'core'): bool ns3::UintegerValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## uinteger.h (module 'core'): uint64_t ns3::UintegerValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## uinteger.h (module 'core'): std::string ns3::UintegerValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## uinteger.h (module 'core'): void ns3::UintegerValue::Set(uint64_t const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('uint64_t const &', 'value')])
-    return
-
-def register_Ns3UlDciLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::UlDciLteControlMessage::UlDciLteControlMessage(ns3::UlDciLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::UlDciLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::UlDciLteControlMessage::UlDciLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::UlDciListElement_s ns3::UlDciLteControlMessage::GetDci() [member function]
-    cls.add_method('GetDci', 
-                   'ns3::UlDciListElement_s', 
-                   [])
-    ## lte-control-messages.h (module 'lte'): void ns3::UlDciLteControlMessage::SetDci(ns3::UlDciListElement_s dci) [member function]
-    cls.add_method('SetDci', 
-                   'void', 
-                   [param('ns3::UlDciListElement_s', 'dci')])
-    return
-
-def register_Ns3Vector2DChecker_methods(root_module, cls):
-    ## vector.h (module 'core'): ns3::Vector2DChecker::Vector2DChecker() [constructor]
-    cls.add_constructor([])
-    ## vector.h (module 'core'): ns3::Vector2DChecker::Vector2DChecker(ns3::Vector2DChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Vector2DChecker const &', 'arg0')])
-    return
-
-def register_Ns3Vector2DValue_methods(root_module, cls):
-    ## vector.h (module 'core'): ns3::Vector2DValue::Vector2DValue() [constructor]
-    cls.add_constructor([])
-    ## vector.h (module 'core'): ns3::Vector2DValue::Vector2DValue(ns3::Vector2D const & value) [constructor]
-    cls.add_constructor([param('ns3::Vector2D const &', 'value')])
-    ## vector.h (module 'core'): ns3::Vector2DValue::Vector2DValue(ns3::Vector2DValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Vector2DValue const &', 'arg0')])
-    ## vector.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::Vector2DValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## vector.h (module 'core'): bool ns3::Vector2DValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## vector.h (module 'core'): ns3::Vector2D ns3::Vector2DValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Vector2D', 
-                   [], 
-                   is_const=True)
-    ## vector.h (module 'core'): std::string ns3::Vector2DValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## vector.h (module 'core'): void ns3::Vector2DValue::Set(ns3::Vector2D const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Vector2D const &', 'value')])
-    return
-
-def register_Ns3Vector3DChecker_methods(root_module, cls):
-    ## vector.h (module 'core'): ns3::Vector3DChecker::Vector3DChecker() [constructor]
-    cls.add_constructor([])
-    ## vector.h (module 'core'): ns3::Vector3DChecker::Vector3DChecker(ns3::Vector3DChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Vector3DChecker const &', 'arg0')])
-    return
-
-def register_Ns3Vector3DValue_methods(root_module, cls):
-    ## vector.h (module 'core'): ns3::Vector3DValue::Vector3DValue() [constructor]
-    cls.add_constructor([])
-    ## vector.h (module 'core'): ns3::Vector3DValue::Vector3DValue(ns3::Vector3D const & value) [constructor]
-    cls.add_constructor([param('ns3::Vector3D const &', 'value')])
-    ## vector.h (module 'core'): ns3::Vector3DValue::Vector3DValue(ns3::Vector3DValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Vector3DValue const &', 'arg0')])
-    ## vector.h (module 'core'): ns3::Ptr<ns3::AttributeValue> ns3::Vector3DValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## vector.h (module 'core'): bool ns3::Vector3DValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## vector.h (module 'core'): ns3::Vector3D ns3::Vector3DValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Vector3D', 
-                   [], 
-                   is_const=True)
-    ## vector.h (module 'core'): std::string ns3::Vector3DValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## vector.h (module 'core'): void ns3::Vector3DValue::Set(ns3::Vector3D const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Vector3D const &', 'value')])
-    return
-
-def register_Ns3VirtualNetDevice_methods(root_module, cls):
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::VirtualNetDevice::VirtualNetDevice(ns3::VirtualNetDevice const & arg0) [constructor]
-    cls.add_constructor([param('ns3::VirtualNetDevice const &', 'arg0')])
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::VirtualNetDevice::VirtualNetDevice() [constructor]
-    cls.add_constructor([])
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::AddLinkChangeCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> callback) [member function]
-    cls.add_method('AddLinkChangeCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::Address ns3::VirtualNetDevice::GetAddress() const [member function]
-    cls.add_method('GetAddress', 
-                   'ns3::Address', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::Address ns3::VirtualNetDevice::GetBroadcast() const [member function]
-    cls.add_method('GetBroadcast', 
-                   'ns3::Address', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::Ptr<ns3::Channel> ns3::VirtualNetDevice::GetChannel() const [member function]
-    cls.add_method('GetChannel', 
-                   'ns3::Ptr< ns3::Channel >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): uint32_t ns3::VirtualNetDevice::GetIfIndex() const [member function]
-    cls.add_method('GetIfIndex', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): uint16_t ns3::VirtualNetDevice::GetMtu() const [member function]
-    cls.add_method('GetMtu', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::Address ns3::VirtualNetDevice::GetMulticast(ns3::Ipv4Address multicastGroup) const [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Address', 
-                   [param('ns3::Ipv4Address', 'multicastGroup')], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::Address ns3::VirtualNetDevice::GetMulticast(ns3::Ipv6Address addr) const [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Address', 
-                   [param('ns3::Ipv6Address', 'addr')], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): ns3::Ptr<ns3::Node> ns3::VirtualNetDevice::GetNode() const [member function]
-    cls.add_method('GetNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): static ns3::TypeId ns3::VirtualNetDevice::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::IsBridge() const [member function]
-    cls.add_method('IsBridge', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::IsBroadcast() const [member function]
-    cls.add_method('IsBroadcast', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::IsLinkUp() const [member function]
-    cls.add_method('IsLinkUp', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::IsMulticast() const [member function]
-    cls.add_method('IsMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::IsPointToPoint() const [member function]
-    cls.add_method('IsPointToPoint', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::NeedsArp() const [member function]
-    cls.add_method('NeedsArp', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::Receive(ns3::Ptr<ns3::Packet> packet, uint16_t protocol, ns3::Address const & source, ns3::Address const & destination, ns3::NetDevice::PacketType packetType) [member function]
-    cls.add_method('Receive', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('uint16_t', 'protocol'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'destination'), param('ns3::NetDevice::PacketType', 'packetType')])
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::Send(ns3::Ptr<ns3::Packet> packet, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('Send', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::SendFrom(ns3::Ptr<ns3::Packet> packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('SendFrom', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetAddress(ns3::Address address) [member function]
-    cls.add_method('SetAddress', 
-                   'void', 
-                   [param('ns3::Address', 'address')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetIfIndex(uint32_t const index) [member function]
-    cls.add_method('SetIfIndex', 
-                   'void', 
-                   [param('uint32_t const', 'index')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetIsPointToPoint(bool isPointToPoint) [member function]
-    cls.add_method('SetIsPointToPoint', 
-                   'void', 
-                   [param('bool', 'isPointToPoint')])
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::SetMtu(uint16_t const mtu) [member function]
-    cls.add_method('SetMtu', 
-                   'bool', 
-                   [param('uint16_t const', 'mtu')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetNeedsArp(bool needsArp) [member function]
-    cls.add_method('SetNeedsArp', 
-                   'void', 
-                   [param('bool', 'needsArp')])
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetNode(ns3::Ptr<ns3::Node> node) [member function]
-    cls.add_method('SetNode', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'node')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetPromiscReceiveCallback(ns3::NetDevice::PromiscReceiveCallback cb) [member function]
-    cls.add_method('SetPromiscReceiveCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetReceiveCallback(ns3::NetDevice::ReceiveCallback cb) [member function]
-    cls.add_method('SetReceiveCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')], 
-                   is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetSendCallback(ns3::VirtualNetDevice::SendCallback transmitCb) [member function]
-    cls.add_method('SetSendCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::Packet >, ns3::Address const &, ns3::Address const &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'transmitCb')])
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::SetSupportsSendFrom(bool supportsSendFrom) [member function]
-    cls.add_method('SetSupportsSendFrom', 
-                   'void', 
-                   [param('bool', 'supportsSendFrom')])
-    ## virtual-net-device.h (module 'virtual-net-device'): bool ns3::VirtualNetDevice::SupportsSendFrom() const [member function]
-    cls.add_method('SupportsSendFrom', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## virtual-net-device.h (module 'virtual-net-device'): void ns3::VirtualNetDevice::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3A2A4RsrqHandoverAlgorithm_methods(root_module, cls):
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): ns3::A2A4RsrqHandoverAlgorithm::A2A4RsrqHandoverAlgorithm(ns3::A2A4RsrqHandoverAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::A2A4RsrqHandoverAlgorithm const &', 'arg0')])
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): ns3::A2A4RsrqHandoverAlgorithm::A2A4RsrqHandoverAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): ns3::LteHandoverManagementSapProvider * ns3::A2A4RsrqHandoverAlgorithm::GetLteHandoverManagementSapProvider() [member function]
-    cls.add_method('GetLteHandoverManagementSapProvider', 
-                   'ns3::LteHandoverManagementSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): static ns3::TypeId ns3::A2A4RsrqHandoverAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): void ns3::A2A4RsrqHandoverAlgorithm::SetLteHandoverManagementSapUser(ns3::LteHandoverManagementSapUser * s) [member function]
-    cls.add_method('SetLteHandoverManagementSapUser', 
-                   'void', 
-                   [param('ns3::LteHandoverManagementSapUser *', 's')], 
-                   is_virtual=True)
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): void ns3::A2A4RsrqHandoverAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): void ns3::A2A4RsrqHandoverAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## a2-a4-rsrq-handover-algorithm.h (module 'lte'): void ns3::A2A4RsrqHandoverAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3A3RsrpHandoverAlgorithm_methods(root_module, cls):
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): ns3::A3RsrpHandoverAlgorithm::A3RsrpHandoverAlgorithm(ns3::A3RsrpHandoverAlgorithm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::A3RsrpHandoverAlgorithm const &', 'arg0')])
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): ns3::A3RsrpHandoverAlgorithm::A3RsrpHandoverAlgorithm() [constructor]
-    cls.add_constructor([])
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): ns3::LteHandoverManagementSapProvider * ns3::A3RsrpHandoverAlgorithm::GetLteHandoverManagementSapProvider() [member function]
-    cls.add_method('GetLteHandoverManagementSapProvider', 
-                   'ns3::LteHandoverManagementSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): static ns3::TypeId ns3::A3RsrpHandoverAlgorithm::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): void ns3::A3RsrpHandoverAlgorithm::SetLteHandoverManagementSapUser(ns3::LteHandoverManagementSapUser * s) [member function]
-    cls.add_method('SetLteHandoverManagementSapUser', 
-                   'void', 
-                   [param('ns3::LteHandoverManagementSapUser *', 's')], 
-                   is_virtual=True)
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): void ns3::A3RsrpHandoverAlgorithm::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): void ns3::A3RsrpHandoverAlgorithm::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## a3-rsrp-handover-algorithm.h (module 'lte'): void ns3::A3RsrpHandoverAlgorithm::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3AddressChecker_methods(root_module, cls):
-    ## address.h (module 'network'): ns3::AddressChecker::AddressChecker() [constructor]
-    cls.add_constructor([])
-    ## address.h (module 'network'): ns3::AddressChecker::AddressChecker(ns3::AddressChecker const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AddressChecker const &', 'arg0')])
-    return
-
-def register_Ns3AddressValue_methods(root_module, cls):
-    ## address.h (module 'network'): ns3::AddressValue::AddressValue() [constructor]
-    cls.add_constructor([])
-    ## address.h (module 'network'): ns3::AddressValue::AddressValue(ns3::Address const & value) [constructor]
-    cls.add_constructor([param('ns3::Address const &', 'value')])
-    ## address.h (module 'network'): ns3::AddressValue::AddressValue(ns3::AddressValue const & arg0) [constructor]
-    cls.add_constructor([param('ns3::AddressValue const &', 'arg0')])
-    ## address.h (module 'network'): ns3::Ptr<ns3::AttributeValue> ns3::AddressValue::Copy() const [member function]
-    cls.add_method('Copy', 
-                   'ns3::Ptr< ns3::AttributeValue >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## address.h (module 'network'): bool ns3::AddressValue::DeserializeFromString(std::string value, ns3::Ptr<const ns3::AttributeChecker> checker) [member function]
-    cls.add_method('DeserializeFromString', 
-                   'bool', 
-                   [param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_virtual=True)
-    ## address.h (module 'network'): ns3::Address ns3::AddressValue::Get() const [member function]
-    cls.add_method('Get', 
-                   'ns3::Address', 
-                   [], 
-                   is_const=True)
-    ## address.h (module 'network'): std::string ns3::AddressValue::SerializeToString(ns3::Ptr<const ns3::AttributeChecker> checker) const [member function]
-    cls.add_method('SerializeToString', 
-                   'std::string', 
-                   [param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')], 
-                   is_const=True, is_virtual=True)
-    ## address.h (module 'network'): void ns3::AddressValue::Set(ns3::Address const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('ns3::Address const &', 'value')])
-    return
-
-def register_Ns3BsrLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::BsrLteControlMessage::BsrLteControlMessage(ns3::BsrLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::BsrLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::BsrLteControlMessage::BsrLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::MacCeListElement_s ns3::BsrLteControlMessage::GetBsr() [member function]
-    cls.add_method('GetBsr', 
-                   'ns3::MacCeListElement_s', 
-                   [])
-    ## lte-control-messages.h (module 'lte'): void ns3::BsrLteControlMessage::SetBsr(ns3::MacCeListElement_s bsr) [member function]
-    cls.add_method('SetBsr', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr')])
-    return
-
-def register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): bool ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::NetDevice> arg0, ns3::Ptr<const ns3::Packet> arg1, short unsigned int arg2, ns3::Address const & arg3, ns3::Address const & arg4, ns3::NetDevice::PacketType arg5) [member operator]
-    cls.add_method('operator()', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'arg0'), param('ns3::Ptr< ns3::Packet const >', 'arg1'), param('short unsigned int', 'arg2'), param('ns3::Address const &', 'arg3'), param('ns3::Address const &', 'arg4'), param('ns3::NetDevice::PacketType', 'arg5')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): bool ns3::CallbackImpl<bool, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::NetDevice> arg0, ns3::Ptr<const ns3::Packet> arg1, short unsigned int arg2, ns3::Address const & arg3) [member operator]
-    cls.add_method('operator()', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'arg0'), param('ns3::Ptr< ns3::Packet const >', 'arg1'), param('short unsigned int', 'arg2'), param('ns3::Address const &', 'arg3')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Packet__gt___Const_ns3Address___amp___Const_ns3Address___amp___Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< bool, ns3::Ptr< ns3::Packet >, ns3::Address const &, ns3::Address const &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): bool ns3::CallbackImpl<bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::Packet> arg0, ns3::Address const & arg1, ns3::Address const & arg2, short unsigned int arg3) [member operator]
-    cls.add_method('operator()', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'arg0'), param('ns3::Address const &', 'arg1'), param('ns3::Address const &', 'arg2'), param('short unsigned int', 'arg3')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< bool, ns3::Ptr< ns3::Socket >, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): bool ns3::CallbackImpl<bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::Socket> arg0, ns3::Address const & arg1) [member operator]
-    cls.add_method('operator()', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Socket >', 'arg0'), param('ns3::Address const &', 'arg1')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Ns3ObjectBase___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): ns3::ObjectBase * ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()() [member operator]
-    cls.add_method('operator()', 
-                   'ns3::ObjectBase *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Const_ns3SpectrumValue___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::SpectrumValue const & arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3DlSchedulingCallbackInfo_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::DlSchedulingCallbackInfo arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::DlSchedulingCallbackInfo', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3EpcUeNasState_Ns3EpcUeNasState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::EpcUeNas::State arg0, ns3::EpcUeNas::State arg1) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::EpcUeNas::State', 'arg0'), param('ns3::EpcUeNas::State', 'arg1')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3PhyReceptionStatParameters_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::PhyReceptionStatParameters arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::PhyReceptionStatParameters', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3PhyTransmissionStatParameters_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::PhyTransmissionStatParameters arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::PhyTransmissionStatParameters', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3MobilityModel__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::MobilityModel const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<const ns3::MobilityModel> arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::MobilityModel const >', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3Packet__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<const ns3::Packet> arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet const >', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3PacketBurst__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<const ns3::PacketBurst> arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PacketBurst const >', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::NetDevice> arg0, ns3::Ptr<const ns3::Packet> arg1, short unsigned int arg2, ns3::Address const & arg3, ns3::Address const & arg4, ns3::NetDevice::PacketType arg5) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'arg0'), param('ns3::Ptr< ns3::Packet const >', 'arg1'), param('short unsigned int', 'arg2'), param('ns3::Address const &', 'arg3'), param('ns3::Address const &', 'arg4'), param('ns3::NetDevice::PacketType', 'arg5')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::NetDevice> arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Packet__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::Packet> arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::Socket >, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::Socket> arg0, ns3::Address const & arg1) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'arg0'), param('ns3::Address const &', 'arg1')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::Socket >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::Socket> arg0) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'arg0')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::Socket >, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<ns3::Socket> arg0, unsigned int arg1) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'arg0'), param('unsigned int', 'arg1')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()() [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::operator()(unsigned int arg0, unsigned int arg1, short unsigned int arg2, unsigned char arg3, short unsigned int arg4, unsigned char arg5) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('unsigned int', 'arg0'), param('unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('unsigned char', 'arg3'), param('short unsigned int', 'arg4'), param('unsigned char', 'arg5')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteRrcSapMeasurementReport_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1, short unsigned int arg2, ns3::LteRrcSap::MeasurementReport arg3) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('ns3::LteRrcSap::MeasurementReport', 'arg3')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteUeRrcState_Ns3LteUeRrcState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1, short unsigned int arg2, ns3::LteUeRrc::State arg3, ns3::LteUeRrc::State arg4) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('ns3::LteUeRrc::State', 'arg3'), param('ns3::LteUeRrc::State', 'arg4')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3UeManagerState_Ns3UeManagerState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::UeManager::State, ns3::UeManager::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1, short unsigned int arg2, ns3::UeManager::State arg3, ns3::UeManager::State arg4) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('ns3::UeManager::State', 'arg3'), param('ns3::UeManager::State', 'arg4')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1, short unsigned int arg2) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('short unsigned int', 'arg2')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1, short unsigned int arg2, short unsigned int arg3) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('short unsigned int', 'arg3')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Ns3Ptr__lt__ns3SpectrumValue__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, ns3::Ptr< ns3::SpectrumValue >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, ns3::Ptr<ns3::SpectrumValue> arg1) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('ns3::Ptr< ns3::SpectrumValue >', 'arg1')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, unsigned char arg1, unsigned int arg2) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('unsigned char', 'arg1'), param('unsigned int', 'arg2')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_long_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, unsigned char arg1, unsigned int arg2, long unsigned int arg3) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('unsigned char', 'arg1'), param('unsigned int', 'arg2'), param('long unsigned int', 'arg3')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Bool_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, double arg2, double arg3, bool arg4, unsigned char arg5) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('double', 'arg2'), param('double', 'arg3'), param('bool', 'arg4'), param('unsigned char', 'arg5')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, double arg2, double arg3, unsigned char arg4) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('double', 'arg2'), param('double', 'arg3'), param('unsigned char', 'arg4')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, double arg2) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('double', 'arg2')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, double arg2, unsigned char arg3) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('double', 'arg2'), param('unsigned char', 'arg3')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3LteUePhyState_Ns3LteUePhyState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, ns3::LteUePhy::State arg2, ns3::LteUePhy::State arg3) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('ns3::LteUePhy::State', 'arg2'), param('ns3::LteUePhy::State', 'arg3')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
-    cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
-    cls.add_method('DoGetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
-    cls.add_method('GetTypeid', 
-                   'std::string', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1) [member operator]
-    cls.add_method('operator()', 
-                   'void', 
-                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1')], 
-                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
-    return
-
-def register_Ns3CqaFfMacScheduler_methods(root_module, cls):
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqaFfMacScheduler::CqaFfMacScheduler(ns3::CqaFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CqaFfMacScheduler const &', 'arg0')])
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqaFfMacScheduler::CqaFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## cqa-ff-mac-scheduler.h (module 'lte'): void ns3::CqaFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::CqaFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::CqaFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::CqaFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::CqaFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): void ns3::CqaFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): void ns3::CqaFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): void ns3::CqaFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## cqa-ff-mac-scheduler.h (module 'lte'): void ns3::CqaFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3DlCqiLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::DlCqiLteControlMessage::DlCqiLteControlMessage(ns3::DlCqiLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DlCqiLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::DlCqiLteControlMessage::DlCqiLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::CqiListElement_s ns3::DlCqiLteControlMessage::GetDlCqi() [member function]
-    cls.add_method('GetDlCqi', 
-                   'ns3::CqiListElement_s', 
-                   [])
-    ## lte-control-messages.h (module 'lte'): void ns3::DlCqiLteControlMessage::SetDlCqi(ns3::CqiListElement_s dlcqi) [member function]
-    cls.add_method('SetDlCqi', 
-                   'void', 
-                   [param('ns3::CqiListElement_s', 'dlcqi')])
-    return
-
-def register_Ns3DlDciLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::DlDciLteControlMessage::DlDciLteControlMessage(ns3::DlDciLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DlDciLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::DlDciLteControlMessage::DlDciLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::DlDciListElement_s ns3::DlDciLteControlMessage::GetDci() [member function]
-    cls.add_method('GetDci', 
-                   'ns3::DlDciListElement_s', 
-                   [])
-    ## lte-control-messages.h (module 'lte'): void ns3::DlDciLteControlMessage::SetDci(ns3::DlDciListElement_s dci) [member function]
-    cls.add_method('SetDci', 
-                   'void', 
-                   [param('ns3::DlDciListElement_s', 'dci')])
-    return
-
-def register_Ns3DlHarqFeedbackLteControlMessage_methods(root_module, cls):
-    ## lte-control-messages.h (module 'lte'): ns3::DlHarqFeedbackLteControlMessage::DlHarqFeedbackLteControlMessage(ns3::DlHarqFeedbackLteControlMessage const & arg0) [constructor]
-    cls.add_constructor([param('ns3::DlHarqFeedbackLteControlMessage const &', 'arg0')])
-    ## lte-control-messages.h (module 'lte'): ns3::DlHarqFeedbackLteControlMessage::DlHarqFeedbackLteControlMessage() [constructor]
-    cls.add_constructor([])
-    ## lte-control-messages.h (module 'lte'): ns3::DlInfoListElement_s ns3::DlHarqFeedbackLteControlMessage::GetDlHarqFeedback() [member function]
-    cls.add_method('GetDlHarqFeedback', 
-                   'ns3::DlInfoListElement_s', 
-                   [])
-    ## lte-control-messages.h (module 'lte'): void ns3::DlHarqFeedbackLteControlMessage::SetDlHarqFeedback(ns3::DlInfoListElement_s m) [member function]
-    cls.add_method('SetDlHarqFeedback', 
-                   'void', 
-                   [param('ns3::DlInfoListElement_s', 'm')])
-    return
-
-def register_Ns3EmuEpcHelper_methods(root_module, cls):
-    ## emu-epc-helper.h (module 'lte'): ns3::EmuEpcHelper::EmuEpcHelper(ns3::EmuEpcHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EmuEpcHelper const &', 'arg0')])
-    ## emu-epc-helper.h (module 'lte'): ns3::EmuEpcHelper::EmuEpcHelper() [constructor]
-    cls.add_constructor([])
-    ## emu-epc-helper.h (module 'lte'): uint8_t ns3::EmuEpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
-    cls.add_method('ActivateEpsBearer', 
-                   'uint8_t', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): void ns3::EmuEpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
-    cls.add_method('AddEnb', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'enbNode'), param('ns3::Ptr< ns3::NetDevice >', 'lteEnbNetDevice'), param('uint16_t', 'cellId')], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): void ns3::EmuEpcHelper::AddUe(ns3::Ptr<ns3::NetDevice> ueLteDevice, uint64_t imsi) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi')], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): void ns3::EmuEpcHelper::AddX2Interface(ns3::Ptr<ns3::Node> enbNode1, ns3::Ptr<ns3::Node> enbNode2) [member function]
-    cls.add_method('AddX2Interface', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'enbNode1'), param('ns3::Ptr< ns3::Node >', 'enbNode2')], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): ns3::Ipv4InterfaceContainer ns3::EmuEpcHelper::AssignUeIpv4Address(ns3::NetDeviceContainer ueDevices) [member function]
-    cls.add_method('AssignUeIpv4Address', 
-                   'ns3::Ipv4InterfaceContainer', 
-                   [param('ns3::NetDeviceContainer', 'ueDevices')], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): void ns3::EmuEpcHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): void ns3::EmuEpcHelper::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::EmuEpcHelper::GetPgwNode() [member function]
-    cls.add_method('GetPgwNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_virtual=True)
-    ## emu-epc-helper.h (module 'lte'): static ns3::TypeId ns3::EmuEpcHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## emu-epc-helper.h (module 'lte'): ns3::Ipv4Address ns3::EmuEpcHelper::GetUeDefaultGatewayAddress() [member function]
-    cls.add_method('GetUeDefaultGatewayAddress', 
-                   'ns3::Ipv4Address', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3FdBetFfMacScheduler_methods(root_module, cls):
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::FdBetFfMacScheduler::FdBetFfMacScheduler(ns3::FdBetFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FdBetFfMacScheduler const &', 'arg0')])
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::FdBetFfMacScheduler::FdBetFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): void ns3::FdBetFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::FdBetFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::FdBetFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::FdBetFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::FdBetFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): void ns3::FdBetFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): void ns3::FdBetFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): void ns3::FdBetFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## fdbet-ff-mac-scheduler.h (module 'lte'): void ns3::FdBetFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3FdMtFfMacScheduler_methods(root_module, cls):
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): ns3::FdMtFfMacScheduler::FdMtFfMacScheduler(ns3::FdMtFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FdMtFfMacScheduler const &', 'arg0')])
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): ns3::FdMtFfMacScheduler::FdMtFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): void ns3::FdMtFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::FdMtFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::FdMtFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::FdMtFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::FdMtFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): void ns3::FdMtFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): void ns3::FdMtFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): void ns3::FdMtFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## fdmt-ff-mac-scheduler.h (module 'lte'): void ns3::FdMtFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3FdTbfqFfMacScheduler_methods(root_module, cls):
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::FdTbfqFfMacScheduler::FdTbfqFfMacScheduler(ns3::FdTbfqFfMacScheduler const & arg0) [constructor]
-    cls.add_constructor([param('ns3::FdTbfqFfMacScheduler const &', 'arg0')])
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::FdTbfqFfMacScheduler::FdTbfqFfMacScheduler() [constructor]
-    cls.add_constructor([])
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::FdTbfqFfMacScheduler::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::FfMacCschedSapProvider * ns3::FdTbfqFfMacScheduler::GetFfMacCschedSapProvider() [member function]
-    cls.add_method('GetFfMacCschedSapProvider', 
-                   'ns3::FfMacCschedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::FfMacSchedSapProvider * ns3::FdTbfqFfMacScheduler::GetFfMacSchedSapProvider() [member function]
-    cls.add_method('GetFfMacSchedSapProvider', 
-                   'ns3::FfMacSchedSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): ns3::LteFfrSapUser * ns3::FdTbfqFfMacScheduler::GetLteFfrSapUser() [member function]
-    cls.add_method('GetLteFfrSapUser', 
-                   'ns3::LteFfrSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): static ns3::TypeId ns3::FdTbfqFfMacScheduler::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::FdTbfqFfMacScheduler::SetFfMacCschedSapUser(ns3::FfMacCschedSapUser * s) [member function]
-    cls.add_method('SetFfMacCschedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacCschedSapUser *', 's')], 
-                   is_virtual=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::FdTbfqFfMacScheduler::SetFfMacSchedSapUser(ns3::FfMacSchedSapUser * s) [member function]
-    cls.add_method('SetFfMacSchedSapUser', 
-                   'void', 
-                   [param('ns3::FfMacSchedSapUser *', 's')], 
-                   is_virtual=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::FdTbfqFfMacScheduler::SetLteFfrSapProvider(ns3::LteFfrSapProvider * s) [member function]
-    cls.add_method('SetLteFfrSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrSapProvider *', 's')], 
-                   is_virtual=True)
-    ## fdtbfq-ff-mac-scheduler.h (module 'lte'): void ns3::FdTbfqFfMacScheduler::TransmissionModeConfigurationUpdate(uint16_t rnti, uint8_t txMode) [member function]
-    cls.add_method('TransmissionModeConfigurationUpdate', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
-    return
-
-def register_Ns3HandoverPreparationInfoHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::HandoverPreparationInfoHeader::HandoverPreparationInfoHeader(ns3::HandoverPreparationInfoHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::HandoverPreparationInfoHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::HandoverPreparationInfoHeader::HandoverPreparationInfoHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::HandoverPreparationInfoHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::AsConfig ns3::HandoverPreparationInfoHeader::GetAsConfig() const [member function]
-    cls.add_method('GetAsConfig', 
-                   'ns3::LteRrcSap::AsConfig', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::HandoverPreparationInfo ns3::HandoverPreparationInfoHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::HandoverPreparationInfo', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::HandoverPreparationInfoHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::HandoverPreparationInfoHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::HandoverPreparationInfoHeader::SetMessage(ns3::LteRrcSap::HandoverPreparationInfo msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::HandoverPreparationInfo', 'msg')])
-    return
-
-def register_Ns3LteDataRadioBearerInfo_methods(root_module, cls):
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::LteDataRadioBearerInfo() [constructor]
-    cls.add_constructor([])
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::LteDataRadioBearerInfo(ns3::LteDataRadioBearerInfo const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteDataRadioBearerInfo const &', 'arg0')])
-    ## lte-radio-bearer-info.h (module 'lte'): static ns3::TypeId ns3::LteDataRadioBearerInfo::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_drbIdentity [variable]
-    cls.add_instance_attribute('m_drbIdentity', 'uint8_t', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_epsBearer [variable]
-    cls.add_instance_attribute('m_epsBearer', 'ns3::EpsBearer', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_epsBearerIdentity [variable]
-    cls.add_instance_attribute('m_epsBearerIdentity', 'uint8_t', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_gtpTeid [variable]
-    cls.add_instance_attribute('m_gtpTeid', 'uint32_t', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_logicalChannelConfig [variable]
-    cls.add_instance_attribute('m_logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_logicalChannelIdentity [variable]
-    cls.add_instance_attribute('m_logicalChannelIdentity', 'uint8_t', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_rlcConfig [variable]
-    cls.add_instance_attribute('m_rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
-    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_transportLayerAddress [variable]
-    cls.add_instance_attribute('m_transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    return
-
-def register_Ns3LteEnbPhy_methods(root_module, cls):
-    ## lte-enb-phy.h (module 'lte'): ns3::LteEnbPhy::LteEnbPhy(ns3::LteEnbPhy const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbPhy const &', 'arg0')])
-    ## lte-enb-phy.h (module 'lte'): ns3::LteEnbPhy::LteEnbPhy() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-phy.h (module 'lte'): ns3::LteEnbPhy::LteEnbPhy(ns3::Ptr<ns3::LteSpectrumPhy> dlPhy, ns3::Ptr<ns3::LteSpectrumPhy> ulPhy) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::LteSpectrumPhy >', 'dlPhy'), param('ns3::Ptr< ns3::LteSpectrumPhy >', 'ulPhy')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::CalcChannelQualityForUe(std::vector<double, std::allocator<double> > sinr, ns3::Ptr<ns3::LteSpectrumPhy> ue) [member function]
-    cls.add_method('CalcChannelQualityForUe', 
-                   'void', 
-                   [param('std::vector< double >', 'sinr'), param('ns3::Ptr< ns3::LteSpectrumPhy >', 'ue')])
-    ## lte-enb-phy.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters ns3::LteEnbPhy::CreatePuschCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('CreatePuschCqiReport', 
-                   'ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters', 
-                   [param('ns3::SpectrumValue const &', 'sinr')])
-    ## lte-enb-phy.h (module 'lte'): ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters ns3::LteEnbPhy::CreateSrsCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('CreateSrsCqiReport', 
-                   'ns3::FfMacSchedSapProvider::SchedUlCqiInfoReqParameters', 
-                   [param('ns3::SpectrumValue const &', 'sinr')])
-    ## lte-enb-phy.h (module 'lte'): ns3::Ptr<ns3::SpectrumValue> ns3::LteEnbPhy::CreateTxPowerSpectralDensity() [member function]
-    cls.add_method('CreateTxPowerSpectralDensity', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): ns3::Ptr<ns3::SpectrumValue> ns3::LteEnbPhy::CreateTxPowerSpectralDensityWithPowerAllocation() [member function]
-    cls.add_method('CreateTxPowerSpectralDensityWithPowerAllocation', 
-                   'ns3::Ptr< ns3::SpectrumValue >', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): std::list<ns3::UlDciLteControlMessage, std::allocator<ns3::UlDciLteControlMessage> > ns3::LteEnbPhy::DequeueUlDci() [member function]
-    cls.add_method('DequeueUlDci', 
-                   'std::list< ns3::UlDciLteControlMessage >', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): int8_t ns3::LteEnbPhy::DoGetReferenceSignalPower() const [member function]
-    cls.add_method('DoGetReferenceSignalPower', 
-                   'int8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::EndFrame() [member function]
-    cls.add_method('EndFrame', 
-                   'void', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::EndSubFrame() [member function]
-    cls.add_method('EndSubFrame', 
-                   'void', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::GenerateCtrlCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GenerateCtrlCqiReport', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::GenerateDataCqiReport(ns3::SpectrumValue const & sinr) [member function]
-    cls.add_method('GenerateDataCqiReport', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'sinr')], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::GeneratePowerAllocationMap(uint16_t rnti, int rbId) [member function]
-    cls.add_method('GeneratePowerAllocationMap', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('int', 'rbId')])
-    ## lte-enb-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LteEnbPhy::GetDlSpectrumPhy() const [member function]
-    cls.add_method('GetDlSpectrumPhy', 
-                   'ns3::Ptr< ns3::LteSpectrumPhy >', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-phy.h (module 'lte'): std::vector<int, std::allocator<int> > ns3::LteEnbPhy::GetDownlinkSubChannels() [member function]
-    cls.add_method('GetDownlinkSubChannels', 
-                   'std::vector< int >', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): ns3::LteEnbCphySapProvider * ns3::LteEnbPhy::GetLteEnbCphySapProvider() [member function]
-    cls.add_method('GetLteEnbCphySapProvider', 
-                   'ns3::LteEnbCphySapProvider *', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): ns3::LteEnbPhySapProvider * ns3::LteEnbPhy::GetLteEnbPhySapProvider() [member function]
-    cls.add_method('GetLteEnbPhySapProvider', 
-                   'ns3::LteEnbPhySapProvider *', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): uint8_t ns3::LteEnbPhy::GetMacChDelay() const [member function]
-    cls.add_method('GetMacChDelay', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-phy.h (module 'lte'): double ns3::LteEnbPhy::GetNoiseFigure() const [member function]
-    cls.add_method('GetNoiseFigure', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-phy.h (module 'lte'): double ns3::LteEnbPhy::GetTxPower() const [member function]
-    cls.add_method('GetTxPower', 
-                   'double', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-phy.h (module 'lte'): static ns3::TypeId ns3::LteEnbPhy::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-enb-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LteEnbPhy::GetUlSpectrumPhy() const [member function]
-    cls.add_method('GetUlSpectrumPhy', 
-                   'ns3::Ptr< ns3::LteSpectrumPhy >', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::PhyPduReceived(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('PhyPduReceived', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::QueueUlDci(ns3::UlDciLteControlMessage m) [member function]
-    cls.add_method('QueueUlDci', 
-                   'void', 
-                   [param('ns3::UlDciLteControlMessage', 'm')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::ReceiveLteControlMessage(ns3::Ptr<ns3::LteControlMessage> msg) [member function]
-    cls.add_method('ReceiveLteControlMessage', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteControlMessage >', 'msg')], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::ReceiveLteControlMessageList(std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > arg0) [member function]
-    cls.add_method('ReceiveLteControlMessageList', 
-                   'void', 
-                   [param('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'arg0')], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::ReceiveLteUlHarqFeedback(ns3::UlInfoListElement_s mes) [member function]
-    cls.add_method('ReceiveLteUlHarqFeedback', 
-                   'void', 
-                   [param('ns3::UlInfoListElement_s', 'mes')], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::ReportInterference(ns3::SpectrumValue const & interf) [member function]
-    cls.add_method('ReportInterference', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'interf')], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::ReportRsReceivedPower(ns3::SpectrumValue const & power) [member function]
-    cls.add_method('ReportRsReceivedPower', 
-                   'void', 
-                   [param('ns3::SpectrumValue const &', 'power')], 
-                   is_virtual=True)
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SendControlChannels(std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > ctrlMsgList) [member function]
-    cls.add_method('SendControlChannels', 
-                   'void', 
-                   [param('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'ctrlMsgList')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SendDataChannels(ns3::Ptr<ns3::PacketBurst> pb) [member function]
-    cls.add_method('SendDataChannels', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::PacketBurst >', 'pb')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetDownlinkSubChannels(std::vector<int, std::allocator<int> > mask) [member function]
-    cls.add_method('SetDownlinkSubChannels', 
-                   'void', 
-                   [param('std::vector< int >', 'mask')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetDownlinkSubChannelsWithPowerAllocation(std::vector<int, std::allocator<int> > mask) [member function]
-    cls.add_method('SetDownlinkSubChannelsWithPowerAllocation', 
-                   'void', 
-                   [param('std::vector< int >', 'mask')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetHarqPhyModule(ns3::Ptr<ns3::LteHarqPhy> harq) [member function]
-    cls.add_method('SetHarqPhyModule', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteHarqPhy >', 'harq')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetLteEnbCphySapUser(ns3::LteEnbCphySapUser * s) [member function]
-    cls.add_method('SetLteEnbCphySapUser', 
-                   'void', 
-                   [param('ns3::LteEnbCphySapUser *', 's')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetLteEnbPhySapUser(ns3::LteEnbPhySapUser * s) [member function]
-    cls.add_method('SetLteEnbPhySapUser', 
-                   'void', 
-                   [param('ns3::LteEnbPhySapUser *', 's')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetMacChDelay(uint8_t delay) [member function]
-    cls.add_method('SetMacChDelay', 
-                   'void', 
-                   [param('uint8_t', 'delay')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetNoiseFigure(double pow) [member function]
-    cls.add_method('SetNoiseFigure', 
-                   'void', 
-                   [param('double', 'pow')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::SetTxPower(double pow) [member function]
-    cls.add_method('SetTxPower', 
-                   'void', 
-                   [param('double', 'pow')])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::StartFrame() [member function]
-    cls.add_method('StartFrame', 
-                   'void', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::StartSubFrame() [member function]
-    cls.add_method('StartSubFrame', 
-                   'void', 
-                   [])
-    ## lte-enb-phy.h (module 'lte'): void ns3::LteEnbPhy::DoSendMacPdu(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('DoSendMacPdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
-                   visibility='private', is_virtual=True)
-    return
-
-def register_Ns3LteNetDevice_methods(root_module, cls):
-    ## lte-net-device.h (module 'lte'): static ns3::TypeId ns3::LteNetDevice::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-net-device.h (module 'lte'): ns3::LteNetDevice::LteNetDevice() [constructor]
-    cls.add_constructor([])
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::SetIfIndex(uint32_t const index) [member function]
-    cls.add_method('SetIfIndex', 
-                   'void', 
-                   [param('uint32_t const', 'index')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): uint32_t ns3::LteNetDevice::GetIfIndex() const [member function]
-    cls.add_method('GetIfIndex', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): ns3::Ptr<ns3::Channel> ns3::LteNetDevice::GetChannel() const [member function]
-    cls.add_method('GetChannel', 
-                   'ns3::Ptr< ns3::Channel >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::SetMtu(uint16_t const mtu) [member function]
-    cls.add_method('SetMtu', 
-                   'bool', 
-                   [param('uint16_t const', 'mtu')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): uint16_t ns3::LteNetDevice::GetMtu() const [member function]
-    cls.add_method('GetMtu', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::SetAddress(ns3::Address address) [member function]
-    cls.add_method('SetAddress', 
-                   'void', 
-                   [param('ns3::Address', 'address')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): ns3::Address ns3::LteNetDevice::GetAddress() const [member function]
-    cls.add_method('GetAddress', 
-                   'ns3::Address', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::IsLinkUp() const [member function]
-    cls.add_method('IsLinkUp', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::AddLinkChangeCallback(ns3::Callback<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> callback) [member function]
-    cls.add_method('AddLinkChangeCallback', 
-                   'void', 
-                   [param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::IsBroadcast() const [member function]
-    cls.add_method('IsBroadcast', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): ns3::Address ns3::LteNetDevice::GetBroadcast() const [member function]
-    cls.add_method('GetBroadcast', 
-                   'ns3::Address', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::IsMulticast() const [member function]
-    cls.add_method('IsMulticast', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::IsPointToPoint() const [member function]
-    cls.add_method('IsPointToPoint', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::IsBridge() const [member function]
-    cls.add_method('IsBridge', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::LteNetDevice::GetNode() const [member function]
-    cls.add_method('GetNode', 
-                   'ns3::Ptr< ns3::Node >', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::SetNode(ns3::Ptr<ns3::Node> node) [member function]
-    cls.add_method('SetNode', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Node >', 'node')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::NeedsArp() const [member function]
-    cls.add_method('NeedsArp', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::SetReceiveCallback(ns3::NetDevice::ReceiveCallback cb) [member function]
-    cls.add_method('SetReceiveCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): ns3::Address ns3::LteNetDevice::GetMulticast(ns3::Ipv4Address addr) const [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Address', 
-                   [param('ns3::Ipv4Address', 'addr')], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): ns3::Address ns3::LteNetDevice::GetMulticast(ns3::Ipv6Address addr) const [member function]
-    cls.add_method('GetMulticast', 
-                   'ns3::Address', 
-                   [param('ns3::Ipv6Address', 'addr')], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::SetPromiscReceiveCallback(ns3::NetDevice::PromiscReceiveCallback cb) [member function]
-    cls.add_method('SetPromiscReceiveCallback', 
-                   'void', 
-                   [param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::SendFrom(ns3::Ptr<ns3::Packet> packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('SendFrom', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')], 
-                   is_virtual=True)
-    ## lte-net-device.h (module 'lte'): bool ns3::LteNetDevice::SupportsSendFrom() const [member function]
-    cls.add_method('SupportsSendFrom', 
-                   'bool', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-net-device.h (module 'lte'): void ns3::LteNetDevice::Receive(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('Receive', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    return
-
-def register_Ns3LteUeNetDevice_methods(root_module, cls):
-    ## lte-ue-net-device.h (module 'lte'): static ns3::TypeId ns3::LteUeNetDevice::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ue-net-device.h (module 'lte'): ns3::LteUeNetDevice::LteUeNetDevice() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-ue-net-device.h (module 'lte'): bool ns3::LteUeNetDevice::Send(ns3::Ptr<ns3::Packet> packet, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('Send', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')], 
-                   is_virtual=True)
-    ## lte-ue-net-device.h (module 'lte'): ns3::Ptr<ns3::LteUeMac> ns3::LteUeNetDevice::GetMac() const [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteUeMac >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): ns3::Ptr<ns3::LteUeRrc> ns3::LteUeNetDevice::GetRrc() const [member function]
-    cls.add_method('GetRrc', 
-                   'ns3::Ptr< ns3::LteUeRrc >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): ns3::Ptr<ns3::LteUePhy> ns3::LteUeNetDevice::GetPhy() const [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteUePhy >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): ns3::Ptr<ns3::EpcUeNas> ns3::LteUeNetDevice::GetNas() const [member function]
-    cls.add_method('GetNas', 
-                   'ns3::Ptr< ns3::EpcUeNas >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): ns3::Ptr<ns3::LteUeComponentCarrierManager> ns3::LteUeNetDevice::GetComponentCarrierManager() const [member function]
-    cls.add_method('GetComponentCarrierManager', 
-                   'ns3::Ptr< ns3::LteUeComponentCarrierManager >', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): uint64_t ns3::LteUeNetDevice::GetImsi() const [member function]
-    cls.add_method('GetImsi', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): uint32_t ns3::LteUeNetDevice::GetDlEarfcn() const [member function]
-    cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::SetDlEarfcn(uint32_t earfcn) [member function]
-    cls.add_method('SetDlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## lte-ue-net-device.h (module 'lte'): uint32_t ns3::LteUeNetDevice::GetCsgId() const [member function]
-    cls.add_method('GetCsgId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::SetCsgId(uint32_t csgId) [member function]
-    cls.add_method('SetCsgId', 
-                   'void', 
-                   [param('uint32_t', 'csgId')])
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::SetTargetEnb(ns3::Ptr<ns3::LteEnbNetDevice> enb) [member function]
-    cls.add_method('SetTargetEnb', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteEnbNetDevice >', 'enb')])
-    ## lte-ue-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbNetDevice> ns3::LteUeNetDevice::GetTargetEnb() [member function]
-    cls.add_method('GetTargetEnb', 
-                   'ns3::Ptr< ns3::LteEnbNetDevice >', 
-                   [])
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::SetCcMap(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierUe>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierUe> > > > ccm) [member function]
-    cls.add_method('SetCcMap', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierUe > >', 'ccm')])
-    ## lte-ue-net-device.h (module 'lte'): std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierUe>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierUe> > > > ns3::LteUeNetDevice::GetCcMap() [member function]
-    cls.add_method('GetCcMap', 
-                   'std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierUe > >', 
-                   [])
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3MeasurementReportHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::MeasurementReportHeader::MeasurementReportHeader(ns3::MeasurementReportHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MeasurementReportHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::MeasurementReportHeader::MeasurementReportHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::MeasurementReportHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::MeasurementReport ns3::MeasurementReportHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::MeasurementReport', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::MeasurementReportHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::MeasurementReportHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::MeasurementReportHeader::SetMessage(ns3::LteRrcSap::MeasurementReport msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::MeasurementReport', 'msg')])
-    return
-
-def register_Ns3RrcConnectionReconfigurationCompleteHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationCompleteHeader::RrcConnectionReconfigurationCompleteHeader(ns3::RrcConnectionReconfigurationCompleteHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionReconfigurationCompleteHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationCompleteHeader::RrcConnectionReconfigurationCompleteHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionReconfigurationCompleteHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfigurationCompleted ns3::RrcConnectionReconfigurationCompleteHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionReconfigurationCompleted', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionReconfigurationCompleteHeader::GetRrcTransactionIdentifier() const [member function]
-    cls.add_method('GetRrcTransactionIdentifier', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReconfigurationCompleteHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReconfigurationCompleteHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReconfigurationCompleteHeader::SetMessage(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReconfigurationCompleted', 'msg')])
-    return
-
-def register_Ns3RrcConnectionReconfigurationHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationHeader::RrcConnectionReconfigurationHeader(ns3::RrcConnectionReconfigurationHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionReconfigurationHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationHeader::RrcConnectionReconfigurationHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionReconfigurationHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): std::list<ns3::LteRrcSap::DrbToAddMod, std::allocator<ns3::LteRrcSap::DrbToAddMod> > ns3::RrcConnectionReconfigurationHeader::GetDrbToAddModList() const [member function]
-    cls.add_method('GetDrbToAddModList', 
-                   'std::list< ns3::LteRrcSap::DrbToAddMod >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): std::list<unsigned char, std::allocator<unsigned char> > ns3::RrcConnectionReconfigurationHeader::GetDrbToReleaseList() const [member function]
-    cls.add_method('GetDrbToReleaseList', 
-                   'std::list< unsigned char >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionReconfigurationHeader::GetHaveMeasConfig() [member function]
-    cls.add_method('GetHaveMeasConfig', 
-                   'bool', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionReconfigurationHeader::GetHaveMobilityControlInfo() [member function]
-    cls.add_method('GetHaveMobilityControlInfo', 
-                   'bool', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionReconfigurationHeader::GetHaveNonCriticalExtensionConfig() [member function]
-    cls.add_method('GetHaveNonCriticalExtensionConfig', 
-                   'bool', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionReconfigurationHeader::GetHaveRadioResourceConfigDedicated() [member function]
-    cls.add_method('GetHaveRadioResourceConfigDedicated', 
-                   'bool', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::MeasConfig ns3::RrcConnectionReconfigurationHeader::GetMeasConfig() [member function]
-    cls.add_method('GetMeasConfig', 
-                   'ns3::LteRrcSap::MeasConfig', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration ns3::RrcConnectionReconfigurationHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionReconfiguration', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::MobilityControlInfo ns3::RrcConnectionReconfigurationHeader::GetMobilityControlInfo() [member function]
-    cls.add_method('GetMobilityControlInfo', 
-                   'ns3::LteRrcSap::MobilityControlInfo', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration ns3::RrcConnectionReconfigurationHeader::GetNonCriticalExtensionConfig() [member function]
-    cls.add_method('GetNonCriticalExtensionConfig', 
-                   'ns3::LteRrcSap::NonCriticalExtensionConfiguration', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated ns3::RrcConnectionReconfigurationHeader::GetPhysicalConfigDedicated() const [member function]
-    cls.add_method('GetPhysicalConfigDedicated', 
-                   'ns3::LteRrcSap::PhysicalConfigDedicated', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated ns3::RrcConnectionReconfigurationHeader::GetRadioResourceConfigDedicated() [member function]
-    cls.add_method('GetRadioResourceConfigDedicated', 
-                   'ns3::LteRrcSap::RadioResourceConfigDedicated', 
-                   [])
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated ns3::RrcConnectionReconfigurationHeader::GetRadioResourceConfigDedicated() const [member function]
-    cls.add_method('GetRadioResourceConfigDedicated', 
-                   'ns3::LteRrcSap::RadioResourceConfigDedicated', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionReconfigurationHeader::GetRrcTransactionIdentifier() const [member function]
-    cls.add_method('GetRrcTransactionIdentifier', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): std::list<ns3::LteRrcSap::SrbToAddMod, std::allocator<ns3::LteRrcSap::SrbToAddMod> > ns3::RrcConnectionReconfigurationHeader::GetSrbToAddModList() const [member function]
-    cls.add_method('GetSrbToAddModList', 
-                   'std::list< ns3::LteRrcSap::SrbToAddMod >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionReconfigurationHeader::HavePhysicalConfigDedicated() const [member function]
-    cls.add_method('HavePhysicalConfigDedicated', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReconfigurationHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReconfigurationHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReconfigurationHeader::SetMessage(ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReconfiguration', 'msg')])
-    return
-
-def register_Ns3RrcConnectionReestablishmentCompleteHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentCompleteHeader::RrcConnectionReestablishmentCompleteHeader(ns3::RrcConnectionReestablishmentCompleteHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionReestablishmentCompleteHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentCompleteHeader::RrcConnectionReestablishmentCompleteHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionReestablishmentCompleteHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentComplete ns3::RrcConnectionReestablishmentCompleteHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionReestablishmentComplete', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionReestablishmentCompleteHeader::GetRrcTransactionIdentifier() const [member function]
-    cls.add_method('GetRrcTransactionIdentifier', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentCompleteHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentCompleteHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentCompleteHeader::SetMessage(ns3::LteRrcSap::RrcConnectionReestablishmentComplete msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentComplete', 'msg')])
-    return
-
-def register_Ns3RrcConnectionReestablishmentHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentHeader::RrcConnectionReestablishmentHeader(ns3::RrcConnectionReestablishmentHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionReestablishmentHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentHeader::RrcConnectionReestablishmentHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionReestablishmentHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishment ns3::RrcConnectionReestablishmentHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionReestablishment', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated ns3::RrcConnectionReestablishmentHeader::GetRadioResourceConfigDedicated() const [member function]
-    cls.add_method('GetRadioResourceConfigDedicated', 
-                   'ns3::LteRrcSap::RadioResourceConfigDedicated', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionReestablishmentHeader::GetRrcTransactionIdentifier() const [member function]
-    cls.add_method('GetRrcTransactionIdentifier', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentHeader::SetMessage(ns3::LteRrcSap::RrcConnectionReestablishment msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishment', 'msg')])
-    return
-
-def register_Ns3RrcConnectionReestablishmentRejectHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentRejectHeader::RrcConnectionReestablishmentRejectHeader(ns3::RrcConnectionReestablishmentRejectHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionReestablishmentRejectHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentRejectHeader::RrcConnectionReestablishmentRejectHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionReestablishmentRejectHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentReject ns3::RrcConnectionReestablishmentRejectHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionReestablishmentReject', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentRejectHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentRejectHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentRejectHeader::SetMessage(ns3::LteRrcSap::RrcConnectionReestablishmentReject msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentReject', 'msg')])
-    return
-
-def register_Ns3RrcConnectionReestablishmentRequestHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentRequestHeader::RrcConnectionReestablishmentRequestHeader(ns3::RrcConnectionReestablishmentRequestHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionReestablishmentRequestHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReestablishmentRequestHeader::RrcConnectionReestablishmentRequestHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionReestablishmentRequestHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReestablishmentRequest ns3::RrcConnectionReestablishmentRequestHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionReestablishmentRequest', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::ReestablishmentCause ns3::RrcConnectionReestablishmentRequestHeader::GetReestablishmentCause() const [member function]
-    cls.add_method('GetReestablishmentCause', 
-                   'ns3::LteRrcSap::ReestablishmentCause', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity ns3::RrcConnectionReestablishmentRequestHeader::GetUeIdentity() const [member function]
-    cls.add_method('GetUeIdentity', 
-                   'ns3::LteRrcSap::ReestabUeIdentity', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentRequestHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentRequestHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReestablishmentRequestHeader::SetMessage(ns3::LteRrcSap::RrcConnectionReestablishmentRequest msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReestablishmentRequest', 'msg')])
-    return
-
-def register_Ns3RrcConnectionRejectHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionRejectHeader::RrcConnectionRejectHeader(ns3::RrcConnectionRejectHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionRejectHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionRejectHeader::RrcConnectionRejectHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionRejectHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReject ns3::RrcConnectionRejectHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionReject', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionRejectHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionRejectHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionRejectHeader::SetMessage(ns3::LteRrcSap::RrcConnectionReject msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionReject', 'msg')])
-    return
-
-def register_Ns3RrcConnectionReleaseHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReleaseHeader::RrcConnectionReleaseHeader(ns3::RrcConnectionReleaseHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionReleaseHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReleaseHeader::RrcConnectionReleaseHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionReleaseHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRelease ns3::RrcConnectionReleaseHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionRelease', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReleaseHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReleaseHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionReleaseHeader::SetMessage(ns3::LteRrcSap::RrcConnectionRelease msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionRelease', 'msg')])
-    return
-
-def register_Ns3RrcConnectionRequestHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionRequestHeader::RrcConnectionRequestHeader(ns3::RrcConnectionRequestHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionRequestHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionRequestHeader::RrcConnectionRequestHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionRequestHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest ns3::RrcConnectionRequestHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionRequest', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): std::bitset<8> ns3::RrcConnectionRequestHeader::GetMmec() const [member function]
-    cls.add_method('GetMmec', 
-                   'std::bitset< 8 >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): std::bitset<32> ns3::RrcConnectionRequestHeader::GetMtmsi() const [member function]
-    cls.add_method('GetMtmsi', 
-                   'std::bitset< 32 >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcConnectionRequestHeader::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionRequestHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionRequestHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionRequestHeader::SetMessage(ns3::LteRrcSap::RrcConnectionRequest msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionRequest', 'msg')])
-    return
-
-def register_Ns3RrcConnectionSetupCompleteHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupCompleteHeader::RrcConnectionSetupCompleteHeader(ns3::RrcConnectionSetupCompleteHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionSetupCompleteHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupCompleteHeader::RrcConnectionSetupCompleteHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionSetupCompleteHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetupCompleted ns3::RrcConnectionSetupCompleteHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionSetupCompleted', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionSetupCompleteHeader::GetRrcTransactionIdentifier() const [member function]
-    cls.add_method('GetRrcTransactionIdentifier', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSetupCompleteHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSetupCompleteHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSetupCompleteHeader::SetMessage(ns3::LteRrcSap::RrcConnectionSetupCompleted msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')])
-    return
-
-def register_Ns3RrcConnectionSetupHeader_methods(root_module, cls):
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupHeader::RrcConnectionSetupHeader(ns3::RrcConnectionSetupHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrcConnectionSetupHeader const &', 'arg0')])
-    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupHeader::RrcConnectionSetupHeader() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionSetupHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('Deserialize', 
-                   'uint32_t', 
-                   [param('ns3::Buffer::Iterator', 'bIterator')], 
-                   is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): std::list<ns3::LteRrcSap::DrbToAddMod, std::allocator<ns3::LteRrcSap::DrbToAddMod> > ns3::RrcConnectionSetupHeader::GetDrbToAddModList() const [member function]
-    cls.add_method('GetDrbToAddModList', 
-                   'std::list< ns3::LteRrcSap::DrbToAddMod >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): std::list<unsigned char, std::allocator<unsigned char> > ns3::RrcConnectionSetupHeader::GetDrbToReleaseList() const [member function]
-    cls.add_method('GetDrbToReleaseList', 
-                   'std::list< unsigned char >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetup ns3::RrcConnectionSetupHeader::GetMessage() const [member function]
-    cls.add_method('GetMessage', 
-                   'ns3::LteRrcSap::RrcConnectionSetup', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated ns3::RrcConnectionSetupHeader::GetPhysicalConfigDedicated() const [member function]
-    cls.add_method('GetPhysicalConfigDedicated', 
-                   'ns3::LteRrcSap::PhysicalConfigDedicated', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated ns3::RrcConnectionSetupHeader::GetRadioResourceConfigDedicated() const [member function]
-    cls.add_method('GetRadioResourceConfigDedicated', 
-                   'ns3::LteRrcSap::RadioResourceConfigDedicated', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionSetupHeader::GetRrcTransactionIdentifier() const [member function]
-    cls.add_method('GetRrcTransactionIdentifier', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): std::list<ns3::LteRrcSap::SrbToAddMod, std::allocator<ns3::LteRrcSap::SrbToAddMod> > ns3::RrcConnectionSetupHeader::GetSrbToAddModList() const [member function]
-    cls.add_method('GetSrbToAddModList', 
-                   'std::list< ns3::LteRrcSap::SrbToAddMod >', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionSetupHeader::HavePhysicalConfigDedicated() const [member function]
-    cls.add_method('HavePhysicalConfigDedicated', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSetupHeader::PreSerialize() const [member function]
-    cls.add_method('PreSerialize', 
-                   'void', 
-                   [], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSetupHeader::Print(std::ostream & os) const [member function]
-    cls.add_method('Print', 
-                   'void', 
-                   [param('std::ostream &', 'os')], 
-                   is_const=True, is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSetupHeader::SetMessage(ns3::LteRrcSap::RrcConnectionSetup msg) [member function]
-    cls.add_method('SetMessage', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')])
-    return
-
-def register_Ns3LteEnbNetDevice_methods(root_module, cls):
-    ## lte-enb-net-device.h (module 'lte'): static ns3::TypeId ns3::LteEnbNetDevice::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::LteEnbNetDevice::LteEnbNetDevice() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-net-device.h (module 'lte'): bool ns3::LteEnbNetDevice::Send(ns3::Ptr<ns3::Packet> packet, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('Send', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')], 
-                   is_virtual=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbMac> ns3::LteEnbNetDevice::GetMac() const [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteEnbMac >', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbMac> ns3::LteEnbNetDevice::GetMac(uint8_t index) [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteEnbMac >', 
-                   [param('uint8_t', 'index')])
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbPhy> ns3::LteEnbNetDevice::GetPhy() const [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteEnbPhy >', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbPhy> ns3::LteEnbNetDevice::GetPhy(uint8_t index) [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteEnbPhy >', 
-                   [param('uint8_t', 'index')])
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbRrc> ns3::LteEnbNetDevice::GetRrc() const [member function]
-    cls.add_method('GetRrc', 
-                   'ns3::Ptr< ns3::LteEnbRrc >', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbComponentCarrierManager> ns3::LteEnbNetDevice::GetComponentCarrierManager() const [member function]
-    cls.add_method('GetComponentCarrierManager', 
-                   'ns3::Ptr< ns3::LteEnbComponentCarrierManager >', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): uint16_t ns3::LteEnbNetDevice::GetCellId() const [member function]
-    cls.add_method('GetCellId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): bool ns3::LteEnbNetDevice::HasCellId(uint16_t cellId) const [member function]
-    cls.add_method('HasCellId', 
-                   'bool', 
-                   [param('uint16_t', 'cellId')], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): uint8_t ns3::LteEnbNetDevice::GetUlBandwidth() const [member function]
-    cls.add_method('GetUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetUlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetUlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## lte-enb-net-device.h (module 'lte'): uint8_t ns3::LteEnbNetDevice::GetDlBandwidth() const [member function]
-    cls.add_method('GetDlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetDlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetDlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## lte-enb-net-device.h (module 'lte'): uint32_t ns3::LteEnbNetDevice::GetDlEarfcn() const [member function]
-    cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetDlEarfcn(uint32_t earfcn) [member function]
-    cls.add_method('SetDlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## lte-enb-net-device.h (module 'lte'): uint32_t ns3::LteEnbNetDevice::GetUlEarfcn() const [member function]
-    cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetUlEarfcn(uint32_t earfcn) [member function]
-    cls.add_method('SetUlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## lte-enb-net-device.h (module 'lte'): uint32_t ns3::LteEnbNetDevice::GetCsgId() const [member function]
-    cls.add_method('GetCsgId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetCsgId(uint32_t csgId) [member function]
-    cls.add_method('SetCsgId', 
-                   'void', 
-                   [param('uint32_t', 'csgId')])
-    ## lte-enb-net-device.h (module 'lte'): bool ns3::LteEnbNetDevice::GetCsgIndication() const [member function]
-    cls.add_method('GetCsgIndication', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetCsgIndication(bool csgIndication) [member function]
-    cls.add_method('SetCsgIndication', 
-                   'void', 
-                   [param('bool', 'csgIndication')])
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetCcMap(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ccm) [member function]
-    cls.add_method('SetCcMap', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 'ccm')])
-    ## lte-enb-net-device.h (module 'lte'): std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ns3::LteEnbNetDevice::GetCcMap() [member function]
-    cls.add_method('GetCcMap', 
-                   'std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 
-                   [])
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ConfigMatchContainer_methods(root_module, cls):
-    ## config.h (module 'core'): ns3::Config::MatchContainer::MatchContainer(ns3::Config::MatchContainer const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Config::MatchContainer const &', 'arg0')])
-    ## config.h (module 'core'): ns3::Config::MatchContainer::MatchContainer() [constructor]
-    cls.add_constructor([])
-    ## config.h (module 'core'): ns3::Config::MatchContainer::MatchContainer(std::vector<ns3::Ptr<ns3::Object>, std::allocator<ns3::Ptr<ns3::Object> > > const & objects, std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > > const & contexts, std::string path) [constructor]
-    cls.add_constructor([param('std::vector< ns3::Ptr< ns3::Object > > const &', 'objects'), param('std::vector< std::string > const &', 'contexts'), param('std::string', 'path')])
-    ## config.h (module 'core'): ns3::Config::MatchContainer::Iterator ns3::Config::MatchContainer::Begin() const [member function]
-    cls.add_method('Begin', 
-                   'ns3::Config::MatchContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## config.h (module 'core'): void ns3::Config::MatchContainer::Connect(std::string name, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('Connect', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
-    ## config.h (module 'core'): void ns3::Config::MatchContainer::ConnectWithoutContext(std::string name, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('ConnectWithoutContext', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
-    ## config.h (module 'core'): void ns3::Config::MatchContainer::Disconnect(std::string name, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('Disconnect', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
-    ## config.h (module 'core'): void ns3::Config::MatchContainer::DisconnectWithoutContext(std::string name, ns3::CallbackBase const & cb) [member function]
-    cls.add_method('DisconnectWithoutContext', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
-    ## config.h (module 'core'): ns3::Config::MatchContainer::Iterator ns3::Config::MatchContainer::End() const [member function]
-    cls.add_method('End', 
-                   'ns3::Config::MatchContainer::Iterator', 
-                   [], 
-                   is_const=True)
-    ## config.h (module 'core'): ns3::Ptr<ns3::Object> ns3::Config::MatchContainer::Get(uint32_t i) const [member function]
-    cls.add_method('Get', 
-                   'ns3::Ptr< ns3::Object >', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## config.h (module 'core'): std::string ns3::Config::MatchContainer::GetMatchedPath(uint32_t i) const [member function]
-    cls.add_method('GetMatchedPath', 
-                   'std::string', 
-                   [param('uint32_t', 'i')], 
-                   is_const=True)
-    ## config.h (module 'core'): uint32_t ns3::Config::MatchContainer::GetN() const [member function]
-    cls.add_method('GetN', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## config.h (module 'core'): std::string ns3::Config::MatchContainer::GetPath() const [member function]
-    cls.add_method('GetPath', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## config.h (module 'core'): void ns3::Config::MatchContainer::Set(std::string name, ns3::AttributeValue const & value) [member function]
-    cls.add_method('Set', 
-                   'void', 
-                   [param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
-    return
-
-def register_Ns3HashImplementation_methods(root_module, cls):
-    ## hash-function.h (module 'core'): ns3::Hash::Implementation::Implementation(ns3::Hash::Implementation const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Hash::Implementation const &', 'arg0')])
-    ## hash-function.h (module 'core'): ns3::Hash::Implementation::Implementation() [constructor]
-    cls.add_constructor([])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Implementation::GetHash32(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash32', 
-                   'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Implementation::GetHash64(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash64', 
-                   'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-function.h (module 'core'): void ns3::Hash::Implementation::clear() [member function]
-    cls.add_method('clear', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3HashFunctionFnv1a_methods(root_module, cls):
-    ## hash-fnv.h (module 'core'): ns3::Hash::Function::Fnv1a::Fnv1a(ns3::Hash::Function::Fnv1a const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Hash::Function::Fnv1a const &', 'arg0')])
-    ## hash-fnv.h (module 'core'): ns3::Hash::Function::Fnv1a::Fnv1a() [constructor]
-    cls.add_constructor([])
-    ## hash-fnv.h (module 'core'): uint32_t ns3::Hash::Function::Fnv1a::GetHash32(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash32', 
-                   'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-fnv.h (module 'core'): uint64_t ns3::Hash::Function::Fnv1a::GetHash64(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash64', 
-                   'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-fnv.h (module 'core'): void ns3::Hash::Function::Fnv1a::clear() [member function]
-    cls.add_method('clear', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3HashFunctionHash32_methods(root_module, cls):
-    ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Function::Hash32 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Hash::Function::Hash32 const &', 'arg0')])
-    ## hash-function.h (module 'core'): ns3::Hash::Function::Hash32::Hash32(ns3::Hash::Hash32Function_ptr hp) [constructor]
-    cls.add_constructor([param('ns3::Hash::Hash32Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash32::GetHash32(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash32', 
-                   'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash32::clear() [member function]
-    cls.add_method('clear', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3HashFunctionHash64_methods(root_module, cls):
-    ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Function::Hash64 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Hash::Function::Hash64 const &', 'arg0')])
-    ## hash-function.h (module 'core'): ns3::Hash::Function::Hash64::Hash64(ns3::Hash::Hash64Function_ptr hp) [constructor]
-    cls.add_constructor([param('ns3::Hash::Hash64Function_ptr', 'hp')])
-    ## hash-function.h (module 'core'): uint32_t ns3::Hash::Function::Hash64::GetHash32(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash32', 
-                   'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-function.h (module 'core'): uint64_t ns3::Hash::Function::Hash64::GetHash64(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash64', 
-                   'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-function.h (module 'core'): void ns3::Hash::Function::Hash64::clear() [member function]
-    cls.add_method('clear', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_Ns3HashFunctionMurmur3_methods(root_module, cls):
-    ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3::Murmur3(ns3::Hash::Function::Murmur3 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Hash::Function::Murmur3 const &', 'arg0')])
-    ## hash-murmur3.h (module 'core'): ns3::Hash::Function::Murmur3::Murmur3() [constructor]
-    cls.add_constructor([])
-    ## hash-murmur3.h (module 'core'): uint32_t ns3::Hash::Function::Murmur3::GetHash32(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash32', 
-                   'uint32_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-murmur3.h (module 'core'): uint64_t ns3::Hash::Function::Murmur3::GetHash64(char const * buffer, size_t const size) [member function]
-    cls.add_method('GetHash64', 
-                   'uint64_t', 
-                   [param('char const *', 'buffer'), param('size_t const', 'size')], 
-                   is_virtual=True)
-    ## hash-murmur3.h (module 'core'): void ns3::Hash::Function::Murmur3::clear() [member function]
-    cls.add_method('clear', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    return
-
-def register_functions(root_module):
-    module = root_module
-    register_functions_ns3_Config(module.get_submodule('Config'), root_module)
-    register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)
-    register_functions_ns3_Hash(module.get_submodule('Hash'), root_module)
-    register_functions_ns3_TracedValueCallback(module.get_submodule('TracedValueCallback'), root_module)
-    register_functions_ns3_internal(module.get_submodule('internal'), root_module)
-    return
-
-def register_functions_ns3_Config(module, root_module):
-    return
-
-def register_functions_ns3_FatalImpl(module, root_module):
-    return
-
-def register_functions_ns3_Hash(module, root_module):
-    register_functions_ns3_Hash_Function(module.get_submodule('Function'), root_module)
-    return
-
-def register_functions_ns3_Hash_Function(module, root_module):
-    return
-
-def register_functions_ns3_TracedValueCallback(module, root_module):
-    return
-
-def register_functions_ns3_internal(module, root_module):
-    return
-
-def main():
-    out = FileCodeSink(sys.stdout)
-    root_module = module_init()
-    register_types(root_module)
-    register_methods(root_module)
-    register_functions(root_module)
-    root_module.generate(out)
-
-if __name__ == '__main__':
-    main()
-
diff -Naru a/bindings/modulegen__gcc_LP64.py b/bindings/modulegen__gcc_LP64.py
--- a/bindings/modulegen__gcc_LP64.py	2017-10-05 11:46:52.038493344 +0200
+++ b/bindings/modulegen__gcc_LP64.py	2017-10-05 11:47:22.290601698 +0200
@@ -106,6 +106,12 @@
     module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::NixVector'])
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::Packet> [struct]
     module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::Packet'])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::QueueItem> [struct]
+    module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::QueueItem'])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apConnectionInfo> [struct]
+    module.add_class('DefaultDeleter', template_parameters=['ns3::S1apConnectionInfo'])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apIfaceInfo> [struct]
+    module.add_class('DefaultDeleter', template_parameters=['ns3::S1apIfaceInfo'])
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumModel> [struct]
     module.add_class('DefaultDeleter', import_from_module='ns.core', template_parameters=['ns3::SpectrumModel'])
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumValue> [struct]
@@ -186,20 +192,24 @@
     module.add_class('ModifyBearerRequestMessage', parent=root_module['ns3::EpcS11Sap::GtpcMessage'], outer_class=root_module['ns3::EpcS11SapSgw'])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap [class]
     module.add_class('EpcS1apSap')
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem [struct]
+    module.add_class('ErabSetupItem', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem [struct]
+    module.add_class('ErabSwitchedInDownlinkItem', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem [struct]
+    module.add_class('ErabSwitchedInUplinkItem', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication [struct]
+    module.add_class('ErabToBeReleasedIndication', outer_class=root_module['ns3::EpcS1apSap'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem [struct]
+    module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcS1apSap'])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb [class]
     module.add_class('EpcS1apSapEnb', parent=root_module['ns3::EpcS1apSap'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem [struct]
-    module.add_class('ErabSwitchedInUplinkItem', outer_class=root_module['ns3::EpcS1apSapEnb'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem [struct]
-    module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcS1apSapEnb'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnbProvider [class]
+    module.add_class('EpcS1apSapEnbProvider', parent=root_module['ns3::EpcS1apSap'])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme [class]
     module.add_class('EpcS1apSapMme', parent=root_module['ns3::EpcS1apSap'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem [struct]
-    module.add_class('ErabSetupItem', outer_class=root_module['ns3::EpcS1apSapMme'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem [struct]
-    module.add_class('ErabSwitchedInDownlinkItem', outer_class=root_module['ns3::EpcS1apSapMme'])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication [struct]
-    module.add_class('ErabToBeReleasedIndication', outer_class=root_module['ns3::EpcS1apSapMme'])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMmeProvider [class]
+    module.add_class('EpcS1apSapMmeProvider', parent=root_module['ns3::EpcS1apSap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap [class]
     module.add_class('EpcX2Sap')
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem [enumeration]
@@ -222,6 +232,8 @@
     module.add_class('ErabToBeSetupItem', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem [struct]
     module.add_class('ErabsSubjectToStatusTransferItem', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams [struct]
+    module.add_class('HandoverFailedParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams [struct]
     module.add_class('HandoverPreparationFailureParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestAckParams [struct]
@@ -234,12 +246,22 @@
     module.add_class('RelativeNarrowbandTxBand', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::ResourceStatusUpdateParams [struct]
     module.add_class('ResourceStatusUpdateParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest [struct]
+    module.add_class('RlcSetupRequest', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams [struct]
+    module.add_class('SecondaryHandoverCompletedParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams [struct]
+    module.add_class('SecondaryHandoverParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams [struct]
     module.add_class('SnStatusTransferParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams [struct]
+    module.add_class('SwitchConnectionParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams [struct]
     module.add_class('UeContextReleaseParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeDataParams [struct]
     module.add_class('UeDataParams', outer_class=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams [struct]
+    module.add_class('UeImsiSinrParams', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem [struct]
     module.add_class('UlHighInterferenceInformationItem', outer_class=root_module['ns3::EpcX2Sap'])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapProvider [class]
@@ -249,7 +271,7 @@
     ## eps-bearer.h (module 'lte'): ns3::EpsBearer [struct]
     module.add_class('EpsBearer')
     ## eps-bearer.h (module 'lte'): ns3::EpsBearer::Qci [enumeration]
-    module.add_enum('Qci', ['GBR_CONV_VOICE', 'GBR_CONV_VIDEO', 'GBR_GAMING', 'GBR_NON_CONV_VIDEO', 'NGBR_IMS', 'NGBR_VIDEO_TCP_OPERATOR', 'NGBR_VOICE_VIDEO_GAMING', 'NGBR_VIDEO_TCP_PREMIUM', 'NGBR_VIDEO_TCP_DEFAULT'], outer_class=root_module['ns3::EpsBearer'])
+    module.add_enum('Qci', ['GBR_CONV_VOICE', 'GBR_CONV_VIDEO', 'GBR_GAMING', 'GBR_NON_CONV_VIDEO', 'NGBR_IMS', 'NGBR_VIDEO_TCP_OPERATOR', 'NGBR_VOICE_VIDEO_GAMING', 'NGBR_VIDEO_TCP_PREMIUM', 'NGBR_VIDEO_TCP_DEFAULT', 'GBR_ULTRA_LOW_LAT'], outer_class=root_module['ns3::EpsBearer'])
     ## lte-common.h (module 'lte'): ns3::EutranMeasurementMapping [class]
     module.add_class('EutranMeasurementMapping')
     ## event-id.h (module 'core'): ns3::EventId [class]
@@ -382,14 +404,6 @@
     module.add_class('LteAsSapProvider', allow_subclassing=True)
     ## lte-as-sap.h (module 'lte'): ns3::LteAsSapUser [class]
     module.add_class('LteAsSapUser', allow_subclassing=True)
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapProvider [class]
-    module.add_class('LteCcmMacSapProvider', allow_subclassing=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider [class]
-    module.add_class('LteCcmRrcSapProvider', allow_subclassing=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig [struct]
-    module.add_class('LcsConfig', outer_class=root_module['ns3::LteCcmRrcSapProvider'])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapUser [class]
-    module.add_class('LteCcmRrcSapUser', allow_subclassing=True)
     ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider [class]
     module.add_class('LteEnbCmacSapProvider', allow_subclassing=True)
     ## lte-enb-cmac-sap.h (module 'lte'): ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue [struct]
@@ -407,7 +421,9 @@
     ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapProvider [class]
     module.add_class('LteEnbCphySapProvider', allow_subclassing=True)
     ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser [class]
-    module.add_class('LteEnbCphySapUser')
+    module.add_class('LteEnbCphySapUser', allow_subclassing=True)
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo [struct]
+    module.add_class('UeAssociatedSinrInfo', outer_class=root_module['ns3::LteEnbCphySapUser'])
     ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapProvider [class]
     module.add_class('LteEnbPhySapProvider', allow_subclassing=True)
     ## lte-enb-phy-sap.h (module 'lte'): ns3::LteEnbPhySapUser [class]
@@ -454,16 +470,14 @@
     module.add_class('TransmitPdcpPduParameters', outer_class=root_module['ns3::LteRlcSapProvider'])
     ## lte-rlc-sap.h (module 'lte'): ns3::LteRlcSapUser [class]
     module.add_class('LteRlcSapUser', allow_subclassing=True)
+    ## lte-rlc.h (module 'lte'): ns3::LteRlcSpecificLteMacSapUser [class]
+    module.add_class('LteRlcSpecificLteMacSapUser', parent=root_module['ns3::LteMacSapUser'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap [class]
     module.add_class('LteRrcSap')
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestablishmentCause [enumeration]
     module.add_enum('ReestablishmentCause', ['RECONFIGURATION_FAILURE', 'HANDOVER_FAILURE', 'OTHER_FAILURE'], outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon [struct]
-    module.add_class('AntennaInfoCommon', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoDedicated [struct]
     module.add_class('AntennaInfoDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl [struct]
-    module.add_class('AntennaInfoUl', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig [struct]
     module.add_class('AsConfig', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::BlackCellsToAddMod [struct]
@@ -474,8 +488,6 @@
     module.add_class('CarrierFreqEutra', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellAccessRelatedInfo [struct]
     module.add_class('CellAccessRelatedInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification [struct]
-    module.add_class('CellIdentification', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellSelectionInfo [struct]
     module.add_class('CellSelectionInfo', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellsToAddMod [struct]
@@ -496,24 +508,18 @@
     module.add_class('MeasConfig', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig [struct]
     module.add_class('MeasGapConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::MeasGapConfig'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::gap [enumeration]
-    module.add_enum('gap', ['GP0', 'GP1'], outer_class=root_module['ns3::LteRrcSap::MeasGapConfig'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig [enumeration]
+    module.add_enum('', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::MeasGapConfig'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig [enumeration]
+    module.add_enum('', ['GP0', 'GP1'], outer_class=root_module['ns3::LteRrcSap::MeasGapConfig'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasIdToAddMod [struct]
     module.add_class('MeasIdToAddMod', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra [struct]
     module.add_class('MeasObjectEutra', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectToAddMod [struct]
     module.add_class('MeasObjectToAddMod', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell [struct]
-    module.add_class('MeasResultBestNeighCell', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra [struct]
     module.add_class('MeasResultEutra', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell [struct]
-    module.add_class('MeasResultScell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList [struct]
-    module.add_class('MeasResultServFreqList', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults [struct]
     module.add_class('MeasResults', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasurementReport [struct]
@@ -522,30 +528,20 @@
     module.add_class('MobilityControlInfo', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MobilityStateParameters [struct]
     module.add_class('MobilityStateParameters', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration [struct]
-    module.add_class('NonCriticalExtensionConfiguration', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration [struct]
-    module.add_class('NonUlConfiguration', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigCommon [struct]
     module.add_class('PdschConfigCommon', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated [struct]
     module.add_class('PdschConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated::db [enumeration]
-    module.add_enum('db', ['dB_6', 'dB_4dot77', 'dB_3', 'dB_1dot77', 'dB0', 'dB1', 'dB2', 'dB3'], outer_class=root_module['ns3::LteRrcSap::PdschConfigDedicated'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigDedicated [enumeration]
+    module.add_enum('', ['dB_6', 'dB_4dot77', 'dB_3', 'dB_1dot77', 'dB0', 'dB1', 'dB2', 'dB3'], outer_class=root_module['ns3::LteRrcSap::PdschConfigDedicated'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysCellIdRange [struct]
     module.add_class('PhysCellIdRange', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated [struct]
     module.add_class('PhysicalConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell [struct]
-    module.add_class('PhysicalConfigDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PlmnIdentityInfo [struct]
     module.add_class('PlmnIdentityInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell [struct]
-    module.add_class('PrachConfigSCell', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PreambleInfo [struct]
     module.add_class('PreambleInfo', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell [struct]
-    module.add_class('PuschConfigDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::QuantityConfig [struct]
     module.add_class('QuantityConfig', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RaSupervisionInfo [struct]
@@ -556,14 +552,10 @@
     module.add_class('RachConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommon [struct]
     module.add_class('RadioResourceConfigCommon', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell [struct]
-    module.add_class('RadioResourceConfigCommonSCell', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSib [struct]
     module.add_class('RadioResourceConfigCommonSib', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated [struct]
     module.add_class('RadioResourceConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell [struct]
-    module.add_class('RadioResourceConfigDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity [struct]
     module.add_class('ReestabUeIdentity', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [struct]
@@ -572,8 +564,8 @@
     module.add_enum('', ['EVENT', 'PERIODICAL'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
     module.add_enum('', ['EVENT_A1', 'EVENT_A2', 'EVENT_A3', 'EVENT_A4', 'EVENT_A5'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::report [enumeration]
-    module.add_enum('report', ['REPORT_STRONGEST_CELLS', 'REPORT_CGI'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
+    module.add_enum('', ['REPORT_STRONGEST_CELLS', 'REPORT_CGI'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
     module.add_enum('', ['RSRP', 'RSRQ'], outer_class=root_module['ns3::LteRrcSap::ReportConfigEutra'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra [enumeration]
@@ -584,8 +576,8 @@
     module.add_class('ReportConfigToAddMod', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig [struct]
     module.add_class('RlcConfig', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::direction [enumeration]
-    module.add_enum('direction', ['AM', 'UM_BI_DIRECTIONAL', 'UM_UNI_DIRECTIONAL_UL', 'UM_UNI_DIRECTIONAL_DL'], outer_class=root_module['ns3::LteRrcSap::RlcConfig'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig [enumeration]
+    module.add_enum('', ['AM', 'UM_BI_DIRECTIONAL', 'UM_UNI_DIRECTIONAL_UL', 'UM_UNI_DIRECTIONAL_DL', 'UM_BI_DIRECTIONAL_LOWLAT'], outer_class=root_module['ns3::LteRrcSap::RlcConfig'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration [struct]
     module.add_class('RrcConnectionReconfiguration', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfigurationCompleted [struct]
@@ -608,20 +600,20 @@
     module.add_class('RrcConnectionSetup', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSetupCompleted [struct]
     module.add_class('RrcConnectionSetupCompleted', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod [struct]
-    module.add_class('SCellToAddMod', outer_class=root_module['ns3::LteRrcSap'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch [struct]
+    module.add_class('RrcConnectionSwitch', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon [struct]
     module.add_class('SoundingRsUlConfigCommon', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SoundingRsUlConfigCommon'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon [enumeration]
+    module.add_enum('', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SoundingRsUlConfigCommon'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated [struct]
     module.add_class('SoundingRsUlConfigDedicated', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SoundingRsUlConfigDedicated'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated [enumeration]
+    module.add_enum('', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SoundingRsUlConfigDedicated'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars [struct]
     module.add_class('SpeedStatePars', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::action [enumeration]
-    module.add_enum('action', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SpeedStatePars'])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars [enumeration]
+    module.add_enum('', ['SETUP', 'RESET'], outer_class=root_module['ns3::LteRrcSap::SpeedStatePars'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStateScaleFactors [struct]
     module.add_class('SpeedStateScaleFactors', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SrbToAddMod [struct]
@@ -636,22 +628,10 @@
     module.add_class('ThresholdEutra', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ThresholdEutra [enumeration]
     module.add_enum('', ['THRESHOLD_RSRP', 'THRESHOLD_RSRQ'], outer_class=root_module['ns3::LteRrcSap::ThresholdEutra'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration [struct]
-    module.add_class('UlConfiguration', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell [struct]
-    module.add_class('UlPowerControlCommonSCell', outer_class=root_module['ns3::LteRrcSap'])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell [struct]
-    module.add_class('UlPowerControlDedicatedSCell', outer_class=root_module['ns3::LteRrcSap'])
     ## lte-chunk-processor.h (module 'lte'): ns3::LteSpectrumValueCatcher [class]
     module.add_class('LteSpectrumValueCatcher')
     ## lte-spectrum-value-helper.h (module 'lte'): ns3::LteSpectrumValueHelper [class]
     module.add_class('LteSpectrumValueHelper')
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider [class]
-    module.add_class('LteUeCcmRrcSapProvider', allow_subclassing=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig [struct]
-    module.add_class('LcsConfig', outer_class=root_module['ns3::LteUeCcmRrcSapProvider'])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapUser [class]
-    module.add_class('LteUeCcmRrcSapUser', allow_subclassing=True)
     ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider [class]
     module.add_class('LteUeCmacSapProvider', allow_subclassing=True)
     ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LogicalChannelConfig [struct]
@@ -772,6 +752,10 @@
     module.add_class('TbStats_t')
     ## nstime.h (module 'core'): ns3::TimeWithUnit [class]
     module.add_class('TimeWithUnit', import_from_module='ns.core')
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool> [class]
+    module.add_class('TracedValue', import_from_module='ns.core', template_parameters=['bool'])
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int> [class]
+    module.add_class('TracedValue', import_from_module='ns.core', template_parameters=['unsigned int'])
     ## lte-common.h (module 'lte'): ns3::TransmissionModesLayers [class]
     module.add_class('TransmissionModesLayers')
     ## type-id.h (module 'core'): ns3::TypeId [class]
@@ -832,6 +816,16 @@
     module.add_class('Chunk', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
     ## lte-global-pathloss-database.h (module 'lte'): ns3::DownlinkLteGlobalPathlossDatabase [class]
     module.add_class('DownlinkLteGlobalPathlossDatabase', parent=root_module['ns3::LteGlobalPathlossDatabase'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpProvider [class]
+    module.add_class('EpcX2PdcpProvider', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpUser [class]
+    module.add_class('EpcX2PdcpUser', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcProvider [class]
+    module.add_class('EpcX2RlcProvider', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcUser [class]
+    module.add_class('EpcX2RlcUser', parent=root_module['ns3::EpcX2Sap'])
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag [class]
+    module.add_class('EpcX2Tag', parent=root_module['ns3::Tag'])
     ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag [class]
     module.add_class('EpsBearerTag', parent=root_module['ns3::Tag'])
     ## header.h (module 'network'): ns3::Header [class]
@@ -842,8 +836,6 @@
     module.add_enum('DscpType', ['DscpDefault', 'DSCP_CS1', 'DSCP_AF11', 'DSCP_AF12', 'DSCP_AF13', 'DSCP_CS2', 'DSCP_AF21', 'DSCP_AF22', 'DSCP_AF23', 'DSCP_CS3', 'DSCP_AF31', 'DSCP_AF32', 'DSCP_AF33', 'DSCP_CS4', 'DSCP_AF41', 'DSCP_AF42', 'DSCP_AF43', 'DSCP_CS5', 'DSCP_EF', 'DSCP_CS6', 'DSCP_CS7'], outer_class=root_module['ns3::Ipv4Header'], import_from_module='ns.internet')
     ## ipv4-header.h (module 'internet'): ns3::Ipv4Header::EcnType [enumeration]
     module.add_enum('EcnType', ['ECN_NotECT', 'ECN_ECT1', 'ECN_ECT0', 'ECN_CE'], outer_class=root_module['ns3::Ipv4Header'], import_from_module='ns.internet')
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapUser [class]
-    module.add_class('LteCcmMacSapUser', parent=root_module['ns3::LteMacSapUser'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider [class]
     module.add_class('LteEnbRrcSapProvider', parent=root_module['ns3::LteRrcSap'])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters [struct]
@@ -896,12 +888,26 @@
     module.add_class('AggregateIterator', import_from_module='ns.core', outer_class=root_module['ns3::Object'])
     ## packet-burst.h (module 'network'): ns3::PacketBurst [class]
     module.add_class('PacketBurst', import_from_module='ns.network', parent=root_module['ns3::Object'])
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter [class]
+    module.add_class('PacketFilter', import_from_module='ns.traffic_control', parent=root_module['ns3::Object'])
     ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag [class]
     module.add_class('PdcpTag', parent=root_module['ns3::Tag'])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc [class]
+    module.add_class('QueueDisc', import_from_module='ns.traffic_control', parent=root_module['ns3::Object'])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::WakeMode [enumeration]
+    module.add_enum('WakeMode', ['WAKE_ROOT', 'WAKE_CHILD'], outer_class=root_module['ns3::QueueDisc'], import_from_module='ns.traffic-control')
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats [struct]
+    module.add_class('Stats', import_from_module='ns.traffic_control', outer_class=root_module['ns3::QueueDisc'])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDiscClass [class]
+    module.add_class('QueueDiscClass', import_from_module='ns.traffic_control', parent=root_module['ns3::Object'])
     ## radio-environment-map-helper.h (module 'lte'): ns3::RadioEnvironmentMapHelper [class]
     module.add_class('RadioEnvironmentMapHelper', parent=root_module['ns3::Object'])
     ## random-variable-stream.h (module 'core'): ns3::RandomVariableStream [class]
     module.add_class('RandomVariableStream', import_from_module='ns.core', parent=root_module['ns3::Object'])
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator [class]
+    module.add_class('RetxStatsCalculator', parent=root_module['ns3::Object'])
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo [class]
+    module.add_class('RlcBearerInfo', parent=root_module['ns3::Object'])
     ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag [class]
     module.add_class('RlcTag', parent=root_module['ns3::Tag'])
     ## random-variable-stream.h (module 'core'): ns3::SequentialRandomVariable [class]
@@ -936,6 +942,12 @@
     module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::NixVector', 'ns3::empty', 'ns3::DefaultDeleter<ns3::NixVector>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> > [class]
     module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Packet', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Packet>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> > [class]
+    module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::QueueItem', 'ns3::empty', 'ns3::DefaultDeleter<ns3::QueueItem>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> > [class]
+    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::S1apConnectionInfo', 'ns3::empty', 'ns3::DefaultDeleter<ns3::S1apConnectionInfo>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> > [class]
+    module.add_class('SimpleRefCount', automatic_type_narrowing=True, template_parameters=['ns3::S1apIfaceInfo', 'ns3::empty', 'ns3::DefaultDeleter<ns3::S1apIfaceInfo>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> > [class]
     module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::SpectrumModel', 'ns3::empty', 'ns3::DefaultDeleter<ns3::SpectrumModel>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> > [class]
@@ -994,6 +1006,10 @@
     module.add_class('TraceFadingLossModel', parent=root_module['ns3::SpectrumPropagationLossModel'])
     ## trace-source-accessor.h (module 'core'): ns3::TraceSourceAccessor [class]
     module.add_class('TraceSourceAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time> [class]
+    module.add_class('TracedValue', import_from_module='ns.core', template_parameters=['ns3::Time'])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time> [class]
+    root_module['ns3::TracedValue< ns3::Time >'].implicitly_converts_to(root_module['ns3::Time'])
     ## trailer.h (module 'network'): ns3::Trailer [class]
     module.add_class('Trailer', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
     ## random-variable-stream.h (module 'core'): ns3::TriangularRandomVariable [class]
@@ -1001,7 +1017,7 @@
     ## lte-enb-rrc.h (module 'lte'): ns3::UeManager [class]
     module.add_class('UeManager', parent=root_module['ns3::Object'])
     ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::State [enumeration]
-    module.add_enum('State', ['INITIAL_RANDOM_ACCESS', 'CONNECTION_SETUP', 'CONNECTION_REJECTED', 'CONNECTED_NORMALLY', 'CONNECTION_RECONFIGURATION', 'CONNECTION_REESTABLISHMENT', 'HANDOVER_PREPARATION', 'HANDOVER_JOINING', 'HANDOVER_PATH_SWITCH', 'HANDOVER_LEAVING', 'NUM_STATES'], outer_class=root_module['ns3::UeManager'])
+    module.add_enum('State', ['INITIAL_RANDOM_ACCESS', 'CONNECTION_SETUP', 'CONNECTION_REJECTED', 'CONNECTED_NORMALLY', 'CONNECTION_RECONFIGURATION', 'CONNECTION_REESTABLISHMENT', 'HANDOVER_PREPARATION', 'HANDOVER_JOINING', 'HANDOVER_PATH_SWITCH', 'HANDOVER_LEAVING', 'PREPARE_MC_CONNECTION_RECONFIGURATION', 'MC_CONNECTION_RECONFIGURATION', 'NUM_STATES'], outer_class=root_module['ns3::UeManager'])
     ## random-variable-stream.h (module 'core'): ns3::UniformRandomVariable [class]
     module.add_class('UniformRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## ff-mac-common.h (module 'lte'): ns3::VendorSpecificValue [struct]
@@ -1036,16 +1052,12 @@
     module.add_class('CallbackImplBase', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])
     ## callback.h (module 'core'): ns3::CallbackValue [class]
     module.add_class('CallbackValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
-    ## cc-helper.h (module 'lte'): ns3::CcHelper [class]
-    module.add_class('CcHelper', parent=root_module['ns3::Object'])
     ## channel.h (module 'network'): ns3::Channel [class]
     module.add_class('Channel', import_from_module='ns.network', parent=root_module['ns3::Object'])
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier [class]
-    module.add_class('ComponentCarrier', parent=root_module['ns3::Object'])
-    ## component-carrier-enb.h (module 'lte'): ns3::ComponentCarrierEnb [class]
-    module.add_class('ComponentCarrierEnb', parent=root_module['ns3::ComponentCarrier'])
-    ## component-carrier-ue.h (module 'lte'): ns3::ComponentCarrierUe [class]
-    module.add_class('ComponentCarrierUe', parent=root_module['ns3::ComponentCarrier'])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc [class]
+    module.add_class('CoDelQueueDisc', import_from_module='ns.traffic_control', parent=root_module['ns3::QueueDisc'])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::QueueDiscMode [enumeration]
+    module.add_enum('QueueDiscMode', ['QUEUE_DISC_MODE_PACKETS', 'QUEUE_DISC_MODE_BYTES'], outer_class=root_module['ns3::CoDelQueueDisc'], import_from_module='ns.traffic-control')
     ## random-variable-stream.h (module 'core'): ns3::ConstantRandomVariable [class]
     module.add_class('ConstantRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## data-calculator.h (module 'stats'): ns3::DataCalculator [class]
@@ -1080,6 +1092,28 @@
     module.add_class('EpcHelper', parent=root_module['ns3::Object'])
     ## epc-mme.h (module 'lte'): ns3::EpcMme [class]
     module.add_class('EpcMme', parent=root_module['ns3::Object'])
+    ## epc-mme-application.h (module 'lte'): ns3::EpcMmeApplication [class]
+    module.add_class('EpcMmeApplication', parent=root_module['ns3::Application'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APErabReleaseIndicationHeader [class]
+    module.add_class('EpcS1APErabReleaseIndicationHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader [class]
+    module.add_class('EpcS1APHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader::ProcedureCode_t [enumeration]
+    module.add_enum('ProcedureCode_t', ['InitialUeMessage', 'PathSwitchRequest', 'ErabReleaseIndication', 'InitialContextSetupResponse', 'InitialContextSetupRequest', 'PathSwitchRequestAck'], outer_class=root_module['ns3::EpcS1APHeader'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupRequestHeader [class]
+    module.add_class('EpcS1APInitialContextSetupRequestHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupResponseHeader [class]
+    module.add_class('EpcS1APInitialContextSetupResponseHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialUeMessageHeader [class]
+    module.add_class('EpcS1APInitialUeMessageHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestAcknowledgeHeader [class]
+    module.add_class('EpcS1APPathSwitchRequestAcknowledgeHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestHeader [class]
+    module.add_class('EpcS1APPathSwitchRequestHeader', parent=root_module['ns3::Header'])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apEnb [class]
+    module.add_class('EpcS1apEnb', parent=root_module['ns3::Object'])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apMme [class]
+    module.add_class('EpcS1apMme', parent=root_module['ns3::Object'])
     ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication [class]
     module.add_class('EpcSgwPgwApplication', parent=root_module['ns3::Application'])
     ## epc-tft.h (module 'lte'): ns3::EpcTft [class]
@@ -1096,6 +1130,8 @@
     module.add_enum('State', ['OFF', 'ATTACHING', 'IDLE_REGISTERED', 'CONNECTING_TO_EPC', 'ACTIVE', 'NUM_STATES'], outer_class=root_module['ns3::EpcUeNas'])
     ## epc-x2.h (module 'lte'): ns3::EpcX2 [class]
     module.add_class('EpcX2', parent=root_module['ns3::Object'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ConnectionSwitchHeader [class]
+    module.add_class('EpcX2ConnectionSwitchHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader [class]
     module.add_class('EpcX2HandoverPreparationFailureHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader [class]
@@ -1105,17 +1141,29 @@
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header [class]
     module.add_class('EpcX2Header', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::ProcedureCode_t [enumeration]
-    module.add_enum('ProcedureCode_t', ['HandoverPreparation', 'LoadIndication', 'SnStatusTransfer', 'UeContextRelease', 'ResourceStatusReporting'], outer_class=root_module['ns3::EpcX2Header'])
+    module.add_enum('ProcedureCode_t', ['HandoverPreparation', 'LoadIndication', 'SnStatusTransfer', 'UeContextRelease', 'ResourceStatusReporting', 'RlcSetupRequest', 'RlcSetupCompleted', 'NotifyMcConnection', 'UpdateUeSinr', 'RequestMcHandover', 'NotifyMmWaveLteHandover', 'NotifyCoordinatorHandoverFailed', 'SwitchConnection', 'SecondaryCellHandoverCompleted'], outer_class=root_module['ns3::EpcX2Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::TypeOfMessage_t [enumeration]
-    module.add_enum('TypeOfMessage_t', ['InitiatingMessage', 'SuccessfulOutcome', 'UnsuccessfulOutcome'], outer_class=root_module['ns3::EpcX2Header'])
+    module.add_enum('TypeOfMessage_t', ['InitiatingMessage', 'SuccessfulOutcome', 'UnsuccessfulOutcome', 'McForwardDownlinkData', 'McForwardUplinkData'], outer_class=root_module['ns3::EpcX2Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader [class]
     module.add_class('EpcX2LoadInformationHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2McHandoverHeader [class]
+    module.add_class('EpcX2McHandoverHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2NotifyCoordinatorHandoverFailedHeader [class]
+    module.add_class('EpcX2NotifyCoordinatorHandoverFailedHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader [class]
     module.add_class('EpcX2ResourceStatusUpdateHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupCompletedHeader [class]
+    module.add_class('EpcX2RlcSetupCompletedHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupRequestHeader [class]
+    module.add_class('EpcX2RlcSetupRequestHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SecondaryCellHandoverCompletedHeader [class]
+    module.add_class('EpcX2SecondaryCellHandoverCompletedHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2SnStatusTransferHeader [class]
     module.add_class('EpcX2SnStatusTransferHeader', parent=root_module['ns3::Header'])
     ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeContextReleaseHeader [class]
     module.add_class('EpcX2UeContextReleaseHeader', parent=root_module['ns3::Header'])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeImsiSinrUpdateHeader [class]
+    module.add_class('EpcX2UeImsiSinrUpdateHeader', parent=root_module['ns3::Header'])
     ## random-variable-stream.h (module 'core'): ns3::ErlangRandomVariable [class]
     module.add_class('ErlangRandomVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariableStream'])
     ## event-impl.h (module 'core'): ns3::EventImpl [class]
@@ -1168,14 +1216,16 @@
     module.add_class('LteControlMessage', parent=root_module['ns3::SimpleRefCount< ns3::LteControlMessage, ns3::empty, ns3::DefaultDeleter<ns3::LteControlMessage> >'])
     ## lte-control-messages.h (module 'lte'): ns3::LteControlMessage::MessageType [enumeration]
     module.add_enum('MessageType', ['DL_DCI', 'UL_DCI', 'DL_CQI', 'UL_CQI', 'BSR', 'DL_HARQ', 'RACH_PREAMBLE', 'RAR', 'MIB', 'SIB1'], outer_class=root_module['ns3::LteControlMessage'])
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteEnbComponentCarrierManager [class]
-    module.add_class('LteEnbComponentCarrierManager', parent=root_module['ns3::Object'])
     ## lte-enb-mac.h (module 'lte'): ns3::LteEnbMac [class]
     module.add_class('LteEnbMac', parent=root_module['ns3::Object'])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc [class]
     module.add_class('LteEnbRrc', parent=root_module['ns3::Object'])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::LteEpsBearerToRlcMapping_t [enumeration]
-    module.add_enum('LteEpsBearerToRlcMapping_t', ['RLC_SM_ALWAYS', 'RLC_UM_ALWAYS', 'RLC_AM_ALWAYS', 'PER_BASED'], outer_class=root_module['ns3::LteEnbRrc'])
+    module.add_enum('LteEpsBearerToRlcMapping_t', ['RLC_SM_ALWAYS', 'RLC_UM_ALWAYS', 'RLC_AM_ALWAYS', 'PER_BASED', 'RLC_UM_LOWLAT_ALWAYS'], outer_class=root_module['ns3::LteEnbRrc'])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverMode [enumeration]
+    module.add_enum('HandoverMode', ['FIXED_TTT', 'DYNAMIC_TTT', 'THRESHOLD'], outer_class=root_module['ns3::LteEnbRrc'])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo [struct]
+    module.add_class('HandoverEventInfo', outer_class=root_module['ns3::LteEnbRrc'])
     ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcProtocolIdeal [class]
     module.add_class('LteEnbRrcProtocolIdeal', parent=root_module['ns3::Object'])
     ## lte-rrc-protocol-real.h (module 'lte'): ns3::LteEnbRrcProtocolReal [class]
@@ -1218,12 +1268,16 @@
     module.add_class('LteRlc', parent=root_module['ns3::Object'])
     ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm [class]
     module.add_class('LteRlcAm', parent=root_module['ns3::LteRlc'])
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu [struct]
+    module.add_class('RetxPdu', outer_class=root_module['ns3::LteRlcAm'])
     ## lte-rlc.h (module 'lte'): ns3::LteRlcSm [class]
     module.add_class('LteRlcSm', parent=root_module['ns3::LteRlc'])
     ## lte-rlc-tm.h (module 'lte'): ns3::LteRlcTm [class]
     module.add_class('LteRlcTm', parent=root_module['ns3::LteRlc'])
     ## lte-rlc-um.h (module 'lte'): ns3::LteRlcUm [class]
     module.add_class('LteRlcUm', parent=root_module['ns3::LteRlc'])
+    ## lte-rlc-um-lowlat.h (module 'lte'): ns3::LteRlcUmLowLat [class]
+    module.add_class('LteRlcUmLowLat', parent=root_module['ns3::LteRlc'])
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo [class]
     module.add_class('LteSignalingRadioBearerInfo', parent=root_module['ns3::LteRadioBearerInfo'])
     ## lte-spectrum-phy.h (module 'lte'): ns3::LteSpectrumPhy [class]
@@ -1240,8 +1294,6 @@
     module.add_class('LteSpectrumSignalParametersUlSrsFrame', parent=root_module['ns3::SpectrumSignalParameters'])
     ## lte-stats-calculator.h (module 'lte'): ns3::LteStatsCalculator [class]
     module.add_class('LteStatsCalculator', parent=root_module['ns3::Object'])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeComponentCarrierManager [class]
-    module.add_class('LteUeComponentCarrierManager', parent=root_module['ns3::Object'])
     ## lte-ue-mac.h (module 'lte'): ns3::LteUeMac [class]
     module.add_class('LteUeMac', parent=root_module['ns3::Object'])
     ## lte-ue-phy.h (module 'lte'): ns3::LteUePhy [class]
@@ -1264,6 +1316,16 @@
     module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
     ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator [class]
     module.add_class('MacStatsCalculator', parent=root_module['ns3::LteStatsCalculator'])
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator [class]
+    module.add_class('MacTxStatsCalculator', parent=root_module['ns3::Object'])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp [class]
+    module.add_class('McEnbPdcp', parent=root_module['ns3::LtePdcp'])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status [struct]
+    module.add_class('Status', outer_class=root_module['ns3::McEnbPdcp'])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp [class]
+    module.add_class('McUePdcp', parent=root_module['ns3::LtePdcp'])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status [struct]
+    module.add_class('Status', outer_class=root_module['ns3::McUePdcp'])
     ## lte-control-messages.h (module 'lte'): ns3::MibLteControlMessage [class]
     module.add_class('MibLteControlMessage', parent=root_module['ns3::LteControlMessage'])
     ## basic-data-calculators.h (module 'stats'): ns3::MinMaxAvgTotalCalculator<unsigned int> [class]
@@ -1278,8 +1340,6 @@
     module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
     ## nix-vector.h (module 'network'): ns3::NixVector [class]
     module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::NoOpComponentCarrierManager [class]
-    module.add_class('NoOpComponentCarrierManager', parent=root_module['ns3::LteEnbComponentCarrierManager'])
     ## no-op-handover-algorithm.h (module 'lte'): ns3::NoOpHandoverAlgorithm [class]
     module.add_class('NoOpHandoverAlgorithm', parent=root_module['ns3::LteHandoverAlgorithm'])
     ## node.h (module 'network'): ns3::Node [class]
@@ -1310,6 +1370,10 @@
     module.add_class('PointerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
     ## pss-ff-mac-scheduler.h (module 'lte'): ns3::PssFfMacScheduler [class]
     module.add_class('PssFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
+    ## queue-item.h (module 'network'): ns3::QueueItem [class]
+    module.add_class('QueueItem', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >'])
+    ## queue-item.h (module 'network'): ns3::QueueItem::Uint8Values [enumeration]
+    module.add_enum('Uint8Values', ['IP_DSFIELD'], outer_class=root_module['ns3::QueueItem'], import_from_module='ns.network')
     ## lte-control-messages.h (module 'lte'): ns3::RachPreambleLteControlMessage [class]
     module.add_class('RachPreambleLteControlMessage', parent=root_module['ns3::LteControlMessage'])
     ## radio-bearer-stats-calculator.h (module 'lte'): ns3::RadioBearerStatsCalculator [class]
@@ -1320,8 +1384,6 @@
     module.add_class('Rar', outer_class=root_module['ns3::RarLteControlMessage'])
     ## rem-spectrum-phy.h (module 'lte'): ns3::RemSpectrumPhy [class]
     module.add_class('RemSpectrumPhy', parent=root_module['ns3::SpectrumPhy'])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::RrComponentCarrierManager [class]
-    module.add_class('RrComponentCarrierManager', parent=root_module['ns3::NoOpComponentCarrierManager'])
     ## rr-ff-mac-scheduler.h (module 'lte'): ns3::RrFfMacScheduler [class]
     module.add_class('RrFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcAsn1Header [class]
@@ -1334,10 +1396,12 @@
     module.add_class('RrcUlCcchMessage', parent=root_module['ns3::RrcAsn1Header'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcUlDcchMessage [class]
     module.add_class('RrcUlDcchMessage', parent=root_module['ns3::RrcAsn1Header'])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo [class]
+    module.add_class('S1apConnectionInfo', parent=root_module['ns3::SimpleRefCount< ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >'])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo [class]
+    module.add_class('S1apIfaceInfo', parent=root_module['ns3::SimpleRefCount< ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >'])
     ## lte-control-messages.h (module 'lte'): ns3::Sib1LteControlMessage [class]
     module.add_class('Sib1LteControlMessage', parent=root_module['ns3::LteControlMessage'])
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::SimpleUeComponentCarrierManager [class]
-    module.add_class('SimpleUeComponentCarrierManager', parent=root_module['ns3::LteUeComponentCarrierManager'])
     ## spectrum-channel.h (module 'spectrum'): ns3::SpectrumChannel [class]
     module.add_class('SpectrumChannel', import_from_module='ns.spectrum', parent=root_module['ns3::Channel'])
     ## lte-vendor-specific-parameters.h (module 'lte'): ns3::SrsCqiRntiVsp [class]
@@ -1394,10 +1458,10 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['bool', 'ns3::Ptr<ns3::Socket>', 'const ns3::Address &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['ns3::ObjectBase *', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'bool', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'const ns3::SpectrumValue &', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', template_parameters=['void', 'ns3::DlSchedulingCallbackInfo', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', template_parameters=['void', 'ns3::EpcUeNas::State', 'ns3::EpcUeNas::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1410,6 +1474,10 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::Packet>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::PacketBurst>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'const char *', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<const ns3::QueueDiscItem>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<const ns3::Packet>', 'unsigned short', 'const ns3::Address &', 'const ns3::Address &', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1422,10 +1490,18 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Socket>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Ptr<ns3::Socket>', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::Time', 'ns3::Time', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned int', 'unsigned int', 'unsigned short', 'unsigned char', 'unsigned short', 'unsigned char', 'unsigned short', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned long', 'unsigned short', 'long double', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned long', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1442,10 +1518,12 @@
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'ns3::Ptr<ns3::SpectrumValue>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned int', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned char', 'unsigned int', 'unsigned long', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty> [class]
-    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'double', 'double', 'bool', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'double', 'double', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'double', 'double', 'unsigned char', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
@@ -1456,6 +1534,8 @@
     module.add_class('CallbackImpl', template_parameters=['void', 'unsigned short', 'unsigned short', 'ns3::LteUePhy::State', 'ns3::LteUePhy::State', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
     module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty> [class]
+    module.add_class('CallbackImpl', import_from_module='ns.core', template_parameters=['void', 'unsigned short', 'unsigned short', 'unsigned int', 'unsigned long', 'bool', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'], parent=root_module['ns3::CallbackImplBase'])
     ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqaFfMacScheduler [class]
     module.add_class('CqaFfMacScheduler', parent=root_module['ns3::FfMacScheduler'])
     ## lte-control-messages.h (module 'lte'): ns3::DlCqiLteControlMessage [class]
@@ -1484,6 +1564,10 @@
     module.add_class('LteUeNetDevice', parent=root_module['ns3::LteNetDevice'])
     ## lte-rrc-header.h (module 'lte'): ns3::MeasurementReportHeader [class]
     module.add_class('MeasurementReportHeader', parent=root_module['ns3::RrcUlDcchMessage'])
+    ## queue-item.h (module 'network'): ns3::QueueDiscItem [class]
+    module.add_class('QueueDiscItem', import_from_module='ns.network', parent=root_module['ns3::QueueItem'])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectToMmWaveHeader [class]
+    module.add_class('RrcConnectToMmWaveHeader', parent=root_module['ns3::RrcDlCcchMessage'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationCompleteHeader [class]
     module.add_class('RrcConnectionReconfigurationCompleteHeader', parent=root_module['ns3::RrcUlDcchMessage'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationHeader [class]
@@ -1506,6 +1590,10 @@
     module.add_class('RrcConnectionSetupCompleteHeader', parent=root_module['ns3::RrcUlDcchMessage'])
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSetupHeader [class]
     module.add_class('RrcConnectionSetupHeader', parent=root_module['ns3::RrcDlCcchMessage'])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSwitchHeader [class]
+    module.add_class('RrcConnectionSwitchHeader', parent=root_module['ns3::RrcDlDcchMessage'])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcNotifySecondaryConnectedHeader [class]
+    module.add_class('RrcNotifySecondaryConnectedHeader', parent=root_module['ns3::RrcUlDcchMessage'])
     ## lte-enb-net-device.h (module 'lte'): ns3::LteEnbNetDevice [class]
     module.add_class('LteEnbNetDevice', parent=root_module['ns3::LteNetDevice'])
     module.add_container('std::vector< ns3::CeBitmap_e >', 'ns3::CeBitmap_e', container_type=u'vector')
@@ -1519,20 +1607,22 @@
     module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextToBeCreated >', 'ns3::EpcS11SapSgw::BearerContextToBeCreated', container_type=u'list')
     module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextToBeRemoved >', 'ns3::EpcS11SapSgw::BearerContextToBeRemoved', container_type=u'list')
     module.add_container('std::list< ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw >', 'ns3::EpcS11SapSgw::BearerContextRemovedSgwPgw', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapEnb::ErabToBeSetupItem >', 'ns3::EpcS1apSapEnb::ErabToBeSetupItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem >', 'ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabToBeReleasedIndication >', 'ns3::EpcS1apSapMme::ErabToBeReleasedIndication', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabSetupItem >', 'ns3::EpcS1apSapMme::ErabSetupItem', container_type=u'list')
-    module.add_container('std::list< ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem >', 'ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'ns3::EpcS1apSap::ErabToBeSetupItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'ns3::EpcS1apSap::ErabSwitchedInUplinkItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'ns3::EpcS1apSap::ErabToBeReleasedIndication', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'ns3::EpcS1apSap::ErabSetupItem', container_type=u'list')
+    module.add_container('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'ns3::EpcS1apSap::ErabSwitchedInDownlinkItem', container_type=u'list')
     module.add_container('std::vector< bool >', 'bool', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem >', 'ns3::EpcX2Sap::UlInterferenceOverloadIndicationItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::UlHighInterferenceInformationItem >', 'ns3::EpcX2Sap::UlHighInterferenceInformationItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 'ns3::EpcX2Sap::ErabToBeSetupItem', container_type=u'vector')
+    module.add_container('std::vector< ns3::EpcX2Sap::RlcSetupRequest >', 'ns3::EpcX2Sap::RlcSetupRequest', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 'ns3::EpcX2Sap::ErabAdmittedItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 'ns3::EpcX2Sap::ErabNotAdmittedItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem >', 'ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::CellInformationItem >', 'ns3::EpcX2Sap::CellInformationItem', container_type=u'vector')
     module.add_container('std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 'ns3::EpcX2Sap::CellMeasurementResultItem', container_type=u'vector')
+    module.add_container('std::map< unsigned long, double >', ('long unsigned int', 'double'), container_type=u'map')
     module.add_container('std::vector< ns3::VendorSpecificListElement_s >', 'ns3::VendorSpecificListElement_s', container_type=u'vector')
     module.add_container('std::vector< ns3::LogicalChannelConfigListElement_s >', 'ns3::LogicalChannelConfigListElement_s', container_type=u'vector')
     module.add_container('std::vector< ns3::PagingInfoListElement_s >', 'ns3::PagingInfoListElement_s', container_type=u'vector')
@@ -1548,9 +1638,9 @@
     module.add_container('std::vector< ns3::UlDciListElement_s >', 'ns3::UlDciListElement_s', container_type=u'vector')
     module.add_container('std::vector< ns3::PhichListElement_s >', 'ns3::PhichListElement_s', container_type=u'vector')
     module.add_container('std::map< std::string, ns3::LogComponent * >', ('std::string', 'ns3::LogComponent *'), container_type=u'map')
-    module.add_container('std::vector< ns3::LteCcmRrcSapProvider::LcsConfig >', 'ns3::LteCcmRrcSapProvider::LcsConfig', container_type=u'vector')
-    module.add_container('std::vector< ns3::LteRrcSap::LogicalChannelConfig >', 'ns3::LteRrcSap::LogicalChannelConfig', container_type=u'vector')
     module.add_container('std::map< unsigned short, std::vector< double > >', ('short unsigned int', 'std::vector< double >'), container_type=u'map')
+    module.add_container('std::list< unsigned int >', 'unsigned int', container_type=u'list')
+    module.add_container('std::list< double >', 'double', container_type=u'list')
     module.add_container('std::vector< int >', 'int', container_type=u'vector')
     module.add_container('ns3::HarqProcessInfoList_t', 'ns3::HarqProcessInfoElement_t', container_type=u'vector')
     module.add_container('std::list< ns3::LteRrcSap::SrbToAddMod >', 'ns3::LteRrcSap::SrbToAddMod', container_type=u'list')
@@ -1561,26 +1651,24 @@
     module.add_container('std::list< ns3::LteRrcSap::MeasObjectToAddMod >', 'ns3::LteRrcSap::MeasObjectToAddMod', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::ReportConfigToAddMod >', 'ns3::LteRrcSap::ReportConfigToAddMod', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::MeasIdToAddMod >', 'ns3::LteRrcSap::MeasIdToAddMod', container_type=u'list')
-    module.add_container('std::list< unsigned int >', 'unsigned int', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::MeasResultScell >', 'ns3::LteRrcSap::MeasResultScell', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::MeasResultBestNeighCell >', 'ns3::LteRrcSap::MeasResultBestNeighCell', container_type=u'list')
     module.add_container('std::list< ns3::LteRrcSap::MeasResultEutra >', 'ns3::LteRrcSap::MeasResultEutra', container_type=u'list')
-    module.add_container('std::list< ns3::LteRrcSap::SCellToAddMod >', 'ns3::LteRrcSap::SCellToAddMod', container_type=u'list')
     module.add_container('std::map< int, double >', ('int', 'double'), container_type=u'map')
-    module.add_container('std::vector< ns3::LteUeCcmRrcSapProvider::LcsConfig >', 'ns3::LteUeCcmRrcSapProvider::LcsConfig', container_type=u'vector')
     module.add_container('std::vector< ns3::LteUeCphySapUser::UeMeasurementsElement >', 'ns3::LteUeCphySapUser::UeMeasurementsElement', container_type=u'vector')
     module.add_container('std::vector< ns3::HigherLayerSelected_s >', 'ns3::HigherLayerSelected_s', container_type=u'vector')
     module.add_container('std::vector< ns3::SiMessageListElement_s >', 'ns3::SiMessageListElement_s', container_type=u'vector')
     module.add_container('std::list< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type=u'list')
+    module.add_container('std::map< std::string, unsigned int >', ('std::string', 'unsigned int'), container_type=u'map')
+    module.add_container('std::map< std::string, unsigned long >', ('std::string', 'long unsigned int'), container_type=u'map')
     module.add_container('std::vector< ns3::Ipv6Address >', 'ns3::Ipv6Address', container_type=u'vector')
     module.add_container('std::vector< double >', 'double', container_type=u'vector')
     module.add_container('ns3::Bands', 'ns3::BandInfo', container_type=u'vector')
-    module.add_container('std::map< unsigned char, ns3::ComponentCarrier >', ('unsigned char', 'ns3::ComponentCarrier'), container_type=u'map')
     module.add_container('std::map< unsigned int, unsigned int >', ('unsigned int', 'unsigned int'), container_type=u'map')
-    module.add_container('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', ('unsigned char', 'ns3::Ptr< ns3::ComponentCarrierEnb >'), container_type=u'map')
+    module.add_container('std::map< unsigned long, ns3::LteEnbRrc::HandoverEventInfo >', ('long unsigned int', 'ns3::LteEnbRrc::HandoverEventInfo'), container_type=u'map')
     module.add_container('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'ns3::Ptr< ns3::LteControlMessage >', container_type=u'list')
+    module.add_container('std::vector< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type=u'vector')
+    module.add_container('std::vector< ns3::LteRlcAm::RetxPdu >', 'ns3::LteRlcAm::RetxPdu', container_type=u'vector')
+    module.add_container('std::map< unsigned int, ns3::Ptr< ns3::Packet > >', ('unsigned int', 'ns3::Ptr< ns3::Packet >'), container_type=u'map')
     module.add_container('std::list< ns3::UlDciLteControlMessage >', 'ns3::UlDciLteControlMessage', container_type=u'list')
-    module.add_container('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierUe > >', ('unsigned char', 'ns3::Ptr< ns3::ComponentCarrierUe >'), container_type=u'map')
     typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >', u'ns3::DlHarqProcessesStatus_t')
     typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >*', u'ns3::DlHarqProcessesStatus_t*')
     typehandlers.add_type_alias(u'std::vector< unsigned char, std::allocator< unsigned char > >&', u'ns3::DlHarqProcessesStatus_t&')
@@ -1620,15 +1708,18 @@
     typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::LteFlowId_t, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::LteFlowId_t > > >', u'ns3::FlowIdMap')
     typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::LteFlowId_t, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::LteFlowId_t > > >*', u'ns3::FlowIdMap*')
     typehandlers.add_type_alias(u'std::map< ns3::ImsiLcidPair_t, ns3::LteFlowId_t, std::less< ns3::ImsiLcidPair_t >, std::allocator< std::pair< ns3::ImsiLcidPair_t const, ns3::LteFlowId_t > > >&', u'ns3::FlowIdMap&')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >', u'ns3::DlHarqProcessesBuffer_t')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >*', u'ns3::DlHarqProcessesBuffer_t*')
-    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >&', u'ns3::DlHarqProcessesBuffer_t&')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LteChunkProcessorCallback')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LteChunkProcessorCallback*')
-    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LteChunkProcessorCallback&')
+    typehandlers.add_type_alias(u'std::map< unsigned long, double, std::less< unsigned long >, std::allocator< std::pair< unsigned long const, double > > >', u'ns3::ImsiSinrMap')
+    typehandlers.add_type_alias(u'std::map< unsigned long, double, std::less< unsigned long >, std::allocator< std::pair< unsigned long const, double > > >*', u'ns3::ImsiSinrMap*')
+    typehandlers.add_type_alias(u'std::map< unsigned long, double, std::less< unsigned long >, std::allocator< std::pair< unsigned long const, double > > >&', u'ns3::ImsiSinrMap&')
+    typehandlers.add_type_alias(u'std::map< unsigned short, double, std::less< unsigned short >, std::allocator< std::pair< unsigned short const, double > > >', u'ns3::CellSinrMap')
+    typehandlers.add_type_alias(u'std::map< unsigned short, double, std::less< unsigned short >, std::allocator< std::pair< unsigned short const, double > > >*', u'ns3::CellSinrMap*')
+    typehandlers.add_type_alias(u'std::map< unsigned short, double, std::less< unsigned short >, std::allocator< std::pair< unsigned short const, double > > >&', u'ns3::CellSinrMap&')
     typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t, std::less< ns3::TbId_t >, std::allocator< std::pair< ns3::TbId_t const, ns3::tbInfo_t > > >', u'ns3::expectedTbs_t')
     typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t, std::less< ns3::TbId_t >, std::allocator< std::pair< ns3::TbId_t const, ns3::tbInfo_t > > >*', u'ns3::expectedTbs_t*')
     typehandlers.add_type_alias(u'std::map< ns3::TbId_t, ns3::tbInfo_t, std::less< ns3::TbId_t >, std::allocator< std::pair< ns3::TbId_t const, ns3::tbInfo_t > > >&', u'ns3::expectedTbs_t&')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyTxEndCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyTxEndCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyTxEndCallback&')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LtePhyRxDataEndErrorCallback')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LtePhyRxDataEndErrorCallback*')
     typehandlers.add_type_alias(u'ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LtePhyRxDataEndErrorCallback&')
@@ -1695,6 +1786,12 @@
     typehandlers.add_type_alias(u'uint32_t', u'ns3::SpectrumModelUid_t')
     typehandlers.add_type_alias(u'uint32_t*', u'ns3::SpectrumModelUid_t*')
     typehandlers.add_type_alias(u'uint32_t&', u'ns3::SpectrumModelUid_t&')
+    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >', u'ns3::DlHarqProcessesBuffer_t')
+    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >*', u'ns3::DlHarqProcessesBuffer_t*')
+    typehandlers.add_type_alias(u'std::vector< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > >, std::allocator< std::vector< ns3::Ptr< ns3::PacketBurst >, std::allocator< ns3::Ptr< ns3::PacketBurst > > > > >&', u'ns3::DlHarqProcessesBuffer_t&')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', u'ns3::LteChunkProcessorCallback')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >*', u'ns3::LteChunkProcessorCallback*')
+    typehandlers.add_type_alias(u'ns3::Callback< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >&', u'ns3::LteChunkProcessorCallback&')
     
     ## Register a nested module for the namespace Config
     
@@ -1842,6 +1939,9 @@
     register_Ns3DefaultDeleter__Ns3LteHarqPhy_methods(root_module, root_module['ns3::DefaultDeleter< ns3::LteHarqPhy >'])
     register_Ns3DefaultDeleter__Ns3NixVector_methods(root_module, root_module['ns3::DefaultDeleter< ns3::NixVector >'])
     register_Ns3DefaultDeleter__Ns3Packet_methods(root_module, root_module['ns3::DefaultDeleter< ns3::Packet >'])
+    register_Ns3DefaultDeleter__Ns3QueueItem_methods(root_module, root_module['ns3::DefaultDeleter< ns3::QueueItem >'])
+    register_Ns3DefaultDeleter__Ns3S1apConnectionInfo_methods(root_module, root_module['ns3::DefaultDeleter< ns3::S1apConnectionInfo >'])
+    register_Ns3DefaultDeleter__Ns3S1apIfaceInfo_methods(root_module, root_module['ns3::DefaultDeleter< ns3::S1apIfaceInfo >'])
     register_Ns3DefaultDeleter__Ns3SpectrumModel_methods(root_module, root_module['ns3::DefaultDeleter< ns3::SpectrumModel >'])
     register_Ns3DefaultDeleter__Ns3SpectrumValue_methods(root_module, root_module['ns3::DefaultDeleter< ns3::SpectrumValue >'])
     register_Ns3DefaultDeleter__Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::DefaultDeleter< ns3::TraceSourceAccessor >'])
@@ -1877,13 +1977,15 @@
     register_Ns3EpcS11SapSgwDeleteBearerResponseMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::DeleteBearerResponseMessage'])
     register_Ns3EpcS11SapSgwModifyBearerRequestMessage_methods(root_module, root_module['ns3::EpcS11SapSgw::ModifyBearerRequestMessage'])
     register_Ns3EpcS1apSap_methods(root_module, root_module['ns3::EpcS1apSap'])
+    register_Ns3EpcS1apSapErabSetupItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabSetupItem'])
+    register_Ns3EpcS1apSapErabSwitchedInDownlinkItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabSwitchedInDownlinkItem'])
+    register_Ns3EpcS1apSapErabSwitchedInUplinkItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabSwitchedInUplinkItem'])
+    register_Ns3EpcS1apSapErabToBeReleasedIndication_methods(root_module, root_module['ns3::EpcS1apSap::ErabToBeReleasedIndication'])
+    register_Ns3EpcS1apSapErabToBeSetupItem_methods(root_module, root_module['ns3::EpcS1apSap::ErabToBeSetupItem'])
     register_Ns3EpcS1apSapEnb_methods(root_module, root_module['ns3::EpcS1apSapEnb'])
-    register_Ns3EpcS1apSapEnbErabSwitchedInUplinkItem_methods(root_module, root_module['ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem'])
-    register_Ns3EpcS1apSapEnbErabToBeSetupItem_methods(root_module, root_module['ns3::EpcS1apSapEnb::ErabToBeSetupItem'])
+    register_Ns3EpcS1apSapEnbProvider_methods(root_module, root_module['ns3::EpcS1apSapEnbProvider'])
     register_Ns3EpcS1apSapMme_methods(root_module, root_module['ns3::EpcS1apSapMme'])
-    register_Ns3EpcS1apSapMmeErabSetupItem_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabSetupItem'])
-    register_Ns3EpcS1apSapMmeErabSwitchedInDownlinkItem_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem'])
-    register_Ns3EpcS1apSapMmeErabToBeReleasedIndication_methods(root_module, root_module['ns3::EpcS1apSapMme::ErabToBeReleasedIndication'])
+    register_Ns3EpcS1apSapMmeProvider_methods(root_module, root_module['ns3::EpcS1apSapMmeProvider'])
     register_Ns3EpcX2Sap_methods(root_module, root_module['ns3::EpcX2Sap'])
     register_Ns3EpcX2SapCellInformationItem_methods(root_module, root_module['ns3::EpcX2Sap::CellInformationItem'])
     register_Ns3EpcX2SapCellMeasurementResultItem_methods(root_module, root_module['ns3::EpcX2Sap::CellMeasurementResultItem'])
@@ -1892,15 +1994,21 @@
     register_Ns3EpcX2SapErabNotAdmittedItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabNotAdmittedItem'])
     register_Ns3EpcX2SapErabToBeSetupItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabToBeSetupItem'])
     register_Ns3EpcX2SapErabsSubjectToStatusTransferItem_methods(root_module, root_module['ns3::EpcX2Sap::ErabsSubjectToStatusTransferItem'])
+    register_Ns3EpcX2SapHandoverFailedParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverFailedParams'])
     register_Ns3EpcX2SapHandoverPreparationFailureParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverPreparationFailureParams'])
     register_Ns3EpcX2SapHandoverRequestAckParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverRequestAckParams'])
     register_Ns3EpcX2SapHandoverRequestParams_methods(root_module, root_module['ns3::EpcX2Sap::HandoverRequestParams'])
     register_Ns3EpcX2SapLoadInformationParams_methods(root_module, root_module['ns3::EpcX2Sap::LoadInformationParams'])
     register_Ns3EpcX2SapRelativeNarrowbandTxBand_methods(root_module, root_module['ns3::EpcX2Sap::RelativeNarrowbandTxBand'])
     register_Ns3EpcX2SapResourceStatusUpdateParams_methods(root_module, root_module['ns3::EpcX2Sap::ResourceStatusUpdateParams'])
+    register_Ns3EpcX2SapRlcSetupRequest_methods(root_module, root_module['ns3::EpcX2Sap::RlcSetupRequest'])
+    register_Ns3EpcX2SapSecondaryHandoverCompletedParams_methods(root_module, root_module['ns3::EpcX2Sap::SecondaryHandoverCompletedParams'])
+    register_Ns3EpcX2SapSecondaryHandoverParams_methods(root_module, root_module['ns3::EpcX2Sap::SecondaryHandoverParams'])
     register_Ns3EpcX2SapSnStatusTransferParams_methods(root_module, root_module['ns3::EpcX2Sap::SnStatusTransferParams'])
+    register_Ns3EpcX2SapSwitchConnectionParams_methods(root_module, root_module['ns3::EpcX2Sap::SwitchConnectionParams'])
     register_Ns3EpcX2SapUeContextReleaseParams_methods(root_module, root_module['ns3::EpcX2Sap::UeContextReleaseParams'])
     register_Ns3EpcX2SapUeDataParams_methods(root_module, root_module['ns3::EpcX2Sap::UeDataParams'])
+    register_Ns3EpcX2SapUeImsiSinrParams_methods(root_module, root_module['ns3::EpcX2Sap::UeImsiSinrParams'])
     register_Ns3EpcX2SapUlHighInterferenceInformationItem_methods(root_module, root_module['ns3::EpcX2Sap::UlHighInterferenceInformationItem'])
     register_Ns3EpcX2SapProvider_methods(root_module, root_module['ns3::EpcX2SapProvider'])
     register_Ns3EpcX2SapUser_methods(root_module, root_module['ns3::EpcX2SapUser'])
@@ -1956,10 +2064,6 @@
     register_Ns3LteAnrSapUser_methods(root_module, root_module['ns3::LteAnrSapUser'])
     register_Ns3LteAsSapProvider_methods(root_module, root_module['ns3::LteAsSapProvider'])
     register_Ns3LteAsSapUser_methods(root_module, root_module['ns3::LteAsSapUser'])
-    register_Ns3LteCcmMacSapProvider_methods(root_module, root_module['ns3::LteCcmMacSapProvider'])
-    register_Ns3LteCcmRrcSapProvider_methods(root_module, root_module['ns3::LteCcmRrcSapProvider'])
-    register_Ns3LteCcmRrcSapProviderLcsConfig_methods(root_module, root_module['ns3::LteCcmRrcSapProvider::LcsConfig'])
-    register_Ns3LteCcmRrcSapUser_methods(root_module, root_module['ns3::LteCcmRrcSapUser'])
     register_Ns3LteEnbCmacSapProvider_methods(root_module, root_module['ns3::LteEnbCmacSapProvider'])
     register_Ns3LteEnbCmacSapProviderAllocateNcRaPreambleReturnValue_methods(root_module, root_module['ns3::LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue'])
     register_Ns3LteEnbCmacSapProviderLcInfo_methods(root_module, root_module['ns3::LteEnbCmacSapProvider::LcInfo'])
@@ -1969,6 +2073,7 @@
     register_Ns3LteEnbCmacSapUserUeConfig_methods(root_module, root_module['ns3::LteEnbCmacSapUser::UeConfig'])
     register_Ns3LteEnbCphySapProvider_methods(root_module, root_module['ns3::LteEnbCphySapProvider'])
     register_Ns3LteEnbCphySapUser_methods(root_module, root_module['ns3::LteEnbCphySapUser'])
+    register_Ns3LteEnbCphySapUserUeAssociatedSinrInfo_methods(root_module, root_module['ns3::LteEnbCphySapUser::UeAssociatedSinrInfo'])
     register_Ns3LteEnbPhySapProvider_methods(root_module, root_module['ns3::LteEnbPhySapProvider'])
     register_Ns3LteEnbPhySapUser_methods(root_module, root_module['ns3::LteEnbPhySapUser'])
     register_Ns3LteFfConverter_methods(root_module, root_module['ns3::LteFfConverter'])
@@ -1992,16 +2097,14 @@
     register_Ns3LteRlcSapProvider_methods(root_module, root_module['ns3::LteRlcSapProvider'])
     register_Ns3LteRlcSapProviderTransmitPdcpPduParameters_methods(root_module, root_module['ns3::LteRlcSapProvider::TransmitPdcpPduParameters'])
     register_Ns3LteRlcSapUser_methods(root_module, root_module['ns3::LteRlcSapUser'])
+    register_Ns3LteRlcSpecificLteMacSapUser_methods(root_module, root_module['ns3::LteRlcSpecificLteMacSapUser'])
     register_Ns3LteRrcSap_methods(root_module, root_module['ns3::LteRrcSap'])
-    register_Ns3LteRrcSapAntennaInfoCommon_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoCommon'])
     register_Ns3LteRrcSapAntennaInfoDedicated_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoDedicated'])
-    register_Ns3LteRrcSapAntennaInfoUl_methods(root_module, root_module['ns3::LteRrcSap::AntennaInfoUl'])
     register_Ns3LteRrcSapAsConfig_methods(root_module, root_module['ns3::LteRrcSap::AsConfig'])
     register_Ns3LteRrcSapBlackCellsToAddMod_methods(root_module, root_module['ns3::LteRrcSap::BlackCellsToAddMod'])
     register_Ns3LteRrcSapCarrierBandwidthEutra_methods(root_module, root_module['ns3::LteRrcSap::CarrierBandwidthEutra'])
     register_Ns3LteRrcSapCarrierFreqEutra_methods(root_module, root_module['ns3::LteRrcSap::CarrierFreqEutra'])
     register_Ns3LteRrcSapCellAccessRelatedInfo_methods(root_module, root_module['ns3::LteRrcSap::CellAccessRelatedInfo'])
-    register_Ns3LteRrcSapCellIdentification_methods(root_module, root_module['ns3::LteRrcSap::CellIdentification'])
     register_Ns3LteRrcSapCellSelectionInfo_methods(root_module, root_module['ns3::LteRrcSap::CellSelectionInfo'])
     register_Ns3LteRrcSapCellsToAddMod_methods(root_module, root_module['ns3::LteRrcSap::CellsToAddMod'])
     register_Ns3LteRrcSapCgiInfo_methods(root_module, root_module['ns3::LteRrcSap::CgiInfo'])
@@ -2015,34 +2118,24 @@
     register_Ns3LteRrcSapMeasIdToAddMod_methods(root_module, root_module['ns3::LteRrcSap::MeasIdToAddMod'])
     register_Ns3LteRrcSapMeasObjectEutra_methods(root_module, root_module['ns3::LteRrcSap::MeasObjectEutra'])
     register_Ns3LteRrcSapMeasObjectToAddMod_methods(root_module, root_module['ns3::LteRrcSap::MeasObjectToAddMod'])
-    register_Ns3LteRrcSapMeasResultBestNeighCell_methods(root_module, root_module['ns3::LteRrcSap::MeasResultBestNeighCell'])
     register_Ns3LteRrcSapMeasResultEutra_methods(root_module, root_module['ns3::LteRrcSap::MeasResultEutra'])
-    register_Ns3LteRrcSapMeasResultScell_methods(root_module, root_module['ns3::LteRrcSap::MeasResultScell'])
-    register_Ns3LteRrcSapMeasResultServFreqList_methods(root_module, root_module['ns3::LteRrcSap::MeasResultServFreqList'])
     register_Ns3LteRrcSapMeasResults_methods(root_module, root_module['ns3::LteRrcSap::MeasResults'])
     register_Ns3LteRrcSapMeasurementReport_methods(root_module, root_module['ns3::LteRrcSap::MeasurementReport'])
     register_Ns3LteRrcSapMobilityControlInfo_methods(root_module, root_module['ns3::LteRrcSap::MobilityControlInfo'])
     register_Ns3LteRrcSapMobilityStateParameters_methods(root_module, root_module['ns3::LteRrcSap::MobilityStateParameters'])
-    register_Ns3LteRrcSapNonCriticalExtensionConfiguration_methods(root_module, root_module['ns3::LteRrcSap::NonCriticalExtensionConfiguration'])
-    register_Ns3LteRrcSapNonUlConfiguration_methods(root_module, root_module['ns3::LteRrcSap::NonUlConfiguration'])
     register_Ns3LteRrcSapPdschConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::PdschConfigCommon'])
     register_Ns3LteRrcSapPdschConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::PdschConfigDedicated'])
     register_Ns3LteRrcSapPhysCellIdRange_methods(root_module, root_module['ns3::LteRrcSap::PhysCellIdRange'])
     register_Ns3LteRrcSapPhysicalConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::PhysicalConfigDedicated'])
-    register_Ns3LteRrcSapPhysicalConfigDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::PhysicalConfigDedicatedSCell'])
     register_Ns3LteRrcSapPlmnIdentityInfo_methods(root_module, root_module['ns3::LteRrcSap::PlmnIdentityInfo'])
-    register_Ns3LteRrcSapPrachConfigSCell_methods(root_module, root_module['ns3::LteRrcSap::PrachConfigSCell'])
     register_Ns3LteRrcSapPreambleInfo_methods(root_module, root_module['ns3::LteRrcSap::PreambleInfo'])
-    register_Ns3LteRrcSapPuschConfigDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::PuschConfigDedicatedSCell'])
     register_Ns3LteRrcSapQuantityConfig_methods(root_module, root_module['ns3::LteRrcSap::QuantityConfig'])
     register_Ns3LteRrcSapRaSupervisionInfo_methods(root_module, root_module['ns3::LteRrcSap::RaSupervisionInfo'])
     register_Ns3LteRrcSapRachConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::RachConfigCommon'])
     register_Ns3LteRrcSapRachConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::RachConfigDedicated'])
     register_Ns3LteRrcSapRadioResourceConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigCommon'])
-    register_Ns3LteRrcSapRadioResourceConfigCommonSCell_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigCommonSCell'])
     register_Ns3LteRrcSapRadioResourceConfigCommonSib_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigCommonSib'])
     register_Ns3LteRrcSapRadioResourceConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigDedicated'])
-    register_Ns3LteRrcSapRadioResourceConfigDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::RadioResourceConfigDedicatedSCell'])
     register_Ns3LteRrcSapReestabUeIdentity_methods(root_module, root_module['ns3::LteRrcSap::ReestabUeIdentity'])
     register_Ns3LteRrcSapReportConfigEutra_methods(root_module, root_module['ns3::LteRrcSap::ReportConfigEutra'])
     register_Ns3LteRrcSapReportConfigToAddMod_methods(root_module, root_module['ns3::LteRrcSap::ReportConfigToAddMod'])
@@ -2058,7 +2151,7 @@
     register_Ns3LteRrcSapRrcConnectionRequest_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionRequest'])
     register_Ns3LteRrcSapRrcConnectionSetup_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSetup'])
     register_Ns3LteRrcSapRrcConnectionSetupCompleted_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSetupCompleted'])
-    register_Ns3LteRrcSapSCellToAddMod_methods(root_module, root_module['ns3::LteRrcSap::SCellToAddMod'])
+    register_Ns3LteRrcSapRrcConnectionSwitch_methods(root_module, root_module['ns3::LteRrcSap::RrcConnectionSwitch'])
     register_Ns3LteRrcSapSoundingRsUlConfigCommon_methods(root_module, root_module['ns3::LteRrcSap::SoundingRsUlConfigCommon'])
     register_Ns3LteRrcSapSoundingRsUlConfigDedicated_methods(root_module, root_module['ns3::LteRrcSap::SoundingRsUlConfigDedicated'])
     register_Ns3LteRrcSapSpeedStatePars_methods(root_module, root_module['ns3::LteRrcSap::SpeedStatePars'])
@@ -2068,14 +2161,8 @@
     register_Ns3LteRrcSapSystemInformationBlockType1_methods(root_module, root_module['ns3::LteRrcSap::SystemInformationBlockType1'])
     register_Ns3LteRrcSapSystemInformationBlockType2_methods(root_module, root_module['ns3::LteRrcSap::SystemInformationBlockType2'])
     register_Ns3LteRrcSapThresholdEutra_methods(root_module, root_module['ns3::LteRrcSap::ThresholdEutra'])
-    register_Ns3LteRrcSapUlConfiguration_methods(root_module, root_module['ns3::LteRrcSap::UlConfiguration'])
-    register_Ns3LteRrcSapUlPowerControlCommonSCell_methods(root_module, root_module['ns3::LteRrcSap::UlPowerControlCommonSCell'])
-    register_Ns3LteRrcSapUlPowerControlDedicatedSCell_methods(root_module, root_module['ns3::LteRrcSap::UlPowerControlDedicatedSCell'])
     register_Ns3LteSpectrumValueCatcher_methods(root_module, root_module['ns3::LteSpectrumValueCatcher'])
     register_Ns3LteSpectrumValueHelper_methods(root_module, root_module['ns3::LteSpectrumValueHelper'])
-    register_Ns3LteUeCcmRrcSapProvider_methods(root_module, root_module['ns3::LteUeCcmRrcSapProvider'])
-    register_Ns3LteUeCcmRrcSapProviderLcsConfig_methods(root_module, root_module['ns3::LteUeCcmRrcSapProvider::LcsConfig'])
-    register_Ns3LteUeCcmRrcSapUser_methods(root_module, root_module['ns3::LteUeCcmRrcSapUser'])
     register_Ns3LteUeCmacSapProvider_methods(root_module, root_module['ns3::LteUeCmacSapProvider'])
     register_Ns3LteUeCmacSapProviderLogicalChannelConfig_methods(root_module, root_module['ns3::LteUeCmacSapProvider::LogicalChannelConfig'])
     register_Ns3LteUeCmacSapProviderRachConfig_methods(root_module, root_module['ns3::LteUeCmacSapProvider::RachConfig'])
@@ -2131,6 +2218,8 @@
     register_Ns3TbId_t_methods(root_module, root_module['ns3::TbId_t'])
     register_Ns3TbStats_t_methods(root_module, root_module['ns3::TbStats_t'])
     register_Ns3TimeWithUnit_methods(root_module, root_module['ns3::TimeWithUnit'])
+    register_Ns3TracedValue__Bool_methods(root_module, root_module['ns3::TracedValue< bool >'])
+    register_Ns3TracedValue__Unsigned_int_methods(root_module, root_module['ns3::TracedValue< unsigned int >'])
     register_Ns3TransmissionModesLayers_methods(root_module, root_module['ns3::TransmissionModesLayers'])
     register_Ns3TypeId_methods(root_module, root_module['ns3::TypeId'])
     register_Ns3TypeIdAttributeInformation_methods(root_module, root_module['ns3::TypeId::AttributeInformation'])
@@ -2156,10 +2245,14 @@
     register_Ns3TdtbfqsFlowPerf_t_methods(root_module, root_module['ns3::tdtbfqsFlowPerf_t'])
     register_Ns3Chunk_methods(root_module, root_module['ns3::Chunk'])
     register_Ns3DownlinkLteGlobalPathlossDatabase_methods(root_module, root_module['ns3::DownlinkLteGlobalPathlossDatabase'])
+    register_Ns3EpcX2PdcpProvider_methods(root_module, root_module['ns3::EpcX2PdcpProvider'])
+    register_Ns3EpcX2PdcpUser_methods(root_module, root_module['ns3::EpcX2PdcpUser'])
+    register_Ns3EpcX2RlcProvider_methods(root_module, root_module['ns3::EpcX2RlcProvider'])
+    register_Ns3EpcX2RlcUser_methods(root_module, root_module['ns3::EpcX2RlcUser'])
+    register_Ns3EpcX2Tag_methods(root_module, root_module['ns3::EpcX2Tag'])
     register_Ns3EpsBearerTag_methods(root_module, root_module['ns3::EpsBearerTag'])
     register_Ns3Header_methods(root_module, root_module['ns3::Header'])
     register_Ns3Ipv4Header_methods(root_module, root_module['ns3::Ipv4Header'])
-    register_Ns3LteCcmMacSapUser_methods(root_module, root_module['ns3::LteCcmMacSapUser'])
     register_Ns3LteEnbRrcSapProvider_methods(root_module, root_module['ns3::LteEnbRrcSapProvider'])
     register_Ns3LteEnbRrcSapProviderCompleteSetupUeParameters_methods(root_module, root_module['ns3::LteEnbRrcSapProvider::CompleteSetupUeParameters'])
     register_Ns3LteEnbRrcSapUser_methods(root_module, root_module['ns3::LteEnbRrcSapUser'])
@@ -2173,9 +2266,15 @@
     register_Ns3Object_methods(root_module, root_module['ns3::Object'])
     register_Ns3ObjectAggregateIterator_methods(root_module, root_module['ns3::Object::AggregateIterator'])
     register_Ns3PacketBurst_methods(root_module, root_module['ns3::PacketBurst'])
+    register_Ns3PacketFilter_methods(root_module, root_module['ns3::PacketFilter'])
     register_Ns3PdcpTag_methods(root_module, root_module['ns3::PdcpTag'])
+    register_Ns3QueueDisc_methods(root_module, root_module['ns3::QueueDisc'])
+    register_Ns3QueueDiscStats_methods(root_module, root_module['ns3::QueueDisc::Stats'])
+    register_Ns3QueueDiscClass_methods(root_module, root_module['ns3::QueueDiscClass'])
     register_Ns3RadioEnvironmentMapHelper_methods(root_module, root_module['ns3::RadioEnvironmentMapHelper'])
     register_Ns3RandomVariableStream_methods(root_module, root_module['ns3::RandomVariableStream'])
+    register_Ns3RetxStatsCalculator_methods(root_module, root_module['ns3::RetxStatsCalculator'])
+    register_Ns3RlcBearerInfo_methods(root_module, root_module['ns3::RlcBearerInfo'])
     register_Ns3RlcTag_methods(root_module, root_module['ns3::RlcTag'])
     register_Ns3SequentialRandomVariable_methods(root_module, root_module['ns3::SequentialRandomVariable'])
     register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
@@ -2193,6 +2292,9 @@
     register_Ns3SimpleRefCount__Ns3LteHarqPhy_Ns3Empty_Ns3DefaultDeleter__lt__ns3LteHarqPhy__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::LteHarqPhy, ns3::empty, ns3::DefaultDeleter<ns3::LteHarqPhy> >'])
     register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
     register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
+    register_Ns3SimpleRefCount__Ns3QueueItem_Ns3Empty_Ns3DefaultDeleter__lt__ns3QueueItem__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >'])
+    register_Ns3SimpleRefCount__Ns3S1apConnectionInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apConnectionInfo__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >'])
+    register_Ns3SimpleRefCount__Ns3S1apIfaceInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apIfaceInfo__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >'])
     register_Ns3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >'])
     register_Ns3SimpleRefCount__Ns3SpectrumSignalParameters_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumSignalParameters__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumSignalParameters, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumSignalParameters> >'])
     register_Ns3SimpleRefCount__Ns3SpectrumValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::SpectrumValue, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumValue> >'])
@@ -2216,6 +2318,7 @@
     register_Ns3Time_methods(root_module, root_module['ns3::Time'])
     register_Ns3TraceFadingLossModel_methods(root_module, root_module['ns3::TraceFadingLossModel'])
     register_Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::TraceSourceAccessor'])
+    register_Ns3TracedValue__Ns3Time_methods(root_module, root_module['ns3::TracedValue< ns3::Time >'])
     register_Ns3Trailer_methods(root_module, root_module['ns3::Trailer'])
     register_Ns3TriangularRandomVariable_methods(root_module, root_module['ns3::TriangularRandomVariable'])
     register_Ns3UeManager_methods(root_module, root_module['ns3::UeManager'])
@@ -2236,11 +2339,8 @@
     register_Ns3CallbackChecker_methods(root_module, root_module['ns3::CallbackChecker'])
     register_Ns3CallbackImplBase_methods(root_module, root_module['ns3::CallbackImplBase'])
     register_Ns3CallbackValue_methods(root_module, root_module['ns3::CallbackValue'])
-    register_Ns3CcHelper_methods(root_module, root_module['ns3::CcHelper'])
     register_Ns3Channel_methods(root_module, root_module['ns3::Channel'])
-    register_Ns3ComponentCarrier_methods(root_module, root_module['ns3::ComponentCarrier'])
-    register_Ns3ComponentCarrierEnb_methods(root_module, root_module['ns3::ComponentCarrierEnb'])
-    register_Ns3ComponentCarrierUe_methods(root_module, root_module['ns3::ComponentCarrierUe'])
+    register_Ns3CoDelQueueDisc_methods(root_module, root_module['ns3::CoDelQueueDisc'])
     register_Ns3ConstantRandomVariable_methods(root_module, root_module['ns3::ConstantRandomVariable'])
     register_Ns3DataCalculator_methods(root_module, root_module['ns3::DataCalculator'])
     register_Ns3DataOutputInterface_methods(root_module, root_module['ns3::DataOutputInterface'])
@@ -2258,20 +2358,37 @@
     register_Ns3EpcEnbApplicationEpsFlowId_t_methods(root_module, root_module['ns3::EpcEnbApplication::EpsFlowId_t'])
     register_Ns3EpcHelper_methods(root_module, root_module['ns3::EpcHelper'])
     register_Ns3EpcMme_methods(root_module, root_module['ns3::EpcMme'])
+    register_Ns3EpcMmeApplication_methods(root_module, root_module['ns3::EpcMmeApplication'])
+    register_Ns3EpcS1APErabReleaseIndicationHeader_methods(root_module, root_module['ns3::EpcS1APErabReleaseIndicationHeader'])
+    register_Ns3EpcS1APHeader_methods(root_module, root_module['ns3::EpcS1APHeader'])
+    register_Ns3EpcS1APInitialContextSetupRequestHeader_methods(root_module, root_module['ns3::EpcS1APInitialContextSetupRequestHeader'])
+    register_Ns3EpcS1APInitialContextSetupResponseHeader_methods(root_module, root_module['ns3::EpcS1APInitialContextSetupResponseHeader'])
+    register_Ns3EpcS1APInitialUeMessageHeader_methods(root_module, root_module['ns3::EpcS1APInitialUeMessageHeader'])
+    register_Ns3EpcS1APPathSwitchRequestAcknowledgeHeader_methods(root_module, root_module['ns3::EpcS1APPathSwitchRequestAcknowledgeHeader'])
+    register_Ns3EpcS1APPathSwitchRequestHeader_methods(root_module, root_module['ns3::EpcS1APPathSwitchRequestHeader'])
+    register_Ns3EpcS1apEnb_methods(root_module, root_module['ns3::EpcS1apEnb'])
+    register_Ns3EpcS1apMme_methods(root_module, root_module['ns3::EpcS1apMme'])
     register_Ns3EpcSgwPgwApplication_methods(root_module, root_module['ns3::EpcSgwPgwApplication'])
     register_Ns3EpcTft_methods(root_module, root_module['ns3::EpcTft'])
     register_Ns3EpcTftPacketFilter_methods(root_module, root_module['ns3::EpcTft::PacketFilter'])
     register_Ns3EpcTftClassifier_methods(root_module, root_module['ns3::EpcTftClassifier'])
     register_Ns3EpcUeNas_methods(root_module, root_module['ns3::EpcUeNas'])
     register_Ns3EpcX2_methods(root_module, root_module['ns3::EpcX2'])
+    register_Ns3EpcX2ConnectionSwitchHeader_methods(root_module, root_module['ns3::EpcX2ConnectionSwitchHeader'])
     register_Ns3EpcX2HandoverPreparationFailureHeader_methods(root_module, root_module['ns3::EpcX2HandoverPreparationFailureHeader'])
     register_Ns3EpcX2HandoverRequestAckHeader_methods(root_module, root_module['ns3::EpcX2HandoverRequestAckHeader'])
     register_Ns3EpcX2HandoverRequestHeader_methods(root_module, root_module['ns3::EpcX2HandoverRequestHeader'])
     register_Ns3EpcX2Header_methods(root_module, root_module['ns3::EpcX2Header'])
     register_Ns3EpcX2LoadInformationHeader_methods(root_module, root_module['ns3::EpcX2LoadInformationHeader'])
+    register_Ns3EpcX2McHandoverHeader_methods(root_module, root_module['ns3::EpcX2McHandoverHeader'])
+    register_Ns3EpcX2NotifyCoordinatorHandoverFailedHeader_methods(root_module, root_module['ns3::EpcX2NotifyCoordinatorHandoverFailedHeader'])
     register_Ns3EpcX2ResourceStatusUpdateHeader_methods(root_module, root_module['ns3::EpcX2ResourceStatusUpdateHeader'])
+    register_Ns3EpcX2RlcSetupCompletedHeader_methods(root_module, root_module['ns3::EpcX2RlcSetupCompletedHeader'])
+    register_Ns3EpcX2RlcSetupRequestHeader_methods(root_module, root_module['ns3::EpcX2RlcSetupRequestHeader'])
+    register_Ns3EpcX2SecondaryCellHandoverCompletedHeader_methods(root_module, root_module['ns3::EpcX2SecondaryCellHandoverCompletedHeader'])
     register_Ns3EpcX2SnStatusTransferHeader_methods(root_module, root_module['ns3::EpcX2SnStatusTransferHeader'])
     register_Ns3EpcX2UeContextReleaseHeader_methods(root_module, root_module['ns3::EpcX2UeContextReleaseHeader'])
+    register_Ns3EpcX2UeImsiSinrUpdateHeader_methods(root_module, root_module['ns3::EpcX2UeImsiSinrUpdateHeader'])
     register_Ns3ErlangRandomVariable_methods(root_module, root_module['ns3::ErlangRandomVariable'])
     register_Ns3EventImpl_methods(root_module, root_module['ns3::EventImpl'])
     register_Ns3ExponentialRandomVariable_methods(root_module, root_module['ns3::ExponentialRandomVariable'])
@@ -2295,9 +2412,9 @@
     register_Ns3LteAnr_methods(root_module, root_module['ns3::LteAnr'])
     register_Ns3LteChunkProcessor_methods(root_module, root_module['ns3::LteChunkProcessor'])
     register_Ns3LteControlMessage_methods(root_module, root_module['ns3::LteControlMessage'])
-    register_Ns3LteEnbComponentCarrierManager_methods(root_module, root_module['ns3::LteEnbComponentCarrierManager'])
     register_Ns3LteEnbMac_methods(root_module, root_module['ns3::LteEnbMac'])
     register_Ns3LteEnbRrc_methods(root_module, root_module['ns3::LteEnbRrc'])
+    register_Ns3LteEnbRrcHandoverEventInfo_methods(root_module, root_module['ns3::LteEnbRrc::HandoverEventInfo'])
     register_Ns3LteEnbRrcProtocolIdeal_methods(root_module, root_module['ns3::LteEnbRrcProtocolIdeal'])
     register_Ns3LteEnbRrcProtocolReal_methods(root_module, root_module['ns3::LteEnbRrcProtocolReal'])
     register_Ns3LteFfrAlgorithm_methods(root_module, root_module['ns3::LteFfrAlgorithm'])
@@ -2319,9 +2436,11 @@
     register_Ns3LteRadioBearerInfo_methods(root_module, root_module['ns3::LteRadioBearerInfo'])
     register_Ns3LteRlc_methods(root_module, root_module['ns3::LteRlc'])
     register_Ns3LteRlcAm_methods(root_module, root_module['ns3::LteRlcAm'])
+    register_Ns3LteRlcAmRetxPdu_methods(root_module, root_module['ns3::LteRlcAm::RetxPdu'])
     register_Ns3LteRlcSm_methods(root_module, root_module['ns3::LteRlcSm'])
     register_Ns3LteRlcTm_methods(root_module, root_module['ns3::LteRlcTm'])
     register_Ns3LteRlcUm_methods(root_module, root_module['ns3::LteRlcUm'])
+    register_Ns3LteRlcUmLowLat_methods(root_module, root_module['ns3::LteRlcUmLowLat'])
     register_Ns3LteSignalingRadioBearerInfo_methods(root_module, root_module['ns3::LteSignalingRadioBearerInfo'])
     register_Ns3LteSpectrumPhy_methods(root_module, root_module['ns3::LteSpectrumPhy'])
     register_Ns3LteSpectrumSignalParameters_methods(root_module, root_module['ns3::LteSpectrumSignalParameters'])
@@ -2329,7 +2448,6 @@
     register_Ns3LteSpectrumSignalParametersDlCtrlFrame_methods(root_module, root_module['ns3::LteSpectrumSignalParametersDlCtrlFrame'])
     register_Ns3LteSpectrumSignalParametersUlSrsFrame_methods(root_module, root_module['ns3::LteSpectrumSignalParametersUlSrsFrame'])
     register_Ns3LteStatsCalculator_methods(root_module, root_module['ns3::LteStatsCalculator'])
-    register_Ns3LteUeComponentCarrierManager_methods(root_module, root_module['ns3::LteUeComponentCarrierManager'])
     register_Ns3LteUeMac_methods(root_module, root_module['ns3::LteUeMac'])
     register_Ns3LteUePhy_methods(root_module, root_module['ns3::LteUePhy'])
     register_Ns3LteUePowerControl_methods(root_module, root_module['ns3::LteUePowerControl'])
@@ -2339,13 +2457,17 @@
     register_Ns3Mac48AddressChecker_methods(root_module, root_module['ns3::Mac48AddressChecker'])
     register_Ns3Mac48AddressValue_methods(root_module, root_module['ns3::Mac48AddressValue'])
     register_Ns3MacStatsCalculator_methods(root_module, root_module['ns3::MacStatsCalculator'])
+    register_Ns3MacTxStatsCalculator_methods(root_module, root_module['ns3::MacTxStatsCalculator'])
+    register_Ns3McEnbPdcp_methods(root_module, root_module['ns3::McEnbPdcp'])
+    register_Ns3McEnbPdcpStatus_methods(root_module, root_module['ns3::McEnbPdcp::Status'])
+    register_Ns3McUePdcp_methods(root_module, root_module['ns3::McUePdcp'])
+    register_Ns3McUePdcpStatus_methods(root_module, root_module['ns3::McUePdcp::Status'])
     register_Ns3MibLteControlMessage_methods(root_module, root_module['ns3::MibLteControlMessage'])
     register_Ns3MinMaxAvgTotalCalculator__Unsigned_int_methods(root_module, root_module['ns3::MinMaxAvgTotalCalculator< unsigned int >'])
     register_Ns3MinMaxAvgTotalCalculator__Unsigned_long_methods(root_module, root_module['ns3::MinMaxAvgTotalCalculator< unsigned long >'])
     register_Ns3MobilityModel_methods(root_module, root_module['ns3::MobilityModel'])
     register_Ns3NetDevice_methods(root_module, root_module['ns3::NetDevice'])
     register_Ns3NixVector_methods(root_module, root_module['ns3::NixVector'])
-    register_Ns3NoOpComponentCarrierManager_methods(root_module, root_module['ns3::NoOpComponentCarrierManager'])
     register_Ns3NoOpHandoverAlgorithm_methods(root_module, root_module['ns3::NoOpHandoverAlgorithm'])
     register_Ns3Node_methods(root_module, root_module['ns3::Node'])
     register_Ns3NormalRandomVariable_methods(root_module, root_module['ns3::NormalRandomVariable'])
@@ -2361,20 +2483,21 @@
     register_Ns3PointerChecker_methods(root_module, root_module['ns3::PointerChecker'])
     register_Ns3PointerValue_methods(root_module, root_module['ns3::PointerValue'])
     register_Ns3PssFfMacScheduler_methods(root_module, root_module['ns3::PssFfMacScheduler'])
+    register_Ns3QueueItem_methods(root_module, root_module['ns3::QueueItem'])
     register_Ns3RachPreambleLteControlMessage_methods(root_module, root_module['ns3::RachPreambleLteControlMessage'])
     register_Ns3RadioBearerStatsCalculator_methods(root_module, root_module['ns3::RadioBearerStatsCalculator'])
     register_Ns3RarLteControlMessage_methods(root_module, root_module['ns3::RarLteControlMessage'])
     register_Ns3RarLteControlMessageRar_methods(root_module, root_module['ns3::RarLteControlMessage::Rar'])
     register_Ns3RemSpectrumPhy_methods(root_module, root_module['ns3::RemSpectrumPhy'])
-    register_Ns3RrComponentCarrierManager_methods(root_module, root_module['ns3::RrComponentCarrierManager'])
     register_Ns3RrFfMacScheduler_methods(root_module, root_module['ns3::RrFfMacScheduler'])
     register_Ns3RrcAsn1Header_methods(root_module, root_module['ns3::RrcAsn1Header'])
     register_Ns3RrcDlCcchMessage_methods(root_module, root_module['ns3::RrcDlCcchMessage'])
     register_Ns3RrcDlDcchMessage_methods(root_module, root_module['ns3::RrcDlDcchMessage'])
     register_Ns3RrcUlCcchMessage_methods(root_module, root_module['ns3::RrcUlCcchMessage'])
     register_Ns3RrcUlDcchMessage_methods(root_module, root_module['ns3::RrcUlDcchMessage'])
+    register_Ns3S1apConnectionInfo_methods(root_module, root_module['ns3::S1apConnectionInfo'])
+    register_Ns3S1apIfaceInfo_methods(root_module, root_module['ns3::S1apIfaceInfo'])
     register_Ns3Sib1LteControlMessage_methods(root_module, root_module['ns3::Sib1LteControlMessage'])
-    register_Ns3SimpleUeComponentCarrierManager_methods(root_module, root_module['ns3::SimpleUeComponentCarrierManager'])
     register_Ns3SpectrumChannel_methods(root_module, root_module['ns3::SpectrumChannel'])
     register_Ns3SrsCqiRntiVsp_methods(root_module, root_module['ns3::SrsCqiRntiVsp'])
     register_Ns3StringChecker_methods(root_module, root_module['ns3::StringChecker'])
@@ -2403,22 +2526,28 @@
     register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Packet__gt___Const_ns3Address___amp___Const_ns3Address___amp___Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::Packet>, const ns3::Address &, const ns3::Address &, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Bool_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< bool, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Ns3ObjectBase___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Bool_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Const_ns3SpectrumValue___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Ns3DlSchedulingCallbackInfo_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3EpcUeNasState_Ns3EpcUeNasState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::EpcUeNas::State, ns3::EpcUeNas::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3PhyReceptionStatParameters_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::PhyReceptionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3PhyTransmissionStatParameters_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::PhyTransmissionStatParameters, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3MobilityModel__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::MobilityModel>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3Packet__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3PacketBurst__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::PacketBurst>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Const_char___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::NetDevice>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Packet__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Const_ns3Address___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, const ns3::Address &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3Socket__gt___Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Ptr<ns3::Socket>, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Ns3Time_Ns3Time_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Unsigned_short_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Long_double_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteRrcSapMeasurementReport_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, unsigned short, ns3::LteRrcSap::MeasurementReport, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Ns3LteUeRrcState_Ns3LteUeRrcState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, unsigned short, ns3::LteUeRrc::State, ns3::LteUeRrc::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
@@ -2427,13 +2556,15 @@
     register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned long, unsigned short, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Ns3Ptr__lt__ns3SpectrumValue__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, ns3::Ptr<ns3::SpectrumValue>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_long_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
-    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Bool_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, double, unsigned char, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3LteUePhyState_Ns3LteUePhyState_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::LteUePhy::State, ns3::LteUePhy::State, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
+    register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Unsigned_int_Unsigned_long_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, root_module['ns3::CallbackImpl< void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty >'])
     register_Ns3CqaFfMacScheduler_methods(root_module, root_module['ns3::CqaFfMacScheduler'])
     register_Ns3DlCqiLteControlMessage_methods(root_module, root_module['ns3::DlCqiLteControlMessage'])
     register_Ns3DlDciLteControlMessage_methods(root_module, root_module['ns3::DlDciLteControlMessage'])
@@ -2448,6 +2579,8 @@
     register_Ns3LteNetDevice_methods(root_module, root_module['ns3::LteNetDevice'])
     register_Ns3LteUeNetDevice_methods(root_module, root_module['ns3::LteUeNetDevice'])
     register_Ns3MeasurementReportHeader_methods(root_module, root_module['ns3::MeasurementReportHeader'])
+    register_Ns3QueueDiscItem_methods(root_module, root_module['ns3::QueueDiscItem'])
+    register_Ns3RrcConnectToMmWaveHeader_methods(root_module, root_module['ns3::RrcConnectToMmWaveHeader'])
     register_Ns3RrcConnectionReconfigurationCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionReconfigurationCompleteHeader'])
     register_Ns3RrcConnectionReconfigurationHeader_methods(root_module, root_module['ns3::RrcConnectionReconfigurationHeader'])
     register_Ns3RrcConnectionReestablishmentCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionReestablishmentCompleteHeader'])
@@ -2459,6 +2592,8 @@
     register_Ns3RrcConnectionRequestHeader_methods(root_module, root_module['ns3::RrcConnectionRequestHeader'])
     register_Ns3RrcConnectionSetupCompleteHeader_methods(root_module, root_module['ns3::RrcConnectionSetupCompleteHeader'])
     register_Ns3RrcConnectionSetupHeader_methods(root_module, root_module['ns3::RrcConnectionSetupHeader'])
+    register_Ns3RrcConnectionSwitchHeader_methods(root_module, root_module['ns3::RrcConnectionSwitchHeader'])
+    register_Ns3RrcNotifySecondaryConnectedHeader_methods(root_module, root_module['ns3::RrcNotifySecondaryConnectedHeader'])
     register_Ns3LteEnbNetDevice_methods(root_module, root_module['ns3::LteEnbNetDevice'])
     register_Ns3ConfigMatchContainer_methods(root_module, root_module['ns3::Config::MatchContainer'])
     register_Ns3HashImplementation_methods(root_module, root_module['ns3::Hash::Implementation'])
@@ -3312,6 +3447,42 @@
                    is_static=True)
     return
 
+def register_Ns3DefaultDeleter__Ns3QueueItem_methods(root_module, cls):
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::QueueItem>::DefaultDeleter() [constructor]
+    cls.add_constructor([])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::QueueItem>::DefaultDeleter(ns3::DefaultDeleter<ns3::QueueItem> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::DefaultDeleter< ns3::QueueItem > const &', 'arg0')])
+    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::QueueItem>::Delete(ns3::QueueItem * object) [member function]
+    cls.add_method('Delete', 
+                   'void', 
+                   [param('ns3::QueueItem *', 'object')], 
+                   is_static=True)
+    return
+
+def register_Ns3DefaultDeleter__Ns3S1apConnectionInfo_methods(root_module, cls):
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apConnectionInfo>::DefaultDeleter() [constructor]
+    cls.add_constructor([])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apConnectionInfo>::DefaultDeleter(ns3::DefaultDeleter<ns3::S1apConnectionInfo> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::DefaultDeleter< ns3::S1apConnectionInfo > const &', 'arg0')])
+    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::S1apConnectionInfo>::Delete(ns3::S1apConnectionInfo * object) [member function]
+    cls.add_method('Delete', 
+                   'void', 
+                   [param('ns3::S1apConnectionInfo *', 'object')], 
+                   is_static=True)
+    return
+
+def register_Ns3DefaultDeleter__Ns3S1apIfaceInfo_methods(root_module, cls):
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apIfaceInfo>::DefaultDeleter() [constructor]
+    cls.add_constructor([])
+    ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::S1apIfaceInfo>::DefaultDeleter(ns3::DefaultDeleter<ns3::S1apIfaceInfo> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::DefaultDeleter< ns3::S1apIfaceInfo > const &', 'arg0')])
+    ## default-deleter.h (module 'core'): static void ns3::DefaultDeleter<ns3::S1apIfaceInfo>::Delete(ns3::S1apIfaceInfo * object) [member function]
+    cls.add_method('Delete', 
+                   'void', 
+                   [param('ns3::S1apIfaceInfo *', 'object')], 
+                   is_static=True)
+    return
+
 def register_Ns3DefaultDeleter__Ns3SpectrumModel_methods(root_module, cls):
     ## default-deleter.h (module 'core'): ns3::DefaultDeleter<ns3::SpectrumModel>::DefaultDeleter() [constructor]
     cls.add_constructor([])
@@ -3810,111 +3981,155 @@
     cls.add_constructor([param('ns3::EpcS1apSap const &', 'arg0')])
     return
 
-def register_Ns3EpcS1apSapEnb_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb() [constructor]
+def register_Ns3EpcS1apSapErabSetupItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::ErabSetupItem() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb(ns3::EpcS1apSapEnb const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::InitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapEnb::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSapEnb::ErabToBeSetupItem> > erabToBeSetupList) [member function]
-    cls.add_method('InitialContextSetupRequest', 
-                   'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapEnb::ErabToBeSetupItem >', 'erabToBeSetupList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::PathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
-    cls.add_method('PathSwitchRequestAcknowledge', 
-                   'void', 
-                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
-                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::ErabSetupItem(ns3::EpcS1apSap::ErabSetupItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabSetupItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::enbTeid [variable]
+    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::enbTransportLayerAddress [variable]
+    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSetupItem::erabId [variable]
+    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3EpcS1apSapErabSwitchedInDownlinkItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem(ns3::EpcS1apSap::ErabSwitchedInDownlinkItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabSwitchedInDownlinkItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::enbTeid [variable]
+    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::enbTransportLayerAddress [variable]
+    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInDownlinkItem::erabId [variable]
+    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
     return
 
-def register_Ns3EpcS1apSapEnbErabSwitchedInUplinkItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem() [constructor]
+def register_Ns3EpcS1apSapErabSwitchedInUplinkItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem(ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::enbTeid [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::ErabSwitchedInUplinkItem(ns3::EpcS1apSap::ErabSwitchedInUplinkItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabSwitchedInUplinkItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::enbTeid [variable]
     cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::erabId [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::erabId [variable]
     cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabSwitchedInUplinkItem::transportLayerAddress [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabSwitchedInUplinkItem::transportLayerAddress [variable]
     cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
     return
 
-def register_Ns3EpcS1apSapEnbErabToBeSetupItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::ErabToBeSetupItem() [constructor]
+def register_Ns3EpcS1apSapErabToBeReleasedIndication_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication::ErabToBeReleasedIndication() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication::ErabToBeReleasedIndication(ns3::EpcS1apSap::ErabToBeReleasedIndication const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabToBeReleasedIndication const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeReleasedIndication::erabId [variable]
+    cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
+    return
+
+def register_Ns3EpcS1apSapErabToBeSetupItem_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::ErabToBeSetupItem() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::ErabToBeSetupItem(ns3::EpcS1apSapEnb::ErabToBeSetupItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapEnb::ErabToBeSetupItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::erabId [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::ErabToBeSetupItem(ns3::EpcS1apSap::ErabToBeSetupItem const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSap::ErabToBeSetupItem const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::erabId [variable]
     cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::erabLevelQosParameters [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::erabLevelQosParameters [variable]
     cls.add_instance_attribute('erabLevelQosParameters', 'ns3::EpsBearer', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::sgwTeid [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::sgwTeid [variable]
     cls.add_instance_attribute('sgwTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::ErabToBeSetupItem::transportLayerAddress [variable]
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSap::ErabToBeSetupItem::transportLayerAddress [variable]
     cls.add_instance_attribute('transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
     return
 
+def register_Ns3EpcS1apSapEnb_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnb::EpcS1apSapEnb(ns3::EpcS1apSapEnb const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSapEnb const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::InitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList) [member function]
+    cls.add_method('InitialContextSetupRequest', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnb::PathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
+    cls.add_method('PathSwitchRequestAcknowledge', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcS1apSapEnbProvider_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnbProvider::EpcS1apSapEnbProvider() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapEnbProvider::EpcS1apSapEnbProvider(ns3::EpcS1apSapEnbProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSapEnbProvider const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    cls.add_method('SendErabReleaseIndication', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendInitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
+    cls.add_method('SendInitialContextSetupResponse', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendInitialUeMessage(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) [member function]
+    cls.add_method('SendInitialUeMessage', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('uint64_t', 'stmsi'), param('uint16_t', 'ecgi')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapEnbProvider::SendPathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('SendPathSwitchRequest', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
 def register_Ns3EpcS1apSapMme_methods(root_module, cls):
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::EpcS1apSapMme() [constructor]
     cls.add_constructor([])
     ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::EpcS1apSapMme(ns3::EpcS1apSapMme const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcS1apSapMme const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::ErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapMme::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSapMme::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::ErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
     cls.add_method('ErabReleaseIndication', 
                    'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapMme::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSapMme::ErabSetupItem, std::allocator<ns3::EpcS1apSapMme::ErabSetupItem> > erabSetupList) [member function]
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
     cls.add_method('InitialContextSetupResponse', 
                    'void', 
-                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSapMme::ErabSetupItem >', 'erabSetupList')], 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')], 
                    is_pure_virtual=True, is_virtual=True)
     ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::InitialUeMessage(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) [member function]
     cls.add_method('InitialUeMessage', 
                    'void', 
                    [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('uint64_t', 'stmsi'), param('uint16_t', 'ecgi')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::PathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMme::PathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
     cls.add_method('PathSwitchRequest', 
                    'void', 
-                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
                    is_pure_virtual=True, is_virtual=True)
     return
 
-def register_Ns3EpcS1apSapMmeErabSetupItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::ErabSetupItem() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::ErabSetupItem(ns3::EpcS1apSapMme::ErabSetupItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabSetupItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::enbTeid [variable]
-    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::enbTransportLayerAddress [variable]
-    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSetupItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapMmeErabSwitchedInDownlinkItem_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem() [constructor]
-    cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::ErabSwitchedInDownlinkItem(ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::enbTeid [variable]
-    cls.add_instance_attribute('enbTeid', 'uint32_t', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::enbTransportLayerAddress [variable]
-    cls.add_instance_attribute('enbTransportLayerAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabSwitchedInDownlinkItem::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3EpcS1apSapMmeErabToBeReleasedIndication_methods(root_module, cls):
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::ErabToBeReleasedIndication() [constructor]
+def register_Ns3EpcS1apSapMmeProvider_methods(root_module, cls):
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMmeProvider::EpcS1apSapMmeProvider() [constructor]
     cls.add_constructor([])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::ErabToBeReleasedIndication(ns3::EpcS1apSapMme::ErabToBeReleasedIndication const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcS1apSapMme::ErabToBeReleasedIndication const &', 'arg0')])
-    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMme::ErabToBeReleasedIndication::erabId [variable]
-    cls.add_instance_attribute('erabId', 'uint8_t', is_const=False)
+    ## epc-s1ap-sap.h (module 'lte'): ns3::EpcS1apSapMmeProvider::EpcS1apSapMmeProvider(ns3::EpcS1apSapMmeProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apSapMmeProvider const &', 'arg0')])
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMmeProvider::SendInitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList, uint16_t cellId) [member function]
+    cls.add_method('SendInitialContextSetupRequest', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList'), param('uint16_t', 'cellId')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-s1ap-sap.h (module 'lte'): void ns3::EpcS1apSapMmeProvider::SendPathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
+    cls.add_method('SendPathSwitchRequestAcknowledge', 
+                   'void', 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3EpcX2Sap_methods(root_module, cls):
@@ -4045,6 +4260,21 @@
     cls.add_instance_attribute('ulPdcpSn', 'uint16_t', is_const=False)
     return
 
+def register_Ns3EpcX2SapHandoverFailedParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::HandoverFailedParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::HandoverFailedParams(ns3::EpcX2Sap::HandoverFailedParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::HandoverFailedParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::coordinatorId [variable]
+    cls.add_instance_attribute('coordinatorId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::imsi [variable]
+    cls.add_instance_attribute('imsi', 'uint64_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverFailedParams::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3EpcX2SapHandoverPreparationFailureParams_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverPreparationFailureParams::HandoverPreparationFailureParams() [constructor]
     cls.add_constructor([])
@@ -4092,10 +4322,14 @@
     cls.add_instance_attribute('bearers', 'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::cause [variable]
     cls.add_instance_attribute('cause', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::isMc [variable]
+    cls.add_instance_attribute('isMc', 'bool', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::mmeUeS1apId [variable]
     cls.add_instance_attribute('mmeUeS1apId', 'uint32_t', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::oldEnbUeX2apId [variable]
     cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::rlcRequests [variable]
+    cls.add_instance_attribute('rlcRequests', 'std::vector< ns3::EpcX2Sap::RlcSetupRequest >', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::rrcContext [variable]
     cls.add_instance_attribute('rrcContext', 'ns3::Ptr< ns3::Packet >', is_const=False)
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::HandoverRequestParams::sourceCellId [variable]
@@ -4151,6 +4385,61 @@
     cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
     return
 
+def register_Ns3EpcX2SapRlcSetupRequest_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::RlcSetupRequest() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::RlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::RlcSetupRequest const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::drbid [variable]
+    cls.add_instance_attribute('drbid', 'uint8_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::gtpTeid [variable]
+    cls.add_instance_attribute('gtpTeid', 'uint32_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::lcinfo [variable]
+    cls.add_instance_attribute('lcinfo', 'ns3::LteEnbCmacSapProvider::LcInfo', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::logicalChannelConfig [variable]
+    cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::lteRnti [variable]
+    cls.add_instance_attribute('lteRnti', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::rlcConfig [variable]
+    cls.add_instance_attribute('rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::rlcType [variable]
+    cls.add_instance_attribute('rlcType', 'ns3::TypeId', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::RlcSetupRequest::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3EpcX2SapSecondaryHandoverCompletedParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::SecondaryHandoverCompletedParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::SecondaryHandoverCompletedParams(ns3::EpcX2Sap::SecondaryHandoverCompletedParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::cellId [variable]
+    cls.add_instance_attribute('cellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::imsi [variable]
+    cls.add_instance_attribute('imsi', 'uint64_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverCompletedParams::oldEnbUeX2apId [variable]
+    cls.add_instance_attribute('oldEnbUeX2apId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3EpcX2SapSecondaryHandoverParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::SecondaryHandoverParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::SecondaryHandoverParams(ns3::EpcX2Sap::SecondaryHandoverParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::SecondaryHandoverParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::imsi [variable]
+    cls.add_instance_attribute('imsi', 'uint64_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::oldCellId [variable]
+    cls.add_instance_attribute('oldCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SecondaryHandoverParams::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3EpcX2SapSnStatusTransferParams_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SnStatusTransferParams::SnStatusTransferParams() [constructor]
     cls.add_constructor([])
@@ -4168,6 +4457,21 @@
     cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
     return
 
+def register_Ns3EpcX2SapSwitchConnectionParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::SwitchConnectionParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::SwitchConnectionParams(ns3::EpcX2Sap::SwitchConnectionParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::SwitchConnectionParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::drbid [variable]
+    cls.add_instance_attribute('drbid', 'uint8_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::mmWaveCellId [variable]
+    cls.add_instance_attribute('mmWaveCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint32_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::SwitchConnectionParams::useMmWaveConnection [variable]
+    cls.add_instance_attribute('useMmWaveConnection', 'bool', is_const=False)
+    return
+
 def register_Ns3EpcX2SapUeContextReleaseParams_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeContextReleaseParams::UeContextReleaseParams() [constructor]
     cls.add_constructor([])
@@ -4198,6 +4502,19 @@
     cls.add_instance_attribute('ueData', 'ns3::Ptr< ns3::Packet >', is_const=False)
     return
 
+def register_Ns3EpcX2SapUeImsiSinrParams_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::UeImsiSinrParams() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::UeImsiSinrParams(ns3::EpcX2Sap::UeImsiSinrParams const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Sap::UeImsiSinrParams const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UeImsiSinrParams::ueImsiSinrMap [variable]
+    cls.add_instance_attribute('ueImsiSinrMap', 'std::map< unsigned long, double >', is_const=False)
+    return
+
 def register_Ns3EpcX2SapUlHighInterferenceInformationItem_methods(root_module, cls):
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2Sap::UlHighInterferenceInformationItem::UlHighInterferenceInformationItem() [constructor]
     cls.add_constructor([])
@@ -4214,6 +4531,31 @@
     cls.add_constructor([])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapProvider::EpcX2SapProvider(ns3::EpcX2SapProvider const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcX2SapProvider const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::AddTeidToBeForwarded(uint32_t gtpTeid, uint16_t targetCellId) [member function]
+    cls.add_method('AddTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'gtpTeid'), param('uint16_t', 'targetCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::ForwardRlcPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('ForwardRlcPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::NotifyCoordinatorHandoverFailed(ns3::EpcX2Sap::HandoverFailedParams params) [member function]
+    cls.add_method('NotifyCoordinatorHandoverFailed', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::HandoverFailedParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::NotifyLteMmWaveHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('NotifyLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::RemoveTeidToBeForwarded(uint32_t gtpTeid) [member function]
+    cls.add_method('RemoveTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'gtpTeid')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
     cls.add_method('SendHandoverPreparationFailure', 
                    'void', 
@@ -4234,16 +4576,41 @@
                    'void', 
                    [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendMcHandoverRequest(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('SendMcHandoverRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
     cls.add_method('SendResourceStatusUpdate', 
                    'void', 
                    [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendRlcSetupCompleted(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SendRlcSetupCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('SendRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('SendSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
     cls.add_method('SendSnStatusTransfer', 
                    'void', 
                    [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendSwitchConnectionToMmWave(ns3::EpcX2Sap::SwitchConnectionParams params) [member function]
+    cls.add_method('SendSwitchConnectionToMmWave', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SwitchConnectionParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
     cls.add_method('SendUeContextRelease', 
                    'void', 
@@ -4254,6 +4621,21 @@
                    'void', 
                    [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SendUeSinrUpdate(ns3::EpcX2Sap::UeImsiSinrParams params) [member function]
+    cls.add_method('SendUeSinrUpdate', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeImsiSinrParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SetEpcX2PdcpUser(uint32_t teid, ns3::EpcX2PdcpUser * s) [member function]
+    cls.add_method('SetEpcX2PdcpUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2PdcpUser *', 's')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapProvider::SetEpcX2RlcUser(uint32_t teid, ns3::EpcX2RlcUser * s) [member function]
+    cls.add_method('SetEpcX2RlcUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2RlcUser *', 's')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3EpcX2SapUser_methods(root_module, cls):
@@ -4261,6 +4643,11 @@
     cls.add_constructor([])
     ## epc-x2-sap.h (module 'lte'): ns3::EpcX2SapUser::EpcX2SapUser(ns3::EpcX2SapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpcX2SapUser const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvConnectionSwitchToMmWave(ns3::EpcX2Sap::SwitchConnectionParams params) [member function]
+    cls.add_method('RecvConnectionSwitchToMmWave', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SwitchConnectionParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
     cls.add_method('RecvHandoverPreparationFailure', 
                    'void', 
@@ -4281,11 +4668,36 @@
                    'void', 
                    [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvLteMmWaveHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('RecvLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvMcHandoverRequest(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('RecvMcHandoverRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
     cls.add_method('RecvResourceStatusUpdate', 
                    'void', 
                    [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvRlcSetupCompleted(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('RecvRlcSetupCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('RecvRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('RecvSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
     cls.add_method('RecvSnStatusTransfer', 
                    'void', 
@@ -4301,6 +4713,11 @@
                    'void', 
                    [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2SapUser::RecvUeSinrUpdate(ns3::EpcX2Sap::UeImsiSinrParams params) [member function]
+    cls.add_method('RecvUeSinrUpdate', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeImsiSinrParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3EpsBearer_methods(root_module, cls):
@@ -5962,10 +6379,20 @@
                    'void', 
                    [], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::ForceCampedOnEnb(uint16_t cellId, uint32_t dlEarfcn) [member function]
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::ForceCampedOnEnb(uint16_t cellId, uint16_t dlEarfcn) [member function]
     cls.add_method('ForceCampedOnEnb', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')], 
+                   [param('uint16_t', 'cellId'), param('uint16_t', 'dlEarfcn')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::NotifySecondaryCellConnected(uint16_t rnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('NotifySecondaryCellConnected', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::NotifySecondaryCellHandover(uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, ns3::LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) [member function]
+    cls.add_method('NotifySecondaryCellHandover', 
+                   'void', 
+                   [param('uint16_t', 'oldRnti'), param('uint16_t', 'newRnti'), param('uint16_t', 'mmWaveCellId'), param('ns3::LteRrcSap::RadioResourceConfigDedicated', 'radioResourceConfigDedicated')], 
                    is_pure_virtual=True, is_virtual=True)
     ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::SendData(ns3::Ptr<ns3::Packet> packet, uint8_t bid) [member function]
     cls.add_method('SendData', 
@@ -5977,10 +6404,10 @@
                    'void', 
                    [param('uint32_t', 'csgId')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::StartCellSelection(uint32_t dlEarfcn) [member function]
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapProvider::StartCellSelection(uint16_t dlEarfcn) [member function]
     cls.add_method('StartCellSelection', 
                    'void', 
-                   [param('uint32_t', 'dlEarfcn')], 
+                   [param('uint16_t', 'dlEarfcn')], 
                    is_pure_virtual=True, is_virtual=True)
     return
 
@@ -5989,6 +6416,11 @@
     cls.add_constructor([])
     ## lte-as-sap.h (module 'lte'): ns3::LteAsSapUser::LteAsSapUser(ns3::LteAsSapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteAsSapUser const &', 'arg0')])
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectToMmWave(uint16_t mmWaveCellId) [member function]
+    cls.add_method('NotifyConnectToMmWave', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionFailed() [member function]
     cls.add_method('NotifyConnectionFailed', 
                    'void', 
@@ -5999,114 +6431,25 @@
                    'void', 
                    [], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionSuccessful() [member function]
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyConnectionSuccessful(uint16_t rnti) [member function]
     cls.add_method('NotifyConnectionSuccessful', 
                    'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::RecvData(ns3::Ptr<ns3::Packet> packet) [member function]
-    cls.add_method('RecvData', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteCcmMacSapProvider_methods(root_module, cls):
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapProvider::LteCcmMacSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapProvider::LteCcmMacSapProvider(ns3::LteCcmMacSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmMacSapProvider const &', 'arg0')])
-    ## lte-ccm-mac-sap.h (module 'lte'): void ns3::LteCcmMacSapProvider::ReportMacCeToScheduler(ns3::MacCeListElement_s bsr) [member function]
-    cls.add_method('ReportMacCeToScheduler', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteCcmRrcSapProvider_methods(root_module, cls):
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LteCcmRrcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LteCcmRrcSapProvider(ns3::LteCcmRrcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmRrcSapProvider const &', 'arg0')])
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::AddLc(ns3::LteEnbCmacSapProvider::LcInfo lcInfo, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('AddLc', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::AddUe(uint16_t rnti, uint8_t state) [member function]
-    cls.add_method('AddUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'state')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteMacSapUser * ns3::LteCcmRrcSapProvider::ConfigureSignalBearer(ns3::LteEnbCmacSapProvider::LcInfo lcInfo, ns3::LteMacSapUser * rlcMacSapUser) [member function]
-    cls.add_method('ConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo'), param('ns3::LteMacSapUser *', 'rlcMacSapUser')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): std::vector<unsigned char, std::allocator<unsigned char> > ns3::LteCcmRrcSapProvider::ReleaseDataRadioBearer(uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('ReleaseDataRadioBearer', 
-                   'std::vector< unsigned char >', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::RemoveUe(uint16_t rnti) [member function]
-    cls.add_method('RemoveUe', 
-                   'void', 
                    [param('uint16_t', 'rnti')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapProvider::ReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('ReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): std::vector<ns3::LteCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteCcmRrcSapProvider::LcsConfig> > ns3::LteCcmRrcSapProvider::SetupDataRadioBearer(ns3::EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('SetupDataRadioBearer', 
-                   'std::vector< ns3::LteCcmRrcSapProvider::LcsConfig >', 
-                   [param('ns3::EpsBearer', 'bearer'), param('uint8_t', 'bearerId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint8_t', 'lcGroup'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteCcmRrcSapProviderLcsConfig_methods(root_module, cls):
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::LcsConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::LcsConfig(ns3::LteCcmRrcSapProvider::LcsConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmRrcSapProvider::LcsConfig const &', 'arg0')])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::componentCarrierId [variable]
-    cls.add_instance_attribute('componentCarrierId', 'uint16_t', is_const=False)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::lc [variable]
-    cls.add_instance_attribute('lc', 'ns3::LteEnbCmacSapProvider::LcInfo', is_const=False)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapProvider::LcsConfig::msu [variable]
-    cls.add_instance_attribute('msu', 'ns3::LteMacSapUser *', is_const=False)
-    return
-
-def register_Ns3LteCcmRrcSapUser_methods(root_module, cls):
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapUser::LteCcmRrcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::LteCcmRrcSapUser::LteCcmRrcSapUser(ns3::LteCcmRrcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmRrcSapUser const &', 'arg0')])
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapUser::AddLcs(std::vector<ns3::LteRrcSap::LogicalChannelConfig, std::allocator<ns3::LteRrcSap::LogicalChannelConfig> > lcConfig) [member function]
-    cls.add_method('AddLcs', 
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifyHandoverSuccessful(uint16_t rnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('NotifyHandoverSuccessful', 
                    'void', 
-                   [param('std::vector< ns3::LteRrcSap::LogicalChannelConfig >', 'lcConfig')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): uint8_t ns3::LteCcmRrcSapUser::AddUeMeasReportConfigForComponentCarrier(ns3::LteRrcSap::ReportConfigEutra reportConfig) [member function]
-    cls.add_method('AddUeMeasReportConfigForComponentCarrier', 
-                   'uint8_t', 
-                   [param('ns3::LteRrcSap::ReportConfigEutra', 'reportConfig')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): ns3::Ptr<ns3::UeManager> ns3::LteCcmRrcSapUser::GetUeManager(uint16_t rnti) [member function]
-    cls.add_method('GetUeManager', 
-                   'ns3::Ptr< ns3::UeManager >', 
-                   [param('uint16_t', 'rnti')], 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveCellId')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapUser::ReleaseLcs(uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('ReleaseLcs', 
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::NotifySecondaryCellHandoverStarted(uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, ns3::LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) [member function]
+    cls.add_method('NotifySecondaryCellHandoverStarted', 
                    'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('uint16_t', 'oldRnti'), param('uint16_t', 'newRnti'), param('uint16_t', 'mmWaveCellId'), param('ns3::LteRrcSap::RadioResourceConfigDedicated', 'radioResourceConfigDedicated')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-rrc-sap.h (module 'lte'): void ns3::LteCcmRrcSapUser::TriggerComponentCarrier(uint16_t rnti, uint16_t targetCellId) [member function]
-    cls.add_method('TriggerComponentCarrier', 
+    ## lte-as-sap.h (module 'lte'): void ns3::LteAsSapUser::RecvData(ns3::Ptr<ns3::Packet> packet) [member function]
+    cls.add_method('RecvData', 
                    'void', 
-                   [param('uint16_t', 'rnti'), param('uint16_t', 'targetCellId')], 
+                   [param('ns3::Ptr< ns3::Packet >', 'packet')], 
                    is_pure_virtual=True, is_virtual=True)
     return
 
@@ -6287,10 +6630,10 @@
                    'void', 
                    [param('uint16_t', 'cellId')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetEarfcn(uint32_t ulEarfcn, uint32_t dlEarfcn) [member function]
+    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetEarfcn(uint16_t ulEarfcn, uint16_t dlEarfcn) [member function]
     cls.add_method('SetEarfcn', 
                    'void', 
-                   [param('uint32_t', 'ulEarfcn'), param('uint32_t', 'dlEarfcn')], 
+                   [param('uint16_t', 'ulEarfcn'), param('uint16_t', 'dlEarfcn')], 
                    is_pure_virtual=True, is_virtual=True)
     ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapProvider::SetMasterInformationBlock(ns3::LteRrcSap::MasterInformationBlock mib) [member function]
     cls.add_method('SetMasterInformationBlock', 
@@ -6324,6 +6667,20 @@
     cls.add_constructor([])
     ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::LteEnbCphySapUser(ns3::LteEnbCphySapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteEnbCphySapUser const &', 'arg0')])
+    ## lte-enb-cphy-sap.h (module 'lte'): void ns3::LteEnbCphySapUser::UpdateUeSinrEstimate(ns3::LteEnbCphySapUser::UeAssociatedSinrInfo info) [member function]
+    cls.add_method('UpdateUeSinrEstimate', 
+                   'void', 
+                   [param('ns3::LteEnbCphySapUser::UeAssociatedSinrInfo', 'info')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3LteEnbCphySapUserUeAssociatedSinrInfo_methods(root_module, cls):
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo::UeAssociatedSinrInfo() [constructor]
+    cls.add_constructor([])
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo::UeAssociatedSinrInfo(ns3::LteEnbCphySapUser::UeAssociatedSinrInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteEnbCphySapUser::UeAssociatedSinrInfo const &', 'arg0')])
+    ## lte-enb-cphy-sap.h (module 'lte'): ns3::LteEnbCphySapUser::UeAssociatedSinrInfo::ueImsiSinrMap [variable]
+    cls.add_instance_attribute('ueImsiSinrMap', 'std::map< unsigned long, double >', is_const=False)
     return
 
 def register_Ns3LteEnbPhySapProvider_methods(root_module, cls):
@@ -6606,8 +6963,14 @@
     cls.add_constructor([])
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::ReportBufferStatusParameters(ns3::LteMacSapProvider::ReportBufferStatusParameters const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteMacSapProvider::ReportBufferStatusParameters const &', 'arg0')])
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::arrivalRate [variable]
+    cls.add_instance_attribute('arrivalRate', 'double', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::lcid [variable]
     cls.add_instance_attribute('lcid', 'uint8_t', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxPacketDelays [variable]
+    cls.add_instance_attribute('retxPacketDelays', 'std::list< double >', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxPacketSizes [variable]
+    cls.add_instance_attribute('retxPacketSizes', 'std::list< unsigned int >', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxQueueHolDelay [variable]
     cls.add_instance_attribute('retxQueueHolDelay', 'uint16_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::retxQueueSize [variable]
@@ -6616,6 +6979,10 @@
     cls.add_instance_attribute('rnti', 'uint16_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::statusPduSize [variable]
     cls.add_instance_attribute('statusPduSize', 'uint16_t', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txPacketDelays [variable]
+    cls.add_instance_attribute('txPacketDelays', 'std::list< double >', is_const=False)
+    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txPacketSizes [variable]
+    cls.add_instance_attribute('txPacketSizes', 'std::list< unsigned int >', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txQueueHolDelay [variable]
     cls.add_instance_attribute('txQueueHolDelay', 'uint16_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::ReportBufferStatusParameters::txQueueSize [variable]
@@ -6627,8 +6994,6 @@
     cls.add_constructor([])
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::TransmitPduParameters(ns3::LteMacSapProvider::TransmitPduParameters const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteMacSapProvider::TransmitPduParameters const &', 'arg0')])
-    ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::componentCarrierId [variable]
-    cls.add_instance_attribute('componentCarrierId', 'uint8_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::harqProcessId [variable]
     cls.add_instance_attribute('harqProcessId', 'uint8_t', is_const=False)
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapProvider::TransmitPduParameters::layer [variable]
@@ -6646,20 +7011,30 @@
     cls.add_constructor([])
     ## lte-mac-sap.h (module 'lte'): ns3::LteMacSapUser::LteMacSapUser(ns3::LteMacSapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteMacSapUser const &', 'arg0')])
+    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyDlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('NotifyDlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
     ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyHarqDeliveryFailure() [member function]
     cls.add_method('NotifyHarqDeliveryFailure', 
                    'void', 
                    [], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
     cls.add_method('NotifyTxOpportunity', 
                    'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::ReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::NotifyUlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('NotifyUlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
+    ## lte-mac-sap.h (module 'lte'): void ns3::LteMacSapUser::ReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('ReceivePdu', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
                    is_pure_virtual=True, is_virtual=True)
     return
 
@@ -6777,27 +7152,45 @@
                    is_pure_virtual=True, is_virtual=True)
     return
 
-def register_Ns3LteRrcSap_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LteRrcSap() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LteRrcSap(ns3::LteRrcSap const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): static double ns3::LteRrcSap::ConvertPdschConfigDedicated2Double(ns3::LteRrcSap::PdschConfigDedicated pdschConfigDedicated) [member function]
-    cls.add_method('ConvertPdschConfigDedicated2Double', 
-                   'double', 
-                   [param('ns3::LteRrcSap::PdschConfigDedicated', 'pdschConfigDedicated')], 
-                   is_static=True)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MaxReportCells [variable]
-    cls.add_static_attribute('MaxReportCells', 'uint8_t const', is_const=True)
-    return
+def register_Ns3LteRlcSpecificLteMacSapUser_methods(root_module, cls):
+    ## lte-rlc.h (module 'lte'): ns3::LteRlcSpecificLteMacSapUser::LteRlcSpecificLteMacSapUser(ns3::LteRlcSpecificLteMacSapUser const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRlcSpecificLteMacSapUser const &', 'arg0')])
+    ## lte-rlc.h (module 'lte'): ns3::LteRlcSpecificLteMacSapUser::LteRlcSpecificLteMacSapUser(ns3::LteRlc * rlc) [constructor]
+    cls.add_constructor([param('ns3::LteRlc *', 'rlc')])
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::NotifyHarqDeliveryFailure() [member function]
+    cls.add_method('NotifyHarqDeliveryFailure', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::NotifyHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('NotifyHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::NotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
+    cls.add_method('NotifyTxOpportunity', 
+                   'void', 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
+                   is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSpecificLteMacSapUser::ReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('ReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    return
 
-def register_Ns3LteRrcSapAntennaInfoCommon_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon::AntennaInfoCommon() [constructor]
+def register_Ns3LteRrcSap_methods(root_module, cls):
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LteRrcSap() [constructor]
     cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon::AntennaInfoCommon(ns3::LteRrcSap::AntennaInfoCommon const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::AntennaInfoCommon const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoCommon::antennaPortsCount [variable]
-    cls.add_instance_attribute('antennaPortsCount', 'uint16_t', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::LteRrcSap(ns3::LteRrcSap const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRrcSap const &', 'arg0')])
+    ## lte-rrc-sap.h (module 'lte'): static double ns3::LteRrcSap::ConvertPdschConfigDedicated2Double(ns3::LteRrcSap::PdschConfigDedicated pdschConfigDedicated) [member function]
+    cls.add_method('ConvertPdschConfigDedicated2Double', 
+                   'double', 
+                   [param('ns3::LteRrcSap::PdschConfigDedicated', 'pdschConfigDedicated')], 
+                   is_static=True)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MaxReportCells [variable]
+    cls.add_static_attribute('MaxReportCells', 'uint8_t const', is_const=True)
     return
 
 def register_Ns3LteRrcSapAntennaInfoDedicated_methods(root_module, cls):
@@ -6809,22 +7202,13 @@
     cls.add_instance_attribute('transmissionMode', 'uint8_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapAntennaInfoUl_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl::AntennaInfoUl() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl::AntennaInfoUl(ns3::LteRrcSap::AntennaInfoUl const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::AntennaInfoUl const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AntennaInfoUl::transmissionMode [variable]
-    cls.add_instance_attribute('transmissionMode', 'uint8_t', is_const=False)
-    return
-
 def register_Ns3LteRrcSapAsConfig_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::AsConfig() [constructor]
     cls.add_constructor([])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::AsConfig(ns3::LteRrcSap::AsConfig const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteRrcSap::AsConfig const &', 'arg0')])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceDlCarrierFreq [variable]
-    cls.add_instance_attribute('sourceDlCarrierFreq', 'uint32_t', is_const=False)
+    cls.add_instance_attribute('sourceDlCarrierFreq', 'uint16_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceMasterInformationBlock [variable]
     cls.add_instance_attribute('sourceMasterInformationBlock', 'ns3::LteRrcSap::MasterInformationBlock', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::AsConfig::sourceMeasConfig [variable]
@@ -6867,9 +7251,9 @@
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra::CarrierFreqEutra(ns3::LteRrcSap::CarrierFreqEutra const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteRrcSap::CarrierFreqEutra const &', 'arg0')])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra::dlCarrierFreq [variable]
-    cls.add_instance_attribute('dlCarrierFreq', 'uint32_t', is_const=False)
+    cls.add_instance_attribute('dlCarrierFreq', 'uint16_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CarrierFreqEutra::ulCarrierFreq [variable]
-    cls.add_instance_attribute('ulCarrierFreq', 'uint32_t', is_const=False)
+    cls.add_instance_attribute('ulCarrierFreq', 'uint16_t', is_const=False)
     return
 
 def register_Ns3LteRrcSapCellAccessRelatedInfo_methods(root_module, cls):
@@ -6887,17 +7271,6 @@
     cls.add_instance_attribute('plmnIdentityInfo', 'ns3::LteRrcSap::PlmnIdentityInfo', is_const=False)
     return
 
-def register_Ns3LteRrcSapCellIdentification_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::CellIdentification() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::CellIdentification(ns3::LteRrcSap::CellIdentification const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::CellIdentification const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::dlCarrierFreq [variable]
-    cls.add_instance_attribute('dlCarrierFreq', 'uint32_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellIdentification::physCellId [variable]
-    cls.add_instance_attribute('physCellId', 'uint32_t', is_const=False)
-    return
-
 def register_Ns3LteRrcSapCellSelectionInfo_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::CellSelectionInfo::CellSelectionInfo() [constructor]
     cls.add_constructor([])
@@ -6946,6 +7319,8 @@
     cls.add_instance_attribute('drbIdentity', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::epsBearerIdentity [variable]
     cls.add_instance_attribute('epsBearerIdentity', 'uint8_t', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::is_mc [variable]
+    cls.add_instance_attribute('is_mc', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::logicalChannelConfig [variable]
     cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::DrbToAddMod::logicalChannelIdentity [variable]
@@ -6962,7 +7337,7 @@
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::FreqInfo::ulBandwidth [variable]
     cls.add_instance_attribute('ulBandwidth', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::FreqInfo::ulCarrierFreq [variable]
-    cls.add_instance_attribute('ulCarrierFreq', 'uint32_t', is_const=False)
+    cls.add_instance_attribute('ulCarrierFreq', 'uint16_t', is_const=False)
     return
 
 def register_Ns3LteRrcSapHandoverPreparationInfo_methods(root_module, cls):
@@ -7040,12 +7415,8 @@
     cls.add_constructor([])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::MeasGapConfig(ns3::LteRrcSap::MeasGapConfig const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteRrcSap::MeasGapConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::gapOffsetChoice [variable]
-    cls.add_instance_attribute('gapOffsetChoice', 'ns3::LteRrcSap::MeasGapConfig::gap', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::gapOffsetValue [variable]
     cls.add_instance_attribute('gapOffsetValue', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasGapConfig::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::MeasGapConfig::action', is_const=False)
     return
 
 def register_Ns3LteRrcSapMeasIdToAddMod_methods(root_module, cls):
@@ -7073,7 +7444,7 @@
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::blackCellsToRemoveList [variable]
     cls.add_instance_attribute('blackCellsToRemoveList', 'std::list< unsigned char >', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::carrierFreq [variable]
-    cls.add_instance_attribute('carrierFreq', 'uint32_t', is_const=False)
+    cls.add_instance_attribute('carrierFreq', 'uint16_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::cellForWhichToReportCGI [variable]
     cls.add_instance_attribute('cellForWhichToReportCGI', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasObjectEutra::cellsToAddModList [variable]
@@ -7101,25 +7472,6 @@
     cls.add_instance_attribute('measObjectId', 'uint8_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapMeasResultBestNeighCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::MeasResultBestNeighCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::MeasResultBestNeighCell(ns3::LteRrcSap::MeasResultBestNeighCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResultBestNeighCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::haveRsrpResult [variable]
-    cls.add_instance_attribute('haveRsrpResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::haveRsrqResult [variable]
-    cls.add_instance_attribute('haveRsrqResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::physCellId [variable]
-    cls.add_instance_attribute('physCellId', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::rsrpResult [variable]
-    cls.add_instance_attribute('rsrpResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::rsrqResult [variable]
-    cls.add_instance_attribute('rsrqResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultBestNeighCell::servFreqId [variable]
-    cls.add_instance_attribute('servFreqId', 'uint16_t', is_const=False)
-    return
-
 def register_Ns3LteRrcSapMeasResultEutra_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultEutra::MeasResultEutra() [constructor]
     cls.add_constructor([])
@@ -7141,38 +7493,6 @@
     cls.add_instance_attribute('rsrqResult', 'uint8_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapMeasResultScell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::MeasResultScell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::MeasResultScell(ns3::LteRrcSap::MeasResultScell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResultScell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::haveRsrpResult [variable]
-    cls.add_instance_attribute('haveRsrpResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::haveRsrqResult [variable]
-    cls.add_instance_attribute('haveRsrqResult', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::rsrpResult [variable]
-    cls.add_instance_attribute('rsrpResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::rsrqResult [variable]
-    cls.add_instance_attribute('rsrqResult', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultScell::servFreqId [variable]
-    cls.add_instance_attribute('servFreqId', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapMeasResultServFreqList_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::MeasResultServFreqList() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::MeasResultServFreqList(ns3::LteRrcSap::MeasResultServFreqList const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::MeasResultServFreqList const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::haveMeasurementResultsNeighCell [variable]
-    cls.add_instance_attribute('haveMeasurementResultsNeighCell', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::haveMeasurementResultsServingSCells [variable]
-    cls.add_instance_attribute('haveMeasurementResultsServingSCells', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::measResultBestNeighCell [variable]
-    cls.add_instance_attribute('measResultBestNeighCell', 'std::list< ns3::LteRrcSap::MeasResultBestNeighCell >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResultServFreqList::measResultScell [variable]
-    cls.add_instance_attribute('measResultScell', 'std::list< ns3::LteRrcSap::MeasResultScell >', is_const=False)
-    return
-
 def register_Ns3LteRrcSapMeasResults_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::MeasResults() [constructor]
     cls.add_constructor([])
@@ -7180,14 +7500,10 @@
     cls.add_constructor([param('ns3::LteRrcSap::MeasResults const &', 'arg0')])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::haveMeasResultNeighCells [variable]
     cls.add_instance_attribute('haveMeasResultNeighCells', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::haveScellsMeas [variable]
-    cls.add_instance_attribute('haveScellsMeas', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::measId [variable]
     cls.add_instance_attribute('measId', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::measResultListEutra [variable]
     cls.add_instance_attribute('measResultListEutra', 'std::list< ns3::LteRrcSap::MeasResultEutra >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::measScellResultList [variable]
-    cls.add_instance_attribute('measScellResultList', 'ns3::LteRrcSap::MeasResultServFreqList', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::rsrpResult [variable]
     cls.add_instance_attribute('rsrpResult', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::MeasResults::rsrqResult [variable]
@@ -7243,30 +7559,6 @@
     cls.add_instance_attribute('tHystNormal', 'uint8_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapNonCriticalExtensionConfiguration_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::NonCriticalExtensionConfiguration() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::NonCriticalExtensionConfiguration(ns3::LteRrcSap::NonCriticalExtensionConfiguration const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::NonCriticalExtensionConfiguration const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::sCellToReleaseList [variable]
-    cls.add_instance_attribute('sCellToReleaseList', 'std::list< unsigned int >', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration::sCellsToAddModList [variable]
-    cls.add_instance_attribute('sCellsToAddModList', 'std::list< ns3::LteRrcSap::SCellToAddMod >', is_const=False)
-    return
-
-def register_Ns3LteRrcSapNonUlConfiguration_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::NonUlConfiguration() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::NonUlConfiguration(ns3::LteRrcSap::NonUlConfiguration const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::NonUlConfiguration const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::antennaInfoCommon [variable]
-    cls.add_instance_attribute('antennaInfoCommon', 'ns3::LteRrcSap::AntennaInfoCommon', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::dlBandwidth [variable]
-    cls.add_instance_attribute('dlBandwidth', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::NonUlConfiguration::pdschConfigCommon [variable]
-    cls.add_instance_attribute('pdschConfigCommon', 'ns3::LteRrcSap::PdschConfigCommon', is_const=False)
-    return
-
 def register_Ns3LteRrcSapPdschConfigCommon_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PdschConfigCommon::PdschConfigCommon() [constructor]
     cls.add_constructor([])
@@ -7319,39 +7611,6 @@
     cls.add_instance_attribute('soundingRsUlConfigDedicated', 'ns3::LteRrcSap::SoundingRsUlConfigDedicated', is_const=False)
     return
 
-def register_Ns3LteRrcSapPhysicalConfigDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::PhysicalConfigDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::PhysicalConfigDedicatedSCell(ns3::LteRrcSap::PhysicalConfigDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PhysicalConfigDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::antennaInfo [variable]
-    cls.add_instance_attribute('antennaInfo', 'ns3::LteRrcSap::AntennaInfoDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::antennaInfoUl [variable]
-    cls.add_instance_attribute('antennaInfoUl', 'ns3::LteRrcSap::AntennaInfoDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::crossCarrierSchedulingConfig [variable]
-    cls.add_instance_attribute('crossCarrierSchedulingConfig', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveAntennaInfoDedicated [variable]
-    cls.add_instance_attribute('haveAntennaInfoDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveAntennaInfoUlDedicated [variable]
-    cls.add_instance_attribute('haveAntennaInfoUlDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveNonUlConfiguration [variable]
-    cls.add_instance_attribute('haveNonUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::havePdschConfigDedicated [variable]
-    cls.add_instance_attribute('havePdschConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveSoundingRsUlConfigDedicated [variable]
-    cls.add_instance_attribute('haveSoundingRsUlConfigDedicated', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::haveUlConfiguration [variable]
-    cls.add_instance_attribute('haveUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::pdschConfigDedicated [variable]
-    cls.add_instance_attribute('pdschConfigDedicated', 'ns3::LteRrcSap::PdschConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::pushConfigDedicatedSCell [variable]
-    cls.add_instance_attribute('pushConfigDedicatedSCell', 'ns3::LteRrcSap::PuschConfigDedicatedSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::soundingRsUlConfigDedicated [variable]
-    cls.add_instance_attribute('soundingRsUlConfigDedicated', 'ns3::LteRrcSap::SoundingRsUlConfigDedicated', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicatedSCell::ulPowerControlDedicatedSCell [variable]
-    cls.add_instance_attribute('ulPowerControlDedicatedSCell', 'ns3::LteRrcSap::UlPowerControlDedicatedSCell', is_const=False)
-    return
-
 def register_Ns3LteRrcSapPlmnIdentityInfo_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PlmnIdentityInfo::PlmnIdentityInfo() [constructor]
     cls.add_constructor([])
@@ -7361,15 +7620,6 @@
     cls.add_instance_attribute('plmnIdentity', 'uint32_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapPrachConfigSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell::PrachConfigSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell::PrachConfigSCell(ns3::LteRrcSap::PrachConfigSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PrachConfigSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PrachConfigSCell::index [variable]
-    cls.add_instance_attribute('index', 'uint16_t', is_const=False)
-    return
-
 def register_Ns3LteRrcSapPreambleInfo_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PreambleInfo::PreambleInfo() [constructor]
     cls.add_constructor([])
@@ -7379,15 +7629,6 @@
     cls.add_instance_attribute('numberOfRaPreambles', 'uint8_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapPuschConfigDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell::PuschConfigDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell::PuschConfigDedicatedSCell(ns3::LteRrcSap::PuschConfigDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::PuschConfigDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::PuschConfigDedicatedSCell::nPuschIdentity [variable]
-    cls.add_instance_attribute('nPuschIdentity', 'uint16_t', is_const=False)
-    return
-
 def register_Ns3LteRrcSapQuantityConfig_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::QuantityConfig::QuantityConfig() [constructor]
     cls.add_constructor([])
@@ -7441,21 +7682,6 @@
     cls.add_instance_attribute('rachConfigCommon', 'ns3::LteRrcSap::RachConfigCommon', is_const=False)
     return
 
-def register_Ns3LteRrcSapRadioResourceConfigCommonSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::RadioResourceConfigCommonSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::RadioResourceConfigCommonSCell(ns3::LteRrcSap::RadioResourceConfigCommonSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RadioResourceConfigCommonSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::haveNonUlConfiguration [variable]
-    cls.add_instance_attribute('haveNonUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::haveUlConfiguration [variable]
-    cls.add_instance_attribute('haveUlConfiguration', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::nonUlConfiguration [variable]
-    cls.add_instance_attribute('nonUlConfiguration', 'ns3::LteRrcSap::NonUlConfiguration', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSCell::ulConfiguration [variable]
-    cls.add_instance_attribute('ulConfiguration', 'ns3::LteRrcSap::UlConfiguration', is_const=False)
-    return
-
 def register_Ns3LteRrcSapRadioResourceConfigCommonSib_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigCommonSib::RadioResourceConfigCommonSib() [constructor]
     cls.add_constructor([])
@@ -7484,15 +7710,6 @@
     cls.add_instance_attribute('srbToAddModList', 'std::list< ns3::LteRrcSap::SrbToAddMod >', is_const=False)
     return
 
-def register_Ns3LteRrcSapRadioResourceConfigDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell::RadioResourceConfigDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell::RadioResourceConfigDedicatedSCell(ns3::LteRrcSap::RadioResourceConfigDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::RadioResourceConfigDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicatedSCell::physicalConfigDedicatedSCell [variable]
-    cls.add_instance_attribute('physicalConfigDedicatedSCell', 'ns3::LteRrcSap::PhysicalConfigDedicatedSCell', is_const=False)
-    return
-
 def register_Ns3LteRrcSapReestabUeIdentity_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReestabUeIdentity::ReestabUeIdentity() [constructor]
     cls.add_constructor([])
@@ -7515,8 +7732,6 @@
     cls.add_instance_attribute('hysteresis', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::maxReportCells [variable]
     cls.add_instance_attribute('maxReportCells', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::purpose [variable]
-    cls.add_instance_attribute('purpose', 'ns3::LteRrcSap::ReportConfigEutra::report', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::reportAmount [variable]
     cls.add_instance_attribute('reportAmount', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::ReportConfigEutra::reportOnLeave [variable]
@@ -7545,8 +7760,6 @@
     cls.add_constructor([])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::RlcConfig(ns3::LteRrcSap::RlcConfig const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteRrcSap::RlcConfig const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RlcConfig::choice [variable]
-    cls.add_instance_attribute('choice', 'ns3::LteRrcSap::RlcConfig::direction', is_const=False)
     return
 
 def register_Ns3LteRrcSapRrcConnectionReconfiguration_methods(root_module, cls):
@@ -7558,16 +7771,12 @@
     cls.add_instance_attribute('haveMeasConfig', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::haveMobilityControlInfo [variable]
     cls.add_instance_attribute('haveMobilityControlInfo', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::haveNonCriticalExtension [variable]
-    cls.add_instance_attribute('haveNonCriticalExtension', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::haveRadioResourceConfigDedicated [variable]
     cls.add_instance_attribute('haveRadioResourceConfigDedicated', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::measConfig [variable]
     cls.add_instance_attribute('measConfig', 'ns3::LteRrcSap::MeasConfig', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::mobilityControlInfo [variable]
     cls.add_instance_attribute('mobilityControlInfo', 'ns3::LteRrcSap::MobilityControlInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::nonCriticalExtension [variable]
-    cls.add_instance_attribute('nonCriticalExtension', 'ns3::LteRrcSap::NonCriticalExtensionConfiguration', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::radioResourceConfigDedicated [variable]
     cls.add_instance_attribute('radioResourceConfigDedicated', 'ns3::LteRrcSap::RadioResourceConfigDedicated', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionReconfiguration::rrcTransactionIdentifier [variable]
@@ -7644,6 +7853,8 @@
     cls.add_constructor([])
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::RrcConnectionRequest(ns3::LteRrcSap::RrcConnectionRequest const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionRequest const &', 'arg0')])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::isMc [variable]
+    cls.add_instance_attribute('isMc', 'bool', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest::ueIdentity [variable]
     cls.add_instance_attribute('ueIdentity', 'uint64_t', is_const=False)
     return
@@ -7668,21 +7879,17 @@
     cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapSCellToAddMod_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::SCellToAddMod() [constructor]
+def register_Ns3LteRrcSapRrcConnectionSwitch_methods(root_module, cls):
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::RrcConnectionSwitch() [constructor]
     cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::SCellToAddMod(ns3::LteRrcSap::SCellToAddMod const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::SCellToAddMod const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::cellIdentification [variable]
-    cls.add_instance_attribute('cellIdentification', 'ns3::LteRrcSap::CellIdentification', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::haveRadioResourceConfigDedicatedSCell [variable]
-    cls.add_instance_attribute('haveRadioResourceConfigDedicatedSCell', 'bool', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::radioResourceConfigCommonSCell [variable]
-    cls.add_instance_attribute('radioResourceConfigCommonSCell', 'ns3::LteRrcSap::RadioResourceConfigCommonSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::radioResourceConfigDedicateSCell [variable]
-    cls.add_instance_attribute('radioResourceConfigDedicateSCell', 'ns3::LteRrcSap::RadioResourceConfigDedicatedSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SCellToAddMod::sCellIndex [variable]
-    cls.add_instance_attribute('sCellIndex', 'uint32_t', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::RrcConnectionSwitch(ns3::LteRrcSap::RrcConnectionSwitch const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRrcSap::RrcConnectionSwitch const &', 'arg0')])
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::drbidList [variable]
+    cls.add_instance_attribute('drbidList', 'std::vector< unsigned char >', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::rrcTransactionIdentifier [variable]
+    cls.add_instance_attribute('rrcTransactionIdentifier', 'uint8_t', is_const=False)
+    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch::useMmWaveConnection [variable]
+    cls.add_instance_attribute('useMmWaveConnection', 'uint16_t', is_const=False)
     return
 
 def register_Ns3LteRrcSapSoundingRsUlConfigCommon_methods(root_module, cls):
@@ -7694,8 +7901,6 @@
     cls.add_instance_attribute('srsBandwidthConfig', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::srsSubframeConfig [variable]
     cls.add_instance_attribute('srsSubframeConfig', 'uint8_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigCommon::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::SoundingRsUlConfigCommon::action', is_const=False)
     return
 
 def register_Ns3LteRrcSapSoundingRsUlConfigDedicated_methods(root_module, cls):
@@ -7707,8 +7912,6 @@
     cls.add_instance_attribute('srsBandwidth', 'uint8_t', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::srsConfigIndex [variable]
     cls.add_instance_attribute('srsConfigIndex', 'uint16_t', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SoundingRsUlConfigDedicated::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::SoundingRsUlConfigDedicated::action', is_const=False)
     return
 
 def register_Ns3LteRrcSapSpeedStatePars_methods(root_module, cls):
@@ -7720,8 +7923,6 @@
     cls.add_instance_attribute('mobilityStateParameters', 'ns3::LteRrcSap::MobilityStateParameters', is_const=False)
     ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::timeToTriggerSf [variable]
     cls.add_instance_attribute('timeToTriggerSf', 'ns3::LteRrcSap::SpeedStateScaleFactors', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::SpeedStatePars::type [variable]
-    cls.add_instance_attribute('type', 'ns3::LteRrcSap::SpeedStatePars::action', is_const=False)
     return
 
 def register_Ns3LteRrcSapSpeedStateScaleFactors_methods(root_module, cls):
@@ -7788,39 +7989,6 @@
     cls.add_instance_attribute('range', 'uint8_t', is_const=False)
     return
 
-def register_Ns3LteRrcSapUlConfiguration_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::UlConfiguration() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::UlConfiguration(ns3::LteRrcSap::UlConfiguration const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::UlConfiguration const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::prachConfigSCell [variable]
-    cls.add_instance_attribute('prachConfigSCell', 'ns3::LteRrcSap::PrachConfigSCell', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::soundingRsUlConfigCommon [variable]
-    cls.add_instance_attribute('soundingRsUlConfigCommon', 'ns3::LteRrcSap::SoundingRsUlConfigCommon', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::ulFreqInfo [variable]
-    cls.add_instance_attribute('ulFreqInfo', 'ns3::LteRrcSap::FreqInfo', is_const=False)
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlConfiguration::ulPowerControlCommonSCell [variable]
-    cls.add_instance_attribute('ulPowerControlCommonSCell', 'ns3::LteRrcSap::UlPowerControlCommonSCell', is_const=False)
-    return
-
-def register_Ns3LteRrcSapUlPowerControlCommonSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell::UlPowerControlCommonSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell::UlPowerControlCommonSCell(ns3::LteRrcSap::UlPowerControlCommonSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::UlPowerControlCommonSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlCommonSCell::alpha [variable]
-    cls.add_instance_attribute('alpha', 'uint16_t', is_const=False)
-    return
-
-def register_Ns3LteRrcSapUlPowerControlDedicatedSCell_methods(root_module, cls):
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell::UlPowerControlDedicatedSCell() [constructor]
-    cls.add_constructor([])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell::UlPowerControlDedicatedSCell(ns3::LteRrcSap::UlPowerControlDedicatedSCell const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRrcSap::UlPowerControlDedicatedSCell const &', 'arg0')])
-    ## lte-rrc-sap.h (module 'lte'): ns3::LteRrcSap::UlPowerControlDedicatedSCell::pSrsOffset [variable]
-    cls.add_instance_attribute('pSrsOffset', 'uint16_t', is_const=False)
-    return
-
 def register_Ns3LteSpectrumValueCatcher_methods(root_module, cls):
     ## lte-chunk-processor.h (module 'lte'): ns3::LteSpectrumValueCatcher::LteSpectrumValueCatcher() [constructor]
     cls.add_constructor([])
@@ -7841,115 +8009,53 @@
     cls.add_constructor([])
     ## lte-spectrum-value-helper.h (module 'lte'): ns3::LteSpectrumValueHelper::LteSpectrumValueHelper(ns3::LteSpectrumValueHelper const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteSpectrumValueHelper const &', 'arg0')])
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateNoisePowerSpectralDensity(uint32_t earfcn, uint8_t bandwidth, double noiseFigure) [member function]
+    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateNoisePowerSpectralDensity(uint16_t earfcn, uint8_t bandwidth, double noiseFigure) [member function]
     cls.add_method('CreateNoisePowerSpectralDensity', 
                    'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'noiseFigure')], 
+                   [param('uint16_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'noiseFigure')], 
                    is_static=True)
     ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateNoisePowerSpectralDensity(double noiseFigure, ns3::Ptr<ns3::SpectrumModel> spectrumModel) [member function]
     cls.add_method('CreateNoisePowerSpectralDensity', 
                    'ns3::Ptr< ns3::SpectrumValue >', 
                    [param('double', 'noiseFigure'), param('ns3::Ptr< ns3::SpectrumModel >', 'spectrumModel')], 
                    is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateTxPowerSpectralDensity(uint32_t earfcn, uint8_t bandwidth, double powerTx, std::vector<int, std::allocator<int> > activeRbs) [member function]
+    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateTxPowerSpectralDensity(uint16_t earfcn, uint8_t bandwidth, double powerTx, std::vector<int, std::allocator<int> > activeRbs) [member function]
     cls.add_method('CreateTxPowerSpectralDensity', 
                    'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'powerTx'), param('std::vector< int >', 'activeRbs')], 
+                   [param('uint16_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'powerTx'), param('std::vector< int >', 'activeRbs')], 
                    is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateTxPowerSpectralDensity(uint32_t earfcn, uint8_t bandwidth, double powerTx, std::map<int, double, std::less<int>, std::allocator<std::pair<const int, double> > > powerTxMap, std::vector<int, std::allocator<int> > activeRbs) [member function]
+    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumValue> ns3::LteSpectrumValueHelper::CreateTxPowerSpectralDensity(uint16_t earfcn, uint8_t bandwidth, double powerTx, std::map<int, double, std::less<int>, std::allocator<std::pair<const int, double> > > powerTxMap, std::vector<int, std::allocator<int> > activeRbs) [member function]
     cls.add_method('CreateTxPowerSpectralDensity', 
                    'ns3::Ptr< ns3::SpectrumValue >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'powerTx'), param('std::map< int, double >', 'powerTxMap'), param('std::vector< int >', 'activeRbs')], 
+                   [param('uint16_t', 'earfcn'), param('uint8_t', 'bandwidth'), param('double', 'powerTx'), param('std::map< int, double >', 'powerTxMap'), param('std::vector< int >', 'activeRbs')], 
                    is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetCarrierFrequency(uint32_t earfcn) [member function]
+    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetCarrierFrequency(uint16_t earfcn) [member function]
     cls.add_method('GetCarrierFrequency', 
                    'double', 
-                   [param('uint32_t', 'earfcn')], 
+                   [param('uint16_t', 'earfcn')], 
                    is_static=True)
     ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetChannelBandwidth(uint8_t txBandwidthConf) [member function]
     cls.add_method('GetChannelBandwidth', 
                    'double', 
                    [param('uint8_t', 'txBandwidthConf')], 
                    is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static uint16_t ns3::LteSpectrumValueHelper::GetDownlinkCarrierBand(uint32_t nDl) [member function]
-    cls.add_method('GetDownlinkCarrierBand', 
-                   'uint16_t', 
-                   [param('uint32_t', 'nDl')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetDownlinkCarrierFrequency(uint32_t earfcn) [member function]
+    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetDownlinkCarrierFrequency(uint16_t earfcn) [member function]
     cls.add_method('GetDownlinkCarrierFrequency', 
                    'double', 
-                   [param('uint32_t', 'earfcn')], 
+                   [param('uint16_t', 'earfcn')], 
                    is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumModel> ns3::LteSpectrumValueHelper::GetSpectrumModel(uint32_t earfcn, uint8_t bandwidth) [member function]
+    ## lte-spectrum-value-helper.h (module 'lte'): static ns3::Ptr<ns3::SpectrumModel> ns3::LteSpectrumValueHelper::GetSpectrumModel(uint16_t earfcn, uint8_t bandwidth) [member function]
     cls.add_method('GetSpectrumModel', 
                    'ns3::Ptr< ns3::SpectrumModel >', 
-                   [param('uint32_t', 'earfcn'), param('uint8_t', 'bandwidth')], 
-                   is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static uint16_t ns3::LteSpectrumValueHelper::GetUplinkCarrierBand(uint32_t nDl) [member function]
-    cls.add_method('GetUplinkCarrierBand', 
-                   'uint16_t', 
-                   [param('uint32_t', 'nDl')], 
+                   [param('uint16_t', 'earfcn'), param('uint8_t', 'bandwidth')], 
                    is_static=True)
-    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetUplinkCarrierFrequency(uint32_t earfcn) [member function]
+    ## lte-spectrum-value-helper.h (module 'lte'): static double ns3::LteSpectrumValueHelper::GetUplinkCarrierFrequency(uint16_t earfcn) [member function]
     cls.add_method('GetUplinkCarrierFrequency', 
                    'double', 
-                   [param('uint32_t', 'earfcn')], 
+                   [param('uint16_t', 'earfcn')], 
                    is_static=True)
     return
 
-def register_Ns3LteUeCcmRrcSapProvider_methods(root_module, cls):
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LteUeCcmRrcSapProvider() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LteUeCcmRrcSapProvider(ns3::LteUeCcmRrcSapProvider const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCcmRrcSapProvider const &', 'arg0')])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): std::vector<ns3::LteUeCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteUeCcmRrcSapProvider::LcsConfig> > ns3::LteUeCcmRrcSapProvider::AddLc(uint8_t lcId, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('AddLc', 
-                   'std::vector< ns3::LteUeCcmRrcSapProvider::LcsConfig >', 
-                   [param('uint8_t', 'lcId'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteMacSapUser * ns3::LteUeCcmRrcSapProvider::ConfigureSignalBearer(uint8_t lcid, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('ConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('uint8_t', 'lcid'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): void ns3::LteUeCcmRrcSapProvider::NotifyConnectionReconfigurationMsg() [member function]
-    cls.add_method('NotifyConnectionReconfigurationMsg', 
-                   'void', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): std::vector<unsigned short, std::allocator<unsigned short> > ns3::LteUeCcmRrcSapProvider::RemoveLc(uint8_t lcid) [member function]
-    cls.add_method('RemoveLc', 
-                   'std::vector< unsigned short >', 
-                   [param('uint8_t', 'lcid')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
-def register_Ns3LteUeCcmRrcSapProviderLcsConfig_methods(root_module, cls):
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::LcsConfig() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::LcsConfig(ns3::LteUeCcmRrcSapProvider::LcsConfig const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCcmRrcSapProvider::LcsConfig const &', 'arg0')])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::componentCarrierId [variable]
-    cls.add_instance_attribute('componentCarrierId', 'uint8_t', is_const=False)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::lcConfig [variable]
-    cls.add_instance_attribute('lcConfig', 'ns3::LteUeCmacSapProvider::LogicalChannelConfig *', is_const=False)
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapProvider::LcsConfig::msu [variable]
-    cls.add_instance_attribute('msu', 'ns3::LteMacSapUser *', is_const=False)
-    return
-
-def register_Ns3LteUeCcmRrcSapUser_methods(root_module, cls):
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapUser::LteUeCcmRrcSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): ns3::LteUeCcmRrcSapUser::LteUeCcmRrcSapUser(ns3::LteUeCcmRrcSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeCcmRrcSapUser const &', 'arg0')])
-    ## lte-ue-ccm-rrc-sap.h (module 'lte'): void ns3::LteUeCcmRrcSapUser::ComponentCarrierEnabling(std::vector<unsigned char, std::allocator<unsigned char> > componentCarrierList) [member function]
-    cls.add_method('ComponentCarrierEnabling', 
-                   'void', 
-                   [param('std::vector< unsigned char >', 'componentCarrierList')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
 def register_Ns3LteUeCmacSapProvider_methods(root_module, cls):
     ## lte-ue-cmac-sap.h (module 'lte'): ns3::LteUeCmacSapProvider::LteUeCmacSapProvider() [constructor]
     cls.add_constructor([])
@@ -7975,11 +8081,6 @@
                    'void', 
                    [], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::SetRnti(uint16_t rnti) [member function]
-    cls.add_method('SetRnti', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   is_pure_virtual=True, is_virtual=True)
     ## lte-ue-cmac-sap.h (module 'lte'): void ns3::LteUeCmacSapProvider::StartContentionBasedRandomAccessProcedure() [member function]
     cls.add_method('StartContentionBasedRandomAccessProcedure', 
                    'void', 
@@ -8069,10 +8170,10 @@
                    'void', 
                    [param('int8_t', 'referenceSignalPower')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::ConfigureUplink(uint32_t ulEarfcn, uint8_t ulBandwidth) [member function]
+    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::ConfigureUplink(uint16_t ulEarfcn, uint8_t ulBandwidth) [member function]
     cls.add_method('ConfigureUplink', 
                    'void', 
-                   [param('uint32_t', 'ulEarfcn'), param('uint8_t', 'ulBandwidth')], 
+                   [param('uint16_t', 'ulEarfcn'), param('uint8_t', 'ulBandwidth')], 
                    is_pure_virtual=True, is_virtual=True)
     ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::Reset() [member function]
     cls.add_method('Reset', 
@@ -8104,20 +8205,20 @@
                    'void', 
                    [param('uint8_t', 'txMode')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::StartCellSearch(uint32_t dlEarfcn) [member function]
+    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::StartCellSearch(uint16_t dlEarfcn) [member function]
     cls.add_method('StartCellSearch', 
                    'void', 
-                   [param('uint32_t', 'dlEarfcn')], 
+                   [param('uint16_t', 'dlEarfcn')], 
                    is_pure_virtual=True, is_virtual=True)
     ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SynchronizeWithEnb(uint16_t cellId) [member function]
     cls.add_method('SynchronizeWithEnb', 
                    'void', 
                    [param('uint16_t', 'cellId')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SynchronizeWithEnb(uint16_t cellId, uint32_t dlEarfcn) [member function]
+    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapProvider::SynchronizeWithEnb(uint16_t cellId, uint16_t dlEarfcn) [member function]
     cls.add_method('SynchronizeWithEnb', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')], 
+                   [param('uint16_t', 'cellId'), param('uint16_t', 'dlEarfcn')], 
                    is_pure_virtual=True, is_virtual=True)
     return
 
@@ -8126,6 +8227,11 @@
     cls.add_constructor([])
     ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::LteUeCphySapUser(ns3::LteUeCphySapUser const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteUeCphySapUser const &', 'arg0')])
+    ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapUser::NotifyRadioLinkFailure(double lastSinrValue) [member function]
+    cls.add_method('NotifyRadioLinkFailure', 
+                   'void', 
+                   [param('double', 'lastSinrValue')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-ue-cphy-sap.h (module 'lte'): void ns3::LteUeCphySapUser::RecvMasterInformationBlock(uint16_t cellId, ns3::LteRrcSap::MasterInformationBlock mib) [member function]
     cls.add_method('RecvMasterInformationBlock', 
                    'void', 
@@ -8161,8 +8267,6 @@
     cls.add_constructor([])
     ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters::UeMeasurementsParameters(ns3::LteUeCphySapUser::UeMeasurementsParameters const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteUeCphySapUser::UeMeasurementsParameters const &', 'arg0')])
-    ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters::m_componentCarrierId [variable]
-    cls.add_instance_attribute('m_componentCarrierId', 'uint8_t', is_const=False)
     ## lte-ue-cphy-sap.h (module 'lte'): ns3::LteUeCphySapUser::UeMeasurementsParameters::m_ueMeasurementsList [variable]
     cls.add_instance_attribute('m_ueMeasurementsList', 'std::vector< ns3::LteUeCphySapUser::UeMeasurementsElement >', is_const=False)
     return
@@ -8221,6 +8325,11 @@
                    'void', 
                    [param('ns3::LteUeRrcSapProvider::CompleteSetupParameters', 'params')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectToMmWave(uint16_t mmWaveCellId) [member function]
+    cls.add_method('RecvRrcConnectToMmWave', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionReconfiguration(ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
     cls.add_method('RecvRrcConnectionReconfiguration', 
                    'void', 
@@ -8251,6 +8360,11 @@
                    'void', 
                    [param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvRrcConnectionSwitch(ns3::LteRrcSap::RrcConnectionSwitch msg) [member function]
+    cls.add_method('RecvRrcConnectionSwitch', 
+                   'void', 
+                   [param('ns3::LteRrcSap::RrcConnectionSwitch', 'msg')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapProvider::RecvSystemInformation(ns3::LteRrcSap::SystemInformation msg) [member function]
     cls.add_method('RecvSystemInformation', 
                    'void', 
@@ -8279,6 +8393,11 @@
                    'void', 
                    [param('ns3::LteRrcSap::MeasurementReport', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendNotifySecondaryCellConnected(uint16_t mmWaveRnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('SendNotifySecondaryCellConnected', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveRnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteUeRrcSapUser::SendRrcConnectionReconfigurationCompleted(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
     cls.add_method('SendRrcConnectionReconfigurationCompleted', 
                    'void', 
@@ -8952,8 +9071,6 @@
     cls.add_constructor([])
     ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::PhyTransmissionStatParameters(ns3::PhyTransmissionStatParameters const & arg0) [constructor]
     cls.add_constructor([param('ns3::PhyTransmissionStatParameters const &', 'arg0')])
-    ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_ccId [variable]
-    cls.add_instance_attribute('m_ccId', 'uint8_t', is_const=False)
     ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_cellId [variable]
     cls.add_instance_attribute('m_cellId', 'uint16_t', is_const=False)
     ## lte-common.h (module 'lte'): ns3::PhyTransmissionStatParameters::m_imsi [variable]
@@ -9448,6 +9565,74 @@
     cls.add_constructor([param('ns3::Time const', 'time'), param('ns3::Time::Unit const', 'unit')])
     return
 
+def register_Ns3TracedValue__Bool_methods(root_module, cls):
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool>::TracedValue() [constructor]
+    cls.add_constructor([])
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool>::TracedValue(ns3::TracedValue<bool> const & o) [constructor]
+    cls.add_constructor([param('ns3::TracedValue< bool > const &', 'o')])
+    ## traced-value.h (module 'core'): ns3::TracedValue<bool>::TracedValue(bool const & v) [constructor]
+    cls.add_constructor([param('bool const &', 'v')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::Connect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::ConnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('ConnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::Disconnect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Disconnect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::DisconnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('DisconnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): bool ns3::TracedValue<bool>::Get() const [member function]
+    cls.add_method('Get', 
+                   'bool', 
+                   [], 
+                   is_const=True)
+    ## traced-value.h (module 'core'): void ns3::TracedValue<bool>::Set(bool const & v) [member function]
+    cls.add_method('Set', 
+                   'void', 
+                   [param('bool const &', 'v')])
+    return
+
+def register_Ns3TracedValue__Unsigned_int_methods(root_module, cls):
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int>::TracedValue() [constructor]
+    cls.add_constructor([])
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int>::TracedValue(ns3::TracedValue<unsigned int> const & o) [constructor]
+    cls.add_constructor([param('ns3::TracedValue< unsigned int > const &', 'o')])
+    ## traced-value.h (module 'core'): ns3::TracedValue<unsigned int>::TracedValue(unsigned int const & v) [constructor]
+    cls.add_constructor([param('unsigned int const &', 'v')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::Connect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::ConnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('ConnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::Disconnect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Disconnect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::DisconnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('DisconnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): unsigned int ns3::TracedValue<unsigned int>::Get() const [member function]
+    cls.add_method('Get', 
+                   'unsigned int', 
+                   [], 
+                   is_const=True)
+    ## traced-value.h (module 'core'): void ns3::TracedValue<unsigned int>::Set(unsigned int const & v) [member function]
+    cls.add_method('Set', 
+                   'void', 
+                   [param('unsigned int const &', 'v')])
+    return
+
 def register_Ns3TransmissionModesLayers_methods(root_module, cls):
     ## lte-common.h (module 'lte'): ns3::TransmissionModesLayers::TransmissionModesLayers() [constructor]
     cls.add_constructor([])
@@ -10123,6 +10308,102 @@
                    is_virtual=True)
     return
 
+def register_Ns3EpcX2PdcpProvider_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpProvider::EpcX2PdcpProvider() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpProvider::EpcX2PdcpProvider(ns3::EpcX2PdcpProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2PdcpProvider const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2PdcpProvider::SendMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SendMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2PdcpUser_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpUser::EpcX2PdcpUser() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2PdcpUser::EpcX2PdcpUser(ns3::EpcX2PdcpUser const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2PdcpUser const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2PdcpUser::ReceiveMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('ReceiveMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2RlcProvider_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcProvider::EpcX2RlcProvider() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcProvider::EpcX2RlcProvider(ns3::EpcX2RlcProvider const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcProvider const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2RlcProvider::ReceiveMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('ReceiveMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2RlcUser_methods(root_module, cls):
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcUser::EpcX2RlcUser() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-sap.h (module 'lte'): ns3::EpcX2RlcUser::EpcX2RlcUser(ns3::EpcX2RlcUser const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcUser const &', 'arg0')])
+    ## epc-x2-sap.h (module 'lte'): void ns3::EpcX2RlcUser::SendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3EpcX2Tag_methods(root_module, cls):
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag::EpcX2Tag(ns3::EpcX2Tag const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Tag const &', 'arg0')])
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag::EpcX2Tag() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-tag.h (module 'lte'): ns3::EpcX2Tag::EpcX2Tag(ns3::Time senderTimestamp) [constructor]
+    cls.add_constructor([param('ns3::Time', 'senderTimestamp')])
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::Deserialize(ns3::TagBuffer i) [member function]
+    cls.add_method('Deserialize', 
+                   'void', 
+                   [param('ns3::TagBuffer', 'i')], 
+                   is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): ns3::TypeId ns3::EpcX2Tag::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): ns3::Time ns3::EpcX2Tag::GetSenderTimestamp() const [member function]
+    cls.add_method('GetSenderTimestamp', 
+                   'ns3::Time', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-tag.h (module 'lte'): uint32_t ns3::EpcX2Tag::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): static ns3::TypeId ns3::EpcX2Tag::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::Serialize(ns3::TagBuffer i) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::TagBuffer', 'i')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-tag.h (module 'lte'): void ns3::EpcX2Tag::SetSenderTimestamp(ns3::Time senderTimestamp) [member function]
+    cls.add_method('SetSenderTimestamp', 
+                   'void', 
+                   [param('ns3::Time', 'senderTimestamp')])
+    return
+
 def register_Ns3EpsBearerTag_methods(root_module, cls):
     ## eps-bearer-tag.h (module 'lte'): ns3::EpsBearerTag::EpsBearerTag(ns3::EpsBearerTag const & arg0) [constructor]
     cls.add_constructor([param('ns3::EpsBearerTag const &', 'arg0')])
@@ -10385,23 +10666,6 @@
                    [param('uint8_t', 'ttl')])
     return
 
-def register_Ns3LteCcmMacSapUser_methods(root_module, cls):
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapUser::LteCcmMacSapUser() [constructor]
-    cls.add_constructor([])
-    ## lte-ccm-mac-sap.h (module 'lte'): ns3::LteCcmMacSapUser::LteCcmMacSapUser(ns3::LteCcmMacSapUser const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteCcmMacSapUser const &', 'arg0')])
-    ## lte-ccm-mac-sap.h (module 'lte'): void ns3::LteCcmMacSapUser::NotifyPrbOccupancy(double prbOccupancy, uint8_t componentCarrierId) [member function]
-    cls.add_method('NotifyPrbOccupancy', 
-                   'void', 
-                   [param('double', 'prbOccupancy'), param('uint8_t', 'componentCarrierId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ccm-mac-sap.h (module 'lte'): void ns3::LteCcmMacSapUser::UlReceiveMacCe(ns3::MacCeListElement_s bsr, uint8_t componentCarrierId) [member function]
-    cls.add_method('UlReceiveMacCe', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr'), param('uint8_t', 'componentCarrierId')], 
-                   is_pure_virtual=True, is_virtual=True)
-    return
-
 def register_Ns3LteEnbRrcSapProvider_methods(root_module, cls):
     ## lte-rrc-sap.h (module 'lte'): ns3::LteEnbRrcSapProvider::LteEnbRrcSapProvider() [constructor]
     cls.add_constructor([])
@@ -10442,6 +10706,11 @@
                    'void', 
                    [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapProvider::RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('RecvRrcSecondaryCellInitialAccessSuccessful', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveRnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     return
 
 def register_Ns3LteEnbRrcSapProviderCompleteSetupUeParameters_methods(root_module, cls):
@@ -10485,6 +10754,11 @@
                    'void', 
                    [param('uint16_t', 'rnti')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectToMmWave(uint16_t rnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('SendRrcConnectToMmWave', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'mmWaveCellId')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionReconfiguration(uint16_t rnti, ns3::LteRrcSap::RrcConnectionReconfiguration msg) [member function]
     cls.add_method('SendRrcConnectionReconfiguration', 
                    'void', 
@@ -10515,10 +10789,15 @@
                    'void', 
                    [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendSystemInformation(uint16_t cellId, ns3::LteRrcSap::SystemInformation msg) [member function]
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendRrcConnectionSwitch(uint16_t rnti, ns3::LteRrcSap::RrcConnectionSwitch msg) [member function]
+    cls.add_method('SendRrcConnectionSwitch', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::RrcConnectionSwitch', 'msg')], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SendSystemInformation(ns3::LteRrcSap::SystemInformation msg) [member function]
     cls.add_method('SendSystemInformation', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::LteRrcSap::SystemInformation', 'msg')], 
+                   [param('ns3::LteRrcSap::SystemInformation', 'msg')], 
                    is_pure_virtual=True, is_virtual=True)
     ## lte-rrc-sap.h (module 'lte'): void ns3::LteEnbRrcSapUser::SetupUe(uint16_t rnti, ns3::LteEnbRrcSapUser::SetupUeParameters params) [member function]
     cls.add_method('SetupUe', 
@@ -11099,6 +11378,35 @@
                    visibility='private', is_virtual=True)
     return
 
+def register_Ns3PacketFilter_methods(root_module, cls):
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter::PacketFilter(ns3::PacketFilter const & arg0) [constructor]
+    cls.add_constructor([param('ns3::PacketFilter const &', 'arg0')])
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter::PacketFilter() [constructor]
+    cls.add_constructor([])
+    ## packet-filter.h (module 'traffic-control'): int32_t ns3::PacketFilter::Classify(ns3::Ptr<ns3::QueueDiscItem> item) const [member function]
+    cls.add_method('Classify', 
+                   'int32_t', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_const=True)
+    ## packet-filter.h (module 'traffic-control'): static ns3::TypeId ns3::PacketFilter::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## packet-filter.h (module 'traffic-control'): ns3::PacketFilter::PF_NO_MATCH [variable]
+    cls.add_static_attribute('PF_NO_MATCH', 'int const', is_const=True)
+    ## packet-filter.h (module 'traffic-control'): bool ns3::PacketFilter::CheckProtocol(ns3::Ptr<ns3::QueueDiscItem> item) const [member function]
+    cls.add_method('CheckProtocol', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
+    ## packet-filter.h (module 'traffic-control'): int32_t ns3::PacketFilter::DoClassify(ns3::Ptr<ns3::QueueDiscItem> item) const [member function]
+    cls.add_method('DoClassify', 
+                   'int32_t', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
+    return
+
 def register_Ns3PdcpTag_methods(root_module, cls):
     ## lte-pdcp-tag.h (module 'lte'): ns3::PdcpTag::PdcpTag(ns3::PdcpTag const & arg0) [constructor]
     cls.add_constructor([param('ns3::PdcpTag const &', 'arg0')])
@@ -11147,20 +11455,292 @@
                    [param('ns3::Time', 'senderTimestamp')])
     return
 
-def register_Ns3RadioEnvironmentMapHelper_methods(root_module, cls):
-    ## radio-environment-map-helper.h (module 'lte'): ns3::RadioEnvironmentMapHelper::RadioEnvironmentMapHelper() [constructor]
+def register_Ns3QueueDisc_methods(root_module, cls):
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::QueueDisc() [constructor]
     cls.add_constructor([])
-    ## radio-environment-map-helper.h (module 'lte'): void ns3::RadioEnvironmentMapHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::AddInternalQueue(ns3::Ptr<ns3::Queue<ns3::QueueDiscItem> > queue) [member function]
+    cls.add_method('AddInternalQueue', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Queue< ns3::QueueDiscItem > >', 'queue')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::AddPacketFilter(ns3::Ptr<ns3::PacketFilter> filter) [member function]
+    cls.add_method('AddPacketFilter', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::PacketFilter >', 'filter')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::AddQueueDiscClass(ns3::Ptr<ns3::QueueDiscClass> qdClass) [member function]
+    cls.add_method('AddQueueDiscClass', 
                    'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscClass >', 'qdClass')])
+    ## queue-disc.h (module 'traffic-control'): int32_t ns3::QueueDisc::Classify(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('Classify', 
+                   'int32_t', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')])
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscItem> ns3::QueueDisc::Dequeue() [member function]
+    cls.add_method('Dequeue', 
+                   'ns3::Ptr< ns3::QueueDiscItem >', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::Enqueue(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('Enqueue', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')])
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::Queue<ns3::QueueDiscItem> > ns3::QueueDisc::GetInternalQueue(uint32_t i) const [member function]
+    cls.add_method('GetInternalQueue', 
+                   'ns3::Ptr< ns3::Queue< ns3::QueueDiscItem > >', 
+                   [param('uint32_t', 'i')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNBytes() const [member function]
+    cls.add_method('GetNBytes', 
+                   'uint32_t', 
                    [], 
-                   is_virtual=True)
-    ## radio-environment-map-helper.h (module 'lte'): uint8_t ns3::RadioEnvironmentMapHelper::GetBandwidth() const [member function]
-    cls.add_method('GetBandwidth', 
-                   'uint8_t', 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNInternalQueues() const [member function]
+    cls.add_method('GetNInternalQueues', 
+                   'uint32_t', 
                    [], 
                    is_const=True)
-    ## radio-environment-map-helper.h (module 'lte'): static ns3::TypeId ns3::RadioEnvironmentMapHelper::GetTypeId() [member function]
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNPacketFilters() const [member function]
+    cls.add_method('GetNPacketFilters', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNPackets() const [member function]
+    cls.add_method('GetNPackets', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetNQueueDiscClasses() const [member function]
+    cls.add_method('GetNQueueDiscClasses', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::NetDevice> ns3::QueueDisc::GetNetDevice() const [member function]
+    cls.add_method('GetNetDevice', 
+                   'ns3::Ptr< ns3::NetDevice >', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::PacketFilter> ns3::QueueDisc::GetPacketFilter(uint32_t i) const [member function]
+    cls.add_method('GetPacketFilter', 
+                   'ns3::Ptr< ns3::PacketFilter >', 
+                   [param('uint32_t', 'i')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscClass> ns3::QueueDisc::GetQueueDiscClass(uint32_t i) const [member function]
+    cls.add_method('GetQueueDiscClass', 
+                   'ns3::Ptr< ns3::QueueDiscClass >', 
+                   [param('uint32_t', 'i')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::GetQuota() const [member function]
+    cls.add_method('GetQuota', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats const & ns3::QueueDisc::GetStats() [member function]
+    cls.add_method('GetStats', 
+                   'ns3::QueueDisc::Stats const &', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): static ns3::TypeId ns3::QueueDisc::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::WakeMode ns3::QueueDisc::GetWakeMode() const [member function]
+    cls.add_method('GetWakeMode', 
+                   'ns3::QueueDisc::WakeMode', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<const ns3::QueueDiscItem> ns3::QueueDisc::Peek() const [member function]
+    cls.add_method('Peek', 
+                   'ns3::Ptr< ns3::QueueDiscItem const >', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::Run() [member function]
+    cls.add_method('Run', 
+                   'void', 
+                   [])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::SetNetDevice(ns3::Ptr<ns3::NetDevice> device) [member function]
+    cls.add_method('SetNetDevice', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'device')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::SetQuota(uint32_t const quota) [member function]
+    cls.add_method('SetQuota', 
+                   'void', 
+                   [param('uint32_t const', 'quota')], 
+                   is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::CHILD_QUEUE_DISC_DROP [variable]
+    cls.add_static_attribute('CHILD_QUEUE_DISC_DROP', 'char const * const', is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::INTERNAL_QUEUE_DROP [variable]
+    cls.add_static_attribute('INTERNAL_QUEUE_DROP', 'char const * const', is_const=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   visibility='protected', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DoInitialize() [member function]
+    cls.add_method('DoInitialize', 
+                   'void', 
+                   [], 
+                   visibility='protected', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DropAfterDequeue(ns3::Ptr<const ns3::QueueDiscItem> item, char const * reason) [member function]
+    cls.add_method('DropAfterDequeue', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'item'), param('char const *', 'reason')], 
+                   visibility='protected')
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::DropBeforeEnqueue(ns3::Ptr<const ns3::QueueDiscItem> item, char const * reason) [member function]
+    cls.add_method('DropBeforeEnqueue', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'item'), param('char const *', 'reason')], 
+                   visibility='protected')
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::Mark(ns3::Ptr<ns3::QueueDiscItem> item, char const * reason) [member function]
+    cls.add_method('Mark', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item'), param('char const *', 'reason')], 
+                   visibility='protected')
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::CheckConfig() [member function]
+    cls.add_method('CheckConfig', 
+                   'bool', 
+                   [], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscItem> ns3::QueueDisc::DoDequeue() [member function]
+    cls.add_method('DoDequeue', 
+                   'ns3::Ptr< ns3::QueueDiscItem >', 
+                   [], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): bool ns3::QueueDisc::DoEnqueue(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('DoEnqueue', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<const ns3::QueueDiscItem> ns3::QueueDisc::DoPeek() const [member function]
+    cls.add_method('DoPeek', 
+                   'ns3::Ptr< ns3::QueueDiscItem const >', 
+                   [], 
+                   is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::InitializeParams() [member function]
+    cls.add_method('InitializeParams', 
+                   'void', 
+                   [], 
+                   is_pure_virtual=True, visibility='private', is_virtual=True)
+    return
+
+def register_Ns3QueueDiscStats_methods(root_module, cls):
+    cls.add_output_stream_operator()
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::Stats(ns3::QueueDisc::Stats const & arg0) [constructor]
+    cls.add_constructor([param('ns3::QueueDisc::Stats const &', 'arg0')])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::Stats() [constructor]
+    cls.add_constructor([])
+    ## queue-disc.h (module 'traffic-control'): uint64_t ns3::QueueDisc::Stats::GetNDroppedBytes(std::string reason) const [member function]
+    cls.add_method('GetNDroppedBytes', 
+                   'uint64_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::Stats::GetNDroppedPackets(std::string reason) const [member function]
+    cls.add_method('GetNDroppedPackets', 
+                   'uint32_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint64_t ns3::QueueDisc::Stats::GetNMarkedBytes(std::string reason) const [member function]
+    cls.add_method('GetNMarkedBytes', 
+                   'uint64_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): uint32_t ns3::QueueDisc::Stats::GetNMarkedPackets(std::string reason) const [member function]
+    cls.add_method('GetNMarkedPackets', 
+                   'uint32_t', 
+                   [param('std::string', 'reason')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDisc::Stats::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedBytesAfterDequeue [variable]
+    cls.add_instance_attribute('nDroppedBytesAfterDequeue', 'std::map< std::string, unsigned long >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedBytesBeforeEnqueue [variable]
+    cls.add_instance_attribute('nDroppedBytesBeforeEnqueue', 'std::map< std::string, unsigned long >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedPacketsAfterDequeue [variable]
+    cls.add_instance_attribute('nDroppedPacketsAfterDequeue', 'std::map< std::string, unsigned int >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nDroppedPacketsBeforeEnqueue [variable]
+    cls.add_instance_attribute('nDroppedPacketsBeforeEnqueue', 'std::map< std::string, unsigned int >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nMarkedBytes [variable]
+    cls.add_instance_attribute('nMarkedBytes', 'std::map< std::string, unsigned long >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nMarkedPackets [variable]
+    cls.add_instance_attribute('nMarkedPackets', 'std::map< std::string, unsigned int >', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDequeuedBytes [variable]
+    cls.add_instance_attribute('nTotalDequeuedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDequeuedPackets [variable]
+    cls.add_instance_attribute('nTotalDequeuedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedBytes [variable]
+    cls.add_instance_attribute('nTotalDroppedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedBytesAfterDequeue [variable]
+    cls.add_instance_attribute('nTotalDroppedBytesAfterDequeue', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedBytesBeforeEnqueue [variable]
+    cls.add_instance_attribute('nTotalDroppedBytesBeforeEnqueue', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedPackets [variable]
+    cls.add_instance_attribute('nTotalDroppedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedPacketsAfterDequeue [variable]
+    cls.add_instance_attribute('nTotalDroppedPacketsAfterDequeue', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalDroppedPacketsBeforeEnqueue [variable]
+    cls.add_instance_attribute('nTotalDroppedPacketsBeforeEnqueue', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalEnqueuedBytes [variable]
+    cls.add_instance_attribute('nTotalEnqueuedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalEnqueuedPackets [variable]
+    cls.add_instance_attribute('nTotalEnqueuedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalMarkedBytes [variable]
+    cls.add_instance_attribute('nTotalMarkedBytes', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalMarkedPackets [variable]
+    cls.add_instance_attribute('nTotalMarkedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalReceivedBytes [variable]
+    cls.add_instance_attribute('nTotalReceivedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalReceivedPackets [variable]
+    cls.add_instance_attribute('nTotalReceivedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalRequeuedBytes [variable]
+    cls.add_instance_attribute('nTotalRequeuedBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalRequeuedPackets [variable]
+    cls.add_instance_attribute('nTotalRequeuedPackets', 'uint32_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalSentBytes [variable]
+    cls.add_instance_attribute('nTotalSentBytes', 'uint64_t', is_const=False)
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDisc::Stats::nTotalSentPackets [variable]
+    cls.add_instance_attribute('nTotalSentPackets', 'uint32_t', is_const=False)
+    return
+
+def register_Ns3QueueDiscClass_methods(root_module, cls):
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDiscClass::QueueDiscClass(ns3::QueueDiscClass const & arg0) [constructor]
+    cls.add_constructor([param('ns3::QueueDiscClass const &', 'arg0')])
+    ## queue-disc.h (module 'traffic-control'): ns3::QueueDiscClass::QueueDiscClass() [constructor]
+    cls.add_constructor([])
+    ## queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDisc> ns3::QueueDiscClass::GetQueueDisc() const [member function]
+    cls.add_method('GetQueueDisc', 
+                   'ns3::Ptr< ns3::QueueDisc >', 
+                   [], 
+                   is_const=True)
+    ## queue-disc.h (module 'traffic-control'): static ns3::TypeId ns3::QueueDiscClass::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDiscClass::SetQueueDisc(ns3::Ptr<ns3::QueueDisc> qd) [member function]
+    cls.add_method('SetQueueDisc', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDisc >', 'qd')])
+    ## queue-disc.h (module 'traffic-control'): void ns3::QueueDiscClass::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3RadioEnvironmentMapHelper_methods(root_module, cls):
+    ## radio-environment-map-helper.h (module 'lte'): ns3::RadioEnvironmentMapHelper::RadioEnvironmentMapHelper() [constructor]
+    cls.add_constructor([])
+    ## radio-environment-map-helper.h (module 'lte'): void ns3::RadioEnvironmentMapHelper::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## radio-environment-map-helper.h (module 'lte'): uint8_t ns3::RadioEnvironmentMapHelper::GetBandwidth() const [member function]
+    cls.add_method('GetBandwidth', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## radio-environment-map-helper.h (module 'lte'): static ns3::TypeId ns3::RadioEnvironmentMapHelper::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
@@ -11218,6 +11798,71 @@
                    is_const=True, visibility='protected')
     return
 
+def register_Ns3RetxStatsCalculator_methods(root_module, cls):
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::RetxStatsCalculator() [constructor]
+    cls.add_constructor([])
+    ## retx-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::RetxStatsCalculator::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## retx-stats-calculator.h (module 'lte'): void ns3::RetxStatsCalculator::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## retx-stats-calculator.h (module 'lte'): void ns3::RetxStatsCalculator::RegisterRetxDl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx) [member function]
+    cls.add_method('RegisterRetxDl', 
+                   'void', 
+                   [param('uint64_t', 'imsi'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize'), param('uint32_t', 'numRetx')])
+    ## retx-stats-calculator.h (module 'lte'): void ns3::RetxStatsCalculator::RegisterRetxUl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx) [member function]
+    cls.add_method('RegisterRetxUl', 
+                   'void', 
+                   [param('uint64_t', 'imsi'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint32_t', 'packetSize'), param('uint32_t', 'numRetx')])
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxDlFile [variable]
+    cls.add_instance_attribute('m_retxDlFile', 'std::ofstream', is_const=False)
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxDlFilename [variable]
+    cls.add_instance_attribute('m_retxDlFilename', 'std::string', is_const=False)
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxUlFile [variable]
+    cls.add_instance_attribute('m_retxUlFile', 'std::ofstream', is_const=False)
+    ## retx-stats-calculator.h (module 'lte'): ns3::RetxStatsCalculator::m_retxUlFilename [variable]
+    cls.add_instance_attribute('m_retxUlFilename', 'std::string', is_const=False)
+    return
+
+def register_Ns3RlcBearerInfo_methods(root_module, cls):
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::RlcBearerInfo(ns3::RlcBearerInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RlcBearerInfo const &', 'arg0')])
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::RlcBearerInfo() [constructor]
+    cls.add_constructor([])
+    ## lte-radio-bearer-info.h (module 'lte'): static ns3::TypeId ns3::RlcBearerInfo::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::drbid [variable]
+    cls.add_instance_attribute('drbid', 'uint8_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::gtpTeid [variable]
+    cls.add_instance_attribute('gtpTeid', 'uint32_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::lcinfo [variable]
+    cls.add_instance_attribute('lcinfo', 'ns3::LteEnbCmacSapProvider::LcInfo', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::logicalChannelConfig [variable]
+    cls.add_instance_attribute('logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::logicalChannelIdentity [variable]
+    cls.add_instance_attribute('logicalChannelIdentity', 'uint8_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::lteRnti [variable]
+    cls.add_instance_attribute('lteRnti', 'uint16_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::m_rlc [variable]
+    cls.add_instance_attribute('m_rlc', 'ns3::Ptr< ns3::LteRlc >', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::mmWaveRnti [variable]
+    cls.add_instance_attribute('mmWaveRnti', 'uint16_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::rlcConfig [variable]
+    cls.add_instance_attribute('rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::RlcBearerInfo::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3RlcTag_methods(root_module, cls):
     ## lte-rlc-tag.h (module 'lte'): ns3::RlcTag::RlcTag(ns3::RlcTag const & arg0) [constructor]
     cls.add_constructor([param('ns3::RlcTag const &', 'arg0')])
@@ -11411,6 +12056,27 @@
     cls.add_constructor([param('ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter< ns3::Packet > > const &', 'o')])
     return
 
+def register_Ns3SimpleRefCount__Ns3QueueItem_Ns3Empty_Ns3DefaultDeleter__lt__ns3QueueItem__gt___methods(root_module, cls):
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >::SimpleRefCount() [constructor]
+    cls.add_constructor([])
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> >::SimpleRefCount(ns3::SimpleRefCount<ns3::QueueItem, ns3::empty, ns3::DefaultDeleter<ns3::QueueItem> > const & o) [constructor]
+    cls.add_constructor([param('ns3::SimpleRefCount< ns3::QueueItem, ns3::empty, ns3::DefaultDeleter< ns3::QueueItem > > const &', 'o')])
+    return
+
+def register_Ns3SimpleRefCount__Ns3S1apConnectionInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apConnectionInfo__gt___methods(root_module, cls):
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >::SimpleRefCount() [constructor]
+    cls.add_constructor([])
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> >::SimpleRefCount(ns3::SimpleRefCount<ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apConnectionInfo> > const & o) [constructor]
+    cls.add_constructor([param('ns3::SimpleRefCount< ns3::S1apConnectionInfo, ns3::empty, ns3::DefaultDeleter< ns3::S1apConnectionInfo > > const &', 'o')])
+    return
+
+def register_Ns3SimpleRefCount__Ns3S1apIfaceInfo_Ns3Empty_Ns3DefaultDeleter__lt__ns3S1apIfaceInfo__gt___methods(root_module, cls):
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >::SimpleRefCount() [constructor]
+    cls.add_constructor([])
+    ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> >::SimpleRefCount(ns3::SimpleRefCount<ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter<ns3::S1apIfaceInfo> > const & o) [constructor]
+    cls.add_constructor([param('ns3::SimpleRefCount< ns3::S1apIfaceInfo, ns3::empty, ns3::DefaultDeleter< ns3::S1apIfaceInfo > > const &', 'o')])
+    return
+
 def register_Ns3SimpleRefCount__Ns3SpectrumModel_Ns3Empty_Ns3DefaultDeleter__lt__ns3SpectrumModel__gt___methods(root_module, cls):
     ## simple-ref-count.h (module 'core'): ns3::SimpleRefCount<ns3::SpectrumModel, ns3::empty, ns3::DefaultDeleter<ns3::SpectrumModel> >::SimpleRefCount() [constructor]
     cls.add_constructor([])
@@ -12598,6 +13264,40 @@
                    is_pure_virtual=True, is_const=True, is_virtual=True)
     return
 
+def register_Ns3TracedValue__Ns3Time_methods(root_module, cls):
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time>::TracedValue() [constructor]
+    cls.add_constructor([])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time>::TracedValue(ns3::TracedValue<ns3::Time> const & o) [constructor]
+    cls.add_constructor([param('ns3::TracedValue< ns3::Time > const &', 'o')])
+    ## traced-value.h (module 'core'): ns3::TracedValue<ns3::Time>::TracedValue(ns3::Time const & v) [constructor]
+    cls.add_constructor([param('ns3::Time const &', 'v')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::Connect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::ConnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('ConnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::Disconnect(ns3::CallbackBase const & cb, std::string path) [member function]
+    cls.add_method('Disconnect', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb'), param('std::string', 'path')])
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::DisconnectWithoutContext(ns3::CallbackBase const & cb) [member function]
+    cls.add_method('DisconnectWithoutContext', 
+                   'void', 
+                   [param('ns3::CallbackBase const &', 'cb')])
+    ## traced-value.h (module 'core'): ns3::Time ns3::TracedValue<ns3::Time>::Get() const [member function]
+    cls.add_method('Get', 
+                   'ns3::Time', 
+                   [], 
+                   is_const=True)
+    ## traced-value.h (module 'core'): void ns3::TracedValue<ns3::Time>::Set(ns3::Time const & v) [member function]
+    cls.add_method('Set', 
+                   'void', 
+                   [param('ns3::Time const &', 'v')])
+    return
+
 def register_Ns3Trailer_methods(root_module, cls):
     cls.add_output_stream_operator()
     ## trailer.h (module 'network'): ns3::Trailer::Trailer() [constructor]
@@ -12679,8 +13379,8 @@
     cls.add_constructor([param('ns3::UeManager const &', 'arg0')])
     ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::UeManager() [constructor]
     cls.add_constructor([])
-    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::UeManager(ns3::Ptr<ns3::LteEnbRrc> rrc, uint16_t rnti, ns3::UeManager::State s, uint8_t componentCarrierId) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::LteEnbRrc >', 'rrc'), param('uint16_t', 'rnti'), param('ns3::UeManager::State', 's'), param('uint8_t', 'componentCarrierId')])
+    ## lte-enb-rrc.h (module 'lte'): ns3::UeManager::UeManager(ns3::Ptr<ns3::LteEnbRrc> rrc, uint16_t rnti, ns3::UeManager::State s) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::LteEnbRrc >', 'rrc'), param('uint16_t', 'rnti'), param('ns3::UeManager::State', 's')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::CmacUeConfigUpdateInd(ns3::LteEnbCmacSapUser::UeConfig cmacParams) [member function]
     cls.add_method('CmacUeConfigUpdateInd', 
                    'void', 
@@ -12693,11 +13393,10 @@
     cls.add_method('DoReceivePdcpSdu', 
                    'void', 
                    [param('ns3::LtePdcpSapUser::ReceivePdcpSduParameters', 'params')])
-    ## lte-enb-rrc.h (module 'lte'): uint8_t ns3::UeManager::GetComponentCarrierId() const [member function]
-    cls.add_method('GetComponentCarrierId', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): bool ns3::UeManager::GetAllMmWaveInOutageAtInitialAccess() [member function]
+    cls.add_method('GetAllMmWaveInOutageAtInitialAccess', 
+                   'bool', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > ns3::UeManager::GetErabList() [member function]
     cls.add_method('GetErabList', 
                    'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 
@@ -12707,6 +13406,11 @@
                    'uint64_t', 
                    [], 
                    is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): bool ns3::UeManager::GetIsMc() const [member function]
+    cls.add_method('GetIsMc', 
+                   'bool', 
+                   [], 
+                   is_const=True)
     ## lte-enb-rrc.h (module 'lte'): ns3::LteRrcSap::RadioResourceConfigDedicated ns3::UeManager::GetRadioResourceConfigForHandoverPreparationInfo() [member function]
     cls.add_method('GetRadioResourceConfigForHandoverPreparationInfo', 
                    'ns3::LteRrcSap::RadioResourceConfigDedicated', 
@@ -12720,6 +13424,10 @@
     cls.add_method('GetRrcConnectionReconfigurationForHandover', 
                    'ns3::LteRrcSap::RrcConnectionReconfiguration', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): std::pair<unsigned short, unsigned short> ns3::UeManager::GetSource() [member function]
+    cls.add_method('GetSource', 
+                   'std::pair< unsigned short, unsigned short >', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::UeManager::GetSrsConfigurationIndex() const [member function]
     cls.add_method('GetSrsConfigurationIndex', 
                    'uint16_t', 
@@ -12743,6 +13451,10 @@
     cls.add_method('RecordDataRadioBearersToBeStarted', 
                    'void', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvConnectionSwitchToMmWave(bool useMmWaveConnection, uint8_t drbid) [member function]
+    cls.add_method('RecvConnectionSwitchToMmWave', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection'), param('uint8_t', 'drbid')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvHandoverPreparationFailure(uint16_t cellId) [member function]
     cls.add_method('RecvHandoverPreparationFailure', 
                    'void', 
@@ -12755,6 +13467,18 @@
     cls.add_method('RecvMeasurementReport', 
                    'void', 
                    [param('ns3::LteRrcSap::MeasurementReport', 'msg')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvNotifyLteMmWaveHandoverCompleted() [member function]
+    cls.add_method('RecvNotifyLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRlcSetupCompleted(uint8_t drbid) [member function]
+    cls.add_method('RecvRlcSetupCompleted', 
+                   'void', 
+                   [param('uint8_t', 'drbid')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('RecvRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcConnectionReconfigurationCompleted(ns3::LteRrcSap::RrcConnectionReconfigurationCompleted msg) [member function]
     cls.add_method('RecvRrcConnectionReconfigurationCompleted', 
                    'void', 
@@ -12775,6 +13499,14 @@
     cls.add_method('RecvRrcConnectionSetupCompleted', 
                    'void', 
                    [param('ns3::LteRrcSap::RrcConnectionSetupCompleted', 'msg')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t mmWaveRnti, uint16_t mmWaveCellId) [member function]
+    cls.add_method('RecvRrcSecondaryCellInitialAccessSuccessful', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveRnti'), param('uint16_t', 'mmWaveCellId')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('RecvSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::RecvSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
     cls.add_method('RecvSnStatusTransfer', 
                    'void', 
@@ -12795,14 +13527,30 @@
     cls.add_method('SendData', 
                    'void', 
                    [param('uint8_t', 'bid'), param('ns3::Ptr< ns3::Packet >', 'p')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SendRrcConnectionSwitch(bool useMmWaveConnection) [member function]
+    cls.add_method('SendRrcConnectionSwitch', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SendUeContextRelease() [member function]
     cls.add_method('SendUeContextRelease', 
                    'void', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetAllMmWaveInOutageAtInitialAccess(bool param) [member function]
+    cls.add_method('SetAllMmWaveInOutageAtInitialAccess', 
+                   'void', 
+                   [param('bool', 'param')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetFirstConnection() [member function]
+    cls.add_method('SetFirstConnection', 
+                   'void', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetImsi(uint64_t imsi) [member function]
     cls.add_method('SetImsi', 
                    'void', 
                    [param('uint64_t', 'imsi')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetIsMc(bool isMc) [member function]
+    cls.add_method('SetIsMc', 
+                   'void', 
+                   [param('bool', 'isMc')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::UeManager::SetPdschConfigDedicated(ns3::LteRrcSap::PdschConfigDedicated pdschConfigDedicated) [member function]
     cls.add_method('SetPdschConfigDedicated', 
                    'void', 
@@ -13547,17 +14295,22 @@
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::NetDevice> '])
+                   is_static=True, visibility='protected', template_parameters=[u'unsigned int'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet const> '])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Time'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned short'])
+                   is_static=True, visibility='protected', template_parameters=[u'bool'])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
+    cls.add_method('GetCppTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Socket> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
@@ -13567,82 +14320,87 @@
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::NetDevice::PacketType'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::NetDevice> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::MobilityModel const> '])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet const> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::PacketBurst const> '])
+                   is_static=True, visibility='protected', template_parameters=[u'unsigned short'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::PhyReceptionStatParameters'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::NetDevice::PacketType'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'double'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned char'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::EpcUeNas::State'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::SpectrumValue> '])
+                   is_static=True, visibility='protected', template_parameters=[u'unsigned long'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::PhyTransmissionStatParameters'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::SpectrumValue const&'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::LteUePhy::State'])
+                   is_static=True, visibility='protected', template_parameters=[u'unsigned char'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'bool'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::MobilityModel const> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Socket> '])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::PacketBurst const> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned int'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::PhyReceptionStatParameters'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::Packet> '])
+                   is_static=True, visibility='protected', template_parameters=[u'double'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::EpcUeNas::State'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::SpectrumValue> '])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::SpectrumValue const&'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::PhyTransmissionStatParameters'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'unsigned long'])
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::Ptr<ns3::QueueDiscItem const> '])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
+    cls.add_method('GetCppTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True, visibility='protected', template_parameters=[u'char const*'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
@@ -13657,7 +14415,12 @@
     cls.add_method('GetCppTypeid', 
                    'std::string', 
                    [], 
-                   is_static=True, visibility='protected', template_parameters=[u'ns3::DlSchedulingCallbackInfo'])
+                   is_static=True, visibility='protected', template_parameters=[u'long double'])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
+    cls.add_method('GetCppTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True, visibility='protected', template_parameters=[u'ns3::LteUePhy::State'])
     ## callback.h (module 'core'): static std::string ns3::CallbackImplBase::GetCppTypeid() [member function]
     cls.add_method('GetCppTypeid', 
                    'std::string', 
@@ -13693,92 +14456,18 @@
                    [param('ns3::CallbackBase', 'base')])
     return
 
-def register_Ns3CcHelper_methods(root_module, cls):
-    ## cc-helper.h (module 'lte'): ns3::CcHelper::CcHelper(ns3::CcHelper const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CcHelper const &', 'arg0')])
-    ## cc-helper.h (module 'lte'): ns3::CcHelper::CcHelper() [constructor]
+def register_Ns3Channel_methods(root_module, cls):
+    ## channel.h (module 'network'): ns3::Channel::Channel(ns3::Channel const & arg0) [constructor]
+    cls.add_constructor([param('ns3::Channel const &', 'arg0')])
+    ## channel.h (module 'network'): ns3::Channel::Channel() [constructor]
     cls.add_constructor([])
-    ## cc-helper.h (module 'lte'): ns3::ComponentCarrier ns3::CcHelper::DoCreateSingleCc(uint16_t ulBandwidth, uint16_t dlBandwidth, uint32_t ulEarfcn, uint32_t dlEarfcn, bool isPrimary) [member function]
-    cls.add_method('DoCreateSingleCc', 
-                   'ns3::ComponentCarrier', 
-                   [param('uint16_t', 'ulBandwidth'), param('uint16_t', 'dlBandwidth'), param('uint32_t', 'ulEarfcn'), param('uint32_t', 'dlEarfcn'), param('bool', 'isPrimary')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## cc-helper.h (module 'lte'): std::map<unsigned char, ns3::ComponentCarrier, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::ComponentCarrier> > > ns3::CcHelper::EquallySpacedCcs() [member function]
-    cls.add_method('EquallySpacedCcs', 
-                   'std::map< unsigned char, ns3::ComponentCarrier >', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint16_t ns3::CcHelper::GetDlBandwidth() [member function]
-    cls.add_method('GetDlBandwidth', 
-                   'uint16_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint32_t ns3::CcHelper::GetDlEarfcn() [member function]
-    cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint16_t ns3::CcHelper::GetNumberOfComponentCarriers() [member function]
-    cls.add_method('GetNumberOfComponentCarriers', 
-                   'uint16_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): static ns3::TypeId ns3::CcHelper::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## cc-helper.h (module 'lte'): uint16_t ns3::CcHelper::GetUlBandwidth() [member function]
-    cls.add_method('GetUlBandwidth', 
-                   'uint16_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): uint32_t ns3::CcHelper::GetUlEarfcn() [member function]
-    cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
-                   [])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetCcAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetCcAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetDlBandwidth(uint16_t dlBandwidth) [member function]
-    cls.add_method('SetDlBandwidth', 
-                   'void', 
-                   [param('uint16_t', 'dlBandwidth')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetDlEarfcn(uint32_t dlEarfcn) [member function]
-    cls.add_method('SetDlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'dlEarfcn')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetNumberOfComponentCarriers(uint16_t nCc) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint16_t', 'nCc')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetUlBandwidth(uint16_t ulBandwidth) [member function]
-    cls.add_method('SetUlBandwidth', 
-                   'void', 
-                   [param('uint16_t', 'ulBandwidth')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::SetUlEarfcn(uint32_t ulEarfcn) [member function]
-    cls.add_method('SetUlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'ulEarfcn')])
-    ## cc-helper.h (module 'lte'): void ns3::CcHelper::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3Channel_methods(root_module, cls):
-    ## channel.h (module 'network'): ns3::Channel::Channel(ns3::Channel const & arg0) [constructor]
-    cls.add_constructor([param('ns3::Channel const &', 'arg0')])
-    ## channel.h (module 'network'): ns3::Channel::Channel() [constructor]
-    cls.add_constructor([])
-    ## channel.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::Channel::GetDevice(uint32_t i) const [member function]
-    cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::NetDevice >', 
-                   [param('uint32_t', 'i')], 
-                   is_pure_virtual=True, is_const=True, is_virtual=True)
-    ## channel.h (module 'network'): uint32_t ns3::Channel::GetId() const [member function]
-    cls.add_method('GetId', 
+    ## channel.h (module 'network'): ns3::Ptr<ns3::NetDevice> ns3::Channel::GetDevice(uint32_t i) const [member function]
+    cls.add_method('GetDevice', 
+                   'ns3::Ptr< ns3::NetDevice >', 
+                   [param('uint32_t', 'i')], 
+                   is_pure_virtual=True, is_const=True, is_virtual=True)
+    ## channel.h (module 'network'): uint32_t ns3::Channel::GetId() const [member function]
+    cls.add_method('GetId', 
                    'uint32_t', 
                    [], 
                    is_const=True)
@@ -13794,199 +14483,67 @@
                    is_static=True)
     return
 
-def register_Ns3ComponentCarrier_methods(root_module, cls):
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::ComponentCarrier(ns3::ComponentCarrier const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ComponentCarrier const &', 'arg0')])
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::ComponentCarrier() [constructor]
-    cls.add_constructor([])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## component-carrier.h (module 'lte'): uint32_t ns3::ComponentCarrier::GetCsgId() const [member function]
-    cls.add_method('GetCsgId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): bool ns3::ComponentCarrier::GetCsgIndication() const [member function]
-    cls.add_method('GetCsgIndication', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): uint8_t ns3::ComponentCarrier::GetDlBandwidth() const [member function]
-    cls.add_method('GetDlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): uint32_t ns3::ComponentCarrier::GetDlEarfcn() const [member function]
-    cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): static ns3::TypeId ns3::ComponentCarrier::GetTypeId() [member function]
+def register_Ns3CoDelQueueDisc_methods(root_module, cls):
+    ## codel-queue-disc.h (module 'traffic-control'): static ns3::TypeId ns3::CoDelQueueDisc::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## component-carrier.h (module 'lte'): uint8_t ns3::ComponentCarrier::GetUlBandwidth() const [member function]
-    cls.add_method('GetUlBandwidth', 
-                   'uint8_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): uint32_t ns3::ComponentCarrier::GetUlEarfcn() const [member function]
-    cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): bool ns3::ComponentCarrier::IsPrimary() const [member function]
-    cls.add_method('IsPrimary', 
-                   'bool', 
-                   [], 
-                   is_const=True)
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetAsPrimary(bool primaryCarrier) [member function]
-    cls.add_method('SetAsPrimary', 
-                   'void', 
-                   [param('bool', 'primaryCarrier')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetCsgId(uint32_t csgId) [member function]
-    cls.add_method('SetCsgId', 
-                   'void', 
-                   [param('uint32_t', 'csgId')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetCsgIndication(bool csgIndication) [member function]
-    cls.add_method('SetCsgIndication', 
-                   'void', 
-                   [param('bool', 'csgIndication')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetDlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetDlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetDlEarfcn(uint32_t earfcn) [member function]
-    cls.add_method('SetDlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetUlBandwidth(uint8_t bw) [member function]
-    cls.add_method('SetUlBandwidth', 
-                   'void', 
-                   [param('uint8_t', 'bw')])
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::SetUlEarfcn(uint32_t earfcn) [member function]
-    cls.add_method('SetUlEarfcn', 
-                   'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_dlBandwidth [variable]
-    cls.add_instance_attribute('m_dlBandwidth', 'uint8_t', is_const=False)
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_dlEarfcn [variable]
-    cls.add_instance_attribute('m_dlEarfcn', 'uint32_t', is_const=False)
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_ulBandwidth [variable]
-    cls.add_instance_attribute('m_ulBandwidth', 'uint8_t', is_const=False)
-    ## component-carrier.h (module 'lte'): ns3::ComponentCarrier::m_ulEarfcn [variable]
-    cls.add_instance_attribute('m_ulEarfcn', 'uint32_t', is_const=False)
-    ## component-carrier.h (module 'lte'): void ns3::ComponentCarrier::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ComponentCarrierEnb_methods(root_module, cls):
-    ## component-carrier-enb.h (module 'lte'): ns3::ComponentCarrierEnb::ComponentCarrierEnb(ns3::ComponentCarrierEnb const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ComponentCarrierEnb const &', 'arg0')])
-    ## component-carrier-enb.h (module 'lte'): ns3::ComponentCarrierEnb::ComponentCarrierEnb() [constructor]
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::CoDelQueueDisc() [constructor]
     cls.add_constructor([])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::DoDispose() [member function]
-    cls.add_method('DoDispose', 
+    ## codel-queue-disc.h (module 'traffic-control'): void ns3::CoDelQueueDisc::SetMode(ns3::CoDelQueueDisc::QueueDiscMode mode) [member function]
+    cls.add_method('SetMode', 
                    'void', 
-                   [], 
-                   is_virtual=True)
-    ## component-carrier-enb.h (module 'lte'): uint16_t ns3::ComponentCarrierEnb::GetCellId() [member function]
-    cls.add_method('GetCellId', 
-                   'uint16_t', 
+                   [param('ns3::CoDelQueueDisc::QueueDiscMode', 'mode')])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::QueueDiscMode ns3::CoDelQueueDisc::GetMode() [member function]
+    cls.add_method('GetMode', 
+                   'ns3::CoDelQueueDisc::QueueDiscMode', 
                    [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::FfMacScheduler> ns3::ComponentCarrierEnb::GetFfMacScheduler() [member function]
-    cls.add_method('GetFfMacScheduler', 
-                   'ns3::Ptr< ns3::FfMacScheduler >', 
-                   [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::LteFfrAlgorithm> ns3::ComponentCarrierEnb::GetFfrAlgorithm() [member function]
-    cls.add_method('GetFfrAlgorithm', 
-                   'ns3::Ptr< ns3::LteFfrAlgorithm >', 
+    ## codel-queue-disc.h (module 'traffic-control'): uint32_t ns3::CoDelQueueDisc::GetQueueSize() [member function]
+    cls.add_method('GetQueueSize', 
+                   'uint32_t', 
                    [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::LteEnbMac> ns3::ComponentCarrierEnb::GetMac() [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteEnbMac >', 
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Time ns3::CoDelQueueDisc::GetTarget() [member function]
+    cls.add_method('GetTarget', 
+                   'ns3::Time', 
                    [])
-    ## component-carrier-enb.h (module 'lte'): ns3::Ptr<ns3::LteEnbPhy> ns3::ComponentCarrierEnb::GetPhy() [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteEnbPhy >', 
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Time ns3::CoDelQueueDisc::GetInterval() [member function]
+    cls.add_method('GetInterval', 
+                   'ns3::Time', 
                    [])
-    ## component-carrier-enb.h (module 'lte'): static ns3::TypeId ns3::ComponentCarrierEnb::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetCellId(uint16_t cellId) [member function]
-    cls.add_method('SetCellId', 
-                   'void', 
-                   [param('uint16_t', 'cellId')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetFfMacScheduler(ns3::Ptr<ns3::FfMacScheduler> s) [member function]
-    cls.add_method('SetFfMacScheduler', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::FfMacScheduler >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetFfrAlgorithm(ns3::Ptr<ns3::LteFfrAlgorithm> s) [member function]
-    cls.add_method('SetFfrAlgorithm', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteFfrAlgorithm >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetMac(ns3::Ptr<ns3::LteEnbMac> s) [member function]
-    cls.add_method('SetMac', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteEnbMac >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::SetPhy(ns3::Ptr<ns3::LteEnbPhy> s) [member function]
-    cls.add_method('SetPhy', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteEnbPhy >', 's')])
-    ## component-carrier-enb.h (module 'lte'): void ns3::ComponentCarrierEnb::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
-def register_Ns3ComponentCarrierUe_methods(root_module, cls):
-    ## component-carrier-ue.h (module 'lte'): ns3::ComponentCarrierUe::ComponentCarrierUe(ns3::ComponentCarrierUe const & arg0) [constructor]
-    cls.add_constructor([param('ns3::ComponentCarrierUe const &', 'arg0')])
-    ## component-carrier-ue.h (module 'lte'): ns3::ComponentCarrierUe::ComponentCarrierUe() [constructor]
-    cls.add_constructor([])
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   is_virtual=True)
-    ## component-carrier-ue.h (module 'lte'): ns3::Ptr<ns3::LteUeMac> ns3::ComponentCarrierUe::GetMac() const [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteUeMac >', 
+    ## codel-queue-disc.h (module 'traffic-control'): uint32_t ns3::CoDelQueueDisc::GetDropNext() [member function]
+    cls.add_method('GetDropNext', 
+                   'uint32_t', 
+                   [])
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::TARGET_EXCEEDED_DROP [variable]
+    cls.add_static_attribute('TARGET_EXCEEDED_DROP', 'char const * const', is_const=True)
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::CoDelQueueDisc::OVERLIMIT_DROP [variable]
+    cls.add_static_attribute('OVERLIMIT_DROP', 'char const * const', is_const=True)
+    ## codel-queue-disc.h (module 'traffic-control'): bool ns3::CoDelQueueDisc::DoEnqueue(ns3::Ptr<ns3::QueueDiscItem> item) [member function]
+    cls.add_method('DoEnqueue', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem >', 'item')], 
+                   visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Ptr<ns3::QueueDiscItem> ns3::CoDelQueueDisc::DoDequeue() [member function]
+    cls.add_method('DoDequeue', 
+                   'ns3::Ptr< ns3::QueueDiscItem >', 
                    [], 
-                   is_const=True)
-    ## component-carrier-ue.h (module 'lte'): ns3::Ptr<ns3::LteUePhy> ns3::ComponentCarrierUe::GetPhy() const [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteUePhy >', 
+                   visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): ns3::Ptr<const ns3::QueueDiscItem> ns3::CoDelQueueDisc::DoPeek() const [member function]
+    cls.add_method('DoPeek', 
+                   'ns3::Ptr< ns3::QueueDiscItem const >', 
                    [], 
-                   is_const=True)
-    ## component-carrier-ue.h (module 'lte'): static ns3::TypeId ns3::ComponentCarrierUe::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
+                   is_const=True, visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): bool ns3::CoDelQueueDisc::CheckConfig() [member function]
+    cls.add_method('CheckConfig', 
+                   'bool', 
                    [], 
-                   is_static=True)
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::SetMac(ns3::Ptr<ns3::LteUeMac> s) [member function]
-    cls.add_method('SetMac', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteUeMac >', 's')])
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::SetPhy(ns3::Ptr<ns3::LteUePhy> s) [member function]
-    cls.add_method('SetPhy', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteUePhy >', 's')])
-    ## component-carrier-ue.h (module 'lte'): void ns3::ComponentCarrierUe::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
+                   visibility='private', is_virtual=True)
+    ## codel-queue-disc.h (module 'traffic-control'): void ns3::CoDelQueueDisc::InitializeParams() [member function]
+    cls.add_method('InitializeParams', 
                    'void', 
                    [], 
-                   visibility='protected', is_virtual=True)
+                   visibility='private', is_virtual=True)
     return
 
 def register_Ns3ConstantRandomVariable_methods(root_module, cls):
@@ -14441,10 +14998,10 @@
     cls.add_method('SetS1SapUser', 
                    'void', 
                    [param('ns3::EpcEnbS1SapUser *', 's')])
-    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::SetS1apSapMme(ns3::EpcS1apSapMme * s) [member function]
+    ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::SetS1apSapMme(ns3::EpcS1apSapEnbProvider * s) [member function]
     cls.add_method('SetS1apSapMme', 
                    'void', 
-                   [param('ns3::EpcS1apSapMme *', 's')])
+                   [param('ns3::EpcS1apSapEnbProvider *', 's')])
     ## epc-enb-application.h (module 'lte'): void ns3::EpcEnbApplication::DoDispose() [member function]
     cls.add_method('DoDispose', 
                    'void', 
@@ -14477,6 +15034,11 @@
                    'uint8_t', 
                    [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
                    is_pure_virtual=True, is_virtual=True)
+    ## epc-helper.h (module 'lte'): uint8_t ns3::EpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, ns3::Ptr<ns3::EpcUeNas> ueNas, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('ActivateEpsBearer', 
+                   'uint8_t', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('ns3::Ptr< ns3::EpcUeNas >', 'ueNas'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
+                   is_pure_virtual=True, is_virtual=True)
     ## epc-helper.h (module 'lte'): void ns3::EpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
     cls.add_method('AddEnb', 
                    'void', 
@@ -14560,743 +15122,2008 @@
                    visibility='protected', is_virtual=True)
     return
 
-def register_Ns3EpcSgwPgwApplication_methods(root_module, cls):
-    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication::EpcSgwPgwApplication(ns3::EpcSgwPgwApplication const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcSgwPgwApplication const &', 'arg0')])
-    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication::EpcSgwPgwApplication(ns3::Ptr<ns3::VirtualNetDevice> const tunDevice, ns3::Ptr<ns3::Socket> const s1uSocket) [constructor]
-    cls.add_constructor([param('ns3::Ptr< ns3::VirtualNetDevice > const', 'tunDevice'), param('ns3::Ptr< ns3::Socket > const', 's1uSocket')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::AddEnb(uint16_t cellId, ns3::Ipv4Address enbAddr, ns3::Ipv4Address sgwAddr) [member function]
+def register_Ns3EpcMmeApplication_methods(root_module, cls):
+    ## epc-mme-application.h (module 'lte'): ns3::EpcMmeApplication::EpcMmeApplication(ns3::EpcMmeApplication const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcMmeApplication const &', 'arg0')])
+    ## epc-mme-application.h (module 'lte'): ns3::EpcMmeApplication::EpcMmeApplication() [constructor]
+    cls.add_constructor([])
+    ## epc-mme-application.h (module 'lte'): uint8_t ns3::EpcMmeApplication::AddBearer(uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('AddBearer', 
+                   'uint8_t', 
+                   [param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::AddEnb(uint16_t ecgi, ns3::Ipv4Address enbS1UAddr) [member function]
     cls.add_method('AddEnb', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('ns3::Ipv4Address', 'enbAddr'), param('ns3::Ipv4Address', 'sgwAddr')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::AddUe(uint64_t imsi) [member function]
+                   [param('uint16_t', 'ecgi'), param('ns3::Ipv4Address', 'enbS1UAddr')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::AddUe(uint64_t imsi) [member function]
     cls.add_method('AddUe', 
                    'void', 
                    [param('uint64_t', 'imsi')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::DoDispose() [member function]
+    ## epc-mme-application.h (module 'lte'): ns3::EpcS11SapMme * ns3::EpcMmeApplication::GetS11SapMme() [member function]
+    cls.add_method('GetS11SapMme', 
+                   'ns3::EpcS11SapMme *', 
+                   [])
+    ## epc-mme-application.h (module 'lte'): ns3::EpcS1apSapMme * ns3::EpcMmeApplication::GetS1apSapMme() [member function]
+    cls.add_method('GetS1apSapMme', 
+                   'ns3::EpcS1apSapMme *', 
+                   [])
+    ## epc-mme-application.h (module 'lte'): static ns3::TypeId ns3::EpcMmeApplication::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::SetS11SapSgw(ns3::EpcS11SapSgw * s) [member function]
+    cls.add_method('SetS11SapSgw', 
+                   'void', 
+                   [param('ns3::EpcS11SapSgw *', 's')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::SetS1apSapMmeProvider(ns3::EpcS1apSapMmeProvider * provider) [member function]
+    cls.add_method('SetS1apSapMmeProvider', 
+                   'void', 
+                   [param('ns3::EpcS1apSapMmeProvider *', 'provider')])
+    ## epc-mme-application.h (module 'lte'): void ns3::EpcMmeApplication::DoDispose() [member function]
     cls.add_method('DoDispose', 
                    'void', 
                    [], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3EpcS1APErabReleaseIndicationHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APErabReleaseIndicationHeader::EpcS1APErabReleaseIndicationHeader(ns3::EpcS1APErabReleaseIndicationHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APErabReleaseIndicationHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APErabReleaseIndicationHeader::EpcS1APErabReleaseIndicationHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcS11SapSgw * ns3::EpcSgwPgwApplication::GetS11SapSgw() [member function]
-    cls.add_method('GetS11SapSgw', 
-                   'ns3::EpcS11SapSgw *', 
-                   [])
-    ## epc-sgw-pgw-application.h (module 'lte'): static ns3::TypeId ns3::EpcSgwPgwApplication::GetTypeId() [member function]
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APErabReleaseIndicationHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > ns3::EpcS1APErabReleaseIndicationHeader::GetErabToBeReleaseIndication() const [member function]
+    cls.add_method('GetErabToBeReleaseIndication', 
+                   'std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APErabReleaseIndicationHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APErabReleaseIndicationHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APErabReleaseIndicationHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APErabReleaseIndicationHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::RecvFromS1uSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromS1uSocket', 
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-sgw-pgw-application.h (module 'lte'): bool ns3::EpcSgwPgwApplication::RecvFromTunDevice(ns3::Ptr<ns3::Packet> packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber) [member function]
-    cls.add_method('RecvFromTunDevice', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SendToS1uSocket(ns3::Ptr<ns3::Packet> packet, ns3::Ipv4Address enbS1uAddress, uint32_t teid) [member function]
-    cls.add_method('SendToS1uSocket', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Ipv4Address', 'enbS1uAddress'), param('uint32_t', 'teid')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SendToTunDevice(ns3::Ptr<ns3::Packet> packet, uint32_t teid) [member function]
-    cls.add_method('SendToTunDevice', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('uint32_t', 'teid')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SetS11SapMme(ns3::EpcS11SapMme * s) [member function]
-    cls.add_method('SetS11SapMme', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::SetErabReleaseIndication(std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    cls.add_method('SetErabReleaseIndication', 
                    'void', 
-                   [param('ns3::EpcS11SapMme *', 's')])
-    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SetUeAddress(uint64_t imsi, ns3::Ipv4Address ueAddr) [member function]
-    cls.add_method('SetUeAddress', 
+                   [param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APErabReleaseIndicationHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
                    'void', 
-                   [param('uint64_t', 'imsi'), param('ns3::Ipv4Address', 'ueAddr')])
+                   [param('uint64_t', 'mmeUeS1Id')])
     return
 
-def register_Ns3EpcTft_methods(root_module, cls):
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::EpcTft(ns3::EpcTft const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcTft const &', 'arg0')])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::EpcTft() [constructor]
+def register_Ns3EpcS1APHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader::EpcS1APHeader(ns3::EpcS1APHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APHeader::EpcS1APHeader() [constructor]
     cls.add_constructor([])
-    ## epc-tft.h (module 'lte'): uint8_t ns3::EpcTft::Add(ns3::EpcTft::PacketFilter f) [member function]
-    cls.add_method('Add', 
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint8_t ns3::EpcS1APHeader::GetProcedureCode() const [member function]
+    cls.add_method('GetProcedureCode', 
                    'uint8_t', 
-                   [param('ns3::EpcTft::PacketFilter', 'f')])
-    ## epc-tft.h (module 'lte'): static ns3::Ptr<ns3::EpcTft> ns3::EpcTft::Default() [member function]
-    cls.add_method('Default', 
-                   'ns3::Ptr< ns3::EpcTft >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-tft.h (module 'lte'): bool ns3::EpcTft::Matches(ns3::EpcTft::Direction direction, ns3::Ipv4Address remoteAddress, ns3::Ipv4Address localAddress, uint16_t remotePort, uint16_t localPort, uint8_t typeOfService) [member function]
-    cls.add_method('Matches', 
-                   'bool', 
-                   [param('ns3::EpcTft::Direction', 'direction'), param('ns3::Ipv4Address', 'remoteAddress'), param('ns3::Ipv4Address', 'localAddress'), param('uint16_t', 'remotePort'), param('uint16_t', 'localPort'), param('uint8_t', 'typeOfService')])
-    return
-
-def register_Ns3EpcTftPacketFilter_methods(root_module, cls):
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::PacketFilter(ns3::EpcTft::PacketFilter const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcTft::PacketFilter const &', 'arg0')])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::PacketFilter() [constructor]
-    cls.add_constructor([])
-    ## epc-tft.h (module 'lte'): bool ns3::EpcTft::PacketFilter::Matches(ns3::EpcTft::Direction d, ns3::Ipv4Address ra, ns3::Ipv4Address la, uint16_t rp, uint16_t lp, uint8_t tos) [member function]
-    cls.add_method('Matches', 
-                   'bool', 
-                   [param('ns3::EpcTft::Direction', 'd'), param('ns3::Ipv4Address', 'ra'), param('ns3::Ipv4Address', 'la'), param('uint16_t', 'rp'), param('uint16_t', 'lp'), param('uint8_t', 'tos')])
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::direction [variable]
-    cls.add_instance_attribute('direction', 'ns3::EpcTft::Direction', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localAddress [variable]
-    cls.add_instance_attribute('localAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localMask [variable]
-    cls.add_instance_attribute('localMask', 'ns3::Ipv4Mask', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localPortEnd [variable]
-    cls.add_instance_attribute('localPortEnd', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localPortStart [variable]
-    cls.add_instance_attribute('localPortStart', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::precedence [variable]
-    cls.add_instance_attribute('precedence', 'uint8_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remoteAddress [variable]
-    cls.add_instance_attribute('remoteAddress', 'ns3::Ipv4Address', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remoteMask [variable]
-    cls.add_instance_attribute('remoteMask', 'ns3::Ipv4Mask', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remotePortEnd [variable]
-    cls.add_instance_attribute('remotePortEnd', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remotePortStart [variable]
-    cls.add_instance_attribute('remotePortStart', 'uint16_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::typeOfService [variable]
-    cls.add_instance_attribute('typeOfService', 'uint8_t', is_const=False)
-    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::typeOfServiceMask [variable]
-    cls.add_instance_attribute('typeOfServiceMask', 'uint8_t', is_const=False)
-    return
-
-def register_Ns3EpcTftClassifier_methods(root_module, cls):
-    ## epc-tft-classifier.h (module 'lte'): ns3::EpcTftClassifier::EpcTftClassifier(ns3::EpcTftClassifier const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcTftClassifier const &', 'arg0')])
-    ## epc-tft-classifier.h (module 'lte'): ns3::EpcTftClassifier::EpcTftClassifier() [constructor]
-    cls.add_constructor([])
-    ## epc-tft-classifier.h (module 'lte'): void ns3::EpcTftClassifier::Add(ns3::Ptr<ns3::EpcTft> tft, uint32_t id) [member function]
-    cls.add_method('Add', 
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
                    'void', 
-                   [param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('uint32_t', 'id')])
-    ## epc-tft-classifier.h (module 'lte'): uint32_t ns3::EpcTftClassifier::Classify(ns3::Ptr<ns3::Packet> p, ns3::EpcTft::Direction direction) [member function]
-    cls.add_method('Classify', 
-                   'uint32_t', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('ns3::EpcTft::Direction', 'direction')])
-    ## epc-tft-classifier.h (module 'lte'): void ns3::EpcTftClassifier::Delete(uint32_t id) [member function]
-    cls.add_method('Delete', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
                    'void', 
-                   [param('uint32_t', 'id')])
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::SetLengthOfIes(uint32_t lengthOfIes) [member function]
+    cls.add_method('SetLengthOfIes', 
+                   'void', 
+                   [param('uint32_t', 'lengthOfIes')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::SetNumberOfIes(uint32_t numberOfIes) [member function]
+    cls.add_method('SetNumberOfIes', 
+                   'void', 
+                   [param('uint32_t', 'numberOfIes')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APHeader::SetProcedureCode(uint8_t procedureCode) [member function]
+    cls.add_method('SetProcedureCode', 
+                   'void', 
+                   [param('uint8_t', 'procedureCode')])
     return
 
-def register_Ns3EpcUeNas_methods(root_module, cls):
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::EpcUeNas(ns3::EpcUeNas const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcUeNas const &', 'arg0')])
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::EpcUeNas() [constructor]
+def register_Ns3EpcS1APInitialContextSetupRequestHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupRequestHeader::EpcS1APInitialContextSetupRequestHeader(ns3::EpcS1APInitialContextSetupRequestHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APInitialContextSetupRequestHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupRequestHeader::EpcS1APInitialContextSetupRequestHeader() [constructor]
     cls.add_constructor([])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::ActivateEpsBearer(ns3::EpsBearer bearer, ns3::Ptr<ns3::EpcTft> tft) [member function]
-    cls.add_method('ActivateEpsBearer', 
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialContextSetupRequestHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > ns3::EpcS1APInitialContextSetupRequestHeader::GetErabToBeSetupItem() const [member function]
+    cls.add_method('GetErabToBeSetupItem', 
+                   'std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APInitialContextSetupRequestHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialContextSetupRequestHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupRequestHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APInitialContextSetupRequestHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
                    'void', 
-                   [param('ns3::EpsBearer', 'bearer'), param('ns3::Ptr< ns3::EpcTft >', 'tft')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Connect() [member function]
-    cls.add_method('Connect', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
                    'void', 
-                   [])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Connect(uint16_t cellId, uint32_t dlEarfcn) [member function]
-    cls.add_method('Connect', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('uint32_t', 'dlEarfcn')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Disconnect() [member function]
-    cls.add_method('Disconnect', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::SetErabToBeSetupItem(std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList) [member function]
+    cls.add_method('SetErabToBeSetupItem', 
                    'void', 
-                   [])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::DoDispose() [member function]
-    cls.add_method('DoDispose', 
+                   [param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupRequestHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
                    'void', 
-                   [], 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1APInitialContextSetupResponseHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupResponseHeader::EpcS1APInitialContextSetupResponseHeader(ns3::EpcS1APInitialContextSetupResponseHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APInitialContextSetupResponseHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialContextSetupResponseHeader::EpcS1APInitialContextSetupResponseHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-ue-nas.h (module 'lte'): ns3::LteAsSapUser * ns3::EpcUeNas::GetAsSapUser() [member function]
-    cls.add_method('GetAsSapUser', 
-                   'ns3::LteAsSapUser *', 
-                   [])
-    ## epc-ue-nas.h (module 'lte'): uint32_t ns3::EpcUeNas::GetCsgId() const [member function]
-    cls.add_method('GetCsgId', 
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialContextSetupResponseHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > ns3::EpcS1APInitialContextSetupResponseHeader::GetErabSetupItem() const [member function]
+    cls.add_method('GetErabSetupItem', 
+                   'std::list< ns3::EpcS1apSap::ErabSetupItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APInitialContextSetupResponseHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::State ns3::EpcUeNas::GetState() const [member function]
-    cls.add_method('GetState', 
-                   'ns3::EpcUeNas::State', 
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialContextSetupResponseHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
                    [], 
                    is_const=True)
-    ## epc-ue-nas.h (module 'lte'): static ns3::TypeId ns3::EpcUeNas::GetTypeId() [member function]
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialContextSetupResponseHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APInitialContextSetupResponseHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-ue-nas.h (module 'lte'): bool ns3::EpcUeNas::Send(ns3::Ptr<ns3::Packet> p) [member function]
-    cls.add_method('Send', 
-                   'bool', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetAsSapProvider(ns3::LteAsSapProvider * s) [member function]
-    cls.add_method('SetAsSapProvider', 
-                   'void', 
-                   [param('ns3::LteAsSapProvider *', 's')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetCsgId(uint32_t csgId) [member function]
-    cls.add_method('SetCsgId', 
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
                    'void', 
-                   [param('uint32_t', 'csgId')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetDevice(ns3::Ptr<ns3::NetDevice> dev) [member function]
-    cls.add_method('SetDevice', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
                    'void', 
-                   [param('ns3::Ptr< ns3::NetDevice >', 'dev')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetForwardUpCallback(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> cb) [member function]
-    cls.add_method('SetForwardUpCallback', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
                    'void', 
-                   [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetImsi(uint64_t imsi) [member function]
-    cls.add_method('SetImsi', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::SetErabSetupItem(std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
+    cls.add_method('SetErabSetupItem', 
                    'void', 
-                   [param('uint64_t', 'imsi')])
-    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::StartCellSelection(uint32_t dlEarfcn) [member function]
-    cls.add_method('StartCellSelection', 
+                   [param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialContextSetupResponseHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
                    'void', 
-                   [param('uint32_t', 'dlEarfcn')])
+                   [param('uint64_t', 'mmeUeS1Id')])
     return
 
-def register_Ns3EpcX2_methods(root_module, cls):
-    ## epc-x2.h (module 'lte'): ns3::EpcX2::EpcX2(ns3::EpcX2 const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2 const &', 'arg0')])
-    ## epc-x2.h (module 'lte'): ns3::EpcX2::EpcX2() [constructor]
+def register_Ns3EpcS1APInitialUeMessageHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialUeMessageHeader::EpcS1APInitialUeMessageHeader(ns3::EpcS1APInitialUeMessageHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APInitialUeMessageHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APInitialUeMessageHeader::EpcS1APInitialUeMessageHeader() [constructor]
     cls.add_constructor([])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::AddX2Interface(uint16_t enb1CellId, ns3::Ipv4Address enb1X2Address, uint16_t enb2CellId, ns3::Ipv4Address enb2X2Address) [member function]
-    cls.add_method('AddX2Interface', 
-                   'void', 
-                   [param('uint16_t', 'enb1CellId'), param('ns3::Ipv4Address', 'enb1X2Address'), param('uint16_t', 'enb2CellId'), param('ns3::Ipv4Address', 'enb2X2Address')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-x2.h (module 'lte'): ns3::EpcX2SapProvider * ns3::EpcX2::GetEpcX2SapProvider() [member function]
-    cls.add_method('GetEpcX2SapProvider', 
-                   'ns3::EpcX2SapProvider *', 
-                   [])
-    ## epc-x2.h (module 'lte'): static ns3::TypeId ns3::EpcX2::GetTypeId() [member function]
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialUeMessageHeader::GetEcgi() const [member function]
+    cls.add_method('GetEcgi', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APInitialUeMessageHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APInitialUeMessageHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialUeMessageHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APInitialUeMessageHeader::GetSTmsi() const [member function]
+    cls.add_method('GetSTmsi', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APInitialUeMessageHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APInitialUeMessageHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::RecvFromX2cSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromX2cSocket', 
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::RecvFromX2uSocket(ns3::Ptr<ns3::Socket> socket) [member function]
-    cls.add_method('RecvFromX2uSocket', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetEcgi(uint16_t ecgi) [member function]
+    cls.add_method('SetEcgi', 
+                   'void', 
+                   [param('uint16_t', 'ecgi')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APInitialUeMessageHeader::SetSTmsi(uint64_t stmsi) [member function]
+    cls.add_method('SetSTmsi', 
+                   'void', 
+                   [param('uint64_t', 'stmsi')])
+    return
+
+def register_Ns3EpcS1APPathSwitchRequestAcknowledgeHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::EpcS1APPathSwitchRequestAcknowledgeHeader(ns3::EpcS1APPathSwitchRequestAcknowledgeHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APPathSwitchRequestAcknowledgeHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::EpcS1APPathSwitchRequestAcknowledgeHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetEcgi() const [member function]
+    cls.add_method('GetEcgi', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetErabSwitchedInUplinkItemList() const [member function]
+    cls.add_method('GetErabSwitchedInUplinkItemList', 
+                   'std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetEcgi(uint16_t ecgi) [member function]
+    cls.add_method('SetEcgi', 
+                   'void', 
+                   [param('uint16_t', 'ecgi')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetErabSwitchedInUplinkItemList(std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('SetErabSwitchedInUplinkItemList', 
+                   'void', 
+                   [param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInDownlinkList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestAcknowledgeHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1APPathSwitchRequestHeader_methods(root_module, cls):
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestHeader::EpcS1APPathSwitchRequestHeader(ns3::EpcS1APPathSwitchRequestHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1APPathSwitchRequestHeader const &', 'arg0')])
+    ## epc-s1ap-header.h (module 'lte'): ns3::EpcS1APPathSwitchRequestHeader::EpcS1APPathSwitchRequestHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestHeader::GetEcgi() const [member function]
+    cls.add_method('GetEcgi', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint16_t ns3::EpcS1APPathSwitchRequestHeader::GetEnbUeS1Id() const [member function]
+    cls.add_method('GetEnbUeS1Id', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > ns3::EpcS1APPathSwitchRequestHeader::GetErabSwitchedInDownlinkItemList() const [member function]
+    cls.add_method('GetErabSwitchedInDownlinkItemList', 
+                   'std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): ns3::TypeId ns3::EpcS1APPathSwitchRequestHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint64_t ns3::EpcS1APPathSwitchRequestHeader::GetMmeUeS1Id() const [member function]
+    cls.add_method('GetMmeUeS1Id', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-s1ap-header.h (module 'lte'): uint32_t ns3::EpcS1APPathSwitchRequestHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): static ns3::TypeId ns3::EpcS1APPathSwitchRequestHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetEcgi(uint16_t ecgi) [member function]
+    cls.add_method('SetEcgi', 
+                   'void', 
+                   [param('uint16_t', 'ecgi')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetEnbUeS1Id(uint16_t enbUeS1Id) [member function]
+    cls.add_method('SetEnbUeS1Id', 
+                   'void', 
+                   [param('uint16_t', 'enbUeS1Id')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetErabSwitchedInDownlinkItemList(std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('SetErabSwitchedInDownlinkItemList', 
+                   'void', 
+                   [param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')])
+    ## epc-s1ap-header.h (module 'lte'): void ns3::EpcS1APPathSwitchRequestHeader::SetMmeUeS1Id(uint64_t mmeUeS1Id) [member function]
+    cls.add_method('SetMmeUeS1Id', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id')])
+    return
+
+def register_Ns3EpcS1apEnb_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apEnb::EpcS1apEnb(ns3::EpcS1apEnb const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apEnb const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apEnb::EpcS1apEnb(ns3::Ptr<ns3::Socket> localSocket, ns3::Ipv4Address enbAddress, ns3::Ipv4Address mmeAddress, uint16_t cellId, uint16_t mmeId) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Socket >', 'localSocket'), param('ns3::Ipv4Address', 'enbAddress'), param('ns3::Ipv4Address', 'mmeAddress'), param('uint16_t', 'cellId'), param('uint16_t', 'mmeId')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::AddS1apInterface(uint16_t enbId, ns3::Ipv4Address enbAddress, uint16_t mmeId, ns3::Ipv4Address mmeAddress, ns3::Ptr<ns3::Socket> localS1apSocket) [member function]
+    cls.add_method('AddS1apInterface', 
+                   'void', 
+                   [param('uint16_t', 'enbId'), param('ns3::Ipv4Address', 'enbAddress'), param('uint16_t', 'mmeId'), param('ns3::Ipv4Address', 'mmeAddress'), param('ns3::Ptr< ns3::Socket >', 'localS1apSocket')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apSapEnbProvider * ns3::EpcS1apEnb::GetEpcS1apSapEnbProvider() [member function]
+    cls.add_method('GetEpcS1apSapEnbProvider', 
+                   'ns3::EpcS1apSapEnbProvider *', 
+                   [])
+    ## epc-s1ap.h (module 'lte'): static ns3::TypeId ns3::EpcS1apEnb::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::RecvFromS1apSocket(ns3::Ptr<ns3::Socket> socket) [member function]
+    cls.add_method('RecvFromS1apSocket', 
                    'void', 
                    [param('ns3::Ptr< ns3::Socket >', 'socket')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::SetEpcX2SapUser(ns3::EpcX2SapUser * s) [member function]
-    cls.add_method('SetEpcX2SapUser', 
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::SetEpcS1apSapEnbUser(ns3::EpcS1apSapEnb * s) [member function]
+    cls.add_method('SetEpcS1apSapEnbUser', 
                    'void', 
-                   [param('ns3::EpcX2SapUser *', 's')])
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
-    cls.add_method('DoSendHandoverPreparationFailure', 
+                   [param('ns3::EpcS1apSapEnb *', 's')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendErabReleaseIndication(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeReleasedIndication, std::allocator<ns3::EpcS1apSap::ErabToBeReleasedIndication> > erabToBeReleaseIndication) [member function]
+    cls.add_method('DoSendErabReleaseIndication', 
                    'void', 
-                   [param('ns3::EpcX2Sap::HandoverPreparationFailureParams', 'params')], 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeReleasedIndication >', 'erabToBeReleaseIndication')], 
                    visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverRequest(ns3::EpcX2Sap::HandoverRequestParams params) [member function]
-    cls.add_method('DoSendHandoverRequest', 
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendInitialContextSetupResponse(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabSetupItem, std::allocator<ns3::EpcS1apSap::ErabSetupItem> > erabSetupList) [member function]
+    cls.add_method('DoSendInitialContextSetupResponse', 
                    'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestParams', 'params')], 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabSetupItem >', 'erabSetupList')], 
                    visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverRequestAck(ns3::EpcX2Sap::HandoverRequestAckParams params) [member function]
-    cls.add_method('DoSendHandoverRequestAck', 
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendInitialUeMessage(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) [member function]
+    cls.add_method('DoSendInitialUeMessage', 
                    'void', 
-                   [param('ns3::EpcX2Sap::HandoverRequestAckParams', 'params')], 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('uint64_t', 'stmsi'), param('uint16_t', 'ecgi')], 
                    visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
-    cls.add_method('DoSendLoadInformation', 
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apEnb::DoSendPathSwitchRequest(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInDownlinkItem> > erabToBeSwitchedInDownlinkList) [member function]
+    cls.add_method('DoSendPathSwitchRequest', 
                    'void', 
-                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'gci'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInDownlinkItem >', 'erabToBeSwitchedInDownlinkList')], 
                    visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
-    cls.add_method('DoSendResourceStatusUpdate', 
+    return
+
+def register_Ns3EpcS1apMme_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apMme::EpcS1apMme(ns3::EpcS1apMme const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcS1apMme const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apMme::EpcS1apMme(ns3::Ptr<ns3::Socket> const s1apSocket, uint16_t mmeId) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Socket > const', 's1apSocket'), param('uint16_t', 'mmeId')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::AddS1apInterface(uint16_t enbId, ns3::Ipv4Address enbAddress) [member function]
+    cls.add_method('AddS1apInterface', 
                    'void', 
-                   [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
-    cls.add_method('DoSendSnStatusTransfer', 
+                   [param('uint16_t', 'enbId'), param('ns3::Ipv4Address', 'enbAddress')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::DoDispose() [member function]
+    cls.add_method('DoDispose', 
                    'void', 
-                   [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
+                   [], 
+                   is_virtual=True)
+    ## epc-s1ap.h (module 'lte'): ns3::EpcS1apSapMmeProvider * ns3::EpcS1apMme::GetEpcS1apSapMmeProvider() [member function]
+    cls.add_method('GetEpcS1apSapMmeProvider', 
+                   'ns3::EpcS1apSapMmeProvider *', 
+                   [])
+    ## epc-s1ap.h (module 'lte'): static ns3::TypeId ns3::EpcS1apMme::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::RecvFromS1apSocket(ns3::Ptr<ns3::Socket> socket) [member function]
+    cls.add_method('RecvFromS1apSocket', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::SetEpcS1apSapMmeUser(ns3::EpcS1apSapMme * s) [member function]
+    cls.add_method('SetEpcS1apSapMmeUser', 
+                   'void', 
+                   [param('ns3::EpcS1apSapMme *', 's')])
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::DoSendInitialContextSetupRequest(uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ns3::EpcS1apSap::ErabToBeSetupItem, std::allocator<ns3::EpcS1apSap::ErabToBeSetupItem> > erabToBeSetupList, uint16_t cellId) [member function]
+    cls.add_method('DoSendInitialContextSetupRequest', 
+                   'void', 
+                   [param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'enbUeS1Id'), param('std::list< ns3::EpcS1apSap::ErabToBeSetupItem >', 'erabToBeSetupList'), param('uint16_t', 'cellId')], 
                    visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
-    cls.add_method('DoSendUeContextRelease', 
+    ## epc-s1ap.h (module 'lte'): void ns3::EpcS1apMme::DoSendPathSwitchRequestAcknowledge(uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ns3::EpcS1apSap::ErabSwitchedInUplinkItem, std::allocator<ns3::EpcS1apSap::ErabSwitchedInUplinkItem> > erabToBeSwitchedInUplinkList) [member function]
+    cls.add_method('DoSendPathSwitchRequestAcknowledge', 
                    'void', 
-                   [param('ns3::EpcX2Sap::UeContextReleaseParams', 'params')], 
+                   [param('uint64_t', 'enbUeS1Id'), param('uint64_t', 'mmeUeS1Id'), param('uint16_t', 'cgi'), param('std::list< ns3::EpcS1apSap::ErabSwitchedInUplinkItem >', 'erabToBeSwitchedInUplinkList')], 
                    visibility='protected', is_virtual=True)
-    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeData(ns3::EpcX2Sap::UeDataParams params) [member function]
-    cls.add_method('DoSendUeData', 
+    return
+
+def register_Ns3EpcSgwPgwApplication_methods(root_module, cls):
+    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication::EpcSgwPgwApplication(ns3::EpcSgwPgwApplication const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcSgwPgwApplication const &', 'arg0')])
+    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcSgwPgwApplication::EpcSgwPgwApplication(ns3::Ptr<ns3::VirtualNetDevice> const tunDevice, ns3::Ptr<ns3::Socket> const s1uSocket) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::VirtualNetDevice > const', 'tunDevice'), param('ns3::Ptr< ns3::Socket > const', 's1uSocket')])
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::AddEnb(uint16_t cellId, ns3::Ipv4Address enbAddr, ns3::Ipv4Address sgwAddr) [member function]
+    cls.add_method('AddEnb', 
+                   'void', 
+                   [param('uint16_t', 'cellId'), param('ns3::Ipv4Address', 'enbAddr'), param('ns3::Ipv4Address', 'sgwAddr')])
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::AddUe(uint64_t imsi) [member function]
+    cls.add_method('AddUe', 
+                   'void', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## epc-sgw-pgw-application.h (module 'lte'): ns3::EpcS11SapSgw * ns3::EpcSgwPgwApplication::GetS11SapSgw() [member function]
+    cls.add_method('GetS11SapSgw', 
+                   'ns3::EpcS11SapSgw *', 
+                   [])
+    ## epc-sgw-pgw-application.h (module 'lte'): static ns3::TypeId ns3::EpcSgwPgwApplication::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::RecvFromS1uSocket(ns3::Ptr<ns3::Socket> socket) [member function]
+    cls.add_method('RecvFromS1uSocket', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
+    ## epc-sgw-pgw-application.h (module 'lte'): bool ns3::EpcSgwPgwApplication::RecvFromTunDevice(ns3::Ptr<ns3::Packet> packet, ns3::Address const & source, ns3::Address const & dest, uint16_t protocolNumber) [member function]
+    cls.add_method('RecvFromTunDevice', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')])
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SendToS1uSocket(ns3::Ptr<ns3::Packet> packet, ns3::Ipv4Address enbS1uAddress, uint32_t teid) [member function]
+    cls.add_method('SendToS1uSocket', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Ipv4Address', 'enbS1uAddress'), param('uint32_t', 'teid')])
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SendToTunDevice(ns3::Ptr<ns3::Packet> packet, uint32_t teid) [member function]
+    cls.add_method('SendToTunDevice', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'packet'), param('uint32_t', 'teid')])
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SetS11SapMme(ns3::EpcS11SapMme * s) [member function]
+    cls.add_method('SetS11SapMme', 
+                   'void', 
+                   [param('ns3::EpcS11SapMme *', 's')])
+    ## epc-sgw-pgw-application.h (module 'lte'): void ns3::EpcSgwPgwApplication::SetUeAddress(uint64_t imsi, ns3::Ipv4Address ueAddr) [member function]
+    cls.add_method('SetUeAddress', 
+                   'void', 
+                   [param('uint64_t', 'imsi'), param('ns3::Ipv4Address', 'ueAddr')])
+    return
+
+def register_Ns3EpcTft_methods(root_module, cls):
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::EpcTft(ns3::EpcTft const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcTft const &', 'arg0')])
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::EpcTft() [constructor]
+    cls.add_constructor([])
+    ## epc-tft.h (module 'lte'): uint8_t ns3::EpcTft::Add(ns3::EpcTft::PacketFilter f) [member function]
+    cls.add_method('Add', 
+                   'uint8_t', 
+                   [param('ns3::EpcTft::PacketFilter', 'f')])
+    ## epc-tft.h (module 'lte'): static ns3::Ptr<ns3::EpcTft> ns3::EpcTft::Default() [member function]
+    cls.add_method('Default', 
+                   'ns3::Ptr< ns3::EpcTft >', 
+                   [], 
+                   is_static=True)
+    ## epc-tft.h (module 'lte'): bool ns3::EpcTft::Matches(ns3::EpcTft::Direction direction, ns3::Ipv4Address remoteAddress, ns3::Ipv4Address localAddress, uint16_t remotePort, uint16_t localPort, uint8_t typeOfService) [member function]
+    cls.add_method('Matches', 
+                   'bool', 
+                   [param('ns3::EpcTft::Direction', 'direction'), param('ns3::Ipv4Address', 'remoteAddress'), param('ns3::Ipv4Address', 'localAddress'), param('uint16_t', 'remotePort'), param('uint16_t', 'localPort'), param('uint8_t', 'typeOfService')])
+    return
+
+def register_Ns3EpcTftPacketFilter_methods(root_module, cls):
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::PacketFilter(ns3::EpcTft::PacketFilter const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcTft::PacketFilter const &', 'arg0')])
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::PacketFilter() [constructor]
+    cls.add_constructor([])
+    ## epc-tft.h (module 'lte'): bool ns3::EpcTft::PacketFilter::Matches(ns3::EpcTft::Direction d, ns3::Ipv4Address ra, ns3::Ipv4Address la, uint16_t rp, uint16_t lp, uint8_t tos) [member function]
+    cls.add_method('Matches', 
+                   'bool', 
+                   [param('ns3::EpcTft::Direction', 'd'), param('ns3::Ipv4Address', 'ra'), param('ns3::Ipv4Address', 'la'), param('uint16_t', 'rp'), param('uint16_t', 'lp'), param('uint8_t', 'tos')])
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::direction [variable]
+    cls.add_instance_attribute('direction', 'ns3::EpcTft::Direction', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localAddress [variable]
+    cls.add_instance_attribute('localAddress', 'ns3::Ipv4Address', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localMask [variable]
+    cls.add_instance_attribute('localMask', 'ns3::Ipv4Mask', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localPortEnd [variable]
+    cls.add_instance_attribute('localPortEnd', 'uint16_t', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::localPortStart [variable]
+    cls.add_instance_attribute('localPortStart', 'uint16_t', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::precedence [variable]
+    cls.add_instance_attribute('precedence', 'uint8_t', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remoteAddress [variable]
+    cls.add_instance_attribute('remoteAddress', 'ns3::Ipv4Address', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remoteMask [variable]
+    cls.add_instance_attribute('remoteMask', 'ns3::Ipv4Mask', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remotePortEnd [variable]
+    cls.add_instance_attribute('remotePortEnd', 'uint16_t', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::remotePortStart [variable]
+    cls.add_instance_attribute('remotePortStart', 'uint16_t', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::typeOfService [variable]
+    cls.add_instance_attribute('typeOfService', 'uint8_t', is_const=False)
+    ## epc-tft.h (module 'lte'): ns3::EpcTft::PacketFilter::typeOfServiceMask [variable]
+    cls.add_instance_attribute('typeOfServiceMask', 'uint8_t', is_const=False)
+    return
+
+def register_Ns3EpcTftClassifier_methods(root_module, cls):
+    ## epc-tft-classifier.h (module 'lte'): ns3::EpcTftClassifier::EpcTftClassifier(ns3::EpcTftClassifier const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcTftClassifier const &', 'arg0')])
+    ## epc-tft-classifier.h (module 'lte'): ns3::EpcTftClassifier::EpcTftClassifier() [constructor]
+    cls.add_constructor([])
+    ## epc-tft-classifier.h (module 'lte'): void ns3::EpcTftClassifier::Add(ns3::Ptr<ns3::EpcTft> tft, uint32_t id) [member function]
+    cls.add_method('Add', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('uint32_t', 'id')])
+    ## epc-tft-classifier.h (module 'lte'): uint32_t ns3::EpcTftClassifier::Classify(ns3::Ptr<ns3::Packet> p, ns3::EpcTft::Direction direction) [member function]
+    cls.add_method('Classify', 
+                   'uint32_t', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('ns3::EpcTft::Direction', 'direction')])
+    ## epc-tft-classifier.h (module 'lte'): void ns3::EpcTftClassifier::Delete(uint32_t id) [member function]
+    cls.add_method('Delete', 
+                   'void', 
+                   [param('uint32_t', 'id')])
+    return
+
+def register_Ns3EpcUeNas_methods(root_module, cls):
+    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::EpcUeNas(ns3::EpcUeNas const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcUeNas const &', 'arg0')])
+    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::EpcUeNas() [constructor]
+    cls.add_constructor([])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::ActivateEpsBearer(ns3::EpsBearer bearer, ns3::Ptr<ns3::EpcTft> tft) [member function]
+    cls.add_method('ActivateEpsBearer', 
+                   'void', 
+                   [param('ns3::EpsBearer', 'bearer'), param('ns3::Ptr< ns3::EpcTft >', 'tft')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Connect() [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Connect(uint16_t cellId, uint16_t dlEarfcn) [member function]
+    cls.add_method('Connect', 
+                   'void', 
+                   [param('uint16_t', 'cellId'), param('uint16_t', 'dlEarfcn')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::ConnectMc(uint16_t cellId, uint16_t dlEarfcn, uint16_t mmWaveCellId) [member function]
+    cls.add_method('ConnectMc', 
+                   'void', 
+                   [param('uint16_t', 'cellId'), param('uint16_t', 'dlEarfcn'), param('uint16_t', 'mmWaveCellId')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::Disconnect() [member function]
+    cls.add_method('Disconnect', 
+                   'void', 
+                   [])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## epc-ue-nas.h (module 'lte'): ns3::LteAsSapUser * ns3::EpcUeNas::GetAsSapUser() [member function]
+    cls.add_method('GetAsSapUser', 
+                   'ns3::LteAsSapUser *', 
+                   [])
+    ## epc-ue-nas.h (module 'lte'): uint32_t ns3::EpcUeNas::GetCsgId() const [member function]
+    cls.add_method('GetCsgId', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-ue-nas.h (module 'lte'): ns3::EpcUeNas::State ns3::EpcUeNas::GetState() const [member function]
+    cls.add_method('GetState', 
+                   'ns3::EpcUeNas::State', 
+                   [], 
+                   is_const=True)
+    ## epc-ue-nas.h (module 'lte'): static ns3::TypeId ns3::EpcUeNas::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-ue-nas.h (module 'lte'): bool ns3::EpcUeNas::Send(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('Send', 
+                   'bool', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetAsSapProvider(ns3::LteAsSapProvider * s) [member function]
+    cls.add_method('SetAsSapProvider', 
+                   'void', 
+                   [param('ns3::LteAsSapProvider *', 's')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetCsgId(uint32_t csgId) [member function]
+    cls.add_method('SetCsgId', 
+                   'void', 
+                   [param('uint32_t', 'csgId')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetDevice(ns3::Ptr<ns3::NetDevice> dev) [member function]
+    cls.add_method('SetDevice', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'dev')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetForwardUpCallback(ns3::Callback<void, ns3::Ptr<ns3::Packet>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> cb) [member function]
+    cls.add_method('SetForwardUpCallback', 
+                   'void', 
+                   [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetImsi(uint64_t imsi) [member function]
+    cls.add_method('SetImsi', 
+                   'void', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::SetMmWaveAsSapProvider(ns3::LteAsSapProvider * s) [member function]
+    cls.add_method('SetMmWaveAsSapProvider', 
+                   'void', 
+                   [param('ns3::LteAsSapProvider *', 's')])
+    ## epc-ue-nas.h (module 'lte'): void ns3::EpcUeNas::StartCellSelection(uint16_t dlEarfcn) [member function]
+    cls.add_method('StartCellSelection', 
+                   'void', 
+                   [param('uint16_t', 'dlEarfcn')])
+    return
+
+def register_Ns3EpcX2_methods(root_module, cls):
+    ## epc-x2.h (module 'lte'): ns3::EpcX2::EpcX2(ns3::EpcX2 const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2 const &', 'arg0')])
+    ## epc-x2.h (module 'lte'): ns3::EpcX2::EpcX2() [constructor]
+    cls.add_constructor([])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::AddX2Interface(uint16_t enb1CellId, ns3::Ipv4Address enb1X2Address, uint16_t enb2CellId, ns3::Ipv4Address enb2X2Address) [member function]
+    cls.add_method('AddX2Interface', 
+                   'void', 
+                   [param('uint16_t', 'enb1CellId'), param('ns3::Ipv4Address', 'enb1X2Address'), param('uint16_t', 'enb2CellId'), param('ns3::Ipv4Address', 'enb2X2Address')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## epc-x2.h (module 'lte'): ns3::EpcX2PdcpProvider * ns3::EpcX2::GetEpcX2PdcpProvider() [member function]
+    cls.add_method('GetEpcX2PdcpProvider', 
+                   'ns3::EpcX2PdcpProvider *', 
+                   [])
+    ## epc-x2.h (module 'lte'): ns3::EpcX2RlcProvider * ns3::EpcX2::GetEpcX2RlcProvider() [member function]
+    cls.add_method('GetEpcX2RlcProvider', 
+                   'ns3::EpcX2RlcProvider *', 
+                   [])
+    ## epc-x2.h (module 'lte'): ns3::EpcX2SapProvider * ns3::EpcX2::GetEpcX2SapProvider() [member function]
+    cls.add_method('GetEpcX2SapProvider', 
+                   'ns3::EpcX2SapProvider *', 
+                   [])
+    ## epc-x2.h (module 'lte'): static ns3::TypeId ns3::EpcX2::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::RecvFromX2cSocket(ns3::Ptr<ns3::Socket> socket) [member function]
+    cls.add_method('RecvFromX2cSocket', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::RecvFromX2uSocket(ns3::Ptr<ns3::Socket> socket) [member function]
+    cls.add_method('RecvFromX2uSocket', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Socket >', 'socket')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::SetEpcX2SapUser(ns3::EpcX2SapUser * s) [member function]
+    cls.add_method('SetEpcX2SapUser', 
+                   'void', 
+                   [param('ns3::EpcX2SapUser *', 's')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::SetMcEpcX2PdcpUser(uint32_t teid, ns3::EpcX2PdcpUser * pdcpUser) [member function]
+    cls.add_method('SetMcEpcX2PdcpUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2PdcpUser *', 'pdcpUser')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::SetMcEpcX2RlcUser(uint32_t teid, ns3::EpcX2RlcUser * rlcUser) [member function]
+    cls.add_method('SetMcEpcX2RlcUser', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('ns3::EpcX2RlcUser *', 'rlcUser')])
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoAddTeidToBeForwarded(uint32_t teid, uint16_t targetCellId) [member function]
+    cls.add_method('DoAddTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'teid'), param('uint16_t', 'targetCellId')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoNotifyCoordinatorHandoverFailed(ns3::EpcX2Sap::HandoverFailedParams params) [member function]
+    cls.add_method('DoNotifyCoordinatorHandoverFailed', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::HandoverFailedParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoNotifyLteMmWaveHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('DoNotifyLteMmWaveHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoReceiveMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoReceiveMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoRemoveTeidToBeForwarded(uint32_t teid) [member function]
+    cls.add_method('DoRemoveTeidToBeForwarded', 
+                   'void', 
+                   [param('uint32_t', 'teid')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverPreparationFailure(ns3::EpcX2Sap::HandoverPreparationFailureParams params) [member function]
+    cls.add_method('DoSendHandoverPreparationFailure', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::HandoverPreparationFailureParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverRequest(ns3::EpcX2Sap::HandoverRequestParams params) [member function]
+    cls.add_method('DoSendHandoverRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::HandoverRequestParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendHandoverRequestAck(ns3::EpcX2Sap::HandoverRequestAckParams params) [member function]
+    cls.add_method('DoSendHandoverRequestAck', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::HandoverRequestAckParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendLoadInformation(ns3::EpcX2Sap::LoadInformationParams params) [member function]
+    cls.add_method('DoSendLoadInformation', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::LoadInformationParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendMcHandoverRequest(ns3::EpcX2Sap::SecondaryHandoverParams params) [member function]
+    cls.add_method('DoSendMcHandoverRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendResourceStatusUpdate(ns3::EpcX2Sap::ResourceStatusUpdateParams params) [member function]
+    cls.add_method('DoSendResourceStatusUpdate', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::ResourceStatusUpdateParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendRlcSetupCompleted(ns3::EpcX2Sap::UeDataParams arg0) [member function]
+    cls.add_method('DoSendRlcSetupCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'arg0')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendRlcSetupRequest(ns3::EpcX2Sap::RlcSetupRequest params) [member function]
+    cls.add_method('DoSendRlcSetupRequest', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::RlcSetupRequest', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSecondaryCellHandoverCompleted(ns3::EpcX2Sap::SecondaryHandoverCompletedParams params) [member function]
+    cls.add_method('DoSendSecondaryCellHandoverCompleted', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SecondaryHandoverCompletedParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSnStatusTransfer(ns3::EpcX2Sap::SnStatusTransferParams params) [member function]
+    cls.add_method('DoSendSnStatusTransfer', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SnStatusTransferParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendSwitchConnectionToMmWave(ns3::EpcX2Sap::SwitchConnectionParams params) [member function]
+    cls.add_method('DoSendSwitchConnectionToMmWave', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::SwitchConnectionParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeContextRelease(ns3::EpcX2Sap::UeContextReleaseParams params) [member function]
+    cls.add_method('DoSendUeContextRelease', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeContextReleaseParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeData(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendUeData', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## epc-x2.h (module 'lte'): void ns3::EpcX2::DoSendUeSinrUpdate(ns3::EpcX2Sap::UeImsiSinrParams params) [member function]
+    cls.add_method('DoSendUeSinrUpdate', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeImsiSinrParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3EpcX2ConnectionSwitchHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ConnectionSwitchHeader::EpcX2ConnectionSwitchHeader(ns3::EpcX2ConnectionSwitchHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2ConnectionSwitchHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ConnectionSwitchHeader::EpcX2ConnectionSwitchHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2ConnectionSwitchHeader::GetDrbid() const [member function]
+    cls.add_method('GetDrbid', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2ConnectionSwitchHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ConnectionSwitchHeader::GetMmWaveRnti() const [member function]
+    cls.add_method('GetMmWaveRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ConnectionSwitchHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2ConnectionSwitchHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): bool ns3::EpcX2ConnectionSwitchHeader::GetUseMmWaveConnection() const [member function]
+    cls.add_method('GetUseMmWaveConnection', 
+                   'bool', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::SetDrbid(uint8_t bid) [member function]
+    cls.add_method('SetDrbid', 
+                   'void', 
+                   [param('uint8_t', 'bid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ConnectionSwitchHeader::SetUseMmWaveConnection(bool useMmWaveConnection) [member function]
+    cls.add_method('SetUseMmWaveConnection', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
+    return
+
+def register_Ns3EpcX2HandoverPreparationFailureHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader::EpcX2HandoverPreparationFailureHeader(ns3::EpcX2HandoverPreparationFailureHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2HandoverPreparationFailureHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader::EpcX2HandoverPreparationFailureHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetCause() const [member function]
+    cls.add_method('GetCause', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetCriticalityDiagnostics() const [member function]
+    cls.add_method('GetCriticalityDiagnostics', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverPreparationFailureHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetOldEnbUeX2apId() const [member function]
+    cls.add_method('GetOldEnbUeX2apId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverPreparationFailureHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetCause(uint16_t cause) [member function]
+    cls.add_method('SetCause', 
+                   'void', 
+                   [param('uint16_t', 'cause')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetCriticalityDiagnostics(uint16_t criticalityDiagnostics) [member function]
+    cls.add_method('SetCriticalityDiagnostics', 
+                   'void', 
+                   [param('uint16_t', 'criticalityDiagnostics')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
+    cls.add_method('SetOldEnbUeX2apId', 
+                   'void', 
+                   [param('uint16_t', 'x2apId')])
+    return
+
+def register_Ns3EpcX2HandoverRequestAckHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader::EpcX2HandoverRequestAckHeader(ns3::EpcX2HandoverRequestAckHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2HandoverRequestAckHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader::EpcX2HandoverRequestAckHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabAdmittedItem> > ns3::EpcX2HandoverRequestAckHeader::GetAdmittedBearers() const [member function]
+    cls.add_method('GetAdmittedBearers', 
+                   'std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverRequestAckHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestAckHeader::GetNewEnbUeX2apId() const [member function]
+    cls.add_method('GetNewEnbUeX2apId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabNotAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabNotAdmittedItem> > ns3::EpcX2HandoverRequestAckHeader::GetNotAdmittedBearers() const [member function]
+    cls.add_method('GetNotAdmittedBearers', 
+                   'std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestAckHeader::GetOldEnbUeX2apId() const [member function]
+    cls.add_method('GetOldEnbUeX2apId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverRequestAckHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetAdmittedBearers(std::vector<ns3::EpcX2Sap::ErabAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabAdmittedItem> > bearers) [member function]
+    cls.add_method('SetAdmittedBearers', 
+                   'void', 
+                   [param('std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 'bearers')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetNewEnbUeX2apId(uint16_t x2apId) [member function]
+    cls.add_method('SetNewEnbUeX2apId', 
+                   'void', 
+                   [param('uint16_t', 'x2apId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetNotAdmittedBearers(std::vector<ns3::EpcX2Sap::ErabNotAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabNotAdmittedItem> > bearers) [member function]
+    cls.add_method('SetNotAdmittedBearers', 
+                   'void', 
+                   [param('std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 'bearers')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
+    cls.add_method('SetOldEnbUeX2apId', 
+                   'void', 
+                   [param('uint16_t', 'x2apId')])
+    return
+
+def register_Ns3EpcX2HandoverRequestHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader(ns3::EpcX2HandoverRequestHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2HandoverRequestHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > ns3::EpcX2HandoverRequestHeader::GetBearers() const [member function]
+    cls.add_method('GetBearers', 
+                   'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetCause() const [member function]
+    cls.add_method('GetCause', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverRequestHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): bool ns3::EpcX2HandoverRequestHeader::GetIsMc() const [member function]
+    cls.add_method('GetIsMc', 
+                   'bool', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetMmeUeS1apId() const [member function]
+    cls.add_method('GetMmeUeS1apId', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetOldEnbUeX2apId() const [member function]
+    cls.add_method('GetOldEnbUeX2apId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::RlcSetupRequest, std::allocator<ns3::EpcX2Sap::RlcSetupRequest> > ns3::EpcX2HandoverRequestHeader::GetRlcSetupRequests() const [member function]
+    cls.add_method('GetRlcSetupRequests', 
+                   'std::vector< ns3::EpcX2Sap::RlcSetupRequest >', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverRequestHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateDownlink() const [member function]
+    cls.add_method('GetUeAggregateMaxBitRateDownlink', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateUplink() const [member function]
+    cls.add_method('GetUeAggregateMaxBitRateUplink', 
+                   'uint64_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetBearers(std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > bearers) [member function]
+    cls.add_method('SetBearers', 
+                   'void', 
+                   [param('std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 'bearers')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetCause(uint16_t cause) [member function]
+    cls.add_method('SetCause', 
+                   'void', 
+                   [param('uint16_t', 'cause')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetIsMc(bool isMc) [member function]
+    cls.add_method('SetIsMc', 
+                   'void', 
+                   [param('bool', 'isMc')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetMmeUeS1apId(uint32_t mmeUeS1apId) [member function]
+    cls.add_method('SetMmeUeS1apId', 
+                   'void', 
+                   [param('uint32_t', 'mmeUeS1apId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
+    cls.add_method('SetOldEnbUeX2apId', 
+                   'void', 
+                   [param('uint16_t', 'x2apId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetRlcSetupRequests(std::vector<ns3::EpcX2Sap::RlcSetupRequest, std::allocator<ns3::EpcX2Sap::RlcSetupRequest> > rlcRequests) [member function]
+    cls.add_method('SetRlcSetupRequests', 
+                   'void', 
+                   [param('std::vector< ns3::EpcX2Sap::RlcSetupRequest >', 'rlcRequests')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
+                   'void', 
+                   [param('uint16_t', 'targetCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateDownlink(uint64_t bitRate) [member function]
+    cls.add_method('SetUeAggregateMaxBitRateDownlink', 
+                   'void', 
+                   [param('uint64_t', 'bitRate')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateUplink(uint64_t bitRate) [member function]
+    cls.add_method('SetUeAggregateMaxBitRateUplink', 
+                   'void', 
+                   [param('uint64_t', 'bitRate')])
+    return
+
+def register_Ns3EpcX2Header_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::EpcX2Header(ns3::EpcX2Header const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2Header const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::EpcX2Header() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2Header::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2Header::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2Header::GetMessageType() const [member function]
+    cls.add_method('GetMessageType', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2Header::GetProcedureCode() const [member function]
+    cls.add_method('GetProcedureCode', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2Header::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2Header::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetLengthOfIes(uint32_t lengthOfIes) [member function]
+    cls.add_method('SetLengthOfIes', 
+                   'void', 
+                   [param('uint32_t', 'lengthOfIes')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetMessageType(uint8_t messageType) [member function]
+    cls.add_method('SetMessageType', 
+                   'void', 
+                   [param('uint8_t', 'messageType')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetNumberOfIes(uint32_t numberOfIes) [member function]
+    cls.add_method('SetNumberOfIes', 
+                   'void', 
+                   [param('uint32_t', 'numberOfIes')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetProcedureCode(uint8_t procedureCode) [member function]
+    cls.add_method('SetProcedureCode', 
                    'void', 
-                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
-                   visibility='protected', is_virtual=True)
+                   [param('uint8_t', 'procedureCode')])
     return
 
-def register_Ns3EpcX2HandoverPreparationFailureHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader::EpcX2HandoverPreparationFailureHeader(ns3::EpcX2HandoverPreparationFailureHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2HandoverPreparationFailureHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverPreparationFailureHeader::EpcX2HandoverPreparationFailureHeader() [constructor]
+def register_Ns3EpcX2LoadInformationHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader::EpcX2LoadInformationHeader(ns3::EpcX2LoadInformationHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2LoadInformationHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader::EpcX2LoadInformationHeader() [constructor]
     cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
     cls.add_method('Deserialize', 
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetCause() const [member function]
-    cls.add_method('GetCause', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetCriticalityDiagnostics() const [member function]
-    cls.add_method('GetCriticalityDiagnostics', 
-                   'uint16_t', 
+    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::CellInformationItem, std::allocator<ns3::EpcX2Sap::CellInformationItem> > ns3::EpcX2LoadInformationHeader::GetCellInformationList() const [member function]
+    cls.add_method('GetCellInformationList', 
+                   'std::vector< ns3::EpcX2Sap::CellInformationItem >', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverPreparationFailureHeader::GetInstanceTypeId() const [member function]
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2LoadInformationHeader::GetInstanceTypeId() const [member function]
     cls.add_method('GetInstanceTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetLengthOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetLengthOfIes() const [member function]
     cls.add_method('GetLengthOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetNumberOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetNumberOfIes() const [member function]
     cls.add_method('GetNumberOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverPreparationFailureHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverPreparationFailureHeader::GetSerializedSize() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverPreparationFailureHeader::GetTypeId() [member function]
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2LoadInformationHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::Print(std::ostream & os) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::Print(std::ostream & os) const [member function]
     cls.add_method('Print', 
                    'void', 
                    [param('std::ostream &', 'os')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
     cls.add_method('Serialize', 
                    'void', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetCause(uint16_t cause) [member function]
-    cls.add_method('SetCause', 
-                   'void', 
-                   [param('uint16_t', 'cause')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetCriticalityDiagnostics(uint16_t criticalityDiagnostics) [member function]
-    cls.add_method('SetCriticalityDiagnostics', 
-                   'void', 
-                   [param('uint16_t', 'criticalityDiagnostics')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverPreparationFailureHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::SetCellInformationList(std::vector<ns3::EpcX2Sap::CellInformationItem, std::allocator<ns3::EpcX2Sap::CellInformationItem> > cellInformationList) [member function]
+    cls.add_method('SetCellInformationList', 
                    'void', 
-                   [param('uint16_t', 'x2apId')])
+                   [param('std::vector< ns3::EpcX2Sap::CellInformationItem >', 'cellInformationList')])
     return
 
-def register_Ns3EpcX2HandoverRequestAckHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader::EpcX2HandoverRequestAckHeader(ns3::EpcX2HandoverRequestAckHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2HandoverRequestAckHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestAckHeader::EpcX2HandoverRequestAckHeader() [constructor]
+def register_Ns3EpcX2McHandoverHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2McHandoverHeader::EpcX2McHandoverHeader(ns3::EpcX2McHandoverHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2McHandoverHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2McHandoverHeader::EpcX2McHandoverHeader() [constructor]
     cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
     cls.add_method('Deserialize', 
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabAdmittedItem> > ns3::EpcX2HandoverRequestAckHeader::GetAdmittedBearers() const [member function]
-    cls.add_method('GetAdmittedBearers', 
-                   'std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2McHandoverHeader::GetImsi() const [member function]
+    cls.add_method('GetImsi', 
+                   'uint64_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverRequestAckHeader::GetInstanceTypeId() const [member function]
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2McHandoverHeader::GetInstanceTypeId() const [member function]
     cls.add_method('GetInstanceTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetLengthOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::GetLengthOfIes() const [member function]
     cls.add_method('GetLengthOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestAckHeader::GetNewEnbUeX2apId() const [member function]
-    cls.add_method('GetNewEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabNotAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabNotAdmittedItem> > ns3::EpcX2HandoverRequestAckHeader::GetNotAdmittedBearers() const [member function]
-    cls.add_method('GetNotAdmittedBearers', 
-                   'std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetNumberOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::GetNumberOfIes() const [member function]
     cls.add_method('GetNumberOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestAckHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2McHandoverHeader::GetOldCellId() const [member function]
+    cls.add_method('GetOldCellId', 
                    'uint16_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestAckHeader::GetSerializedSize() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2McHandoverHeader::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverRequestAckHeader::GetTypeId() [member function]
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2McHandoverHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2McHandoverHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::Print(std::ostream & os) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::Print(std::ostream & os) const [member function]
     cls.add_method('Print', 
                    'void', 
                    [param('std::ostream &', 'os')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
     cls.add_method('Serialize', 
                    'void', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetAdmittedBearers(std::vector<ns3::EpcX2Sap::ErabAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabAdmittedItem> > bearers) [member function]
-    cls.add_method('SetAdmittedBearers', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::ErabAdmittedItem >', 'bearers')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetNewEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetNewEnbUeX2apId', 
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::SetImsi(uint64_t imsi) [member function]
+    cls.add_method('SetImsi', 
                    'void', 
-                   [param('uint16_t', 'x2apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetNotAdmittedBearers(std::vector<ns3::EpcX2Sap::ErabNotAdmittedItem, std::allocator<ns3::EpcX2Sap::ErabNotAdmittedItem> > bearers) [member function]
-    cls.add_method('SetNotAdmittedBearers', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::SetOldCellId(uint16_t oldCellId) [member function]
+    cls.add_method('SetOldCellId', 
                    'void', 
-                   [param('std::vector< ns3::EpcX2Sap::ErabNotAdmittedItem >', 'bearers')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestAckHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
+                   [param('uint16_t', 'oldCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2McHandoverHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
                    'void', 
-                   [param('uint16_t', 'x2apId')])
+                   [param('uint16_t', 'targetCellId')])
     return
 
-def register_Ns3EpcX2HandoverRequestHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader(ns3::EpcX2HandoverRequestHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2HandoverRequestHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader() [constructor]
+def register_Ns3EpcX2NotifyCoordinatorHandoverFailedHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::EpcX2NotifyCoordinatorHandoverFailedHeader(ns3::EpcX2NotifyCoordinatorHandoverFailedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2NotifyCoordinatorHandoverFailedHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::EpcX2NotifyCoordinatorHandoverFailedHeader() [constructor]
     cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
     cls.add_method('Deserialize', 
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > ns3::EpcX2HandoverRequestHeader::GetBearers() const [member function]
-    cls.add_method('GetBearers', 
-                   'std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetCause() const [member function]
-    cls.add_method('GetCause', 
-                   'uint16_t', 
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetImsi() const [member function]
+    cls.add_method('GetImsi', 
+                   'uint64_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2HandoverRequestHeader::GetInstanceTypeId() const [member function]
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetInstanceTypeId() const [member function]
     cls.add_method('GetInstanceTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetLengthOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetLengthOfIes() const [member function]
     cls.add_method('GetLengthOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetMmeUeS1apId() const [member function]
-    cls.add_method('GetMmeUeS1apId', 
-                   'uint32_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetNumberOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetNumberOfIes() const [member function]
     cls.add_method('GetNumberOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetOldEnbUeX2apId() const [member function]
-    cls.add_method('GetOldEnbUeX2apId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2HandoverRequestHeader::GetSerializedSize() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2HandoverRequestHeader::GetTargetCellId() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetTargetCellId() const [member function]
     cls.add_method('GetTargetCellId', 
                    'uint16_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2HandoverRequestHeader::GetTypeId() [member function]
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateDownlink() const [member function]
-    cls.add_method('GetUeAggregateMaxBitRateDownlink', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateUplink() const [member function]
-    cls.add_method('GetUeAggregateMaxBitRateUplink', 
-                   'uint64_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::Print(std::ostream & os) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::Print(std::ostream & os) const [member function]
     cls.add_method('Print', 
                    'void', 
                    [param('std::ostream &', 'os')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
     cls.add_method('Serialize', 
                    'void', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetBearers(std::vector<ns3::EpcX2Sap::ErabToBeSetupItem, std::allocator<ns3::EpcX2Sap::ErabToBeSetupItem> > bearers) [member function]
-    cls.add_method('SetBearers', 
-                   'void', 
-                   [param('std::vector< ns3::EpcX2Sap::ErabToBeSetupItem >', 'bearers')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetCause(uint16_t cause) [member function]
-    cls.add_method('SetCause', 
-                   'void', 
-                   [param('uint16_t', 'cause')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetMmeUeS1apId(uint32_t mmeUeS1apId) [member function]
-    cls.add_method('SetMmeUeS1apId', 
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::SetImsi(uint64_t imsi) [member function]
+    cls.add_method('SetImsi', 
                    'void', 
-                   [param('uint32_t', 'mmeUeS1apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetOldEnbUeX2apId(uint16_t x2apId) [member function]
-    cls.add_method('SetOldEnbUeX2apId', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::SetSourceCellId(uint16_t oldCellId) [member function]
+    cls.add_method('SetSourceCellId', 
                    'void', 
-                   [param('uint16_t', 'x2apId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+                   [param('uint16_t', 'oldCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2NotifyCoordinatorHandoverFailedHeader::SetTargetCellId(uint16_t targetCellId) [member function]
     cls.add_method('SetTargetCellId', 
                    'void', 
                    [param('uint16_t', 'targetCellId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateDownlink(uint64_t bitRate) [member function]
-    cls.add_method('SetUeAggregateMaxBitRateDownlink', 
+    return
+
+def register_Ns3EpcX2ResourceStatusUpdateHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader::EpcX2ResourceStatusUpdateHeader(ns3::EpcX2ResourceStatusUpdateHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2ResourceStatusUpdateHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader::EpcX2ResourceStatusUpdateHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::CellMeasurementResultItem, std::allocator<ns3::EpcX2Sap::CellMeasurementResultItem> > ns3::EpcX2ResourceStatusUpdateHeader::GetCellMeasurementResultList() const [member function]
+    cls.add_method('GetCellMeasurementResultList', 
+                   'std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ResourceStatusUpdateHeader::GetEnb1MeasurementId() const [member function]
+    cls.add_method('GetEnb1MeasurementId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ResourceStatusUpdateHeader::GetEnb2MeasurementId() const [member function]
+    cls.add_method('GetEnb2MeasurementId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2ResourceStatusUpdateHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2ResourceStatusUpdateHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
                    'void', 
-                   [param('uint64_t', 'bitRate')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateUplink(uint64_t bitRate) [member function]
-    cls.add_method('SetUeAggregateMaxBitRateUplink', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
                    'void', 
-                   [param('uint64_t', 'bitRate')])
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetCellMeasurementResultList(std::vector<ns3::EpcX2Sap::CellMeasurementResultItem, std::allocator<ns3::EpcX2Sap::CellMeasurementResultItem> > cellMeasurementResultList) [member function]
+    cls.add_method('SetCellMeasurementResultList', 
+                   'void', 
+                   [param('std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 'cellMeasurementResultList')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetEnb1MeasurementId(uint16_t enb1MeasurementId) [member function]
+    cls.add_method('SetEnb1MeasurementId', 
+                   'void', 
+                   [param('uint16_t', 'enb1MeasurementId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetEnb2MeasurementId(uint16_t enb2MeasurementId) [member function]
+    cls.add_method('SetEnb2MeasurementId', 
+                   'void', 
+                   [param('uint16_t', 'enb2MeasurementId')])
     return
 
-def register_Ns3EpcX2Header_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::EpcX2Header(ns3::EpcX2Header const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2Header const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2Header::EpcX2Header() [constructor]
+def register_Ns3EpcX2RlcSetupCompletedHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupCompletedHeader::EpcX2RlcSetupCompletedHeader(ns3::EpcX2RlcSetupCompletedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcSetupCompletedHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupCompletedHeader::EpcX2RlcSetupCompletedHeader() [constructor]
     cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2Header::Deserialize(ns3::Buffer::Iterator start) [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
     cls.add_method('Deserialize', 
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2Header::GetInstanceTypeId() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetGtpTeid() const [member function]
+    cls.add_method('GetGtpTeid', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2RlcSetupCompletedHeader::GetInstanceTypeId() const [member function]
     cls.add_method('GetInstanceTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2Header::GetMessageType() const [member function]
-    cls.add_method('GetMessageType', 
-                   'uint8_t', 
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2Header::GetProcedureCode() const [member function]
-    cls.add_method('GetProcedureCode', 
-                   'uint8_t', 
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2Header::GetSerializedSize() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupCompletedHeader::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2Header::GetTypeId() [member function]
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupCompletedHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupCompletedHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2RlcSetupCompletedHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::Print(std::ostream & os) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::Print(std::ostream & os) const [member function]
     cls.add_method('Print', 
                    'void', 
                    [param('std::ostream &', 'os')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::Serialize(ns3::Buffer::Iterator start) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
     cls.add_method('Serialize', 
                    'void', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetLengthOfIes(uint32_t lengthOfIes) [member function]
-    cls.add_method('SetLengthOfIes', 
-                   'void', 
-                   [param('uint32_t', 'lengthOfIes')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetMessageType(uint8_t messageType) [member function]
-    cls.add_method('SetMessageType', 
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::SetGtpTeid(uint32_t gtpTeid) [member function]
+    cls.add_method('SetGtpTeid', 
                    'void', 
-                   [param('uint8_t', 'messageType')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetNumberOfIes(uint32_t numberOfIes) [member function]
-    cls.add_method('SetNumberOfIes', 
+                   [param('uint32_t', 'gtpTeid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::SetSourceCellId(uint16_t sourceCellId) [member function]
+    cls.add_method('SetSourceCellId', 
                    'void', 
-                   [param('uint32_t', 'numberOfIes')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2Header::SetProcedureCode(uint8_t procedureCode) [member function]
-    cls.add_method('SetProcedureCode', 
+                   [param('uint16_t', 'sourceCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupCompletedHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
                    'void', 
-                   [param('uint8_t', 'procedureCode')])
+                   [param('uint16_t', 'targetCellId')])
     return
 
-def register_Ns3EpcX2LoadInformationHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader::EpcX2LoadInformationHeader(ns3::EpcX2LoadInformationHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2LoadInformationHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2LoadInformationHeader::EpcX2LoadInformationHeader() [constructor]
+def register_Ns3EpcX2RlcSetupRequestHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupRequestHeader::EpcX2RlcSetupRequestHeader(ns3::EpcX2RlcSetupRequestHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2RlcSetupRequestHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2RlcSetupRequestHeader::EpcX2RlcSetupRequestHeader() [constructor]
     cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
     cls.add_method('Deserialize', 
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::CellInformationItem, std::allocator<ns3::EpcX2Sap::CellInformationItem> > ns3::EpcX2LoadInformationHeader::GetCellInformationList() const [member function]
-    cls.add_method('GetCellInformationList', 
-                   'std::vector< ns3::EpcX2Sap::CellInformationItem >', 
+    ## epc-x2-header.h (module 'lte'): uint8_t ns3::EpcX2RlcSetupRequestHeader::GetDrbid() const [member function]
+    cls.add_method('GetDrbid', 
+                   'uint8_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2LoadInformationHeader::GetInstanceTypeId() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetGtpTeid() const [member function]
+    cls.add_method('GetGtpTeid', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2RlcSetupRequestHeader::GetInstanceTypeId() const [member function]
     cls.add_method('GetInstanceTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetLengthOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): ns3::LteEnbCmacSapProvider::LcInfo ns3::EpcX2RlcSetupRequestHeader::GetLcInfo() const [member function]
+    cls.add_method('GetLcInfo', 
+                   'ns3::LteEnbCmacSapProvider::LcInfo', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetLengthOfIes() const [member function]
     cls.add_method('GetLengthOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetNumberOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): ns3::LteRrcSap::LogicalChannelConfig ns3::EpcX2RlcSetupRequestHeader::GetLogicalChannelConfig() [member function]
+    cls.add_method('GetLogicalChannelConfig', 
+                   'ns3::LteRrcSap::LogicalChannelConfig', 
+                   [])
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetLteRnti() const [member function]
+    cls.add_method('GetLteRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetMmWaveRnti() const [member function]
+    cls.add_method('GetMmWaveRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetNumberOfIes() const [member function]
     cls.add_method('GetNumberOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2LoadInformationHeader::GetSerializedSize() const [member function]
+    ## epc-x2-header.h (module 'lte'): ns3::LteRrcSap::RlcConfig ns3::EpcX2RlcSetupRequestHeader::GetRlcConfig() const [member function]
+    cls.add_method('GetRlcConfig', 
+                   'ns3::LteRrcSap::RlcConfig', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2RlcSetupRequestHeader::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2LoadInformationHeader::GetTypeId() [member function]
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2RlcSetupRequestHeader::GetTargetCellId() const [member function]
+    cls.add_method('GetTargetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2RlcSetupRequestHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::Print(std::ostream & os) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::Print(std::ostream & os) const [member function]
     cls.add_method('Print', 
                    'void', 
                    [param('std::ostream &', 'os')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
     cls.add_method('Serialize', 
                    'void', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2LoadInformationHeader::SetCellInformationList(std::vector<ns3::EpcX2Sap::CellInformationItem, std::allocator<ns3::EpcX2Sap::CellInformationItem> > cellInformationList) [member function]
-    cls.add_method('SetCellInformationList', 
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetDrbid(uint8_t drbid) [member function]
+    cls.add_method('SetDrbid', 
                    'void', 
-                   [param('std::vector< ns3::EpcX2Sap::CellInformationItem >', 'cellInformationList')])
+                   [param('uint8_t', 'drbid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetGtpTeid(uint32_t gtpTeid) [member function]
+    cls.add_method('SetGtpTeid', 
+                   'void', 
+                   [param('uint32_t', 'gtpTeid')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetLcInfo(ns3::LteEnbCmacSapProvider::LcInfo lcInfo) [member function]
+    cls.add_method('SetLcInfo', 
+                   'void', 
+                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetLogicalChannelConfig(ns3::LteRrcSap::LogicalChannelConfig conf) [member function]
+    cls.add_method('SetLogicalChannelConfig', 
+                   'void', 
+                   [param('ns3::LteRrcSap::LogicalChannelConfig', 'conf')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetLteRnti(uint16_t rnti) [member function]
+    cls.add_method('SetLteRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetRlcConfig(ns3::LteRrcSap::RlcConfig rlcConfig) [member function]
+    cls.add_method('SetRlcConfig', 
+                   'void', 
+                   [param('ns3::LteRrcSap::RlcConfig', 'rlcConfig')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetSourceCellId(uint16_t sourceCellId) [member function]
+    cls.add_method('SetSourceCellId', 
+                   'void', 
+                   [param('uint16_t', 'sourceCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2RlcSetupRequestHeader::SetTargetCellId(uint16_t targetCellId) [member function]
+    cls.add_method('SetTargetCellId', 
+                   'void', 
+                   [param('uint16_t', 'targetCellId')])
     return
 
-def register_Ns3EpcX2ResourceStatusUpdateHeader_methods(root_module, cls):
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader::EpcX2ResourceStatusUpdateHeader(ns3::EpcX2ResourceStatusUpdateHeader const & arg0) [constructor]
-    cls.add_constructor([param('ns3::EpcX2ResourceStatusUpdateHeader const &', 'arg0')])
-    ## epc-x2-header.h (module 'lte'): ns3::EpcX2ResourceStatusUpdateHeader::EpcX2ResourceStatusUpdateHeader() [constructor]
+def register_Ns3EpcX2SecondaryCellHandoverCompletedHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SecondaryCellHandoverCompletedHeader::EpcX2SecondaryCellHandoverCompletedHeader(ns3::EpcX2SecondaryCellHandoverCompletedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2SecondaryCellHandoverCompletedHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2SecondaryCellHandoverCompletedHeader::EpcX2SecondaryCellHandoverCompletedHeader() [constructor]
     cls.add_constructor([])
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
     cls.add_method('Deserialize', 
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): std::vector<ns3::EpcX2Sap::CellMeasurementResultItem, std::allocator<ns3::EpcX2Sap::CellMeasurementResultItem> > ns3::EpcX2ResourceStatusUpdateHeader::GetCellMeasurementResultList() const [member function]
-    cls.add_method('GetCellMeasurementResultList', 
-                   'std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ResourceStatusUpdateHeader::GetEnb1MeasurementId() const [member function]
-    cls.add_method('GetEnb1MeasurementId', 
-                   'uint16_t', 
-                   [], 
-                   is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2ResourceStatusUpdateHeader::GetEnb2MeasurementId() const [member function]
-    cls.add_method('GetEnb2MeasurementId', 
-                   'uint16_t', 
+    ## epc-x2-header.h (module 'lte'): uint64_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetImsi() const [member function]
+    cls.add_method('GetImsi', 
+                   'uint64_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2ResourceStatusUpdateHeader::GetInstanceTypeId() const [member function]
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetInstanceTypeId() const [member function]
     cls.add_method('GetInstanceTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetLengthOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetLengthOfIes() const [member function]
     cls.add_method('GetLengthOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetNumberOfIes() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetMmWaveRnti() const [member function]
+    cls.add_method('GetMmWaveRnti', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetNumberOfIes() const [member function]
     cls.add_method('GetNumberOfIes', 
                    'uint32_t', 
                    [], 
                    is_const=True)
-    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2ResourceStatusUpdateHeader::GetSerializedSize() const [member function]
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetOldEnbUeX2apId() const [member function]
+    cls.add_method('GetOldEnbUeX2apId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetSerializedSize() const [member function]
     cls.add_method('GetSerializedSize', 
                    'uint32_t', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2ResourceStatusUpdateHeader::GetTypeId() [member function]
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2SecondaryCellHandoverCompletedHeader::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::Print(std::ostream & os) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::Print(std::ostream & os) const [member function]
     cls.add_method('Print', 
                    'void', 
                    [param('std::ostream &', 'os')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
     cls.add_method('Serialize', 
                    'void', 
                    [param('ns3::Buffer::Iterator', 'start')], 
                    is_const=True, is_virtual=True)
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetCellMeasurementResultList(std::vector<ns3::EpcX2Sap::CellMeasurementResultItem, std::allocator<ns3::EpcX2Sap::CellMeasurementResultItem> > cellMeasurementResultList) [member function]
-    cls.add_method('SetCellMeasurementResultList', 
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::SetImsi(uint64_t imsi) [member function]
+    cls.add_method('SetImsi', 
                    'void', 
-                   [param('std::vector< ns3::EpcX2Sap::CellMeasurementResultItem >', 'cellMeasurementResultList')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetEnb1MeasurementId(uint16_t enb1MeasurementId) [member function]
-    cls.add_method('SetEnb1MeasurementId', 
+                   [param('uint64_t', 'imsi')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::SetMmWaveRnti(uint16_t mmWaveRnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
                    'void', 
-                   [param('uint16_t', 'enb1MeasurementId')])
-    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2ResourceStatusUpdateHeader::SetEnb2MeasurementId(uint16_t enb2MeasurementId) [member function]
-    cls.add_method('SetEnb2MeasurementId', 
+                   [param('uint16_t', 'mmWaveRnti')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2SecondaryCellHandoverCompletedHeader::SetOldEnbUeX2apId(uint16_t oldEnbUeX2apId) [member function]
+    cls.add_method('SetOldEnbUeX2apId', 
                    'void', 
-                   [param('uint16_t', 'enb2MeasurementId')])
+                   [param('uint16_t', 'oldEnbUeX2apId')])
     return
 
 def register_Ns3EpcX2SnStatusTransferHeader_methods(root_module, cls):
@@ -15438,6 +17265,71 @@
                    [param('uint16_t', 'x2apId')])
     return
 
+def register_Ns3EpcX2UeImsiSinrUpdateHeader_methods(root_module, cls):
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeImsiSinrUpdateHeader::EpcX2UeImsiSinrUpdateHeader(ns3::EpcX2UeImsiSinrUpdateHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::EpcX2UeImsiSinrUpdateHeader const &', 'arg0')])
+    ## epc-x2-header.h (module 'lte'): ns3::EpcX2UeImsiSinrUpdateHeader::EpcX2UeImsiSinrUpdateHeader() [constructor]
+    cls.add_constructor([])
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::Deserialize(ns3::Buffer::Iterator start) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): ns3::TypeId ns3::EpcX2UeImsiSinrUpdateHeader::GetInstanceTypeId() const [member function]
+    cls.add_method('GetInstanceTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::GetLengthOfIes() const [member function]
+    cls.add_method('GetLengthOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::GetNumberOfIes() const [member function]
+    cls.add_method('GetNumberOfIes', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): uint32_t ns3::EpcX2UeImsiSinrUpdateHeader::GetSerializedSize() const [member function]
+    cls.add_method('GetSerializedSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): uint16_t ns3::EpcX2UeImsiSinrUpdateHeader::GetSourceCellId() const [member function]
+    cls.add_method('GetSourceCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): static ns3::TypeId ns3::EpcX2UeImsiSinrUpdateHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## epc-x2-header.h (module 'lte'): std::map<unsigned long, double, std::less<unsigned long>, std::allocator<std::pair<const unsigned long, double> > > ns3::EpcX2UeImsiSinrUpdateHeader::GetUeImsiSinrMap() const [member function]
+    cls.add_method('GetUeImsiSinrMap', 
+                   'std::map< unsigned long, double >', 
+                   [], 
+                   is_const=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::Serialize(ns3::Buffer::Iterator start) const [member function]
+    cls.add_method('Serialize', 
+                   'void', 
+                   [param('ns3::Buffer::Iterator', 'start')], 
+                   is_const=True, is_virtual=True)
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::SetSourceCellId(uint16_t sourceCellId) [member function]
+    cls.add_method('SetSourceCellId', 
+                   'void', 
+                   [param('uint16_t', 'sourceCellId')])
+    ## epc-x2-header.h (module 'lte'): void ns3::EpcX2UeImsiSinrUpdateHeader::SetUeImsiSinrMap(std::map<unsigned long, double, std::less<unsigned long>, std::allocator<std::pair<const unsigned long, double> > > map) [member function]
+    cls.add_method('SetUeImsiSinrMap', 
+                   'void', 
+                   [param('std::map< unsigned long, double >', 'map')])
+    return
+
 def register_Ns3ErlangRandomVariable_methods(root_module, cls):
     ## random-variable-stream.h (module 'core'): static ns3::TypeId ns3::ErlangRandomVariable::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
@@ -16400,68 +18292,6 @@
                    [param('ns3::LteControlMessage::MessageType', 'type')])
     return
 
-def register_Ns3LteEnbComponentCarrierManager_methods(root_module, cls):
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteEnbComponentCarrierManager::LteEnbComponentCarrierManager(ns3::LteEnbComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteEnbComponentCarrierManager const &', 'arg0')])
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteEnbComponentCarrierManager::LteEnbComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteCcmMacSapUser * ns3::LteEnbComponentCarrierManager::GetLteCcmMacSapUser() [member function]
-    cls.add_method('GetLteCcmMacSapUser', 
-                   'ns3::LteCcmMacSapUser *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteCcmRrcSapProvider * ns3::LteEnbComponentCarrierManager::GetLteCcmRrcSapProvider() [member function]
-    cls.add_method('GetLteCcmRrcSapProvider', 
-                   'ns3::LteCcmRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): ns3::LteMacSapProvider * ns3::LteEnbComponentCarrierManager::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::LteEnbComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): bool ns3::LteEnbComponentCarrierManager::SetCcmMacSapProviders(uint8_t componentCarrierId, ns3::LteCcmMacSapProvider * sap) [member function]
-    cls.add_method('SetCcmMacSapProviders', 
-                   'bool', 
-                   [param('uint8_t', 'componentCarrierId'), param('ns3::LteCcmMacSapProvider *', 'sap')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::SetLteCcmRrcSapUser(ns3::LteCcmRrcSapUser * s) [member function]
-    cls.add_method('SetLteCcmRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteCcmRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): bool ns3::LteEnbComponentCarrierManager::SetMacSapProvider(uint8_t componentCarrierId, ns3::LteMacSapProvider * sap) [member function]
-    cls.add_method('SetMacSapProvider', 
-                   'bool', 
-                   [param('uint8_t', 'componentCarrierId'), param('ns3::LteMacSapProvider *', 'sap')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::SetNumberOfComponentCarriers(uint16_t noOfComponentCarriers) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint16_t', 'noOfComponentCarriers')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::SetRrc(ns3::Ptr<ns3::LteEnbRrc> const rrc) [member function]
-    cls.add_method('SetRrc', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::LteEnbRrc > const', 'rrc')], 
-                   is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## lte-enb-component-carrier-manager.h (module 'lte'): void ns3::LteEnbComponentCarrierManager::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   is_pure_virtual=True, visibility='protected', is_virtual=True)
-    return
-
 def register_Ns3LteEnbMac_methods(root_module, cls):
     ## lte-enb-mac.h (module 'lte'): ns3::LteEnbMac::LteEnbMac(ns3::LteEnbMac const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteEnbMac const &', 'arg0')])
@@ -16484,10 +18314,6 @@
     cls.add_method('GetFfMacSchedSapUser', 
                    'ns3::FfMacSchedSapUser *', 
                    [])
-    ## lte-enb-mac.h (module 'lte'): ns3::LteCcmMacSapProvider * ns3::LteEnbMac::GetLteCcmMacSapProvider() [member function]
-    cls.add_method('GetLteCcmMacSapProvider', 
-                   'ns3::LteCcmMacSapProvider *', 
-                   [])
     ## lte-enb-mac.h (module 'lte'): ns3::LteEnbCmacSapProvider * ns3::LteEnbMac::GetLteEnbCmacSapProvider() [member function]
     cls.add_method('GetLteEnbCmacSapProvider', 
                    'ns3::LteEnbCmacSapProvider *', 
@@ -16505,10 +18331,6 @@
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetComponentCarrierId(uint8_t index) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'index')])
     ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetFfMacCschedSapProvider(ns3::FfMacCschedSapProvider * s) [member function]
     cls.add_method('SetFfMacCschedSapProvider', 
                    'void', 
@@ -16517,10 +18339,6 @@
     cls.add_method('SetFfMacSchedSapProvider', 
                    'void', 
                    [param('ns3::FfMacSchedSapProvider *', 's')])
-    ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetLteCcmMacSapUser(ns3::LteCcmMacSapUser * s) [member function]
-    cls.add_method('SetLteCcmMacSapUser', 
-                   'void', 
-                   [param('ns3::LteCcmMacSapUser *', 's')])
     ## lte-enb-mac.h (module 'lte'): void ns3::LteEnbMac::SetLteEnbCmacSapUser(ns3::LteEnbCmacSapUser * s) [member function]
     cls.add_method('SetLteEnbCmacSapUser', 
                    'void', 
@@ -16548,22 +18366,10 @@
     cls.add_method('AddX2Neighbour', 
                    'void', 
                    [param('uint16_t', 'cellId')])
-    ## lte-enb-rrc.h (module 'lte'): uint8_t ns3::LteEnbRrc::CellToComponentCarrierId(uint16_t cellId) [member function]
-    cls.add_method('CellToComponentCarrierId', 
-                   'uint8_t', 
-                   [param('uint16_t', 'cellId')])
-    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::LteEnbRrc::ComponentCarrierToCellId(uint8_t componentCarrierId) [member function]
-    cls.add_method('ComponentCarrierToCellId', 
-                   'uint16_t', 
-                   [param('uint8_t', 'componentCarrierId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConfigureCarriers(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ccPhyConf) [member function]
-    cls.add_method('ConfigureCarriers', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 'ccPhyConf')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConfigureCell(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ccPhyConf) [member function]
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConfigureCell(uint8_t ulBandwidth, uint8_t dlBandwidth, uint16_t ulEarfcn, uint16_t dlEarfcn, uint16_t cellId) [member function]
     cls.add_method('ConfigureCell', 
                    'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 'ccPhyConf')])
+                   [param('uint8_t', 'ulBandwidth'), param('uint8_t', 'dlBandwidth'), param('uint16_t', 'ulEarfcn'), param('uint16_t', 'dlEarfcn'), param('uint16_t', 'cellId')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::ConnectionRejectedTimeout(uint16_t rnti) [member function]
     cls.add_method('ConnectionRejectedTimeout', 
                    'void', 
@@ -16580,34 +18386,41 @@
     cls.add_method('DoSendReleaseDataRadioBearer', 
                    'void', 
                    [param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('uint8_t', 'bearerId')])
+    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::LteEnbRrc::GetCellId() const [member function]
+    cls.add_method('GetCellId', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): ns3::EpcX2PdcpProvider * ns3::LteEnbRrc::GetEpcX2PdcpProvider() const [member function]
+    cls.add_method('GetEpcX2PdcpProvider', 
+                   'ns3::EpcX2PdcpProvider *', 
+                   [], 
+                   is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): ns3::EpcX2RlcProvider * ns3::LteEnbRrc::GetEpcX2RlcProvider() const [member function]
+    cls.add_method('GetEpcX2RlcProvider', 
+                   'ns3::EpcX2RlcProvider *', 
+                   [], 
+                   is_const=True)
     ## lte-enb-rrc.h (module 'lte'): ns3::EpcX2SapUser * ns3::LteEnbRrc::GetEpcX2SapUser() [member function]
     cls.add_method('GetEpcX2SapUser', 
                    'ns3::EpcX2SapUser *', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): uint64_t ns3::LteEnbRrc::GetImsiFromRnti(uint16_t rnti) [member function]
+    cls.add_method('GetImsiFromRnti', 
+                   'uint64_t', 
+                   [param('uint16_t', 'rnti')])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteAnrSapUser * ns3::LteEnbRrc::GetLteAnrSapUser() [member function]
     cls.add_method('GetLteAnrSapUser', 
                    'ns3::LteAnrSapUser *', 
                    [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteCcmRrcSapUser * ns3::LteEnbRrc::GetLteCcmRrcSapUser() [member function]
-    cls.add_method('GetLteCcmRrcSapUser', 
-                   'ns3::LteCcmRrcSapUser *', 
-                   [])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCmacSapUser * ns3::LteEnbRrc::GetLteEnbCmacSapUser() [member function]
     cls.add_method('GetLteEnbCmacSapUser', 
                    'ns3::LteEnbCmacSapUser *', 
                    [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCmacSapUser * ns3::LteEnbRrc::GetLteEnbCmacSapUser(uint8_t pos) [member function]
-    cls.add_method('GetLteEnbCmacSapUser', 
-                   'ns3::LteEnbCmacSapUser *', 
-                   [param('uint8_t', 'pos')])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCphySapUser * ns3::LteEnbRrc::GetLteEnbCphySapUser() [member function]
     cls.add_method('GetLteEnbCphySapUser', 
                    'ns3::LteEnbCphySapUser *', 
                    [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbCphySapUser * ns3::LteEnbRrc::GetLteEnbCphySapUser(uint8_t pos) [member function]
-    cls.add_method('GetLteEnbCphySapUser', 
-                   'ns3::LteEnbCphySapUser *', 
-                   [param('uint8_t', 'pos')])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrcSapProvider * ns3::LteEnbRrc::GetLteEnbRrcSapProvider() [member function]
     cls.add_method('GetLteEnbRrcSapProvider', 
                    'ns3::LteEnbRrcSapProvider *', 
@@ -16616,14 +18429,14 @@
     cls.add_method('GetLteFfrRrcSapUser', 
                    'ns3::LteFfrRrcSapUser *', 
                    [])
-    ## lte-enb-rrc.h (module 'lte'): ns3::LteFfrRrcSapUser * ns3::LteEnbRrc::GetLteFfrRrcSapUser(uint8_t index) [member function]
-    cls.add_method('GetLteFfrRrcSapUser', 
-                   'ns3::LteFfrRrcSapUser *', 
-                   [param('uint8_t', 'index')])
     ## lte-enb-rrc.h (module 'lte'): ns3::LteHandoverManagementSapUser * ns3::LteEnbRrc::GetLteHandoverManagementSapUser() [member function]
     cls.add_method('GetLteHandoverManagementSapUser', 
                    'ns3::LteHandoverManagementSapUser *', 
                    [])
+    ## lte-enb-rrc.h (module 'lte'): uint16_t ns3::LteEnbRrc::GetRntiFromImsi(uint64_t imsi) [member function]
+    cls.add_method('GetRntiFromImsi', 
+                   'uint16_t', 
+                   [param('uint64_t', 'imsi')])
     ## lte-enb-rrc.h (module 'lte'): ns3::EpcEnbS1SapUser * ns3::LteEnbRrc::GetS1SapUser() [member function]
     cls.add_method('GetS1SapUser', 
                    'ns3::EpcEnbS1SapUser *', 
@@ -16655,6 +18468,10 @@
                    'bool', 
                    [param('uint16_t', 'rnti')], 
                    is_const=True)
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::RegisterImsiToRnti(uint64_t imsi, uint16_t rnti) [member function]
+    cls.add_method('RegisterImsiToRnti', 
+                   'void', 
+                   [param('uint64_t', 'imsi'), param('uint16_t', 'rnti')])
     ## lte-enb-rrc.h (module 'lte'): bool ns3::LteEnbRrc::SendData(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('SendData', 
                    'bool', 
@@ -16667,14 +18484,22 @@
     cls.add_method('SetCellId', 
                    'void', 
                    [param('uint16_t', 'm_cellId')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetCellId(uint16_t m_cellId, uint8_t ccIndex) [member function]
-    cls.add_method('SetCellId', 
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetClosestLteCellId(uint16_t cellId) [member function]
+    cls.add_method('SetClosestLteCellId', 
                    'void', 
-                   [param('uint16_t', 'm_cellId'), param('uint8_t', 'ccIndex')])
+                   [param('uint16_t', 'cellId')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetCsgId(uint32_t csgId, bool csgIndication) [member function]
     cls.add_method('SetCsgId', 
                    'void', 
                    [param('uint32_t', 'csgId'), param('bool', 'csgIndication')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetEpcX2PdcpProvider(ns3::EpcX2PdcpProvider * s) [member function]
+    cls.add_method('SetEpcX2PdcpProvider', 
+                   'void', 
+                   [param('ns3::EpcX2PdcpProvider *', 's')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetEpcX2RlcProvider(ns3::EpcX2RlcProvider * s) [member function]
+    cls.add_method('SetEpcX2RlcProvider', 
+                   'void', 
+                   [param('ns3::EpcX2RlcProvider *', 's')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetEpcX2SapProvider(ns3::EpcX2SapProvider * s) [member function]
     cls.add_method('SetEpcX2SapProvider', 
                    'void', 
@@ -16683,30 +18508,22 @@
     cls.add_method('SetForwardUpCallback', 
                    'void', 
                    [param('ns3::Callback< void, ns3::Ptr< ns3::Packet >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')])
+    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetInterRatHoMode() [member function]
+    cls.add_method('SetInterRatHoMode', 
+                   'void', 
+                   [])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteAnrSapProvider(ns3::LteAnrSapProvider * s) [member function]
     cls.add_method('SetLteAnrSapProvider', 
                    'void', 
                    [param('ns3::LteAnrSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteCcmRrcSapProvider(ns3::LteCcmRrcSapProvider * s) [member function]
-    cls.add_method('SetLteCcmRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteCcmRrcSapProvider *', 's')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCmacSapProvider(ns3::LteEnbCmacSapProvider * s) [member function]
     cls.add_method('SetLteEnbCmacSapProvider', 
                    'void', 
                    [param('ns3::LteEnbCmacSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCmacSapProvider(ns3::LteEnbCmacSapProvider * s, uint8_t pos) [member function]
-    cls.add_method('SetLteEnbCmacSapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider *', 's'), param('uint8_t', 'pos')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCphySapProvider(ns3::LteEnbCphySapProvider * s) [member function]
     cls.add_method('SetLteEnbCphySapProvider', 
                    'void', 
                    [param('ns3::LteEnbCphySapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbCphySapProvider(ns3::LteEnbCphySapProvider * s, uint8_t pos) [member function]
-    cls.add_method('SetLteEnbCphySapProvider', 
-                   'void', 
-                   [param('ns3::LteEnbCphySapProvider *', 's'), param('uint8_t', 'pos')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteEnbRrcSapUser(ns3::LteEnbRrcSapUser * s) [member function]
     cls.add_method('SetLteEnbRrcSapUser', 
                    'void', 
@@ -16715,10 +18532,6 @@
     cls.add_method('SetLteFfrRrcSapProvider', 
                    'void', 
                    [param('ns3::LteFfrRrcSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteFfrRrcSapProvider(ns3::LteFfrRrcSapProvider * s, uint8_t index) [member function]
-    cls.add_method('SetLteFfrRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteFfrRrcSapProvider *', 's'), param('uint8_t', 'index')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetLteHandoverManagementSapProvider(ns3::LteHandoverManagementSapProvider * s) [member function]
     cls.add_method('SetLteHandoverManagementSapProvider', 
                    'void', 
@@ -16727,10 +18540,6 @@
     cls.add_method('SetLteMacSapProvider', 
                    'void', 
                    [param('ns3::LteMacSapProvider *', 's')])
-    ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetNumberOfComponentCarriers(uint16_t numberOfComponentCarriers) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint16_t', 'numberOfComponentCarriers')])
     ## lte-enb-rrc.h (module 'lte'): void ns3::LteEnbRrc::SetS1SapProvider(ns3::EpcEnbS1SapProvider * s) [member function]
     cls.add_method('SetS1SapProvider', 
                    'void', 
@@ -16746,6 +18555,19 @@
                    visibility='protected', is_virtual=True)
     return
 
+def register_Ns3LteEnbRrcHandoverEventInfo_methods(root_module, cls):
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::HandoverEventInfo() [constructor]
+    cls.add_constructor([])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::HandoverEventInfo(ns3::LteEnbRrc::HandoverEventInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteEnbRrc::HandoverEventInfo const &', 'arg0')])
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::scheduledHandoverEvent [variable]
+    cls.add_instance_attribute('scheduledHandoverEvent', 'ns3::EventId', is_const=False)
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::sourceCellId [variable]
+    cls.add_instance_attribute('sourceCellId', 'uint16_t', is_const=False)
+    ## lte-enb-rrc.h (module 'lte'): ns3::LteEnbRrc::HandoverEventInfo::targetCellId [variable]
+    cls.add_instance_attribute('targetCellId', 'uint16_t', is_const=False)
+    return
+
 def register_Ns3LteEnbRrcProtocolIdeal_methods(root_module, cls):
     ## lte-rrc-protocol-ideal.h (module 'lte'): ns3::LteEnbRrcProtocolIdeal::LteEnbRrcProtocolIdeal(ns3::LteEnbRrcProtocolIdeal const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteEnbRrcProtocolIdeal const &', 'arg0')])
@@ -17870,16 +19692,6 @@
     cls.add_method('EnableUlTxPhyTraces', 
                    'void', 
                    [])
-    ## lte-helper.h (module 'lte'): ns3::Ptr<ns3::SpectrumChannel> ns3::LteHelper::GetDownlinkSpectrumChannel() const [member function]
-    cls.add_method('GetDownlinkSpectrumChannel', 
-                   'ns3::Ptr< ns3::SpectrumChannel >', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetEnbComponentCarrierManagerType() const [member function]
-    cls.add_method('GetEnbComponentCarrierManagerType', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
     ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetFfrAlgorithmType() const [member function]
     cls.add_method('GetFfrAlgorithmType', 
                    'std::string', 
@@ -17908,24 +19720,10 @@
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## lte-helper.h (module 'lte'): std::string ns3::LteHelper::GetUeComponentCarrierManagerType() const [member function]
-    cls.add_method('GetUeComponentCarrierManagerType', 
-                   'std::string', 
-                   [], 
-                   is_const=True)
-    ## lte-helper.h (module 'lte'): ns3::Ptr<ns3::SpectrumChannel> ns3::LteHelper::GetUplinkSpectrumChannel() const [member function]
-    cls.add_method('GetUplinkSpectrumChannel', 
-                   'ns3::Ptr< ns3::SpectrumChannel >', 
-                   [], 
-                   is_const=True)
     ## lte-helper.h (module 'lte'): void ns3::LteHelper::HandoverRequest(ns3::Time hoTime, ns3::Ptr<ns3::NetDevice> ueDev, ns3::Ptr<ns3::NetDevice> sourceEnbDev, ns3::Ptr<ns3::NetDevice> targetEnbDev) [member function]
     cls.add_method('HandoverRequest', 
                    'void', 
                    [param('ns3::Time', 'hoTime'), param('ns3::Ptr< ns3::NetDevice >', 'ueDev'), param('ns3::Ptr< ns3::NetDevice >', 'sourceEnbDev'), param('ns3::Ptr< ns3::NetDevice >', 'targetEnbDev')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::HandoverRequest(ns3::Time hoTime, ns3::Ptr<ns3::NetDevice> ueDev, ns3::Ptr<ns3::NetDevice> sourceEnbDev, uint16_t targetCellId) [member function]
-    cls.add_method('HandoverRequest', 
-                   'void', 
-                   [param('ns3::Time', 'hoTime'), param('ns3::Ptr< ns3::NetDevice >', 'ueDev'), param('ns3::Ptr< ns3::NetDevice >', 'sourceEnbDev'), param('uint16_t', 'targetCellId')])
     ## lte-helper.h (module 'lte'): ns3::NetDeviceContainer ns3::LteHelper::InstallEnbDevice(ns3::NodeContainer c) [member function]
     cls.add_method('InstallEnbDevice', 
                    'ns3::NetDeviceContainer', 
@@ -17934,10 +19732,6 @@
     cls.add_method('InstallUeDevice', 
                    'ns3::NetDeviceContainer', 
                    [param('ns3::NodeContainer', 'c')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetCcPhyParams(std::map<unsigned char, ns3::ComponentCarrier, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::ComponentCarrier> > > ccmap) [member function]
-    cls.add_method('SetCcPhyParams', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::ComponentCarrier >', 'ccmap')])
     ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbAntennaModelAttribute(std::string n, ns3::AttributeValue const & v) [member function]
     cls.add_method('SetEnbAntennaModelAttribute', 
                    'void', 
@@ -17946,14 +19740,6 @@
     cls.add_method('SetEnbAntennaModelType', 
                    'void', 
                    [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbComponentCarrierManagerAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetEnbComponentCarrierManagerAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbComponentCarrierManagerType(std::string type) [member function]
-    cls.add_method('SetEnbComponentCarrierManagerType', 
-                   'void', 
-                   [param('std::string', 'type')])
     ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetEnbDeviceAttribute(std::string n, ns3::AttributeValue const & v) [member function]
     cls.add_method('SetEnbDeviceAttribute', 
                    'void', 
@@ -17990,10 +19776,10 @@
     cls.add_method('SetPathlossModelAttribute', 
                    'void', 
                    [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetPathlossModelType(ns3::TypeId type) [member function]
+    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetPathlossModelType(std::string type) [member function]
     cls.add_method('SetPathlossModelType', 
                    'void', 
-                   [param('ns3::TypeId', 'type')])
+                   [param('std::string', 'type')])
     ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetSchedulerAttribute(std::string n, ns3::AttributeValue const & v) [member function]
     cls.add_method('SetSchedulerAttribute', 
                    'void', 
@@ -18018,14 +19804,6 @@
     cls.add_method('SetUeAntennaModelType', 
                    'void', 
                    [param('std::string', 'type')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeComponentCarrierManagerAttribute(std::string n, ns3::AttributeValue const & v) [member function]
-    cls.add_method('SetUeComponentCarrierManagerAttribute', 
-                   'void', 
-                   [param('std::string', 'n'), param('ns3::AttributeValue const &', 'v')])
-    ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeComponentCarrierManagerType(std::string type) [member function]
-    cls.add_method('SetUeComponentCarrierManagerType', 
-                   'void', 
-                   [param('std::string', 'type')])
     ## lte-helper.h (module 'lte'): void ns3::LteHelper::SetUeDeviceAttribute(std::string n, ns3::AttributeValue const & v) [member function]
     cls.add_method('SetUeDeviceAttribute', 
                    'void', 
@@ -18215,17 +19993,13 @@
                    'void', 
                    [param('ns3::SpectrumValue const &', 'sinr')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): uint8_t ns3::LtePhy::GetComponentCarrierId() [member function]
-    cls.add_method('GetComponentCarrierId', 
-                   'uint8_t', 
-                   [])
     ## lte-phy.h (module 'lte'): std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > ns3::LtePhy::GetControlMessages() [member function]
     cls.add_method('GetControlMessages', 
                    'std::list< ns3::Ptr< ns3::LteControlMessage > >', 
                    [])
-    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::LteNetDevice> ns3::LtePhy::GetDevice() const [member function]
+    ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::NetDevice> ns3::LtePhy::GetDevice() const [member function]
     cls.add_method('GetDevice', 
-                   'ns3::Ptr< ns3::LteNetDevice >', 
+                   'ns3::Ptr< ns3::NetDevice >', 
                    [], 
                    is_const=True)
     ## lte-phy.h (module 'lte'): ns3::Ptr<ns3::LteSpectrumPhy> ns3::LtePhy::GetDownlinkSpectrumPhy() [member function]
@@ -18275,18 +20049,14 @@
                    'void', 
                    [param('ns3::SpectrumValue const &', 'power')], 
                    is_pure_virtual=True, is_virtual=True)
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetComponentCarrierId(uint8_t index) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'index')])
     ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetControlMessages(ns3::Ptr<ns3::LteControlMessage> m) [member function]
     cls.add_method('SetControlMessages', 
                    'void', 
                    [param('ns3::Ptr< ns3::LteControlMessage >', 'm')])
-    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDevice(ns3::Ptr<ns3::LteNetDevice> d) [member function]
+    ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDevice(ns3::Ptr<ns3::NetDevice> d) [member function]
     cls.add_method('SetDevice', 
                    'void', 
-                   [param('ns3::Ptr< ns3::LteNetDevice >', 'd')])
+                   [param('ns3::Ptr< ns3::NetDevice >', 'd')])
     ## lte-phy.h (module 'lte'): void ns3::LtePhy::SetDownlinkChannel(ns3::Ptr<ns3::SpectrumChannel> c) [member function]
     cls.add_method('SetDownlinkChannel', 
                    'void', 
@@ -18331,6 +20101,10 @@
                    'void', 
                    [], 
                    is_virtual=True)
+    ## lte-rlc.h (module 'lte'): ns3::EpcX2RlcUser * ns3::LteRlc::GetEpcX2RlcUser() [member function]
+    cls.add_method('GetEpcX2RlcUser', 
+                   'ns3::EpcX2RlcUser *', 
+                   [])
     ## lte-rlc.h (module 'lte'): ns3::LteMacSapUser * ns3::LteRlc::GetLteMacSapUser() [member function]
     cls.add_method('GetLteMacSapUser', 
                    'ns3::LteMacSapUser *', 
@@ -18344,6 +20118,10 @@
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetEpcX2RlcProvider(ns3::EpcX2RlcProvider * s) [member function]
+    cls.add_method('SetEpcX2RlcProvider', 
+                   'void', 
+                   [param('ns3::EpcX2RlcProvider *', 's')])
     ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetLcId(uint8_t lcId) [member function]
     cls.add_method('SetLcId', 
                    'void', 
@@ -18360,20 +20138,34 @@
     cls.add_method('SetRnti', 
                    'void', 
                    [param('uint16_t', 'rnti')])
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::SetUeDataParams(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SetUeDataParams', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')])
     ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyHarqDeliveryFailure() [member function]
     cls.add_method('DoNotifyHarqDeliveryFailure', 
                    'void', 
                    [], 
                    is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('DoNotifyHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   visibility='protected', is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
     cls.add_method('DoNotifyTxOpportunity', 
                    'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
                    is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoReceivePdu', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_pure_virtual=True, visibility='protected', is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_pure_virtual=True, visibility='protected', is_virtual=True)
     ## lte-rlc.h (module 'lte'): void ns3::LteRlc::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
@@ -18383,8 +20175,6 @@
     return
 
 def register_Ns3LteRlcAm_methods(root_module, cls):
-    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::LteRlcAm(ns3::LteRlcAm const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteRlcAm const &', 'arg0')])
     ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::LteRlcAm() [constructor]
     cls.add_constructor([])
     ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoDispose() [member function]
@@ -18392,31 +20182,101 @@
                    'void', 
                    [], 
                    is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyDlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('DoNotifyDlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
+                   is_virtual=True)
     ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyHarqDeliveryFailure() [member function]
     cls.add_method('DoNotifyHarqDeliveryFailure', 
                    'void', 
                    [], 
                    is_virtual=True)
-    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
     cls.add_method('DoNotifyTxOpportunity', 
                    'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
+                   is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoNotifyUlHarqDeliveryFailure(uint8_t harqId) [member function]
+    cls.add_method('DoNotifyUlHarqDeliveryFailure', 
+                   'void', 
+                   [param('uint8_t', 'harqId')], 
                    is_virtual=True)
-    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoReceivePdu', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_virtual=True)
     ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p')], 
                    is_virtual=True)
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::LteRlcAm::RetxPdu, std::allocator<ns3::LteRlcAm::RetxPdu> > ns3::LteRlcAm::GetRetxBuffer() [member function]
+    cls.add_method('GetRetxBuffer', 
+                   'std::vector< ns3::LteRlcAm::RetxPdu >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetRetxBufferSize() [member function]
+    cls.add_method('GetRetxBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): ns3::Ptr<ns3::Packet> ns3::LteRlcAm::GetSegmentedRlcsdu() [member function]
+    cls.add_method('GetSegmentedRlcsdu', 
+                   'ns3::Ptr< ns3::Packet >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::map<unsigned int, ns3::Ptr<ns3::Packet>, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, ns3::Ptr<ns3::Packet> > > > ns3::LteRlcAm::GetTransmittingRlcSduBuffer() [member function]
+    cls.add_method('GetTransmittingRlcSduBuffer', 
+                   'std::map< unsigned int, ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetTransmittingRlcSduBufferSize() [member function]
+    cls.add_method('GetTransmittingRlcSduBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcAm::GetTxBuffer() [member function]
+    cls.add_method('GetTxBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetTxBufferSize() [member function]
+    cls.add_method('GetTxBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::LteRlcAm::RetxPdu, std::allocator<ns3::LteRlcAm::RetxPdu> > ns3::LteRlcAm::GetTxedBuffer() [member function]
+    cls.add_method('GetTxedBuffer', 
+                   'std::vector< ns3::LteRlcAm::RetxPdu >', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): uint32_t ns3::LteRlcAm::GetTxedBufferSize() [member function]
+    cls.add_method('GetTxedBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-am.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcAm::GetTxedRlcSduBuffer() [member function]
+    cls.add_method('GetTxedRlcSduBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
     ## lte-rlc-am.h (module 'lte'): static ns3::TypeId ns3::LteRlcAm::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
+    ## lte-rlc-am.h (module 'lte'): void ns3::LteRlcAm::RlcPdusToRlcSdus(std::vector<ns3::LteRlcAm::RetxPdu, std::allocator<ns3::LteRlcAm::RetxPdu> > Pdus) [member function]
+    cls.add_method('RlcPdusToRlcSdus', 
+                   'void', 
+                   [param('std::vector< ns3::LteRlcAm::RetxPdu >', 'Pdus')])
+    return
+
+def register_Ns3LteRlcAmRetxPdu_methods(root_module, cls):
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::RetxPdu() [constructor]
+    cls.add_constructor([])
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::RetxPdu(ns3::LteRlcAm::RetxPdu const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRlcAm::RetxPdu const &', 'arg0')])
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::m_pdu [variable]
+    cls.add_instance_attribute('m_pdu', 'ns3::Ptr< ns3::Packet >', is_const=False)
+    ## lte-rlc-am.h (module 'lte'): ns3::LteRlcAm::RetxPdu::m_retxCount [variable]
+    cls.add_instance_attribute('m_retxCount', 'uint16_t', is_const=False)
     return
 
 def register_Ns3LteRlcSm_methods(root_module, cls):
@@ -18439,15 +20299,20 @@
                    'void', 
                    [], 
                    is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
     cls.add_method('DoNotifyTxOpportunity', 
                    'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
                    is_virtual=True)
-    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoReceivePdu', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_virtual=True)
     ## lte-rlc.h (module 'lte'): void ns3::LteRlcSm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
@@ -18476,15 +20341,20 @@
                    'void', 
                    [], 
                    is_virtual=True)
-    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
     cls.add_method('DoNotifyTxOpportunity', 
                    'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
                    is_virtual=True)
-    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoReceivePdu', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_virtual=True)
     ## lte-rlc-tm.h (module 'lte'): void ns3::LteRlcTm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
@@ -18513,21 +20383,38 @@
                    'void', 
                    [], 
                    is_virtual=True)
-    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
     cls.add_method('DoNotifyTxOpportunity', 
                    'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
                    is_virtual=True)
-    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
+    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoReceivePdu', 
                    'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
                    is_virtual=True)
     ## lte-rlc-um.h (module 'lte'): void ns3::LteRlcUm::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
     cls.add_method('DoTransmitPdcpPdu', 
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p')], 
                    is_virtual=True)
+    ## lte-rlc-um.h (module 'lte'): uint32_t ns3::LteRlcUm::GetMaxBuff() [member function]
+    cls.add_method('GetMaxBuff', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-um.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcUm::GetTxBuffer() [member function]
+    cls.add_method('GetTxBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-um.h (module 'lte'): uint32_t ns3::LteRlcUm::GetTxBufferSize() [member function]
+    cls.add_method('GetTxBufferSize', 
+                   'uint32_t', 
+                   [])
     ## lte-rlc-um.h (module 'lte'): static ns3::TypeId ns3::LteRlcUm::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
@@ -18535,6 +20422,56 @@
                    is_static=True)
     return
 
+def register_Ns3LteRlcUmLowLat_methods(root_module, cls):
+    ## lte-rlc-um-lowlat.h (module 'lte'): ns3::LteRlcUmLowLat::LteRlcUmLowLat(ns3::LteRlcUmLowLat const & arg0) [constructor]
+    cls.add_constructor([param('ns3::LteRlcUmLowLat const &', 'arg0')])
+    ## lte-rlc-um-lowlat.h (module 'lte'): ns3::LteRlcUmLowLat::LteRlcUmLowLat() [constructor]
+    cls.add_constructor([])
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoNotifyHarqDeliveryFailure() [member function]
+    cls.add_method('DoNotifyHarqDeliveryFailure', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId) [member function]
+    cls.add_method('DoNotifyTxOpportunity', 
+                   'void', 
+                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoSendMcPdcpSdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoSendMcPdcpSdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): void ns3::LteRlcUmLowLat::DoTransmitPdcpPdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoTransmitPdcpPdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   is_virtual=True)
+    ## lte-rlc-um-lowlat.h (module 'lte'): std::vector<ns3::Ptr<ns3::Packet>, std::allocator<ns3::Ptr<ns3::Packet> > > ns3::LteRlcUmLowLat::GetTxBuffer() [member function]
+    cls.add_method('GetTxBuffer', 
+                   'std::vector< ns3::Ptr< ns3::Packet > >', 
+                   [])
+    ## lte-rlc-um-lowlat.h (module 'lte'): uint32_t ns3::LteRlcUmLowLat::GetTxBufferSize() [member function]
+    cls.add_method('GetTxBufferSize', 
+                   'uint32_t', 
+                   [])
+    ## lte-rlc-um-lowlat.h (module 'lte'): static ns3::TypeId ns3::LteRlcUmLowLat::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    return
+
 def register_Ns3LteSignalingRadioBearerInfo_methods(root_module, cls):
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteSignalingRadioBearerInfo::LteSignalingRadioBearerInfo() [constructor]
     cls.add_constructor([])
@@ -18648,6 +20585,10 @@
     cls.add_method('StartTxUlSrsFrame', 
                    'bool', 
                    [])
+    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyTxEndCallback(ns3::LtePhyTxEndCallback c) [member function]
+    cls.add_method('SetLtePhyTxEndCallback', 
+                   'void', 
+                   [param('ns3::Callback< void, ns3::Ptr< ns3::Packet const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'c')])
     ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetLtePhyRxDataEndErrorCallback(ns3::LtePhyRxDataEndErrorCallback c) [member function]
     cls.add_method('SetLtePhyRxDataEndErrorCallback', 
                    'void', 
@@ -18684,10 +20625,6 @@
     cls.add_method('SetCellId', 
                    'void', 
                    [param('uint16_t', 'cellId')])
-    ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::SetComponentCarrierId(uint8_t componentCarrierId) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'componentCarrierId')])
     ## lte-spectrum-phy.h (module 'lte'): void ns3::LteSpectrumPhy::AddRsPowerChunkProcessor(ns3::Ptr<ns3::LteChunkProcessor> p) [member function]
     cls.add_method('AddRsPowerChunkProcessor', 
                    'void', 
@@ -18890,46 +20827,6 @@
                    is_static=True, visibility='protected')
     return
 
-def register_Ns3LteUeComponentCarrierManager_methods(root_module, cls):
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeComponentCarrierManager::LteUeComponentCarrierManager(ns3::LteUeComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::LteUeComponentCarrierManager const &', 'arg0')])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeComponentCarrierManager::LteUeComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeCcmRrcSapProvider * ns3::LteUeComponentCarrierManager::GetLteCcmRrcSapProvider() [member function]
-    cls.add_method('GetLteCcmRrcSapProvider', 
-                   'ns3::LteUeCcmRrcSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): ns3::LteMacSapProvider * ns3::LteUeComponentCarrierManager::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::LteUeComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): bool ns3::LteUeComponentCarrierManager::SetComponentCarrierMacSapProviders(uint8_t componentCarrierId, ns3::LteMacSapProvider * sap) [member function]
-    cls.add_method('SetComponentCarrierMacSapProviders', 
-                   'bool', 
-                   [param('uint8_t', 'componentCarrierId'), param('ns3::LteMacSapProvider *', 'sap')])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): void ns3::LteUeComponentCarrierManager::SetLteCcmRrcSapUser(ns3::LteUeCcmRrcSapUser * s) [member function]
-    cls.add_method('SetLteCcmRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteUeCcmRrcSapUser *', 's')], 
-                   is_pure_virtual=True, is_virtual=True)
-    ## lte-ue-component-carrier-manager.h (module 'lte'): void ns3::LteUeComponentCarrierManager::SetNumberOfComponentCarriers(uint8_t noOfComponentCarriers) [member function]
-    cls.add_method('SetNumberOfComponentCarriers', 
-                   'void', 
-                   [param('uint8_t', 'noOfComponentCarriers')])
-    ## lte-ue-component-carrier-manager.h (module 'lte'): void ns3::LteUeComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    return
-
 def register_Ns3LteUeMac_methods(root_module, cls):
     ## lte-ue-mac.h (module 'lte'): ns3::LteUeMac::LteUeMac(ns3::LteUeMac const & arg0) [constructor]
     cls.add_constructor([param('ns3::LteUeMac const &', 'arg0')])
@@ -18965,10 +20862,6 @@
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## lte-ue-mac.h (module 'lte'): void ns3::LteUeMac::SetComponentCarrierId(uint8_t index) [member function]
-    cls.add_method('SetComponentCarrierId', 
-                   'void', 
-                   [param('uint8_t', 'index')])
     ## lte-ue-mac.h (module 'lte'): void ns3::LteUeMac::SetLteUeCmacSapUser(ns3::LteUeCmacSapUser * s) [member function]
     cls.add_method('SetLteUeCmacSapUser', 
                    'void', 
@@ -19080,10 +20973,10 @@
     cls.add_method('PhyPduReceived', 
                    'void', 
                    [param('ns3::Ptr< ns3::Packet >', 'p')])
-    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReceiveLteControlMessageList(std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > msgList) [member function]
+    ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReceiveLteControlMessageList(std::list<ns3::Ptr<ns3::LteControlMessage>, std::allocator<ns3::Ptr<ns3::LteControlMessage> > > arg0) [member function]
     cls.add_method('ReceiveLteControlMessageList', 
                    'void', 
-                   [param('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'msgList')], 
+                   [param('std::list< ns3::Ptr< ns3::LteControlMessage > >', 'arg0')], 
                    is_virtual=True)
     ## lte-ue-phy.h (module 'lte'): void ns3::LteUePhy::ReceiveLteDlHarqFeedback(ns3::DlInfoListElement_s mes) [member function]
     cls.add_method('ReceiveLteDlHarqFeedback', 
@@ -19258,6 +21151,14 @@
     cls.add_constructor([param('ns3::LteUeRrc const &', 'arg0')])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::LteUeRrc() [constructor]
     cls.add_constructor([])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::AddLteCellId(uint16_t cellId) [member function]
+    cls.add_method('AddLteCellId', 
+                   'void', 
+                   [param('uint16_t', 'cellId')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::AddMmWaveCellId(uint16_t cellId) [member function]
+    cls.add_method('AddMmWaveCellId', 
+                   'void', 
+                   [param('uint16_t', 'cellId')])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteAsSapProvider * ns3::LteUeRrc::GetAsSapProvider() [member function]
     cls.add_method('GetAsSapProvider', 
                    'ns3::LteAsSapProvider *', 
@@ -19272,9 +21173,9 @@
                    'uint8_t', 
                    [], 
                    is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): uint32_t ns3::LteUeRrc::GetDlEarfcn() const [member function]
+    ## lte-ue-rrc.h (module 'lte'): uint16_t ns3::LteUeRrc::GetDlEarfcn() const [member function]
     cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_const=True)
     ## lte-ue-rrc.h (module 'lte'): uint64_t ns3::LteUeRrc::GetImsi() const [member function]
@@ -19282,26 +21183,14 @@
                    'uint64_t', 
                    [], 
                    is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCcmRrcSapUser * ns3::LteUeRrc::GetLteCcmRrcSapUser() [member function]
-    cls.add_method('GetLteCcmRrcSapUser', 
-                   'ns3::LteUeCcmRrcSapUser *', 
-                   [])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCmacSapUser * ns3::LteUeRrc::GetLteUeCmacSapUser() [member function]
     cls.add_method('GetLteUeCmacSapUser', 
                    'ns3::LteUeCmacSapUser *', 
                    [])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCmacSapUser * ns3::LteUeRrc::GetLteUeCmacSapUser(uint8_t index) [member function]
-    cls.add_method('GetLteUeCmacSapUser', 
-                   'ns3::LteUeCmacSapUser *', 
-                   [param('uint8_t', 'index')])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCphySapUser * ns3::LteUeRrc::GetLteUeCphySapUser() [member function]
     cls.add_method('GetLteUeCphySapUser', 
                    'ns3::LteUeCphySapUser *', 
                    [])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeCphySapUser * ns3::LteUeRrc::GetLteUeCphySapUser(uint8_t index) [member function]
-    cls.add_method('GetLteUeCphySapUser', 
-                   'ns3::LteUeCphySapUser *', 
-                   [param('uint8_t', 'index')])
     ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrcSapProvider * ns3::LteUeRrc::GetLteUeRrcSapProvider() [member function]
     cls.add_method('GetLteUeRrcSapProvider', 
                    'ns3::LteUeRrcSapProvider *', 
@@ -19326,15 +21215,11 @@
                    'uint8_t', 
                    [], 
                    is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): uint32_t ns3::LteUeRrc::GetUlEarfcn() const [member function]
+    ## lte-ue-rrc.h (module 'lte'): uint16_t ns3::LteUeRrc::GetUlEarfcn() const [member function]
     cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_const=True)
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::InitializeSap() [member function]
-    cls.add_method('InitializeSap', 
-                   'void', 
-                   [])
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetAsSapUser(ns3::LteAsSapUser * s) [member function]
     cls.add_method('SetAsSapUser', 
                    'void', 
@@ -19343,10 +21228,6 @@
     cls.add_method('SetImsi', 
                    'void', 
                    [param('uint64_t', 'imsi')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteCcmRrcSapProvider(ns3::LteUeCcmRrcSapProvider * s) [member function]
-    cls.add_method('SetLteCcmRrcSapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCcmRrcSapProvider *', 's')])
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteMacSapProvider(ns3::LteMacSapProvider * s) [member function]
     cls.add_method('SetLteMacSapProvider', 
                    'void', 
@@ -19355,28 +21236,34 @@
     cls.add_method('SetLteUeCmacSapProvider', 
                    'void', 
                    [param('ns3::LteUeCmacSapProvider *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeCmacSapProvider(ns3::LteUeCmacSapProvider * s, uint8_t index) [member function]
-    cls.add_method('SetLteUeCmacSapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCmacSapProvider *', 's'), param('uint8_t', 'index')])
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeCphySapProvider(ns3::LteUeCphySapProvider * s) [member function]
     cls.add_method('SetLteUeCphySapProvider', 
                    'void', 
                    [param('ns3::LteUeCphySapProvider *', 's')])
-    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeCphySapProvider(ns3::LteUeCphySapProvider * s, uint8_t index) [member function]
-    cls.add_method('SetLteUeCphySapProvider', 
-                   'void', 
-                   [param('ns3::LteUeCphySapProvider *', 's'), param('uint8_t', 'index')])
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetLteUeRrcSapUser(ns3::LteUeRrcSapUser * s) [member function]
     cls.add_method('SetLteUeRrcSapUser', 
                    'void', 
                    [param('ns3::LteUeRrcSapUser *', 's')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetMmWaveMacSapProvider(ns3::LteMacSapProvider * s) [member function]
+    cls.add_method('SetMmWaveMacSapProvider', 
+                   'void', 
+                   [param('ns3::LteMacSapProvider *', 's')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetMmWaveUeCmacSapProvider(ns3::LteUeCmacSapProvider * s) [member function]
+    cls.add_method('SetMmWaveUeCmacSapProvider', 
+                   'void', 
+                   [param('ns3::LteUeCmacSapProvider *', 's')])
+    ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetMmWaveUeCphySapProvider(ns3::LteUeCphySapProvider * s) [member function]
+    cls.add_method('SetMmWaveUeCphySapProvider', 
+                   'void', 
+                   [param('ns3::LteUeCphySapProvider *', 's')])
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::SetUseRlcSm(bool val) [member function]
     cls.add_method('SetUseRlcSm', 
                    'void', 
                    [param('bool', 'val')])
-    ## lte-ue-rrc.h (module 'lte'): ns3::LteUeRrc::m_numberOfComponentCarriers [variable]
-    cls.add_instance_attribute('m_numberOfComponentCarriers', 'uint16_t', is_const=False)
+    ## lte-ue-rrc.h (module 'lte'): bool ns3::LteUeRrc::SwitchLowerLayerProviders(uint16_t cellId) [member function]
+    cls.add_method('SwitchLowerLayerProviders', 
+                   'bool', 
+                   [param('uint16_t', 'cellId')])
     ## lte-ue-rrc.h (module 'lte'): void ns3::LteUeRrc::DoDispose() [member function]
     cls.add_method('DoDispose', 
                    'void', 
@@ -19484,53 +21371,270 @@
     ## mac48-address.h (module 'network'): void ns3::Mac48AddressValue::Set(ns3::Mac48Address const & value) [member function]
     cls.add_method('Set', 
                    'void', 
-                   [param('ns3::Mac48Address const &', 'value')])
+                   [param('ns3::Mac48Address const &', 'value')])
+    return
+
+def register_Ns3MacStatsCalculator_methods(root_module, cls):
+    ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator::MacStatsCalculator(ns3::MacStatsCalculator const & arg0) [constructor]
+    cls.add_constructor([param('ns3::MacStatsCalculator const &', 'arg0')])
+    ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator::MacStatsCalculator() [constructor]
+    cls.add_constructor([])
+    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::DlScheduling(uint16_t cellId, uint64_t imsi, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2) [member function]
+    cls.add_method('DlScheduling', 
+                   'void', 
+                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcsTb1'), param('uint16_t', 'sizeTb1'), param('uint8_t', 'mcsTb2'), param('uint16_t', 'sizeTb2')])
+    ## mac-stats-calculator.h (module 'lte'): static void ns3::MacStatsCalculator::DlSchedulingCallback(ns3::Ptr<ns3::MacStatsCalculator> macStats, std::string path, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2) [member function]
+    cls.add_method('DlSchedulingCallback', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::MacStatsCalculator >', 'macStats'), param('std::string', 'path'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcsTb1'), param('uint16_t', 'sizeTb1'), param('uint8_t', 'mcsTb2'), param('uint16_t', 'sizeTb2')], 
+                   is_static=True)
+    ## mac-stats-calculator.h (module 'lte'): std::string ns3::MacStatsCalculator::GetDlOutputFilename() [member function]
+    cls.add_method('GetDlOutputFilename', 
+                   'std::string', 
+                   [])
+    ## mac-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::MacStatsCalculator::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## mac-stats-calculator.h (module 'lte'): std::string ns3::MacStatsCalculator::GetUlOutputFilename() [member function]
+    cls.add_method('GetUlOutputFilename', 
+                   'std::string', 
+                   [])
+    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::SetDlOutputFilename(std::string outputFilename) [member function]
+    cls.add_method('SetDlOutputFilename', 
+                   'void', 
+                   [param('std::string', 'outputFilename')])
+    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::SetUlOutputFilename(std::string outputFilename) [member function]
+    cls.add_method('SetUlOutputFilename', 
+                   'void', 
+                   [param('std::string', 'outputFilename')])
+    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::UlScheduling(uint16_t cellId, uint64_t imsi, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcsTb, uint16_t sizeTb) [member function]
+    cls.add_method('UlScheduling', 
+                   'void', 
+                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcsTb'), param('uint16_t', 'sizeTb')])
+    ## mac-stats-calculator.h (module 'lte'): static void ns3::MacStatsCalculator::UlSchedulingCallback(ns3::Ptr<ns3::MacStatsCalculator> macStats, std::string path, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcs, uint16_t size) [member function]
+    cls.add_method('UlSchedulingCallback', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::MacStatsCalculator >', 'macStats'), param('std::string', 'path'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcs'), param('uint16_t', 'size')], 
+                   is_static=True)
+    return
+
+def register_Ns3MacTxStatsCalculator_methods(root_module, cls):
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::MacTxStatsCalculator() [constructor]
+    cls.add_constructor([])
+    ## mac-tx-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::MacTxStatsCalculator::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## mac-tx-stats-calculator.h (module 'lte'): void ns3::MacTxStatsCalculator::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## mac-tx-stats-calculator.h (module 'lte'): void ns3::MacTxStatsCalculator::RegisterMacTxDl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx) [member function]
+    cls.add_method('RegisterMacTxDl', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'cellId'), param('uint32_t', 'packetSize'), param('uint8_t', 'numRetx')])
+    ## mac-tx-stats-calculator.h (module 'lte'): void ns3::MacTxStatsCalculator::RegisterMacTxUl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx) [member function]
+    cls.add_method('RegisterMacTxUl', 
+                   'void', 
+                   [param('uint16_t', 'rnti'), param('uint16_t', 'cellId'), param('uint32_t', 'packetSize'), param('uint8_t', 'numRetx')])
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxDlFile [variable]
+    cls.add_instance_attribute('m_retxDlFile', 'std::ofstream', is_const=False)
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxDlFilename [variable]
+    cls.add_instance_attribute('m_retxDlFilename', 'std::string', is_const=False)
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxUlFile [variable]
+    cls.add_instance_attribute('m_retxUlFile', 'std::ofstream', is_const=False)
+    ## mac-tx-stats-calculator.h (module 'lte'): ns3::MacTxStatsCalculator::m_retxUlFilename [variable]
+    cls.add_instance_attribute('m_retxUlFilename', 'std::string', is_const=False)
+    return
+
+def register_Ns3McEnbPdcp_methods(root_module, cls):
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::McEnbPdcp(ns3::McEnbPdcp const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McEnbPdcp const &', 'arg0')])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::McEnbPdcp() [constructor]
+    cls.add_constructor([])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoDispose() [member function]
+    cls.add_method('DoDispose', 
+                   'void', 
+                   [], 
+                   is_virtual=True)
+    ## mc-enb-pdcp.h (module 'lte'): ns3::EpcX2PdcpUser * ns3::McEnbPdcp::GetEpcX2PdcpUser() [member function]
+    cls.add_method('GetEpcX2PdcpUser', 
+                   'ns3::EpcX2PdcpUser *', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::LtePdcpSapProvider * ns3::McEnbPdcp::GetLtePdcpSapProvider() [member function]
+    cls.add_method('GetLtePdcpSapProvider', 
+                   'ns3::LtePdcpSapProvider *', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::LteRlcSapUser * ns3::McEnbPdcp::GetLteRlcSapUser() [member function]
+    cls.add_method('GetLteRlcSapUser', 
+                   'ns3::LteRlcSapUser *', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status ns3::McEnbPdcp::GetStatus() [member function]
+    cls.add_method('GetStatus', 
+                   'ns3::McEnbPdcp::Status', 
+                   [])
+    ## mc-enb-pdcp.h (module 'lte'): static ns3::TypeId ns3::McEnbPdcp::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## mc-enb-pdcp.h (module 'lte'): bool ns3::McEnbPdcp::GetUseMmWaveConnection() const [member function]
+    cls.add_method('GetUseMmWaveConnection', 
+                   'bool', 
+                   [], 
+                   is_const=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetEpcX2PdcpProvider(ns3::EpcX2PdcpProvider * s) [member function]
+    cls.add_method('SetEpcX2PdcpProvider', 
+                   'void', 
+                   [param('ns3::EpcX2PdcpProvider *', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetLcId(uint8_t lcId) [member function]
+    cls.add_method('SetLcId', 
+                   'void', 
+                   [param('uint8_t', 'lcId')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetLtePdcpSapUser(ns3::LtePdcpSapUser * s) [member function]
+    cls.add_method('SetLtePdcpSapUser', 
+                   'void', 
+                   [param('ns3::LtePdcpSapUser *', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetLteRlcSapProvider(ns3::LteRlcSapProvider * s) [member function]
+    cls.add_method('SetLteRlcSapProvider', 
+                   'void', 
+                   [param('ns3::LteRlcSapProvider *', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetRnti(uint16_t rnti) [member function]
+    cls.add_method('SetRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetStatus(ns3::McEnbPdcp::Status s) [member function]
+    cls.add_method('SetStatus', 
+                   'void', 
+                   [param('ns3::McEnbPdcp::Status', 's')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SetUeDataParams(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('SetUeDataParams', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')])
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::SwitchConnection(bool useMmWaveConnection) [member function]
+    cls.add_method('SwitchConnection', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::MAX_PDCP_SN [variable]
+    cls.add_static_attribute('MAX_PDCP_SN', 'uint16_t const', is_const=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoReceiveMcPdcpPdu(ns3::EpcX2Sap::UeDataParams params) [member function]
+    cls.add_method('DoReceiveMcPdcpPdu', 
+                   'void', 
+                   [param('ns3::EpcX2Sap::UeDataParams', 'params')], 
+                   visibility='protected', is_virtual=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
+    ## mc-enb-pdcp.h (module 'lte'): void ns3::McEnbPdcp::DoTransmitPdcpSdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoTransmitPdcpSdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
     return
 
-def register_Ns3MacStatsCalculator_methods(root_module, cls):
-    ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator::MacStatsCalculator(ns3::MacStatsCalculator const & arg0) [constructor]
-    cls.add_constructor([param('ns3::MacStatsCalculator const &', 'arg0')])
-    ## mac-stats-calculator.h (module 'lte'): ns3::MacStatsCalculator::MacStatsCalculator() [constructor]
+def register_Ns3McEnbPdcpStatus_methods(root_module, cls):
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::Status() [constructor]
     cls.add_constructor([])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::DlScheduling(uint16_t cellId, uint64_t imsi, ns3::DlSchedulingCallbackInfo dlSchedulingCallbackInfo) [member function]
-    cls.add_method('DlScheduling', 
-                   'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('ns3::DlSchedulingCallbackInfo', 'dlSchedulingCallbackInfo')])
-    ## mac-stats-calculator.h (module 'lte'): static void ns3::MacStatsCalculator::DlSchedulingCallback(ns3::Ptr<ns3::MacStatsCalculator> macStats, std::string path, ns3::DlSchedulingCallbackInfo dlSchedulingCallbackInfo) [member function]
-    cls.add_method('DlSchedulingCallback', 
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::Status(ns3::McEnbPdcp::Status const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McEnbPdcp::Status const &', 'arg0')])
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::rxSn [variable]
+    cls.add_instance_attribute('rxSn', 'uint16_t', is_const=False)
+    ## mc-enb-pdcp.h (module 'lte'): ns3::McEnbPdcp::Status::txSn [variable]
+    cls.add_instance_attribute('txSn', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3McUePdcp_methods(root_module, cls):
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::McUePdcp(ns3::McUePdcp const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McUePdcp const &', 'arg0')])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::McUePdcp() [constructor]
+    cls.add_constructor([])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::DoDispose() [member function]
+    cls.add_method('DoDispose', 
                    'void', 
-                   [param('ns3::Ptr< ns3::MacStatsCalculator >', 'macStats'), param('std::string', 'path'), param('ns3::DlSchedulingCallbackInfo', 'dlSchedulingCallbackInfo')], 
-                   is_static=True)
-    ## mac-stats-calculator.h (module 'lte'): std::string ns3::MacStatsCalculator::GetDlOutputFilename() [member function]
-    cls.add_method('GetDlOutputFilename', 
-                   'std::string', 
+                   [], 
+                   is_virtual=True)
+    ## mc-ue-pdcp.h (module 'lte'): ns3::LtePdcpSapProvider * ns3::McUePdcp::GetLtePdcpSapProvider() [member function]
+    cls.add_method('GetLtePdcpSapProvider', 
+                   'ns3::LtePdcpSapProvider *', 
                    [])
-    ## mac-stats-calculator.h (module 'lte'): static ns3::TypeId ns3::MacStatsCalculator::GetTypeId() [member function]
+    ## mc-ue-pdcp.h (module 'lte'): ns3::LteRlcSapUser * ns3::McUePdcp::GetLteRlcSapUser() [member function]
+    cls.add_method('GetLteRlcSapUser', 
+                   'ns3::LteRlcSapUser *', 
+                   [])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status ns3::McUePdcp::GetStatus() [member function]
+    cls.add_method('GetStatus', 
+                   'ns3::McUePdcp::Status', 
+                   [])
+    ## mc-ue-pdcp.h (module 'lte'): static ns3::TypeId ns3::McUePdcp::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
                    'ns3::TypeId', 
                    [], 
                    is_static=True)
-    ## mac-stats-calculator.h (module 'lte'): std::string ns3::MacStatsCalculator::GetUlOutputFilename() [member function]
-    cls.add_method('GetUlOutputFilename', 
-                   'std::string', 
-                   [])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::SetDlOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetDlOutputFilename', 
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetLcId(uint8_t lcId) [member function]
+    cls.add_method('SetLcId', 
                    'void', 
-                   [param('std::string', 'outputFilename')])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::SetUlOutputFilename(std::string outputFilename) [member function]
-    cls.add_method('SetUlOutputFilename', 
+                   [param('uint8_t', 'lcId')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetLtePdcpSapUser(ns3::LtePdcpSapUser * s) [member function]
+    cls.add_method('SetLtePdcpSapUser', 
                    'void', 
-                   [param('std::string', 'outputFilename')])
-    ## mac-stats-calculator.h (module 'lte'): void ns3::MacStatsCalculator::UlScheduling(uint16_t cellId, uint64_t imsi, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcsTb, uint16_t sizeTb, uint8_t componentCarrierId) [member function]
-    cls.add_method('UlScheduling', 
+                   [param('ns3::LtePdcpSapUser *', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetLteRlcSapProvider(ns3::LteRlcSapProvider * s) [member function]
+    cls.add_method('SetLteRlcSapProvider', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcsTb'), param('uint16_t', 'sizeTb'), param('uint8_t', 'componentCarrierId')])
-    ## mac-stats-calculator.h (module 'lte'): static void ns3::MacStatsCalculator::UlSchedulingCallback(ns3::Ptr<ns3::MacStatsCalculator> macStats, std::string path, uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcs, uint16_t size, uint8_t componentCarrierId) [member function]
-    cls.add_method('UlSchedulingCallback', 
+                   [param('ns3::LteRlcSapProvider *', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetMmWaveRlcSapProvider(ns3::LteRlcSapProvider * s) [member function]
+    cls.add_method('SetMmWaveRlcSapProvider', 
                    'void', 
-                   [param('ns3::Ptr< ns3::MacStatsCalculator >', 'macStats'), param('std::string', 'path'), param('uint32_t', 'frameNo'), param('uint32_t', 'subframeNo'), param('uint16_t', 'rnti'), param('uint8_t', 'mcs'), param('uint16_t', 'size'), param('uint8_t', 'componentCarrierId')], 
-                   is_static=True)
+                   [param('ns3::LteRlcSapProvider *', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetMmWaveRnti(uint16_t rnti) [member function]
+    cls.add_method('SetMmWaveRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetRnti(uint16_t rnti) [member function]
+    cls.add_method('SetRnti', 
+                   'void', 
+                   [param('uint16_t', 'rnti')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SetStatus(ns3::McUePdcp::Status s) [member function]
+    cls.add_method('SetStatus', 
+                   'void', 
+                   [param('ns3::McUePdcp::Status', 's')])
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::SwitchConnection(bool useMmWaveConnection) [member function]
+    cls.add_method('SwitchConnection', 
+                   'void', 
+                   [param('bool', 'useMmWaveConnection')])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::MAX_PDCP_SN [variable]
+    cls.add_static_attribute('MAX_PDCP_SN', 'uint16_t const', is_const=True)
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::DoReceivePdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoReceivePdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
+    ## mc-ue-pdcp.h (module 'lte'): void ns3::McUePdcp::DoTransmitPdcpSdu(ns3::Ptr<ns3::Packet> p) [member function]
+    cls.add_method('DoTransmitPdcpSdu', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::Packet >', 'p')], 
+                   visibility='protected', is_virtual=True)
+    return
+
+def register_Ns3McUePdcpStatus_methods(root_module, cls):
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::Status() [constructor]
+    cls.add_constructor([])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::Status(ns3::McUePdcp::Status const & arg0) [constructor]
+    cls.add_constructor([param('ns3::McUePdcp::Status const &', 'arg0')])
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::rxSn [variable]
+    cls.add_instance_attribute('rxSn', 'uint16_t', is_const=False)
+    ## mc-ue-pdcp.h (module 'lte'): ns3::McUePdcp::Status::txSn [variable]
+    cls.add_instance_attribute('txSn', 'uint16_t', is_const=False)
     return
 
 def register_Ns3MibLteControlMessage_methods(root_module, cls):
@@ -19930,98 +22034,6 @@
                    is_const=True)
     return
 
-def register_Ns3NoOpComponentCarrierManager_methods(root_module, cls):
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::NoOpComponentCarrierManager::NoOpComponentCarrierManager(ns3::NoOpComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::NoOpComponentCarrierManager const &', 'arg0')])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::NoOpComponentCarrierManager::NoOpComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## no-op-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::NoOpComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoAddLc(ns3::LteEnbCmacSapProvider::LcInfo lcInfo, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoAddLc', 
-                   'void', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcInfo'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoAddUe(uint16_t rnti, uint8_t state) [member function]
-    cls.add_method('DoAddUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'state')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::LteMacSapUser * ns3::NoOpComponentCarrierManager::DoConfigureSignalBearer(ns3::LteEnbCmacSapProvider::LcInfo lcinfo, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('ns3::LteEnbCmacSapProvider::LcInfo', 'lcinfo'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoNotifyPrbOccupancy(double prbOccupancy, uint8_t componentCarrierId) [member function]
-    cls.add_method('DoNotifyPrbOccupancy', 
-                   'void', 
-                   [param('double', 'prbOccupancy'), param('uint8_t', 'componentCarrierId')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): std::vector<unsigned char, std::allocator<unsigned char> > ns3::NoOpComponentCarrierManager::DoReleaseDataRadioBearer(uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReleaseDataRadioBearer', 
-                   'std::vector< unsigned char >', 
-                   [param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoRemoveUe(uint16_t rnti) [member function]
-    cls.add_method('DoRemoveUe', 
-                   'void', 
-                   [param('uint16_t', 'rnti')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoReportBufferStatus(ns3::LteMacSapProvider::ReportBufferStatusParameters params) [member function]
-    cls.add_method('DoReportBufferStatus', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::ReportBufferStatusParameters', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): std::vector<ns3::LteCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteCcmRrcSapProvider::LcsConfig> > ns3::NoOpComponentCarrierManager::DoSetupDataRadioBearer(ns3::EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoSetupDataRadioBearer', 
-                   'std::vector< ns3::LteCcmRrcSapProvider::LcsConfig >', 
-                   [param('ns3::EpsBearer', 'bearer'), param('uint8_t', 'bearerId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid'), param('uint8_t', 'lcGroup'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoTransmitPdu(ns3::LteMacSapProvider::TransmitPduParameters params) [member function]
-    cls.add_method('DoTransmitPdu', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::TransmitPduParameters', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::NoOpComponentCarrierManager::DoUlReceiveMacCe(ns3::MacCeListElement_s bsr, uint8_t componentCarrierId) [member function]
-    cls.add_method('DoUlReceiveMacCe', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr'), param('uint8_t', 'componentCarrierId')], 
-                   visibility='protected', is_virtual=True)
-    return
-
 def register_Ns3NoOpHandoverAlgorithm_methods(root_module, cls):
     ## no-op-handover-algorithm.h (module 'lte'): ns3::NoOpHandoverAlgorithm::NoOpHandoverAlgorithm(ns3::NoOpHandoverAlgorithm const & arg0) [constructor]
     cls.add_constructor([param('ns3::NoOpHandoverAlgorithm const &', 'arg0')])
@@ -20584,14 +22596,14 @@
     cls.add_method('GetUeSinrFilename', 
                    'std::string', 
                    [])
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportCurrentCellRsrpSinr(uint16_t cellId, uint64_t imsi, uint16_t rnti, double rsrp, double sinr, uint8_t componentCarrierId) [member function]
+    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportCurrentCellRsrpSinr(uint16_t cellId, uint64_t imsi, uint16_t rnti, double rsrp, double sinr) [member function]
     cls.add_method('ReportCurrentCellRsrpSinr', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('double', 'rsrp'), param('double', 'sinr'), param('uint8_t', 'componentCarrierId')])
-    ## phy-stats-calculator.h (module 'lte'): static void ns3::PhyStatsCalculator::ReportCurrentCellRsrpSinrCallback(ns3::Ptr<ns3::PhyStatsCalculator> phyStats, std::string path, uint16_t cellId, uint16_t rnti, double rsrp, double sinr, uint8_t componentCarrierId) [member function]
+                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('double', 'rsrp'), param('double', 'sinr')])
+    ## phy-stats-calculator.h (module 'lte'): static void ns3::PhyStatsCalculator::ReportCurrentCellRsrpSinrCallback(ns3::Ptr<ns3::PhyStatsCalculator> phyStats, std::string path, uint16_t cellId, uint16_t rnti, double rsrp, double sinr) [member function]
     cls.add_method('ReportCurrentCellRsrpSinrCallback', 
                    'void', 
-                   [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('double', 'rsrp'), param('double', 'sinr'), param('uint8_t', 'componentCarrierId')], 
+                   [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('double', 'rsrp'), param('double', 'sinr')], 
                    is_static=True)
     ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportInterference(uint16_t cellId, ns3::Ptr<ns3::SpectrumValue> interference) [member function]
     cls.add_method('ReportInterference', 
@@ -20602,14 +22614,14 @@
                    'void', 
                    [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('ns3::Ptr< ns3::SpectrumValue >', 'interference')], 
                    is_static=True)
-    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportUeSinr(uint16_t cellId, uint64_t imsi, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId) [member function]
+    ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::ReportUeSinr(uint16_t cellId, uint64_t imsi, uint16_t rnti, double sinrLinear) [member function]
     cls.add_method('ReportUeSinr', 
                    'void', 
-                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('double', 'sinrLinear'), param('uint8_t', 'componentCarrierId')])
-    ## phy-stats-calculator.h (module 'lte'): static void ns3::PhyStatsCalculator::ReportUeSinr(ns3::Ptr<ns3::PhyStatsCalculator> phyStats, std::string path, uint16_t cellId, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId) [member function]
+                   [param('uint16_t', 'cellId'), param('uint64_t', 'imsi'), param('uint16_t', 'rnti'), param('double', 'sinrLinear')])
+    ## phy-stats-calculator.h (module 'lte'): static void ns3::PhyStatsCalculator::ReportUeSinr(ns3::Ptr<ns3::PhyStatsCalculator> phyStats, std::string path, uint16_t cellId, uint16_t rnti, double sinrLinear) [member function]
     cls.add_method('ReportUeSinr', 
                    'void', 
-                   [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('double', 'sinrLinear'), param('uint8_t', 'componentCarrierId')], 
+                   [param('ns3::Ptr< ns3::PhyStatsCalculator >', 'phyStats'), param('std::string', 'path'), param('uint16_t', 'cellId'), param('uint16_t', 'rnti'), param('double', 'sinrLinear')], 
                    is_static=True)
     ## phy-stats-calculator.h (module 'lte'): void ns3::PhyStatsCalculator::SetCurrentCellRsrpSinrFilename(std::string filename) [member function]
     cls.add_method('SetCurrentCellRsrpSinrFilename', 
@@ -20681,6 +22693,11 @@
                    'uint8_t', 
                    [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
                    is_virtual=True)
+    ## point-to-point-epc-helper.h (module 'lte'): uint8_t ns3::PointToPointEpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, ns3::Ptr<ns3::EpcUeNas> ueNas, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('ActivateEpsBearer', 
+                   'uint8_t', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('ns3::Ptr< ns3::EpcUeNas >', 'ueNas'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
+                   is_virtual=True)
     ## point-to-point-epc-helper.h (module 'lte'): void ns3::PointToPointEpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
     cls.add_method('AddEnb', 
                    'void', 
@@ -20706,6 +22723,11 @@
                    'void', 
                    [], 
                    is_virtual=True)
+    ## point-to-point-epc-helper.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::PointToPointEpcHelper::GetMmeNode() [member function]
+    cls.add_method('GetMmeNode', 
+                   'ns3::Ptr< ns3::Node >', 
+                   [], 
+                   is_virtual=True)
     ## point-to-point-epc-helper.h (module 'lte'): ns3::Ptr<ns3::Node> ns3::PointToPointEpcHelper::GetPgwNode() [member function]
     cls.add_method('GetPgwNode', 
                    'ns3::Ptr< ns3::Node >', 
@@ -20819,6 +22841,32 @@
                    [param('uint16_t', 'rnti'), param('uint8_t', 'txMode')])
     return
 
+def register_Ns3QueueItem_methods(root_module, cls):
+    cls.add_output_stream_operator()
+    ## queue-item.h (module 'network'): ns3::QueueItem::QueueItem(ns3::Ptr<ns3::Packet> p) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Packet >', 'p')])
+    ## queue-item.h (module 'network'): ns3::Ptr<ns3::Packet> ns3::QueueItem::GetPacket() const [member function]
+    cls.add_method('GetPacket', 
+                   'ns3::Ptr< ns3::Packet >', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): uint32_t ns3::QueueItem::GetSize() const [member function]
+    cls.add_method('GetSize', 
+                   'uint32_t', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## queue-item.h (module 'network'): bool ns3::QueueItem::GetUint8Value(ns3::QueueItem::Uint8Values field, uint8_t & value) const [member function]
+    cls.add_method('GetUint8Value', 
+                   'bool', 
+                   [param('ns3::QueueItem::Uint8Values', 'field'), param('uint8_t &', 'value')], 
+                   is_const=True, is_virtual=True)
+    ## queue-item.h (module 'network'): void ns3::QueueItem::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    return
+
 def register_Ns3RachPreambleLteControlMessage_methods(root_module, cls):
     ## lte-control-messages.h (module 'lte'): ns3::RachPreambleLteControlMessage::RachPreambleLteControlMessage(ns3::RachPreambleLteControlMessage const & arg0) [constructor]
     cls.add_constructor([param('ns3::RachPreambleLteControlMessage const &', 'arg0')])
@@ -21100,28 +23148,6 @@
                    [param('int32_t', 'rbId')])
     return
 
-def register_Ns3RrComponentCarrierManager_methods(root_module, cls):
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::RrComponentCarrierManager::RrComponentCarrierManager(ns3::RrComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::RrComponentCarrierManager const &', 'arg0')])
-    ## no-op-component-carrier-manager.h (module 'lte'): ns3::RrComponentCarrierManager::RrComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## no-op-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::RrComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::RrComponentCarrierManager::DoReportBufferStatus(ns3::LteMacSapProvider::ReportBufferStatusParameters params) [member function]
-    cls.add_method('DoReportBufferStatus', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::ReportBufferStatusParameters', 'params')], 
-                   visibility='protected', is_virtual=True)
-    ## no-op-component-carrier-manager.h (module 'lte'): void ns3::RrComponentCarrierManager::DoUlReceiveMacCe(ns3::MacCeListElement_s bsr, uint8_t componentCarrierId) [member function]
-    cls.add_method('DoUlReceiveMacCe', 
-                   'void', 
-                   [param('ns3::MacCeListElement_s', 'bsr'), param('uint8_t', 'componentCarrierId')], 
-                   visibility='protected', is_virtual=True)
-    return
-
 def register_Ns3RrFfMacScheduler_methods(root_module, cls):
     ## rr-ff-mac-scheduler.h (module 'lte'): ns3::RrFfMacScheduler::RrFfMacScheduler(ns3::RrFfMacScheduler const & arg0) [constructor]
     cls.add_constructor([param('ns3::RrFfMacScheduler const &', 'arg0')])
@@ -21187,11 +23213,6 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'bIterator')], 
                    is_pure_virtual=True, visibility='protected', is_virtual=True)
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeCellIdentification(ns3::LteRrcSap::CellIdentification * ci, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeCellIdentification', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::CellIdentification *', 'ci'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
     ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeDrbToAddModList(std::list<ns3::LteRrcSap::DrbToAddMod, std::allocator<ns3::LteRrcSap::DrbToAddMod> > * drbToAddModLis, ns3::Buffer::Iterator bIterator) [member function]
     cls.add_method('DeserializeDrbToAddModList', 
                    'ns3::Buffer::Iterator', 
@@ -21212,21 +23233,11 @@
                    'ns3::Buffer::Iterator', 
                    [param('ns3::LteRrcSap::MeasResults *', 'measResults'), param('ns3::Buffer::Iterator', 'bIterator')], 
                    visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeNonCriticalExtensionConfig(ns3::LteRrcSap::NonCriticalExtensionConfiguration * nonCriticalExtension, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeNonCriticalExtensionConfig', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::NonCriticalExtensionConfiguration *', 'nonCriticalExtension'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
     ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializePhysicalConfigDedicated(ns3::LteRrcSap::PhysicalConfigDedicated * physicalConfigDedicated, ns3::Buffer::Iterator bIterator) [member function]
     cls.add_method('DeserializePhysicalConfigDedicated', 
                    'ns3::Buffer::Iterator', 
                    [param('ns3::LteRrcSap::PhysicalConfigDedicated *', 'physicalConfigDedicated'), param('ns3::Buffer::Iterator', 'bIterator')], 
                    visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializePhysicalConfigDedicatedSCell(ns3::LteRrcSap::PhysicalConfigDedicatedSCell * pcdsc, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializePhysicalConfigDedicatedSCell', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::PhysicalConfigDedicatedSCell *', 'pcdsc'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
     ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializePlmnIdentity(uint32_t * plmnId, ns3::Buffer::Iterator bIterator) [member function]
     cls.add_method('DeserializePlmnIdentity', 
                    'ns3::Buffer::Iterator', 
@@ -21247,11 +23258,6 @@
                    'ns3::Buffer::Iterator', 
                    [param('ns3::LteRrcSap::RadioResourceConfigCommon *', 'radioResourceConfigCommon'), param('ns3::Buffer::Iterator', 'bIterator')], 
                    visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigCommonSCell(ns3::LteRrcSap::RadioResourceConfigCommonSCell * rrccsc, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRadioResourceConfigCommonSCell', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommonSCell *', 'rrccsc'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
     ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigCommonSib(ns3::LteRrcSap::RadioResourceConfigCommonSib * radioResourceConfigCommonSib, ns3::Buffer::Iterator bIterator) [member function]
     cls.add_method('DeserializeRadioResourceConfigCommonSib', 
                    'ns3::Buffer::Iterator', 
@@ -21262,11 +23268,6 @@
                    'ns3::Buffer::Iterator', 
                    [param('ns3::LteRrcSap::RadioResourceConfigDedicated *', 'radioResourceConfigDedicated'), param('ns3::Buffer::Iterator', 'bIterator')], 
                    visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeRadioResourceConfigDedicatedSCell(ns3::LteRrcSap::RadioResourceConfigDedicatedSCell * rrcdsc, ns3::Buffer::Iterator bIterator) [member function]
-    cls.add_method('DeserializeRadioResourceConfigDedicatedSCell', 
-                   'ns3::Buffer::Iterator', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigDedicatedSCell *', 'rrcdsc'), param('ns3::Buffer::Iterator', 'bIterator')], 
-                   visibility='protected')
     ## lte-rrc-header.h (module 'lte'): ns3::Buffer::Iterator ns3::RrcAsn1Header::DeserializeSrbToAddModList(std::list<ns3::LteRrcSap::SrbToAddMod, std::allocator<ns3::LteRrcSap::SrbToAddMod> > * srbToAddModList, ns3::Buffer::Iterator bIterator) [member function]
     cls.add_method('DeserializeSrbToAddModList', 
                    'ns3::Buffer::Iterator', 
@@ -21332,21 +23333,11 @@
                    'void', 
                    [param('ns3::LteRrcSap::MeasResults', 'measResults')], 
                    is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeNonCriticalExtensionConfiguration(ns3::LteRrcSap::NonCriticalExtensionConfiguration nonCriticalExtensionConfiguration) const [member function]
-    cls.add_method('SerializeNonCriticalExtensionConfiguration', 
-                   'void', 
-                   [param('ns3::LteRrcSap::NonCriticalExtensionConfiguration', 'nonCriticalExtensionConfiguration')], 
-                   is_const=True, visibility='protected')
     ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializePhysicalConfigDedicated(ns3::LteRrcSap::PhysicalConfigDedicated physicalConfigDedicated) const [member function]
     cls.add_method('SerializePhysicalConfigDedicated', 
                    'void', 
                    [param('ns3::LteRrcSap::PhysicalConfigDedicated', 'physicalConfigDedicated')], 
                    is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializePhysicalConfigDedicatedSCell(ns3::LteRrcSap::PhysicalConfigDedicatedSCell pcdsc) const [member function]
-    cls.add_method('SerializePhysicalConfigDedicatedSCell', 
-                   'void', 
-                   [param('ns3::LteRrcSap::PhysicalConfigDedicatedSCell', 'pcdsc')], 
-                   is_const=True, visibility='protected')
     ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializePlmnIdentity(uint32_t plmnId) const [member function]
     cls.add_method('SerializePlmnIdentity', 
                    'void', 
@@ -21367,11 +23358,6 @@
                    'void', 
                    [param('ns3::LteRrcSap::RadioResourceConfigCommon', 'radioResourceConfigCommon')], 
                    is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceConfigCommonSCell(ns3::LteRrcSap::RadioResourceConfigCommonSCell rrccsc) const [member function]
-    cls.add_method('SerializeRadioResourceConfigCommonSCell', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigCommonSCell', 'rrccsc')], 
-                   is_const=True, visibility='protected')
     ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceConfigCommonSib(ns3::LteRrcSap::RadioResourceConfigCommonSib radioResourceConfigCommonSib) const [member function]
     cls.add_method('SerializeRadioResourceConfigCommonSib', 
                    'void', 
@@ -21382,11 +23368,6 @@
                    'void', 
                    [param('ns3::LteRrcSap::RadioResourceConfigDedicated', 'radioResourceConfigDedicated')], 
                    is_const=True, visibility='protected')
-    ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeRadioResourceDedicatedSCell(ns3::LteRrcSap::RadioResourceConfigDedicatedSCell rrcdsc) const [member function]
-    cls.add_method('SerializeRadioResourceDedicatedSCell', 
-                   'void', 
-                   [param('ns3::LteRrcSap::RadioResourceConfigDedicatedSCell', 'rrcdsc')], 
-                   is_const=True, visibility='protected')
     ## lte-rrc-header.h (module 'lte'): void ns3::RrcAsn1Header::SerializeSrbToAddModList(std::list<ns3::LteRrcSap::SrbToAddMod, std::allocator<ns3::LteRrcSap::SrbToAddMod> > srbToAddModList) const [member function]
     cls.add_method('SerializeSrbToAddModList', 
                    'void', 
@@ -21537,6 +23518,28 @@
                    is_const=True, visibility='protected')
     return
 
+def register_Ns3S1apConnectionInfo_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::S1apConnectionInfo(ns3::S1apConnectionInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::S1apConnectionInfo const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::S1apConnectionInfo(uint16_t enbId, uint16_t mmeId) [constructor]
+    cls.add_constructor([param('uint16_t', 'enbId'), param('uint16_t', 'mmeId')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::m_enbId [variable]
+    cls.add_instance_attribute('m_enbId', 'uint16_t', is_const=False)
+    ## epc-s1ap.h (module 'lte'): ns3::S1apConnectionInfo::m_mmeId [variable]
+    cls.add_instance_attribute('m_mmeId', 'uint16_t', is_const=False)
+    return
+
+def register_Ns3S1apIfaceInfo_methods(root_module, cls):
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::S1apIfaceInfo(ns3::S1apIfaceInfo const & arg0) [constructor]
+    cls.add_constructor([param('ns3::S1apIfaceInfo const &', 'arg0')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::S1apIfaceInfo(ns3::Ipv4Address remoteIpAddr, ns3::Ptr<ns3::Socket> localCtrlPlaneSocket) [constructor]
+    cls.add_constructor([param('ns3::Ipv4Address', 'remoteIpAddr'), param('ns3::Ptr< ns3::Socket >', 'localCtrlPlaneSocket')])
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::m_localCtrlPlaneSocket [variable]
+    cls.add_instance_attribute('m_localCtrlPlaneSocket', 'ns3::Ptr< ns3::Socket >', is_const=False)
+    ## epc-s1ap.h (module 'lte'): ns3::S1apIfaceInfo::m_remoteIpAddr [variable]
+    cls.add_instance_attribute('m_remoteIpAddr', 'ns3::Ipv4Address', is_const=False)
+    return
+
 def register_Ns3Sib1LteControlMessage_methods(root_module, cls):
     ## lte-control-messages.h (module 'lte'): ns3::Sib1LteControlMessage::Sib1LteControlMessage(ns3::Sib1LteControlMessage const & arg0) [constructor]
     cls.add_constructor([param('ns3::Sib1LteControlMessage const &', 'arg0')])
@@ -21553,93 +23556,6 @@
                    [param('ns3::LteRrcSap::SystemInformationBlockType1', 'sib1')])
     return
 
-def register_Ns3SimpleUeComponentCarrierManager_methods(root_module, cls):
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::SimpleUeComponentCarrierManager::SimpleUeComponentCarrierManager(ns3::SimpleUeComponentCarrierManager const & arg0) [constructor]
-    cls.add_constructor([param('ns3::SimpleUeComponentCarrierManager const &', 'arg0')])
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::SimpleUeComponentCarrierManager::SimpleUeComponentCarrierManager() [constructor]
-    cls.add_constructor([])
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::LteUeCcmRrcSapProvider * ns3::SimpleUeComponentCarrierManager::GetLteCcmRrcSapProvider() [member function]
-    cls.add_method('GetLteCcmRrcSapProvider', 
-                   'ns3::LteUeCcmRrcSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::LteMacSapProvider * ns3::SimpleUeComponentCarrierManager::GetLteMacSapProvider() [member function]
-    cls.add_method('GetLteMacSapProvider', 
-                   'ns3::LteMacSapProvider *', 
-                   [], 
-                   is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): static ns3::TypeId ns3::SimpleUeComponentCarrierManager::GetTypeId() [member function]
-    cls.add_method('GetTypeId', 
-                   'ns3::TypeId', 
-                   [], 
-                   is_static=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::SetLteCcmRrcSapUser(ns3::LteUeCcmRrcSapUser * s) [member function]
-    cls.add_method('SetLteCcmRrcSapUser', 
-                   'void', 
-                   [param('ns3::LteUeCcmRrcSapUser *', 's')], 
-                   is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): std::vector<ns3::LteUeCcmRrcSapProvider::LcsConfig, std::allocator<ns3::LteUeCcmRrcSapProvider::LcsConfig> > ns3::SimpleUeComponentCarrierManager::DoAddLc(uint8_t lcId, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoAddLc', 
-                   'std::vector< ns3::LteUeCcmRrcSapProvider::LcsConfig >', 
-                   [param('uint8_t', 'lcId'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): ns3::LteMacSapUser * ns3::SimpleUeComponentCarrierManager::DoConfigureSignalBearer(uint8_t lcId, ns3::LteUeCmacSapProvider::LogicalChannelConfig lcConfig, ns3::LteMacSapUser * msu) [member function]
-    cls.add_method('DoConfigureSignalBearer', 
-                   'ns3::LteMacSapUser *', 
-                   [param('uint8_t', 'lcId'), param('ns3::LteUeCmacSapProvider::LogicalChannelConfig', 'lcConfig'), param('ns3::LteMacSapUser *', 'msu')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoDispose() [member function]
-    cls.add_method('DoDispose', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoInitialize() [member function]
-    cls.add_method('DoInitialize', 
-                   'void', 
-                   [], 
-                   visibility='protected', is_virtual=True)
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoNotifyConnectionReconfigurationMsg() [member function]
-    cls.add_method('DoNotifyConnectionReconfigurationMsg', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoNotifyHarqDeliveryFailure() [member function]
-    cls.add_method('DoNotifyHarqDeliveryFailure', 
-                   'void', 
-                   [], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoNotifyTxOpportunity(uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoNotifyTxOpportunity', 
-                   'void', 
-                   [param('uint32_t', 'bytes'), param('uint8_t', 'layer'), param('uint8_t', 'harqId'), param('uint8_t', 'componentCarrierId'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoReceivePdu(ns3::Ptr<ns3::Packet> p, uint16_t rnti, uint8_t lcid) [member function]
-    cls.add_method('DoReceivePdu', 
-                   'void', 
-                   [param('ns3::Ptr< ns3::Packet >', 'p'), param('uint16_t', 'rnti'), param('uint8_t', 'lcid')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): std::vector<unsigned short, std::allocator<unsigned short> > ns3::SimpleUeComponentCarrierManager::DoRemoveLc(uint8_t lcid) [member function]
-    cls.add_method('DoRemoveLc', 
-                   'std::vector< unsigned short >', 
-                   [param('uint8_t', 'lcid')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoReportBufferStatus(ns3::LteMacSapProvider::ReportBufferStatusParameters params) [member function]
-    cls.add_method('DoReportBufferStatus', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::ReportBufferStatusParameters', 'params')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoReportUeMeas(uint16_t rnti, ns3::LteRrcSap::MeasResults measResults) [member function]
-    cls.add_method('DoReportUeMeas', 
-                   'void', 
-                   [param('uint16_t', 'rnti'), param('ns3::LteRrcSap::MeasResults', 'measResults')], 
-                   visibility='protected')
-    ## simple-ue-component-carrier-manager.h (module 'lte'): void ns3::SimpleUeComponentCarrierManager::DoTransmitPdu(ns3::LteMacSapProvider::TransmitPduParameters params) [member function]
-    cls.add_method('DoTransmitPdu', 
-                   'void', 
-                   [param('ns3::LteMacSapProvider::TransmitPduParameters', 'params')], 
-                   visibility='protected')
-    return
-
 def register_Ns3SpectrumChannel_methods(root_module, cls):
     ## spectrum-channel.h (module 'spectrum'): ns3::SpectrumChannel::SpectrumChannel() [constructor]
     cls.add_constructor([])
@@ -22529,47 +24445,47 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
-def register_Ns3CallbackImpl__Void_Const_ns3SpectrumValue___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+def register_Ns3CallbackImpl__Void_Bool_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
     cls.add_method('DoGetTypeid', 
                    'std::string', 
                    [], 
                    is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
     cls.add_method('GetTypeid', 
                    'std::string', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::SpectrumValue const & arg0) [member operator]
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, bool, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(bool arg0, bool arg1) [member operator]
     cls.add_method('operator()', 
                    'void', 
-                   [param('ns3::SpectrumValue const &', 'arg0')], 
+                   [param('bool', 'arg0'), param('bool', 'arg1')], 
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
-def register_Ns3CallbackImpl__Void_Ns3DlSchedulingCallbackInfo_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+def register_Ns3CallbackImpl__Void_Const_ns3SpectrumValue___amp___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::SpectrumValue const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
     cls.add_method('DoGetTypeid', 
                    'std::string', 
                    [], 
                    is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
     cls.add_method('GetTypeid', 
                    'std::string', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::DlSchedulingCallbackInfo, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::DlSchedulingCallbackInfo arg0) [member operator]
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, const ns3::SpectrumValue &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::SpectrumValue const & arg0) [member operator]
     cls.add_method('operator()', 
                    'void', 
-                   [param('ns3::DlSchedulingCallbackInfo', 'arg0')], 
+                   [param('ns3::SpectrumValue const &', 'arg0')], 
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
@@ -22705,6 +24621,50 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Const_char___star___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::QueueDiscItem const >, char const *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, const char *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<const ns3::QueueDiscItem> arg0, char const * arg1) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'arg0'), param('char const *', 'arg1')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
+def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__const_ns3QueueDiscItem__gt___Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Ptr< ns3::QueueDiscItem const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Ptr<const ns3::QueueDiscItem>, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Ptr<const ns3::QueueDiscItem> arg0) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('ns3::Ptr< ns3::QueueDiscItem const >', 'arg0')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Ns3Ptr__lt__ns3NetDevice__gt___Ns3Ptr__lt__const_ns3Packet__gt___Unsigned_short_Const_ns3Address___amp___Const_ns3Address___amp___Ns3NetDevicePacketType_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Ptr<ns3::NetDevice>, ns3::Ptr<const ns3::Packet>, unsigned short, const ns3::Address &, const ns3::Address &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -22837,6 +24797,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Ns3Time_Ns3Time_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, ns3::Time, ns3::Time, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(ns3::Time arg0, ns3::Time arg1) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('ns3::Time', 'arg0'), param('ns3::Time', 'arg1')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -22859,25 +24841,91 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
-def register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+def register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(unsigned int arg0, unsigned int arg1) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('unsigned int', 'arg0'), param('unsigned int', 'arg1')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
+def register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(unsigned int arg0, unsigned int arg1, short unsigned int arg2, unsigned char arg3, short unsigned int arg4) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('unsigned int', 'arg0'), param('unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('unsigned char', 'arg3'), param('short unsigned int', 'arg4')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
+def register_Ns3CallbackImpl__Void_Unsigned_int_Unsigned_int_Unsigned_short_Unsigned_char_Unsigned_short_Unsigned_char_Unsigned_short_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, unsigned short, ns3::empty, ns3::empty>::operator()(unsigned int arg0, unsigned int arg1, short unsigned int arg2, unsigned char arg3, short unsigned int arg4, unsigned char arg5, short unsigned int arg6) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('unsigned int', 'arg0'), param('unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('unsigned char', 'arg3'), param('short unsigned int', 'arg4'), param('unsigned char', 'arg5'), param('short unsigned int', 'arg6')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
+def register_Ns3CallbackImpl__Void_Unsigned_long_Unsigned_short_Long_double_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
     cls.add_method('DoGetTypeid', 
                    'std::string', 
                    [], 
                    is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
     cls.add_method('GetTypeid', 
                    'std::string', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned int, unsigned int, unsigned short, unsigned char, unsigned short, unsigned char, ns3::empty, ns3::empty, ns3::empty>::operator()(unsigned int arg0, unsigned int arg1, short unsigned int arg2, unsigned char arg3, short unsigned int arg4, unsigned char arg5) [member operator]
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned long, unsigned short, long double, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(long unsigned int arg0, short unsigned int arg1, long double arg2) [member operator]
     cls.add_method('operator()', 
                    'void', 
-                   [param('unsigned int', 'arg0'), param('unsigned int', 'arg1'), param('short unsigned int', 'arg2'), param('unsigned char', 'arg3'), param('short unsigned int', 'arg4'), param('unsigned char', 'arg5')], 
+                   [param('long unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('long double', 'arg2')], 
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
@@ -23057,6 +25105,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_int_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned int, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, unsigned char arg1, unsigned int arg2, unsigned int arg3) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('short unsigned int', 'arg0'), param('unsigned char', 'arg1'), param('unsigned int', 'arg2'), param('unsigned int', 'arg3')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_char_Unsigned_int_Unsigned_long_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
     ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned char, unsigned int, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
@@ -23079,25 +25149,25 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
-def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Bool_Unsigned_char_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Double_Double_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
     cls.add_constructor([])
-    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
-    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
-    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
     cls.add_method('DoGetTypeid', 
                    'std::string', 
                    [], 
                    is_static=True)
-    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
     cls.add_method('GetTypeid', 
                    'std::string', 
                    [], 
                    is_const=True, is_virtual=True)
-    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, unsigned char, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, double arg2, double arg3, bool arg4, unsigned char arg5) [member operator]
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, double, double, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, double arg2, double arg3, bool arg4) [member operator]
     cls.add_method('operator()', 
                    'void', 
-                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('double', 'arg2'), param('double', 'arg3'), param('bool', 'arg4'), param('unsigned char', 'arg5')], 
+                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('double', 'arg2'), param('double', 'arg3'), param('bool', 'arg4')], 
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
@@ -23211,6 +25281,28 @@
                    is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
     return
 
+def register_Ns3CallbackImpl__Void_Unsigned_short_Unsigned_short_Unsigned_int_Unsigned_long_Bool_Ns3Empty_Ns3Empty_Ns3Empty_Ns3Empty_methods(root_module, cls):
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl() [constructor]
+    cls.add_constructor([])
+    ## callback.h (module 'core'): ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::CallbackImpl(ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty> const & arg0) [constructor]
+    cls.add_constructor([param('ns3::CallbackImpl< void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty > const &', 'arg0')])
+    ## callback.h (module 'core'): static std::string ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::DoGetTypeid() [member function]
+    cls.add_method('DoGetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_static=True)
+    ## callback.h (module 'core'): std::string ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::GetTypeid() const [member function]
+    cls.add_method('GetTypeid', 
+                   'std::string', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## callback.h (module 'core'): void ns3::CallbackImpl<void, unsigned short, unsigned short, unsigned int, unsigned long, bool, ns3::empty, ns3::empty, ns3::empty, ns3::empty>::operator()(short unsigned int arg0, short unsigned int arg1, unsigned int arg2, long unsigned int arg3, bool arg4) [member operator]
+    cls.add_method('operator()', 
+                   'void', 
+                   [param('short unsigned int', 'arg0'), param('short unsigned int', 'arg1'), param('unsigned int', 'arg2'), param('long unsigned int', 'arg3'), param('bool', 'arg4')], 
+                   is_pure_virtual=True, is_virtual=True, custom_name=u'__call__')
+    return
+
 def register_Ns3CqaFfMacScheduler_methods(root_module, cls):
     ## cqa-ff-mac-scheduler.h (module 'lte'): ns3::CqaFfMacScheduler::CqaFfMacScheduler(ns3::CqaFfMacScheduler const & arg0) [constructor]
     cls.add_constructor([param('ns3::CqaFfMacScheduler const &', 'arg0')])
@@ -23317,6 +25409,11 @@
                    'uint8_t', 
                    [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
                    is_virtual=True)
+    ## emu-epc-helper.h (module 'lte'): uint8_t ns3::EmuEpcHelper::ActivateEpsBearer(ns3::Ptr<ns3::NetDevice> ueLteDevice, ns3::Ptr<ns3::EpcUeNas> ueNas, uint64_t imsi, ns3::Ptr<ns3::EpcTft> tft, ns3::EpsBearer bearer) [member function]
+    cls.add_method('ActivateEpsBearer', 
+                   'uint8_t', 
+                   [param('ns3::Ptr< ns3::NetDevice >', 'ueLteDevice'), param('ns3::Ptr< ns3::EpcUeNas >', 'ueNas'), param('uint64_t', 'imsi'), param('ns3::Ptr< ns3::EpcTft >', 'tft'), param('ns3::EpsBearer', 'bearer')], 
+                   is_virtual=True)
     ## emu-epc-helper.h (module 'lte'): void ns3::EmuEpcHelper::AddEnb(ns3::Ptr<ns3::Node> enbNode, ns3::Ptr<ns3::NetDevice> lteEnbNetDevice, uint16_t cellId) [member function]
     cls.add_method('AddEnb', 
                    'void', 
@@ -23571,12 +25668,16 @@
     cls.add_instance_attribute('m_epsBearerIdentity', 'uint8_t', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_gtpTeid [variable]
     cls.add_instance_attribute('m_gtpTeid', 'uint32_t', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_isMc [variable]
+    cls.add_instance_attribute('m_isMc', 'bool', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_logicalChannelConfig [variable]
     cls.add_instance_attribute('m_logicalChannelConfig', 'ns3::LteRrcSap::LogicalChannelConfig', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_logicalChannelIdentity [variable]
     cls.add_instance_attribute('m_logicalChannelIdentity', 'uint8_t', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_rlcConfig [variable]
     cls.add_instance_attribute('m_rlcConfig', 'ns3::LteRrcSap::RlcConfig', is_const=False)
+    ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_rlcSetupRequest [variable]
+    cls.add_instance_attribute('m_rlcSetupRequest', 'ns3::EpcX2Sap::RlcSetupRequest', is_const=False)
     ## lte-radio-bearer-info.h (module 'lte'): ns3::LteDataRadioBearerInfo::m_transportLayerAddress [variable]
     cls.add_instance_attribute('m_transportLayerAddress', 'ns3::Ipv4Address', is_const=False)
     return
@@ -23953,25 +26054,20 @@
                    'ns3::Ptr< ns3::EpcUeNas >', 
                    [], 
                    is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): ns3::Ptr<ns3::LteUeComponentCarrierManager> ns3::LteUeNetDevice::GetComponentCarrierManager() const [member function]
-    cls.add_method('GetComponentCarrierManager', 
-                   'ns3::Ptr< ns3::LteUeComponentCarrierManager >', 
-                   [], 
-                   is_const=True)
     ## lte-ue-net-device.h (module 'lte'): uint64_t ns3::LteUeNetDevice::GetImsi() const [member function]
     cls.add_method('GetImsi', 
                    'uint64_t', 
                    [], 
                    is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): uint32_t ns3::LteUeNetDevice::GetDlEarfcn() const [member function]
+    ## lte-ue-net-device.h (module 'lte'): uint16_t ns3::LteUeNetDevice::GetDlEarfcn() const [member function]
     cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_const=True)
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::SetDlEarfcn(uint32_t earfcn) [member function]
+    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::SetDlEarfcn(uint16_t earfcn) [member function]
     cls.add_method('SetDlEarfcn', 
                    'void', 
-                   [param('uint32_t', 'earfcn')])
+                   [param('uint16_t', 'earfcn')])
     ## lte-ue-net-device.h (module 'lte'): uint32_t ns3::LteUeNetDevice::GetCsgId() const [member function]
     cls.add_method('GetCsgId', 
                    'uint32_t', 
@@ -23989,14 +26085,6 @@
     cls.add_method('GetTargetEnb', 
                    'ns3::Ptr< ns3::LteEnbNetDevice >', 
                    [])
-    ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::SetCcMap(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierUe>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierUe> > > > ccm) [member function]
-    cls.add_method('SetCcMap', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierUe > >', 'ccm')])
-    ## lte-ue-net-device.h (module 'lte'): std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierUe>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierUe> > > > ns3::LteUeNetDevice::GetCcMap() [member function]
-    cls.add_method('GetCcMap', 
-                   'std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierUe > >', 
-                   [])
     ## lte-ue-net-device.h (module 'lte'): void ns3::LteUeNetDevice::DoInitialize() [member function]
     cls.add_method('DoInitialize', 
                    'void', 
@@ -24035,6 +26123,90 @@
                    [param('ns3::LteRrcSap::MeasurementReport', 'msg')])
     return
 
+def register_Ns3QueueDiscItem_methods(root_module, cls):
+    ## queue-item.h (module 'network'): ns3::QueueDiscItem::QueueDiscItem(ns3::Ptr<ns3::Packet> p, ns3::Address const & addr, uint16_t protocol) [constructor]
+    cls.add_constructor([param('ns3::Ptr< ns3::Packet >', 'p'), param('ns3::Address const &', 'addr'), param('uint16_t', 'protocol')])
+    ## queue-item.h (module 'network'): ns3::Address ns3::QueueDiscItem::GetAddress() const [member function]
+    cls.add_method('GetAddress', 
+                   'ns3::Address', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): uint16_t ns3::QueueDiscItem::GetProtocol() const [member function]
+    cls.add_method('GetProtocol', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): uint8_t ns3::QueueDiscItem::GetTxQueueIndex() const [member function]
+    cls.add_method('GetTxQueueIndex', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::SetTxQueueIndex(uint8_t txq) [member function]
+    cls.add_method('SetTxQueueIndex', 
+                   'void', 
+                   [param('uint8_t', 'txq')])
+    ## queue-item.h (module 'network'): ns3::Time ns3::QueueDiscItem::GetTimeStamp() const [member function]
+    cls.add_method('GetTimeStamp', 
+                   'ns3::Time', 
+                   [], 
+                   is_const=True)
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::SetTimeStamp(ns3::Time t) [member function]
+    cls.add_method('SetTimeStamp', 
+                   'void', 
+                   [param('ns3::Time', 't')])
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::AddHeader() [member function]
+    cls.add_method('AddHeader', 
+                   'void', 
+                   [], 
+                   is_pure_virtual=True, is_virtual=True)
+    ## queue-item.h (module 'network'): void ns3::QueueDiscItem::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## queue-item.h (module 'network'): bool ns3::QueueDiscItem::Mark() [member function]
+    cls.add_method('Mark', 
+                   'bool', 
+                   [], 
+                   is_pure_virtual=True, is_virtual=True)
+    return
+
+def register_Ns3RrcConnectToMmWaveHeader_methods(root_module, cls):
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectToMmWaveHeader::RrcConnectToMmWaveHeader(ns3::RrcConnectToMmWaveHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RrcConnectToMmWaveHeader const &', 'arg0')])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectToMmWaveHeader::RrcConnectToMmWaveHeader() [constructor]
+    cls.add_constructor([])
+    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectToMmWaveHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'bIterator')], 
+                   is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): uint16_t ns3::RrcConnectToMmWaveHeader::GetMessage() const [member function]
+    cls.add_method('GetMessage', 
+                   'uint16_t', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcConnectToMmWaveHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectToMmWaveHeader::PreSerialize() const [member function]
+    cls.add_method('PreSerialize', 
+                   'void', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectToMmWaveHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectToMmWaveHeader::SetMessage(uint16_t mmWaveId) [member function]
+    cls.add_method('SetMessage', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveId')])
+    return
+
 def register_Ns3RrcConnectionReconfigurationCompleteHeader_methods(root_module, cls):
     ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionReconfigurationCompleteHeader::RrcConnectionReconfigurationCompleteHeader(ns3::RrcConnectionReconfigurationCompleteHeader const & arg0) [constructor]
     cls.add_constructor([param('ns3::RrcConnectionReconfigurationCompleteHeader const &', 'arg0')])
@@ -24099,10 +26271,6 @@
     cls.add_method('GetHaveMobilityControlInfo', 
                    'bool', 
                    [])
-    ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionReconfigurationHeader::GetHaveNonCriticalExtensionConfig() [member function]
-    cls.add_method('GetHaveNonCriticalExtensionConfig', 
-                   'bool', 
-                   [])
     ## lte-rrc-header.h (module 'lte'): bool ns3::RrcConnectionReconfigurationHeader::GetHaveRadioResourceConfigDedicated() [member function]
     cls.add_method('GetHaveRadioResourceConfigDedicated', 
                    'bool', 
@@ -24120,10 +26288,6 @@
     cls.add_method('GetMobilityControlInfo', 
                    'ns3::LteRrcSap::MobilityControlInfo', 
                    [])
-    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::NonCriticalExtensionConfiguration ns3::RrcConnectionReconfigurationHeader::GetNonCriticalExtensionConfig() [member function]
-    cls.add_method('GetNonCriticalExtensionConfig', 
-                   'ns3::LteRrcSap::NonCriticalExtensionConfiguration', 
-                   [])
     ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::PhysicalConfigDedicated ns3::RrcConnectionReconfigurationHeader::GetPhysicalConfigDedicated() const [member function]
     cls.add_method('GetPhysicalConfigDedicated', 
                    'ns3::LteRrcSap::PhysicalConfigDedicated', 
@@ -24390,6 +26554,11 @@
                    'uint32_t', 
                    [param('ns3::Buffer::Iterator', 'bIterator')], 
                    is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): std::bitset<1> ns3::RrcConnectionRequestHeader::GetIsMc() const [member function]
+    cls.add_method('GetIsMc', 
+                   'std::bitset< 1 >', 
+                   [], 
+                   is_const=True)
     ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionRequest ns3::RrcConnectionRequestHeader::GetMessage() const [member function]
     cls.add_method('GetMessage', 
                    'ns3::LteRrcSap::RrcConnectionRequest', 
@@ -24528,6 +26697,83 @@
                    [param('ns3::LteRrcSap::RrcConnectionSetup', 'msg')])
     return
 
+def register_Ns3RrcConnectionSwitchHeader_methods(root_module, cls):
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSwitchHeader::RrcConnectionSwitchHeader(ns3::RrcConnectionSwitchHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RrcConnectionSwitchHeader const &', 'arg0')])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcConnectionSwitchHeader::RrcConnectionSwitchHeader() [constructor]
+    cls.add_constructor([])
+    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcConnectionSwitchHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'bIterator')], 
+                   is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): ns3::LteRrcSap::RrcConnectionSwitch ns3::RrcConnectionSwitchHeader::GetMessage() const [member function]
+    cls.add_method('GetMessage', 
+                   'ns3::LteRrcSap::RrcConnectionSwitch', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): uint8_t ns3::RrcConnectionSwitchHeader::GetRrcTransactionIdentifier() const [member function]
+    cls.add_method('GetRrcTransactionIdentifier', 
+                   'uint8_t', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcConnectionSwitchHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSwitchHeader::PreSerialize() const [member function]
+    cls.add_method('PreSerialize', 
+                   'void', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSwitchHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcConnectionSwitchHeader::SetMessage(ns3::LteRrcSap::RrcConnectionSwitch msg) [member function]
+    cls.add_method('SetMessage', 
+                   'void', 
+                   [param('ns3::LteRrcSap::RrcConnectionSwitch', 'msg')])
+    return
+
+def register_Ns3RrcNotifySecondaryConnectedHeader_methods(root_module, cls):
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcNotifySecondaryConnectedHeader::RrcNotifySecondaryConnectedHeader(ns3::RrcNotifySecondaryConnectedHeader const & arg0) [constructor]
+    cls.add_constructor([param('ns3::RrcNotifySecondaryConnectedHeader const &', 'arg0')])
+    ## lte-rrc-header.h (module 'lte'): ns3::RrcNotifySecondaryConnectedHeader::RrcNotifySecondaryConnectedHeader() [constructor]
+    cls.add_constructor([])
+    ## lte-rrc-header.h (module 'lte'): uint32_t ns3::RrcNotifySecondaryConnectedHeader::Deserialize(ns3::Buffer::Iterator bIterator) [member function]
+    cls.add_method('Deserialize', 
+                   'uint32_t', 
+                   [param('ns3::Buffer::Iterator', 'bIterator')], 
+                   is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): std::pair<unsigned short, unsigned short> ns3::RrcNotifySecondaryConnectedHeader::GetMessage() const [member function]
+    cls.add_method('GetMessage', 
+                   'std::pair< unsigned short, unsigned short >', 
+                   [], 
+                   is_const=True)
+    ## lte-rrc-header.h (module 'lte'): static ns3::TypeId ns3::RrcNotifySecondaryConnectedHeader::GetTypeId() [member function]
+    cls.add_method('GetTypeId', 
+                   'ns3::TypeId', 
+                   [], 
+                   is_static=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcNotifySecondaryConnectedHeader::PreSerialize() const [member function]
+    cls.add_method('PreSerialize', 
+                   'void', 
+                   [], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcNotifySecondaryConnectedHeader::Print(std::ostream & os) const [member function]
+    cls.add_method('Print', 
+                   'void', 
+                   [param('std::ostream &', 'os')], 
+                   is_const=True, is_virtual=True)
+    ## lte-rrc-header.h (module 'lte'): void ns3::RrcNotifySecondaryConnectedHeader::SetMessage(uint16_t mmWaveId, uint16_t mmWaveRnti) [member function]
+    cls.add_method('SetMessage', 
+                   'void', 
+                   [param('uint16_t', 'mmWaveId'), param('uint16_t', 'mmWaveRnti')])
+    return
+
 def register_Ns3LteEnbNetDevice_methods(root_module, cls):
     ## lte-enb-net-device.h (module 'lte'): static ns3::TypeId ns3::LteEnbNetDevice::GetTypeId() [member function]
     cls.add_method('GetTypeId', 
@@ -24551,39 +26797,21 @@
                    'ns3::Ptr< ns3::LteEnbMac >', 
                    [], 
                    is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbMac> ns3::LteEnbNetDevice::GetMac(uint8_t index) [member function]
-    cls.add_method('GetMac', 
-                   'ns3::Ptr< ns3::LteEnbMac >', 
-                   [param('uint8_t', 'index')])
     ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbPhy> ns3::LteEnbNetDevice::GetPhy() const [member function]
     cls.add_method('GetPhy', 
                    'ns3::Ptr< ns3::LteEnbPhy >', 
                    [], 
                    is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbPhy> ns3::LteEnbNetDevice::GetPhy(uint8_t index) [member function]
-    cls.add_method('GetPhy', 
-                   'ns3::Ptr< ns3::LteEnbPhy >', 
-                   [param('uint8_t', 'index')])
     ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbRrc> ns3::LteEnbNetDevice::GetRrc() const [member function]
     cls.add_method('GetRrc', 
                    'ns3::Ptr< ns3::LteEnbRrc >', 
                    [], 
                    is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): ns3::Ptr<ns3::LteEnbComponentCarrierManager> ns3::LteEnbNetDevice::GetComponentCarrierManager() const [member function]
-    cls.add_method('GetComponentCarrierManager', 
-                   'ns3::Ptr< ns3::LteEnbComponentCarrierManager >', 
-                   [], 
-                   is_const=True)
     ## lte-enb-net-device.h (module 'lte'): uint16_t ns3::LteEnbNetDevice::GetCellId() const [member function]
     cls.add_method('GetCellId', 
                    'uint16_t', 
                    [], 
                    is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): bool ns3::LteEnbNetDevice::HasCellId(uint16_t cellId) const [member function]
-    cls.add_method('HasCellId', 
-                   'bool', 
-                   [param('uint16_t', 'cellId')], 
-                   is_const=True)
     ## lte-enb-net-device.h (module 'lte'): uint8_t ns3::LteEnbNetDevice::GetUlBandwidth() const [member function]
     cls.add_method('GetUlBandwidth', 
                    'uint8_t', 
@@ -24602,24 +26830,24 @@
     cls.add_method('SetDlBandwidth', 
                    'void', 
                    [param('uint8_t', 'bw')])
-    ## lte-enb-net-device.h (module 'lte'): uint32_t ns3::LteEnbNetDevice::GetDlEarfcn() const [member function]
+    ## lte-enb-net-device.h (module 'lte'): uint16_t ns3::LteEnbNetDevice::GetDlEarfcn() const [member function]
     cls.add_method('GetDlEarfcn', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetDlEarfcn(uint32_t earfcn) [member function]
+    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetDlEarfcn(uint16_t earfcn) [member function]
     cls.add_method('SetDlEarfcn', 
                    'void', 
-                   [param('uint32_t', 'earfcn')])
-    ## lte-enb-net-device.h (module 'lte'): uint32_t ns3::LteEnbNetDevice::GetUlEarfcn() const [member function]
+                   [param('uint16_t', 'earfcn')])
+    ## lte-enb-net-device.h (module 'lte'): uint16_t ns3::LteEnbNetDevice::GetUlEarfcn() const [member function]
     cls.add_method('GetUlEarfcn', 
-                   'uint32_t', 
+                   'uint16_t', 
                    [], 
                    is_const=True)
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetUlEarfcn(uint32_t earfcn) [member function]
+    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetUlEarfcn(uint16_t earfcn) [member function]
     cls.add_method('SetUlEarfcn', 
                    'void', 
-                   [param('uint32_t', 'earfcn')])
+                   [param('uint16_t', 'earfcn')])
     ## lte-enb-net-device.h (module 'lte'): uint32_t ns3::LteEnbNetDevice::GetCsgId() const [member function]
     cls.add_method('GetCsgId', 
                    'uint32_t', 
@@ -24638,14 +26866,6 @@
     cls.add_method('SetCsgIndication', 
                    'void', 
                    [param('bool', 'csgIndication')])
-    ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::SetCcMap(std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ccm) [member function]
-    cls.add_method('SetCcMap', 
-                   'void', 
-                   [param('std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 'ccm')])
-    ## lte-enb-net-device.h (module 'lte'): std::map<unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb>, std::less<unsigned char>, std::allocator<std::pair<const unsigned char, ns3::Ptr<ns3::ComponentCarrierEnb> > > > ns3::LteEnbNetDevice::GetCcMap() [member function]
-    cls.add_method('GetCcMap', 
-                   'std::map< unsigned char, ns3::Ptr< ns3::ComponentCarrierEnb > >', 
-                   [])
     ## lte-enb-net-device.h (module 'lte'): void ns3::LteEnbNetDevice::DoInitialize() [member function]
     cls.add_method('DoInitialize', 
                    'void', 
diff -Naru a/examples/lena-cc-helper.cc b/examples/lena-cc-helper.cc
--- a/examples/lena-cc-helper.cc	2017-10-05 11:46:52.070493458 +0200
+++ b/examples/lena-cc-helper.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- */
-
-
-#include "ns3/core-module.h"
-#include "ns3/config-store.h"
-#include <ns3/buildings-helper.h>
-#include "ns3/component-carrier.h"
-#include "ns3/cc-helper.h"
-
-using namespace ns3;
-
-
-void Print ( ComponentCarrier cc);
-
-int main (int argc, char *argv[])
-{	
-  CommandLine cmd;
-  cmd.Parse (argc, argv);
-	
-  Config::SetDefault ("ns3::ComponentCarrier::UlBandwidth", UintegerValue (50));
-  Config::SetDefault ("ns3::ComponentCarrier::PrimaryCarrier", BooleanValue (true));
-
-  // Parse again so you can override default values from the command line
-  cmd.Parse (argc, argv);
-
-  Ptr<CcHelper> cch = CreateObject<CcHelper> ();
-  cch->SetNumberOfComponentCarriers(2);
-
-  std::map< uint8_t, ComponentCarrier > ccm = cch->EquallySpacedCcs ();
- 
-  std::map< uint8_t, ComponentCarrier >::iterator it;
-  
-  std::cout << " CcMap size " << ccm.size () << std::endl;
-  for (it = ccm.begin (); it !=ccm.end (); it++)
-    {
-      Print (it->second);
-    }
- 
-
-  Simulator::Stop (Seconds (1.05));
-
-  Simulator::Run ();
-
-  // GtkConfigStore config;
-  // config.ConfigureAttributes ();
-
-  Simulator::Destroy ();
-  return 0;
-}
-
-void Print ( ComponentCarrier cc)
-{
-  std::cout << " UlBandwidth " << uint16_t (cc.GetUlBandwidth ())
-            << " DlBandwidth " << uint16_t (cc.GetDlBandwidth ())
-            << " Dl Earfcn " << cc.GetDlEarfcn ()
-            << " Ul Earfcn " << cc.GetUlEarfcn ()
-            << " - Is this the Primary Channel? " << cc.IsPrimary () 
-            << std::endl;
-}
diff -Naru a/helper/cc-helper.cc b/helper/cc-helper.cc
--- a/helper/cc-helper.cc	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/cc-helper.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,252 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- */
-
-
-#include "cc-helper.h"
-#include <ns3/component-carrier.h>
-#include <ns3/string.h>
-#include <ns3/log.h>
-#include <ns3/abort.h>
-#include <ns3/pointer.h>
-#include <iostream>
-#include <ns3/uinteger.h>
-#include <ns3/lte-spectrum-value-helper.h>
-
-#define MIN_CC 1
-#define MAX_CC 2
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("CcHelper");
-
-NS_OBJECT_ENSURE_REGISTERED (CcHelper);
-
-CcHelper::CcHelper (void)
-{
-  NS_LOG_FUNCTION (this);
-  m_ccFactory.SetTypeId (ComponentCarrier::GetTypeId ());
-}
-
-void
-CcHelper::DoInitialize (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-TypeId CcHelper::GetTypeId (void)
-{
-  static TypeId
-    tid =
-    TypeId ("ns3::CcHelper")
-    .SetParent<Object> ()
-    .AddConstructor<CcHelper> ()
-    .AddAttribute ("NumberOfComponentCarriers",
-                   "Set the number of Component Carriers to setup per eNodeB"
-                   "Currently the maximum Number of Component Carriers allowed is 2",
-                   UintegerValue (1),
-                   MakeUintegerAccessor (&CcHelper::m_numberOfComponentCarriers),
-                   MakeUintegerChecker<uint16_t> (MIN_CC, MAX_CC))
-    .AddAttribute ("UlEarfcn",
-                   "Set Ul Channel [EARFCN] for the first carrier component",
-                   UintegerValue (0),
-                   MakeUintegerAccessor (&CcHelper::m_ulEarfcn),
-                   MakeUintegerChecker<uint32_t> ())
-    .AddAttribute ("DlEarfcn",
-                   "Set Dl Channel [EARFCN] for the first carrier component",
-                   UintegerValue (0),
-                   MakeUintegerAccessor (&CcHelper::m_dlEarfcn),
-                   MakeUintegerChecker<uint32_t> (0))
-    .AddAttribute ("DlBandwidth",
-                   "Set Dl Bandwidth for the first carrier component",
-                   UintegerValue (25),
-                   MakeUintegerAccessor (&CcHelper::m_dlBandwidth),
-                   MakeUintegerChecker<uint16_t> (0,100))
-    .AddAttribute ("UlBandwidth",
-                   "Set Dl Bandwidth for the first carrier component",
-                   UintegerValue (25),
-                   MakeUintegerAccessor (&CcHelper::m_ulBandwidth),
-                   MakeUintegerChecker<uint16_t> (0,100))
-  ;
-
-  return tid;
-}
-
-CcHelper::~CcHelper (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-void
-CcHelper::DoDispose ()
-{
-  NS_LOG_FUNCTION (this);
-  Object::DoDispose ();
-}
-
-void 
-CcHelper::SetCcAttribute (std::string n, const AttributeValue &v)
-{
-  NS_LOG_FUNCTION (this << n);
-  m_ccFactory.Set (n, v);
-}
-
-void
-CcHelper:: SetNumberOfComponentCarriers (uint16_t nCc)
-{
-  m_numberOfComponentCarriers = nCc;
-}
-
-void
-CcHelper::SetUlEarfcn (uint32_t ulEarfcn)
-{
-  m_ulEarfcn = ulEarfcn;
-}
-
-void
-CcHelper::SetDlEarfcn (uint32_t dlEarfcn)
-{
-  m_dlEarfcn = dlEarfcn;
-}
-
-void
-CcHelper::SetDlBandwidth (uint16_t dlBandwidth)
-{
-  m_dlBandwidth = dlBandwidth;
-}
-
-void
-CcHelper::SetUlBandwidth (uint16_t ulBandwidth)
-{
-  m_ulBandwidth = ulBandwidth;
-}
-
-uint16_t
-CcHelper::GetNumberOfComponentCarriers ()
-{
-  return m_numberOfComponentCarriers;
-}
-
-uint32_t CcHelper::GetUlEarfcn ()
-{
-  return m_ulEarfcn;
-}
-
-uint32_t CcHelper::GetDlEarfcn ()
-{
-  return m_dlEarfcn;
-}
-
-uint16_t CcHelper::GetDlBandwidth ()
-{
-  return m_dlBandwidth;
-}
-
-uint16_t CcHelper::GetUlBandwidth ()
-{
-  return m_ulBandwidth;
-}
-
-ComponentCarrier
-CcHelper::DoCreateSingleCc (uint16_t ulBandwidth, uint16_t dlBandwidth, uint32_t ulEarfcn, uint32_t dlEarfcn, bool isPrimary)
-{
-  return CreateSingleCc (ulBandwidth, dlBandwidth, ulEarfcn, dlEarfcn, isPrimary);
-}
-
-std::map< uint8_t, ComponentCarrier >
-CcHelper::EquallySpacedCcs ()
-{
-  std::map< uint8_t, ComponentCarrier > ccmap;
-
-  uint32_t ulEarfcn = m_ulEarfcn;
-  uint32_t dlEarfcn = m_dlEarfcn;
-  uint32_t maxBandwidthRb = std::max<uint32_t> (m_ulBandwidth, m_dlBandwidth);
-
-  // Convert bandwidth from RBs to kHz
-  uint32_t maxBandwidthKhz = LteSpectrumValueHelper::GetChannelBandwidth(maxBandwidthRb) / 1e3;
-
-  for (uint8_t i = 0; i < m_numberOfComponentCarriers; i++)
-    {
-      // Make sure we stay within the same band.
-      if (LteSpectrumValueHelper::GetUplinkCarrierBand (ulEarfcn) !=
-          LteSpectrumValueHelper::GetUplinkCarrierBand (m_ulEarfcn)
-       || LteSpectrumValueHelper::GetDownlinkCarrierBand (dlEarfcn) !=
-          LteSpectrumValueHelper::GetDownlinkCarrierBand (m_dlEarfcn))
-        {
-          NS_FATAL_ERROR ("Band is not wide enough to allocate " << +m_numberOfComponentCarriers << " CCs");
-        }
-
-      bool pc =false;
-
-      if (i == 0)
-        {
-          pc = true;
-        }
-      ComponentCarrier cc = CreateSingleCc (m_ulBandwidth, m_dlBandwidth, ulEarfcn, dlEarfcn, pc);
-      ccmap.insert (std::pair<uint8_t, ComponentCarrier >(i, cc));
-
-      NS_LOG_INFO("ulBandwidth: " << m_ulBandwidth <<
-                  ", dlBandwidth: " << m_dlBandwidth <<
-                  ", ulEarfcn: " << ulEarfcn <<
-                  ", dlEarfcn: " << dlEarfcn);
-
-      // The spacing between the centre frequencies of two contiguous CCs should be multiple of 300 kHz.
-      // Round spacing up to 300 kHz.
-      uint32_t frequencyShift = 300 * (1 + (maxBandwidthKhz - 1) / 300);
-
-      // Unit of EARFCN corresponds to 100kHz.
-      uint32_t earfcnShift = frequencyShift / 100;
-      ulEarfcn += earfcnShift;
-      dlEarfcn += earfcnShift;
-    }
-
-  return ccmap;
-}
-ComponentCarrier
-CcHelper::CreateSingleCc (uint16_t ulBandwidth, uint16_t dlBandwidth, uint32_t ulEarfcn, uint32_t dlEarfcn, bool isPrimary)
-{
-  ComponentCarrier cc;
-  if ( m_ulEarfcn != 0)
-    {
-      cc.SetUlEarfcn (ulEarfcn);
-    }
-  else 
-    {
-      uint16_t ul = cc.GetUlEarfcn () + ulEarfcn;
-      cc.SetUlEarfcn (ul);
-    }
-  if ( m_dlEarfcn != 0)
-    {
-      cc.SetDlEarfcn (dlEarfcn);
-    }
-  else 
-    {
-      uint16_t dl = cc.GetDlEarfcn () + dlEarfcn;
-      cc.SetDlEarfcn (dl);
-    }
-  cc.SetDlBandwidth (dlBandwidth);
-  cc.SetUlBandwidth (ulBandwidth);
-
-  cc.SetAsPrimary (isPrimary);
-
-  return cc;
-
-
-}
-
-} // namespace ns3
diff -Naru a/helper/cc-helper.h b/helper/cc-helper.h
--- a/helper/cc-helper.h	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/cc-helper.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,201 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it> 
- */
-
-#ifndef CC_HELPER_H
-#define CC_HELPER_H
-
-#include <ns3/config.h>
-#include <ns3/simulator.h>
-#include <ns3/names.h>
-#include <ns3/net-device.h>
-#include <ns3/net-device-container.h>
-#include <ns3/node.h>
-#include <ns3/node-container.h>
-#include <ns3/component-carrier.h>
-#include <map>
-
-namespace ns3 {
-
-
-/**
- * \ingroup lte
- *
- * Creation and configuration of Component Carrier entities. One CcHelper instance is
- * typically enough for an LTE simulation. To create it:
- *
- *     Ptr<CcHelper> ccHelper = CreateObject<CcHelper> ();
- *
- * The general responsibility of the helper is to create various Component Carrier objects
- * and arrange them together to set the eNodeB. The overall
- * arrangement would look like the following:
- * - Ul Bandwidths
- * - Dl Bandwidths
- * - Ul Earfcn
- * - Dl Earfcn
- *
- *
- * This helper it is also used within the LteHelper in order to maintain backwards compatibility
- * with previous user simulation script. 
- */
-class CcHelper : public Object
-{
-public:
-  CcHelper (void);
-  virtual ~CcHelper (void);
-
-  /**
-   *  Register this type.
-   *  \return The object TypeId.
-   */
-  static TypeId GetTypeId (void);
-  virtual void DoDispose (void);
-
-  /**
-  * Create single CC.
-  *
-  * \param ulBandwidth the UL bandwidth
-  * \param dlBandwidth the DL bandwidth
-  * \param ulEarfcn the UL EARFCN
-  * \param dlEarfcn the DL EARFCN
-  * \param isPrimary ture if primary
-  * \returns the component carrier
-  */
-  ComponentCarrier DoCreateSingleCc (uint16_t ulBandwidth, uint16_t dlBandwidth, uint32_t ulEarfcn, uint32_t dlEarfcn, bool isPrimary);
-
-  /**
-  * Set an attribute for the Component Carrier to be created.
-  *
-  * \param n the name of the attribute.
-  * \param v the value of the attribute
-  */
-  void SetCcAttribute (std::string n, const AttributeValue &v);
-
-  /**
-  * EquallySpacedCcs() create a valid std::map< uint8_t, Ptr<ComponentCarrier> >
-  * The Primary Component Carrier it is at the position 0 in the map
-  * The number of Component Carrier created depend on m_noOfCcs
-  * Currently it is limited to maximum 2 ComponentCarrier
-  * Since, only a LteEnbPhy object is available just symmetric Carrier Aggregation scheme
-  * are allowed, i.e. 2 Uplink Component Carrier and 2 Downlink Component Carrier
-  * Using this method, each CC will have the same characteristics (bandwidth)
-  * while they are spaced by exactly the bandwidth. Hence, using this method,
-  * you will create a intra-channel Carrier Aggregation scheme.
-  *
-  * \returns std::map< uint8_t, Ptr<ComponentCarrier> >
-  */
-
-  std::map< uint8_t, ComponentCarrier > EquallySpacedCcs ();
-
-  /**
-  * Set number of CCs.
-  *
-  * \param nCc the number of CCs
-  */
-  void SetNumberOfComponentCarriers (uint16_t nCc);
-  /**
-  * Set UL EARFCN.
-  *
-  * \param ulEarfcn the UL EARFCN
-  */
-  void SetUlEarfcn (uint32_t ulEarfcn);
-  /**
-  * Set DL EARFCN.
-  *
-  * \param dlEarfcn the DL EARFCN
-  */
-  void SetDlEarfcn (uint32_t dlEarfcn);
-  /**
-  * Set DL bandwidth.
-  *
-  * \param dlBandwidth the DL bandwidth
-  */
-  void SetDlBandwidth (uint16_t dlBandwidth);
-  /**
-  * Set UL bandwidth.
-  *
-  * \param ulBandwidth the UL bandwidth
-  */
-  void SetUlBandwidth (uint16_t ulBandwidth);
-  /**
-  * Get number of component carriers.
-  *
-  * \returns the number of component carriers
-  */
-  uint16_t GetNumberOfComponentCarriers ();
-  /**
-  * Get UL EARFCN.
-  *
-  * \returns the UL EARFCN
-  */
-  uint32_t GetUlEarfcn ();
-  /**
-  * Get DL EARFCN.
-  *
-  * \returns the DL EARFCN
-  */
-  uint32_t GetDlEarfcn ();
-  /**
-  * Get DL bandwidth.
-  *
-  * \returns the DL bandwidth
-  */
-  uint16_t GetDlBandwidth ();
-  /**
-  * Get UL bandwidth.
-  *
-  * \returns the UL bandwidth
-  */
-  uint16_t GetUlBandwidth ();
-
-protected:
-  // inherited from Object
-  virtual void DoInitialize (void);
-
-private:
-  /**
-   * Create a single component carrier.
-   *
-   * \param ulBandwidth uplink bandwidth for the current CC
-   * \param dlBandwidth downlink bandwidth for the current CC
-   * \param ulEarfcn uplink EARFCN - not control on the validity at this point
-   * \param dlEarfcn downlink EARFCN - not control on the validity at this point	
-   * \param isPrimary identify if this is the Primary Component Carrier (PCC) - only one PCC is allowed 
-   * \return the component carrier
-   */
-  ComponentCarrier CreateSingleCc (uint16_t ulBandwidth, uint16_t dlBandwidth, uint32_t ulEarfcn, uint32_t dlEarfcn, bool isPrimary);
-
-  /// Factory for each Carrier Component.
-  ObjectFactory m_ccFactory;
-
-  uint32_t m_ulEarfcn; ///< Uplink EARFCN
-  uint32_t m_dlEarfcn; ///< Downlink EARFCN
-  uint16_t m_dlBandwidth; ///< Downlink Bandwidth
-  uint16_t m_ulBandwidth; ///< Uplink Bandwidth
-  uint16_t m_numberOfComponentCarriers; ///< Number of component carriers
-
-
-}; // end of `class LteHelper`
-
-
-} // namespace ns3
-
-
-
-#endif // LTE_HELPER_H
diff -Naru a/helper/emu-epc-helper.cc b/helper/emu-epc-helper.cc
--- a/helper/emu-epc-helper.cc	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/emu-epc-helper.cc	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab 
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,8 +19,11 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
-
+#include <ns3/point-to-point-helper.h>
 #include <ns3/emu-epc-helper.h>
 #include <ns3/log.h>
 #include <ns3/inet-socket-address.h>
@@ -35,9 +39,10 @@
 
 #include <ns3/lte-enb-rrc.h>
 #include <ns3/epc-x2.h>
+#include <ns3/epc-s1ap.h>
 #include <ns3/lte-enb-net-device.h>
 #include <ns3/lte-ue-net-device.h>
-#include <ns3/epc-mme.h>
+#include <ns3/epc-mme-application.h>
 #include <ns3/epc-ue-nas.h>
 #include <ns3/string.h>
 #include <ns3/abort.h>
@@ -45,6 +50,8 @@
 #include <iomanip>
 #include <iostream>
 
+// TODO S1AP is a P2P link, extend to support emulation on this link
+
 namespace ns3 {
 
 NS_LOG_COMPONENT_DEFINE ("EmuEpcHelper");
@@ -53,7 +60,8 @@
 
 
 EmuEpcHelper::EmuEpcHelper () 
-  : m_gtpuUdpPort (2152)  // fixed by the standard
+  : m_gtpuUdpPort (2152),  // fixed by the standard
+    m_s1apUdpPort (36412)
 {
   NS_LOG_FUNCTION (this);
 
@@ -91,6 +99,21 @@
                    StringValue ("00:00:00:eb:00"),
                    MakeStringAccessor (&EmuEpcHelper::m_enbMacAddressBase),
                    MakeStringChecker ())
+    .AddAttribute ("S1apLinkDataRate", 
+                   "The data rate to be used for the S1-AP link to be created",
+                   DataRateValue (DataRate ("10Mb/s")),
+                   MakeDataRateAccessor (&EmuEpcHelper::m_s1apLinkDataRate),
+                   MakeDataRateChecker ())
+    .AddAttribute ("S1apLinkDelay", 
+                   "The delay to be used for the S1-AP link to be created",
+                   TimeValue (Seconds (0.1)),
+                   MakeTimeAccessor (&EmuEpcHelper::m_s1apLinkDelay),
+                   MakeTimeChecker ())
+    .AddAttribute ("S1apLinkMtu", 
+                   "The MTU of the next S1-AP link to be created",
+                   UintegerValue (2000),
+                   MakeUintegerAccessor (&EmuEpcHelper::m_s1apLinkMtu),
+                   MakeUintegerChecker<uint16_t> ())
     ;
   return tid;
 }
@@ -103,7 +126,7 @@
 
   // we use a /8 net for all UEs
   m_ueAddressHelper.SetBase ("7.0.0.0", "255.0.0.0");
-
+  m_s1apIpv4AddressHelper.SetBase ("11.0.0.0", "255.255.255.252");
   
  
   // create SgwPgwNode
@@ -111,12 +134,21 @@
   InternetStackHelper internet;
   internet.SetIpv4StackInstall (true);
   internet.Install (m_sgwPgw);
+
+  // create MmeNode
+  m_mmeNode = CreateObject<Node> ();
+  internet.Install (m_mmeNode);
   
-  // create S1-U socket
+  // create S1-U socket for SgwPgwNode
   Ptr<Socket> sgwPgwS1uSocket = Socket::CreateSocket (m_sgwPgw, TypeId::LookupByName ("ns3::UdpSocketFactory"));
   int retval = sgwPgwS1uSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_gtpuUdpPort));
   NS_ASSERT (retval == 0);
 
+  // create S1-AP socket for MmeNode
+  Ptr<Socket> mmeS1apSocket = Socket::CreateSocket (m_mmeNode, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = mmeS1apSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_s1apUdpPort)); // it listens on any IP, port m_s1apUdpPort
+  NS_ASSERT (retval == 0);
+
   // create TUN device implementing tunneling of user data over GTP-U/UDP/IP 
   m_tunDevice = CreateObject<VirtualNetDevice> ();
   // allow jumbo packets
@@ -141,10 +173,18 @@
   // connect SgwPgwApplication and virtual net device for tunneling
   m_tunDevice->SetSendCallback (MakeCallback (&EpcSgwPgwApplication::RecvFromTunDevice, m_sgwPgwApp));
 
-  // Create MME and connect with SGW via S11 interface
-  m_mme = CreateObject<EpcMme> ();
-  m_mme->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
-  m_sgwPgwApp->SetS11SapMme (m_mme->GetS11SapMme ());
+  // create S1apMme object and aggregate it with the m_mmeNode
+  Ptr<EpcS1apMme> s1apMme = CreateObject<EpcS1apMme> (mmeS1apSocket, 1); // for now, only one mme!
+  m_mmeNode->AggregateObject(s1apMme);
+
+  // create EpcMmeApplication and connect with SGW via S11 interface
+  m_mmeApp = CreateObject<EpcMmeApplication> ();
+  m_mmeNode->AddApplication (m_mmeApp);
+  m_mmeApp->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
+  m_sgwPgwApp->SetS11SapMme (m_mmeApp->GetS11SapMme ());
+  // connect m_mmeApp to the s1apMme
+  m_mmeApp->SetS1apSapMmeProvider(s1apMme->GetEpcS1apSapMmeProvider());
+  s1apMme->SetEpcS1apSapMmeUser(m_mmeApp->GetS1apSapMme());
 
   // Create EmuFdNetDevice for SGW
   EmuFdNetDeviceHelper emu;
@@ -232,6 +272,29 @@
   retval = enbLteSocket->Connect (enbLteSocketConnectAddress);
   NS_ASSERT (retval == 0);  
   
+  // create a point to point link between the new eNB and the MME with
+  // the corresponding new NetDevices on each side
+  NodeContainer enbMmeNodes;
+  enbMmeNodes.Add (m_mmeNode);
+  enbMmeNodes.Add (enb);
+  PointToPointHelper p2ph_mme;
+  p2ph_mme.SetDeviceAttribute ("DataRate", DataRateValue (m_s1apLinkDataRate));
+  p2ph_mme.SetDeviceAttribute ("Mtu", UintegerValue (m_s1apLinkMtu));
+  p2ph_mme.SetChannelAttribute ("Delay", TimeValue (m_s1apLinkDelay));  
+  NetDeviceContainer enbMmeDevices = p2ph_mme.Install (enb, m_mmeNode);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing p2p dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());  
+
+  m_s1apIpv4AddressHelper.NewNetwork ();
+  Ipv4InterfaceContainer enbMmeIpIfaces = m_s1apIpv4AddressHelper.Assign (enbMmeDevices);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
+  
+  Ipv4Address mme_enbAddress = enbMmeIpIfaces.GetAddress (0);
+  Ipv4Address mmeAddress = enbMmeIpIfaces.GetAddress (1);
+
+  // create S1-AP socket for the ENB
+  Ptr<Socket> enbS1apSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = enbS1apSocket->Bind (InetSocketAddress (mme_enbAddress, m_s1apUdpPort));
+  NS_ASSERT (retval == 0);
 
   NS_LOG_INFO ("create EpcEnbApplication");
   Ptr<EpcEnbApplication> enbApp = CreateObject<EpcEnbApplication> (enbLteSocket, enbS1uSocket, enbAddress, sgwAddress, cellId);
@@ -246,9 +309,18 @@
   enb->AggregateObject (x2);
 
   NS_LOG_INFO ("connect S1-AP interface");
-  m_mme->AddEnb (cellId, enbAddress, enbApp->GetS1apSapEnb ());
+
+  uint16_t mmeId = 1;
+  Ptr<EpcS1apEnb> s1apEnb = CreateObject<EpcS1apEnb> (enbS1apSocket, mme_enbAddress, mmeAddress, cellId, mmeId); // only one mme!
+  enb->AggregateObject(s1apEnb);
+  enbApp->SetS1apSapMme (s1apEnb->GetEpcS1apSapEnbProvider ());
+  s1apEnb->SetEpcS1apSapEnbUser (enbApp->GetS1apSapEnb());
+  m_mmeApp->AddEnb (cellId, mme_enbAddress); // TODO consider if this can be removed
+  // add the interface to the S1AP endpoint on the MME
+  Ptr<EpcS1apMme> s1apMme = m_mmeNode->GetObject<EpcS1apMme> ();
+  s1apMme->AddS1apInterface (cellId, mme_enbAddress);
+  
   m_sgwPgwApp->AddEnb (cellId, enbAddress, sgwAddress);
-  enbApp->SetS1apSapMme (m_mme->GetS1apSapMme ());
 }
 
 
@@ -307,7 +379,7 @@
 {
   NS_LOG_FUNCTION (this << imsi << ueDevice );
   
-  m_mme->AddUe (imsi);
+  m_mmeApp->AddUe (imsi);
   m_sgwPgwApp->AddUe (imsi);
   
 }
@@ -329,7 +401,7 @@
   Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
   NS_LOG_LOGIC (" UE IP address: " << ueAddr);  m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
   
-  uint8_t bearerId = m_mme->AddBearer (imsi, tft, bearer);
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
   Ptr<LteUeNetDevice> ueLteDevice = ueDevice->GetObject<LteUeNetDevice> ();
   if (ueLteDevice)
     {
@@ -338,6 +410,28 @@
   return bearerId;
 }
 
+uint8_t
+EmuEpcHelper::ActivateEpsBearer (Ptr<NetDevice> ueDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer)
+{
+  NS_LOG_FUNCTION (this << ueDevice << imsi);
+
+  // we now retrieve the IPv4 address of the UE and notify it to the SGW;
+  // we couldn't do it before since address assignment is triggered by
+  // the user simulation program, rather than done by the EPC   
+  Ptr<Node> ueNode = ueDevice->GetNode (); 
+  Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
+  NS_ASSERT_MSG (ueIpv4 != 0, "UEs need to have IPv4 installed before EPS bearers can be activated");
+  int32_t interface =  ueIpv4->GetInterfaceForDevice (ueDevice);
+  NS_ASSERT (interface >= 0);
+  NS_ASSERT (ueIpv4->GetNAddresses (interface) == 1);
+  Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
+  NS_LOG_LOGIC (" UE IP address: " << ueAddr);  m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
+  
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
+  Simulator::ScheduleNow (&EpcUeNas::ActivateEpsBearer, ueNas, bearer, tft);
+  return bearerId;
+}
+
 
 Ptr<Node>
 EmuEpcHelper::GetPgwNode ()
diff -Naru a/helper/emu-epc-helper.h b/helper/emu-epc-helper.h
--- a/helper/emu-epc-helper.h	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/emu-epc-helper.h	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #ifndef EMU_EPC_HELPER_H
@@ -37,7 +41,10 @@
 class VirtualNetDevice;
 class EpcSgwPgwApplication;
 class EpcX2;
-class EpcMme;
+class EpcUeNas;
+class EpcMmeApplication;
+class EpcS1apEnb;
+class EpcS1apMme;
 
 /**
  * \ingroup lte
@@ -78,6 +85,7 @@
   virtual void AddUe (Ptr<NetDevice> ueLteDevice, uint64_t imsi);
   virtual void AddX2Interface (Ptr<Node> enbNode1, Ptr<Node> enbNode2);
   virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
+  virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
   virtual Ptr<Node> GetPgwNode ();
   virtual Ipv4InterfaceContainer AssignUeIpv4Address (NetDeviceContainer ueDevices);
   virtual Ipv4Address GetUeDefaultGatewayAddress ();
@@ -91,6 +99,12 @@
    */
   Ipv4AddressHelper m_ueAddressHelper; 
 
+  /** 
+   * helper to assign addresses to S1-AP NetDevices 
+   */
+  Ipv4AddressHelper m_s1apIpv4AddressHelper; 
+
+
   /**
    * SGW-PGW network element
    */  
@@ -109,7 +123,12 @@
   /**
    * MME network element
    */
-  Ptr<EpcMme> m_mme;
+  Ptr<Node> m_mmeNode;
+
+  /**
+   * MME application
+   */
+  Ptr<EpcMmeApplication> m_mmeApp;
 
   /** 
    * helper to assign addresses to S1-U NetDevices 
@@ -122,6 +141,27 @@
   uint16_t m_gtpuUdpPort;
 
   /**
+   * The data rate to be used for the next S1-AP link to be created
+   */
+  DataRate m_s1apLinkDataRate;
+
+  /**
+   * The delay to be used for the next S1-AP link to be created
+   */
+  Time     m_s1apLinkDelay;
+
+  /**
+   * The MTU of the next S1-AP link to be created. 
+   */
+  uint16_t m_s1apLinkMtu;
+
+  /**
+   * UDP port where the UDP Socket is bound, fixed by the standard as 
+   * 36412 (it should be sctp, but it is not supported in ns-3)
+   */
+  uint16_t m_s1apUdpPort;
+
+  /**
    * Map storing for each IMSI the corresponding eNB NetDevice
    * 
    */
diff -Naru a/helper/epc-helper.cc b/helper/epc-helper.cc
--- a/helper/epc-helper.cc	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/epc-helper.cc	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #include <ns3/epc-helper.h>
diff -Naru a/helper/epc-helper.h b/helper/epc-helper.h
--- a/helper/epc-helper.h	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/epc-helper.h	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #ifndef EPC_HELPER_H
@@ -37,6 +41,7 @@
 class EpcSgwPgwApplication;
 class EpcX2;
 class EpcMme;
+class EpcUeNas;
 
 /**
  * \ingroup lte
@@ -106,10 +111,23 @@
    * \param imsi the unique identifier of the UE
    * \param tft the Traffic Flow Template of the new bearer
    * \param bearer struct describing the characteristics of the EPS bearer to be activated
-   * \return bearer ID
    */
   virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer) = 0;
 
+  /** 
+   * Activate an EPS bearer, setting up the corresponding S1-U tunnel.
+   * 
+   * 
+   * 
+   * \param ueLteDevice the Ipv4-enabled device of the UE, normally
+   * connected via the LTE radio interface
+   * \param the NAS of that device
+   * \param imsi the unique identifier of the UE
+   * \param tft the Traffic Flow Template of the new bearer
+   * \param bearer struct describing the characteristics of the EPS bearer to be activated
+   */
+  virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer) = 0;
+
 
   /** 
    * 
diff -Naru a/helper/lte-global-pathloss-database.h b/helper/lte-global-pathloss-database.h
--- a/helper/lte-global-pathloss-database.h	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/lte-global-pathloss-database.h	2017-10-05 11:47:22.294601711 +0200
@@ -61,7 +61,7 @@
    * \param cellId the id of the eNB
    * \param imsi the id of the UE
    * 
-   * \return the pathloss value between the UE and the eNB
+   * \return the pathloss value bewteen the UE and the eNB
    */
   double GetPathloss (uint16_t cellId, uint64_t imsi);
 
diff -Naru a/helper/lte-helper.cc b/helper/lte-helper.cc
--- a/helper/lte-helper.cc	2017-10-05 11:46:52.074493472 +0200
+++ b/helper/lte-helper.cc	2017-10-05 11:47:22.294601711 +0200
@@ -17,8 +17,6 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es> (re-wrote from scratch this helper)
  *         Giuseppe Piro <g.piro@poliba.it> (parts of the PHY & channel  creation & configuration copied from the GSoC 2011 code)
- * Modified by: Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation) 
  */
 
 
@@ -47,8 +45,6 @@
 #include <ns3/ff-mac-scheduler.h>
 #include <ns3/lte-ffr-algorithm.h>
 #include <ns3/lte-handover-algorithm.h>
-#include <ns3/lte-enb-component-carrier-manager.h>
-#include <ns3/lte-ue-component-carrier-manager.h>
 #include <ns3/lte-anr.h>
 #include <ns3/lte-rlc.h>
 #include <ns3/lte-rlc-um.h>
@@ -65,9 +61,6 @@
 #include <ns3/buildings-propagation-loss-model.h>
 #include <ns3/lte-spectrum-value-helper.h>
 #include <ns3/epc-x2.h>
-#include <ns3/pointer.h>
-#include <ns3/object-map.h>
-#include <ns3/object-factory.h>
 
 namespace ns3 {
 
@@ -78,7 +71,7 @@
 LteHelper::LteHelper (void)
   : m_fadingStreamsAssigned (false),
     m_imsiCounter (0),
-    m_cellIdCounter {1}
+    m_cellIdCounter (0)
 {
   NS_LOG_FUNCTION (this);
   m_enbNetDeviceFactory.SetTypeId (LteEnbNetDevice::GetTypeId ());
@@ -92,7 +85,45 @@
 LteHelper::DoInitialize (void)
 {
   NS_LOG_FUNCTION (this);
-  ChannelModelInitialization ();
+  m_downlinkChannel = m_channelFactory.Create<SpectrumChannel> ();
+  m_uplinkChannel = m_channelFactory.Create<SpectrumChannel> ();
+
+  m_downlinkPathlossModel = m_dlPathlossModelFactory.Create ();
+  Ptr<SpectrumPropagationLossModel> dlSplm = m_downlinkPathlossModel->GetObject<SpectrumPropagationLossModel> ();
+  if (dlSplm != 0)
+    {
+      NS_LOG_LOGIC (this << " using a SpectrumPropagationLossModel in DL");
+      m_downlinkChannel->AddSpectrumPropagationLossModel (dlSplm);
+    }
+  else
+    {
+      NS_LOG_LOGIC (this << " using a PropagationLossModel in DL");
+      Ptr<PropagationLossModel> dlPlm = m_downlinkPathlossModel->GetObject<PropagationLossModel> ();
+      NS_ASSERT_MSG (dlPlm != 0, " " << m_downlinkPathlossModel << " is neither PropagationLossModel nor SpectrumPropagationLossModel");
+      m_downlinkChannel->AddPropagationLossModel (dlPlm);
+    }
+
+  m_uplinkPathlossModel = m_ulPathlossModelFactory.Create ();
+  Ptr<SpectrumPropagationLossModel> ulSplm = m_uplinkPathlossModel->GetObject<SpectrumPropagationLossModel> ();
+  if (ulSplm != 0)
+    {
+      NS_LOG_LOGIC (this << " using a SpectrumPropagationLossModel in UL");
+      m_uplinkChannel->AddSpectrumPropagationLossModel (ulSplm);
+    }
+  else
+    {
+      NS_LOG_LOGIC (this << " using a PropagationLossModel in UL");
+      Ptr<PropagationLossModel> ulPlm = m_uplinkPathlossModel->GetObject<PropagationLossModel> ();
+      NS_ASSERT_MSG (ulPlm != 0, " " << m_uplinkPathlossModel << " is neither PropagationLossModel nor SpectrumPropagationLossModel");
+      m_uplinkChannel->AddPropagationLossModel (ulPlm);
+    }
+  if (!m_fadingModelType.empty ())
+    {
+      m_fadingModule = m_fadingModelFactory.Create<SpectrumPropagationLossModel> ();
+      m_fadingModule->Initialize ();
+      m_downlinkChannel->AddSpectrumPropagationLossModel (m_fadingModule);
+      m_uplinkChannel->AddSpectrumPropagationLossModel (m_fadingModule);
+    }
   m_phyStats = CreateObject<PhyStatsCalculator> ();
   m_phyTxStats = CreateObject<PhyTxStatsCalculator> ();
   m_phyRxStats = CreateObject<PhyRxStatsCalculator> ();
@@ -141,9 +172,9 @@
                    "The type of pathloss model to be used. "
                    "The allowed values for this attributes are the type names "
                    "of any class inheriting from ns3::PropagationLossModel.",
-                   TypeIdValue (FriisPropagationLossModel::GetTypeId ()),
-                   MakeTypeIdAccessor (&LteHelper::SetPathlossModelType),
-                   MakeTypeIdChecker ())
+                   StringValue ("ns3::FriisPropagationLossModel"),
+                   MakeStringAccessor (&LteHelper::SetPathlossModelType),
+                   MakeStringChecker ())
     .AddAttribute ("FadingModel",
                    "The type of fading model to be used."
                    "The allowed values for this attributes are the type names "
@@ -169,34 +200,6 @@
                    BooleanValue (true),
                    MakeBooleanAccessor (&LteHelper::m_usePdschForCqiGeneration),
                    MakeBooleanChecker ())
-    .AddAttribute ("EnbComponentCarrierManager",
-                   "The type of Component Carrier Manager to be used for eNBs. "
-                   "The allowed values for this attributes are the type names "
-                   "of any class inheriting ns3::LteEnbComponentCarrierManager.",
-                   StringValue ("ns3::NoOpComponentCarrierManager"),
-                   MakeStringAccessor (&LteHelper::SetEnbComponentCarrierManagerType,
-                                       &LteHelper::GetEnbComponentCarrierManagerType),
-                   MakeStringChecker ())
-    .AddAttribute ("UeComponentCarrierManager",
-                   "The type of Component Carrier Manager to be used for UEs. "
-                   "The allowed values for this attributes are the type names "
-                   "of any class inheriting ns3::LteUeComponentCarrierManager.",
-                   StringValue ("ns3::SimpleUeComponentCarrierManager"),
-                   MakeStringAccessor (&LteHelper::SetUeComponentCarrierManagerType,
-                                       &LteHelper::GetUeComponentCarrierManagerType),
-                   MakeStringChecker ())
-    .AddAttribute ("UseCa",
-                   "If true, Carrier Aggregation feature is enabled and a valid Component Carrier Map is expected."
-                   "If false, single carrier simulation.",
-                   BooleanValue (false),
-                   MakeBooleanAccessor (&LteHelper::m_useCa),
-                   MakeBooleanChecker ())
-    .AddAttribute ("NumberOfComponentCarriers",
-                   "Set the number of Component carrier to use "
-                   "If it is more than one and m_useCa is false, it will raise an error ",
-                   UintegerValue (1),
-                   MakeUintegerAccessor (&LteHelper::m_noOfCcs),
-                   MakeUintegerChecker<uint16_t> (MIN_NO_CC, MAX_NO_CC))
   ;
   return tid;
 }
@@ -207,69 +210,9 @@
   NS_LOG_FUNCTION (this);
   m_downlinkChannel = 0;
   m_uplinkChannel = 0;
-  m_componentCarrierPhyParams.clear();
   Object::DoDispose ();
 }
 
-Ptr<SpectrumChannel>
-LteHelper::GetUplinkSpectrumChannel (void) const
-{
-  return m_uplinkChannel;
-}
-
-Ptr<SpectrumChannel>
-LteHelper::GetDownlinkSpectrumChannel (void) const
-{
-  return m_downlinkChannel;
-}
-
-void
-LteHelper::ChannelModelInitialization (void)
-{
-  // Channel Object (i.e. Ptr<SpectrumChannel>) are within a vector
-  // PathLossModel Objects are vectors --> in InstallSingleEnb we will set the frequency
-  NS_LOG_FUNCTION (this << m_noOfCcs);
-
-  m_downlinkChannel = m_channelFactory.Create<SpectrumChannel> ();
-  m_uplinkChannel = m_channelFactory.Create<SpectrumChannel> ();
-
-  m_downlinkPathlossModel = m_pathlossModelFactory.Create ();
-  Ptr<SpectrumPropagationLossModel> dlSplm = m_downlinkPathlossModel->GetObject<SpectrumPropagationLossModel> ();
-  if (dlSplm != 0)
-    {
-      NS_LOG_LOGIC (this << " using a SpectrumPropagationLossModel in DL");
-      m_downlinkChannel->AddSpectrumPropagationLossModel (dlSplm);
-    }
-  else
-    {
-      NS_LOG_LOGIC (this << " using a PropagationLossModel in DL");
-      Ptr<PropagationLossModel> dlPlm = m_downlinkPathlossModel->GetObject<PropagationLossModel> ();
-      NS_ASSERT_MSG (dlPlm != 0, " " << m_downlinkPathlossModel << " is neither PropagationLossModel nor SpectrumPropagationLossModel");
-      m_downlinkChannel->AddPropagationLossModel (dlPlm);
-    }
-
-  m_uplinkPathlossModel = m_pathlossModelFactory.Create ();
-  Ptr<SpectrumPropagationLossModel> ulSplm = m_uplinkPathlossModel->GetObject<SpectrumPropagationLossModel> ();
-  if (ulSplm != 0)
-    {
-      NS_LOG_LOGIC (this << " using a SpectrumPropagationLossModel in UL");
-      m_uplinkChannel->AddSpectrumPropagationLossModel (ulSplm);
-    }
-  else
-    {
-      NS_LOG_LOGIC (this << " using a PropagationLossModel in UL");
-      Ptr<PropagationLossModel> ulPlm = m_uplinkPathlossModel->GetObject<PropagationLossModel> ();
-      NS_ASSERT_MSG (ulPlm != 0, " " << m_uplinkPathlossModel << " is neither PropagationLossModel nor SpectrumPropagationLossModel");
-      m_uplinkChannel->AddPropagationLossModel (ulPlm);
-    }
-  if (!m_fadingModelType.empty ())
-    {
-      m_fadingModule = m_fadingModelFactory.Create<SpectrumPropagationLossModel> ();
-      m_fadingModule->Initialize ();
-      m_downlinkChannel->AddSpectrumPropagationLossModel (m_fadingModule);
-      m_uplinkChannel->AddSpectrumPropagationLossModel (m_fadingModule);
-    }
-}
 
 void 
 LteHelper::SetEpcHelper (Ptr<EpcHelper> h)
@@ -342,61 +285,22 @@
 }
 
 
-std::string
-LteHelper::GetEnbComponentCarrierManagerType () const
-{
-  return m_enbComponentCarrierManagerFactory.GetTypeId ().GetName ();
-}
-
-void
-LteHelper::SetEnbComponentCarrierManagerType (std::string type)
-{
-  NS_LOG_FUNCTION (this << type);
-  m_enbComponentCarrierManagerFactory = ObjectFactory ();
-  m_enbComponentCarrierManagerFactory.SetTypeId (type);
-}
-
-void
-LteHelper::SetEnbComponentCarrierManagerAttribute (std::string n, const AttributeValue &v)
-{
-  NS_LOG_FUNCTION (this << n);
-  m_enbComponentCarrierManagerFactory.Set (n, v);
-}
-
-std::string
-LteHelper::GetUeComponentCarrierManagerType () const
-{
-  return m_ueComponentCarrierManagerFactory.GetTypeId ().GetName ();
-}
-
-void
-LteHelper::SetUeComponentCarrierManagerType (std::string type)
-{
-  NS_LOG_FUNCTION (this << type);
-  m_ueComponentCarrierManagerFactory = ObjectFactory ();
-  m_ueComponentCarrierManagerFactory.SetTypeId (type);
-}
-
-void
-LteHelper::SetUeComponentCarrierManagerAttribute (std::string n, const AttributeValue &v)
-{
-  NS_LOG_FUNCTION (this << n);
-  m_ueComponentCarrierManagerFactory.Set (n, v);
-}
-
-void
-LteHelper::SetPathlossModelType (TypeId type)
+void 
+LteHelper::SetPathlossModelType (std::string type) 
 {
   NS_LOG_FUNCTION (this << type);
-  m_pathlossModelFactory = ObjectFactory ();
-  m_pathlossModelFactory.SetTypeId (type);
+  m_dlPathlossModelFactory = ObjectFactory ();
+  m_dlPathlossModelFactory.SetTypeId (type);
+  m_ulPathlossModelFactory = ObjectFactory ();
+  m_ulPathlossModelFactory.SetTypeId (type);
 }
 
 void 
 LteHelper::SetPathlossModelAttribute (std::string n, const AttributeValue &v)
 {
   NS_LOG_FUNCTION (this << n);
-  m_pathlossModelFactory.Set (n, v);
+  m_dlPathlossModelFactory.Set (n, v);
+  m_ulPathlossModelFactory.Set (n, v);
 }
 
 void
@@ -473,12 +377,6 @@
   m_channelFactory.Set (n, v);
 }
 
-void
-LteHelper::SetCcPhyParams ( std::map< uint8_t, ComponentCarrier> ccMapParams)
-{
-  NS_LOG_FUNCTION (this);
-  m_componentCarrierPhyParams = ccMapParams;
-}
 
 NetDeviceContainer
 LteHelper::InstallEnbDevice (NodeContainer c)
@@ -513,92 +411,51 @@
 Ptr<NetDevice>
 LteHelper::InstallSingleEnbDevice (Ptr<Node> n)
 {
-  uint16_t cellId = m_cellIdCounter; // \todo Remove, eNB has no cell ID
 
-  Ptr<LteEnbNetDevice> dev = m_enbNetDeviceFactory.Create<LteEnbNetDevice> ();
-  Ptr<LteHandoverAlgorithm> handoverAlgorithm = m_handoverAlgorithmFactory.Create<LteHandoverAlgorithm> ();
-
-  if (m_componentCarrierPhyParams.size() == 0)
-    {
-      DoComponentCarrierConfigure (dev->GetUlEarfcn (), dev->GetDlEarfcn (), dev->GetUlBandwidth (), dev->GetDlBandwidth ());
-    }
+  NS_ABORT_MSG_IF (m_cellIdCounter == 65535, "max num eNBs exceeded");
+  uint16_t cellId = ++m_cellIdCounter;
 
-  NS_ASSERT_MSG(m_componentCarrierPhyParams.size()!=0, "Cannot create enb ccm map.");
-  // create component carrier map for this eNb device
-  std::map<uint8_t,Ptr<ComponentCarrierEnb> > ccMap;
-  for (std::map<uint8_t, ComponentCarrier >::iterator it = m_componentCarrierPhyParams.begin (); it != m_componentCarrierPhyParams.end (); ++it)
-    {
-      Ptr <ComponentCarrierEnb> cc =  CreateObject<ComponentCarrierEnb> ();
-      cc->SetUlBandwidth(it->second.GetUlBandwidth());
-      cc->SetDlBandwidth(it->second.GetDlBandwidth());
-      cc->SetDlEarfcn(it->second.GetDlEarfcn());
-      cc->SetUlEarfcn(it->second.GetUlEarfcn());
-      cc->SetAsPrimary(it->second.IsPrimary());
-      NS_ABORT_MSG_IF (m_cellIdCounter == 65535, "max num cells exceeded");
-      cc->SetCellId (m_cellIdCounter++);
-      ccMap [it->first] =  cc;
-    }
-  NS_ABORT_MSG_IF (m_useCa && ccMap.size()<2, "You have to either specify carriers or disable carrier aggregation");
-  NS_ASSERT (ccMap.size () == m_noOfCcs);
-
-  for (std::map<uint8_t,Ptr<ComponentCarrierEnb> >::iterator it = ccMap.begin (); it != ccMap.end (); ++it)
-    {
-      NS_LOG_DEBUG (this << "component carrier map size " << (uint16_t) ccMap.size ());
-      Ptr<LteSpectrumPhy> dlPhy = CreateObject<LteSpectrumPhy> ();
-      Ptr<LteSpectrumPhy> ulPhy = CreateObject<LteSpectrumPhy> ();
-      Ptr<LteEnbPhy> phy = CreateObject<LteEnbPhy> (dlPhy, ulPhy);
-
-      Ptr<LteHarqPhy> harq = Create<LteHarqPhy> ();
-      dlPhy->SetHarqPhyModule (harq);
-      ulPhy->SetHarqPhyModule (harq);
-      phy->SetHarqPhyModule (harq);
-
-      Ptr<LteChunkProcessor> pCtrl = Create<LteChunkProcessor> ();
-      pCtrl->AddCallback (MakeCallback (&LteEnbPhy::GenerateCtrlCqiReport, phy));
-      ulPhy->AddCtrlSinrChunkProcessor (pCtrl);   // for evaluating SRS UL-CQI
-
-      Ptr<LteChunkProcessor> pData = Create<LteChunkProcessor> ();
-      pData->AddCallback (MakeCallback (&LteEnbPhy::GenerateDataCqiReport, phy));
-      pData->AddCallback (MakeCallback (&LteSpectrumPhy::UpdateSinrPerceived, ulPhy));
-      ulPhy->AddDataSinrChunkProcessor (pData);   // for evaluating PUSCH UL-CQI
-
-      Ptr<LteChunkProcessor> pInterf = Create<LteChunkProcessor> ();
-      pInterf->AddCallback (MakeCallback (&LteEnbPhy::ReportInterference, phy));
-      ulPhy->AddInterferenceDataChunkProcessor (pInterf);   // for interference power tracing
-
-      dlPhy->SetChannel (m_downlinkChannel);
-      ulPhy->SetChannel (m_uplinkChannel);
-
-      Ptr<MobilityModel> mm = n->GetObject<MobilityModel> ();
-      NS_ASSERT_MSG (mm, "MobilityModel needs to be set on node before calling LteHelper::InstallEnbDevice ()");
-      dlPhy->SetMobility (mm);
-      ulPhy->SetMobility (mm);
-
-      Ptr<AntennaModel> antenna = (m_enbAntennaModelFactory.Create ())->GetObject<AntennaModel> ();
-      NS_ASSERT_MSG (antenna, "error in creating the AntennaModel object");
-      dlPhy->SetAntenna (antenna);
-      ulPhy->SetAntenna (antenna);
-
-      Ptr<LteEnbMac> mac = CreateObject<LteEnbMac> ();
-      Ptr<FfMacScheduler> sched = m_schedulerFactory.Create<FfMacScheduler> ();
-      Ptr<LteFfrAlgorithm> ffrAlgorithm = m_ffrAlgorithmFactory.Create<LteFfrAlgorithm> ();
-      it->second->SetMac (mac);
-      it->second->SetFfMacScheduler (sched);
-      it->second->SetFfrAlgorithm (ffrAlgorithm);
-  
-      it->second->SetPhy (phy);
+  Ptr<LteSpectrumPhy> dlPhy = CreateObject<LteSpectrumPhy> ();
+  Ptr<LteSpectrumPhy> ulPhy = CreateObject<LteSpectrumPhy> ();
 
-    }
+  Ptr<LteEnbPhy> phy = CreateObject<LteEnbPhy> (dlPhy, ulPhy);
 
+  Ptr<LteHarqPhy> harq = Create<LteHarqPhy> ();
+  dlPhy->SetHarqPhyModule (harq);
+  ulPhy->SetHarqPhyModule (harq);
+  phy->SetHarqPhyModule (harq);
+
+  Ptr<LteChunkProcessor> pCtrl = Create<LteChunkProcessor> ();
+  pCtrl->AddCallback (MakeCallback (&LteEnbPhy::GenerateCtrlCqiReport, phy));
+  ulPhy->AddCtrlSinrChunkProcessor (pCtrl); // for evaluating SRS UL-CQI
+
+  Ptr<LteChunkProcessor> pData = Create<LteChunkProcessor> ();
+  pData->AddCallback (MakeCallback (&LteEnbPhy::GenerateDataCqiReport, phy));
+  pData->AddCallback (MakeCallback (&LteSpectrumPhy::UpdateSinrPerceived, ulPhy));
+  ulPhy->AddDataSinrChunkProcessor (pData); // for evaluating PUSCH UL-CQI
+
+  Ptr<LteChunkProcessor> pInterf = Create<LteChunkProcessor> ();
+  pInterf->AddCallback (MakeCallback (&LteEnbPhy::ReportInterference, phy));
+  ulPhy->AddInterferenceDataChunkProcessor (pInterf); // for interference power tracing
+
+  dlPhy->SetChannel (m_downlinkChannel);
+  ulPhy->SetChannel (m_uplinkChannel);
+
+  Ptr<MobilityModel> mm = n->GetObject<MobilityModel> ();
+  NS_ASSERT_MSG (mm, "MobilityModel needs to be set on node before calling LteHelper::InstallUeDevice ()");
+  dlPhy->SetMobility (mm);
+  ulPhy->SetMobility (mm);
+
+  Ptr<AntennaModel> antenna = (m_enbAntennaModelFactory.Create ())->GetObject<AntennaModel> ();
+  NS_ASSERT_MSG (antenna, "error in creating the AntennaModel object");
+  dlPhy->SetAntenna (antenna);
+  ulPhy->SetAntenna (antenna);
+
+  Ptr<LteEnbMac> mac = CreateObject<LteEnbMac> ();
+  Ptr<FfMacScheduler> sched = m_schedulerFactory.Create<FfMacScheduler> ();
+  Ptr<LteFfrAlgorithm> ffrAlgorithm = m_ffrAlgorithmFactory.Create<LteFfrAlgorithm> ();
+  Ptr<LteHandoverAlgorithm> handoverAlgorithm = m_handoverAlgorithmFactory.Create<LteHandoverAlgorithm> ();
   Ptr<LteEnbRrc> rrc = CreateObject<LteEnbRrc> ();
-  Ptr<LteEnbComponentCarrierManager> ccmEnbManager = m_enbComponentCarrierManagerFactory.Create<LteEnbComponentCarrierManager> ();
-  rrc->ConfigureCarriers (ccMap);
-  
-  //ComponentCarrierManager SAP
-  rrc->SetLteCcmRrcSapProvider (ccmEnbManager->GetLteCcmRrcSapProvider ());
-  ccmEnbManager->SetLteCcmRrcSapUser (rrc->GetLteCcmRrcSapUser ());
-  ccmEnbManager->SetNumberOfComponentCarriers (m_noOfCcs);
-  ccmEnbManager->SetRrc(rrc);
 
   if (m_useIdealRrc)
     {
@@ -628,72 +485,42 @@
         }
     }
 
+  rrc->SetLteEnbCmacSapProvider (mac->GetLteEnbCmacSapProvider ());
+  mac->SetLteEnbCmacSapUser (rrc->GetLteEnbCmacSapUser ());
+  rrc->SetLteMacSapProvider (mac->GetLteMacSapProvider ());
+
   rrc->SetLteHandoverManagementSapProvider (handoverAlgorithm->GetLteHandoverManagementSapProvider ());
   handoverAlgorithm->SetLteHandoverManagementSapUser (rrc->GetLteHandoverManagementSapUser ());
- 
-  // This RRC attribute is used to connect each new RLC instance with the MAC layer
-  // (for function such as TransmitPdu, ReportBufferStatusReport).
-  // Since in this new architecture, the component carrier manager acts a proxy, it
-  // will have its own LteMacSapProvider interface, RLC will see it as through original MAC
-  // interface LteMacSapProvider, but the function call will go now through LteEnbComponentCarrierManager
-  // instance that needs to implement functions of this interface, and its task will be to
-  // forward these calls to the specific MAC of some of the instances of component carriers. This
-  // decision will depend on the specific implementation of the component carrier manager.
-  rrc->SetLteMacSapProvider (ccmEnbManager->GetLteMacSapProvider ());
-
-  bool ccmTest;
-  for (std::map<uint8_t,Ptr<ComponentCarrierEnb> >::iterator it = ccMap.begin (); it != ccMap.end (); ++it)
-    {
-      it->second->GetPhy ()->SetLteEnbCphySapUser (rrc->GetLteEnbCphySapUser (it->first));
-      rrc->SetLteEnbCphySapProvider (it->second->GetPhy ()->GetLteEnbCphySapProvider (), it->first);
-
-      rrc->SetLteEnbCmacSapProvider (it->second->GetMac ()->GetLteEnbCmacSapProvider (),it->first );
-      it->second->GetMac ()->SetLteEnbCmacSapUser (rrc->GetLteEnbCmacSapUser (it->first));
-
-      it->second->GetPhy ()->SetComponentCarrierId (it->first);
-      it->second->GetMac ()->SetComponentCarrierId (it->first);
-      //FFR SAP
-      it->second->GetFfMacScheduler ()->SetLteFfrSapProvider (it->second->GetFfrAlgorithm ()->GetLteFfrSapProvider ());
-      it->second->GetFfrAlgorithm ()->SetLteFfrSapUser (it->second->GetFfMacScheduler ()->GetLteFfrSapUser ());
-      rrc->SetLteFfrRrcSapProvider (it->second->GetFfrAlgorithm ()->GetLteFfrRrcSapProvider (), it->first);
-      it->second->GetFfrAlgorithm ()->SetLteFfrRrcSapUser (rrc->GetLteFfrRrcSapUser (it->first));
-      //FFR SAP END
-
-      // PHY <--> MAC SAP
-      it->second->GetPhy ()->SetLteEnbPhySapUser (it->second->GetMac ()->GetLteEnbPhySapUser ());
-      it->second->GetMac ()->SetLteEnbPhySapProvider (it->second->GetPhy ()->GetLteEnbPhySapProvider ());
-      // PHY <--> MAC SAP END
-
-      //Scheduler SAP
-      it->second->GetMac ()->SetFfMacSchedSapProvider (it->second->GetFfMacScheduler ()->GetFfMacSchedSapProvider ());
-      it->second->GetMac ()->SetFfMacCschedSapProvider (it->second->GetFfMacScheduler ()->GetFfMacCschedSapProvider ());
-
-      it->second->GetFfMacScheduler ()->SetFfMacSchedSapUser (it->second->GetMac ()->GetFfMacSchedSapUser ());
-      it->second->GetFfMacScheduler ()->SetFfMacCschedSapUser (it->second->GetMac ()->GetFfMacCschedSapUser ());
-      // Scheduler SAP END
 
-      it->second->GetMac ()->SetLteCcmMacSapUser (ccmEnbManager->GetLteCcmMacSapUser ());
-      ccmEnbManager->SetCcmMacSapProviders (it->first, it->second->GetMac ()->GetLteCcmMacSapProvider ());
+  mac->SetFfMacSchedSapProvider (sched->GetFfMacSchedSapProvider ());
+  mac->SetFfMacCschedSapProvider (sched->GetFfMacCschedSapProvider ());
 
-      // insert the pointer to the LteMacSapProvider interface of the MAC layer of the specific component carrier
-      ccmTest = ccmEnbManager->SetMacSapProvider (it->first, it->second->GetMac ()->GetLteMacSapProvider());
+  sched->SetFfMacSchedSapUser (mac->GetFfMacSchedSapUser ());
+  sched->SetFfMacCschedSapUser (mac->GetFfMacCschedSapUser ());
 
-      if (ccmTest == false)
-        {
-          NS_FATAL_ERROR ("Error in SetComponentCarrierMacSapProviders");
-        }
-    }
+  phy->SetLteEnbPhySapUser (mac->GetLteEnbPhySapUser ());
+  mac->SetLteEnbPhySapProvider (phy->GetLteEnbPhySapProvider ());
 
+  phy->SetLteEnbCphySapUser (rrc->GetLteEnbCphySapUser ());
+  rrc->SetLteEnbCphySapProvider (phy->GetLteEnbCphySapProvider ());
 
+  //FFR SAP
+  sched->SetLteFfrSapProvider (ffrAlgorithm->GetLteFfrSapProvider ());
+  ffrAlgorithm->SetLteFfrSapUser (sched->GetLteFfrSapUser ());
 
+  rrc->SetLteFfrRrcSapProvider (ffrAlgorithm->GetLteFfrRrcSapProvider ());
+  ffrAlgorithm->SetLteFfrRrcSapUser (rrc->GetLteFfrRrcSapUser ());
+  //FFR SAP END
+
+  Ptr<LteEnbNetDevice> dev = m_enbNetDeviceFactory.Create<LteEnbNetDevice> ();
   dev->SetNode (n);
-  dev->SetAttribute ("CellId", UintegerValue (cellId));
-  dev->SetAttribute ("LteEnbComponentCarrierManager", PointerValue (ccmEnbManager));
-  dev->SetCcMap (ccMap);
-  std::map<uint8_t,Ptr<ComponentCarrierEnb> >::iterator it = ccMap.begin ();
+  dev->SetAttribute ("CellId", UintegerValue (cellId)); 
+  dev->SetAttribute ("LteEnbPhy", PointerValue (phy));
+  dev->SetAttribute ("LteEnbMac", PointerValue (mac));
+  dev->SetAttribute ("FfMacScheduler", PointerValue (sched));
   dev->SetAttribute ("LteEnbRrc", PointerValue (rrc)); 
   dev->SetAttribute ("LteHandoverAlgorithm", PointerValue (handoverAlgorithm));
-  dev->SetAttribute ("LteFfrAlgorithm", PointerValue (it->second->GetFfrAlgorithm ()));
+  dev->SetAttribute ("LteFfrAlgorithm", PointerValue (ffrAlgorithm));
 
   if (m_isAnrEnabled)
     {
@@ -703,42 +530,36 @@
       dev->SetAttribute ("LteAnr", PointerValue (anr));
     }
 
-  for (it = ccMap.begin (); it != ccMap.end (); ++it)
-    {
-      Ptr<LteEnbPhy> ccPhy = it->second->GetPhy ();
-      ccPhy->SetDevice (dev);
-      ccPhy->GetUlSpectrumPhy ()->SetDevice (dev);
-      ccPhy->GetDlSpectrumPhy ()->SetDevice (dev);
-      ccPhy->GetUlSpectrumPhy ()->SetLtePhyRxDataEndOkCallback (MakeCallback (&LteEnbPhy::PhyPduReceived, ccPhy));
-      ccPhy->GetUlSpectrumPhy ()->SetLtePhyRxCtrlEndOkCallback (MakeCallback (&LteEnbPhy::ReceiveLteControlMessageList, ccPhy));
-      ccPhy->GetUlSpectrumPhy ()->SetLtePhyUlHarqFeedbackCallback (MakeCallback (&LteEnbPhy::ReceiveLteUlHarqFeedback, ccPhy));
-      NS_LOG_LOGIC ("set the propagation model frequencies");
-      double dlFreq = LteSpectrumValueHelper::GetCarrierFrequency (it->second->m_dlEarfcn);
-      NS_LOG_LOGIC ("DL freq: " << dlFreq);
-      bool dlFreqOk = m_downlinkPathlossModel->SetAttributeFailSafe ("Frequency", DoubleValue (dlFreq));
-      if (!dlFreqOk)
-        {
-          NS_LOG_WARN ("DL propagation model does not have a Frequency attribute");
-        }
-
-      double ulFreq = LteSpectrumValueHelper::GetCarrierFrequency (it->second->m_ulEarfcn);
+  phy->SetDevice (dev);
+  dlPhy->SetDevice (dev);
+  ulPhy->SetDevice (dev);
 
-      NS_LOG_LOGIC ("UL freq: " << ulFreq);
-      bool ulFreqOk = m_uplinkPathlossModel->SetAttributeFailSafe ("Frequency", DoubleValue (ulFreq));
-      if (!ulFreqOk)
-        {
-          NS_LOG_WARN ("UL propagation model does not have a Frequency attribute");
-        }
-    }  //end for
-  rrc->SetForwardUpCallback (MakeCallback (&LteEnbNetDevice::Receive, dev));
-  dev->Initialize ();
   n->AddDevice (dev);
+  ulPhy->SetLtePhyRxDataEndOkCallback (MakeCallback (&LteEnbPhy::PhyPduReceived, phy));
+  ulPhy->SetLtePhyRxCtrlEndOkCallback (MakeCallback (&LteEnbPhy::ReceiveLteControlMessageList, phy));
+  ulPhy->SetLtePhyUlHarqFeedbackCallback (MakeCallback (&LteEnbPhy::ReceiveLteUlHarqFeedback, phy));
+  rrc->SetForwardUpCallback (MakeCallback (&LteEnbNetDevice::Receive, dev));
 
-  for (it = ccMap.begin (); it != ccMap.end (); ++it)
+  NS_LOG_LOGIC ("set the propagation model frequencies");
+  double dlFreq = LteSpectrumValueHelper::GetCarrierFrequency (dev->GetDlEarfcn ());
+  NS_LOG_LOGIC ("DL freq: " << dlFreq);
+  bool dlFreqOk = m_downlinkPathlossModel->SetAttributeFailSafe ("Frequency", DoubleValue (dlFreq));
+  if (!dlFreqOk)
+    {
+      NS_LOG_WARN ("DL propagation model does not have a Frequency attribute");
+    }
+  double ulFreq = LteSpectrumValueHelper::GetCarrierFrequency (dev->GetUlEarfcn ());
+  NS_LOG_LOGIC ("UL freq: " << ulFreq);
+  bool ulFreqOk = m_uplinkPathlossModel->SetAttributeFailSafe ("Frequency", DoubleValue (ulFreq));
+  if (!ulFreqOk)
     {
-      m_uplinkChannel->AddRx (it->second->GetPhy ()->GetUlSpectrumPhy ());
+      NS_LOG_WARN ("UL propagation model does not have a Frequency attribute");
     }
 
+  dev->Initialize ();
+
+  m_uplinkChannel->AddRx (ulPhy);
+
   if (m_epcHelper != 0)
     {
       NS_LOG_INFO ("adding this eNB to the EPC");
@@ -763,94 +584,63 @@
 LteHelper::InstallSingleUeDevice (Ptr<Node> n)
 {
   NS_LOG_FUNCTION (this);
+  Ptr<LteSpectrumPhy> dlPhy = CreateObject<LteSpectrumPhy> ();
+  Ptr<LteSpectrumPhy> ulPhy = CreateObject<LteSpectrumPhy> ();
 
-  NS_ABORT_MSG_IF (m_componentCarrierPhyParams.size() == 0 && m_useCa, "If CA is enabled, before call this method you need to install Enbs --> InstallEnbDevice()");
+  Ptr<LteUePhy> phy = CreateObject<LteUePhy> (dlPhy, ulPhy);
 
-  Ptr<LteUeNetDevice> dev = m_ueNetDeviceFactory.Create<LteUeNetDevice> ();
-  std::map<uint8_t, Ptr<ComponentCarrierUe> > ueCcMap;
-
-  for (std::map< uint8_t, ComponentCarrier >::iterator it = m_componentCarrierPhyParams.begin() ; it != m_componentCarrierPhyParams.end(); ++it)
-    {
-      Ptr <ComponentCarrierUe> cc =  CreateObject<ComponentCarrierUe> ();
-      cc->SetUlBandwidth ( it->second.GetUlBandwidth ());
-      cc->SetDlBandwidth ( it->second.GetDlBandwidth ());
-      cc->SetDlEarfcn ( it->second.GetDlEarfcn ());
-      cc->SetUlEarfcn ( it->second.GetUlEarfcn ());
-      cc->SetAsPrimary (it->second.IsPrimary());
-      Ptr<LteUeMac> mac = CreateObject<LteUeMac> ();
-      cc->SetMac (mac);
-      // cc->GetPhy ()->Initialize (); // it is initialized within the LteUeNetDevice::DoInitialize ()
-      ueCcMap.insert (std::pair<uint8_t, Ptr<ComponentCarrierUe> > (it->first, cc));
+  Ptr<LteHarqPhy> harq = Create<LteHarqPhy> ();
+  dlPhy->SetHarqPhyModule (harq);
+  ulPhy->SetHarqPhyModule (harq);
+  phy->SetHarqPhyModule (harq);
+
+  Ptr<LteChunkProcessor> pRs = Create<LteChunkProcessor> ();
+  pRs->AddCallback (MakeCallback (&LteUePhy::ReportRsReceivedPower, phy));
+  dlPhy->AddRsPowerChunkProcessor (pRs);
+
+  Ptr<LteChunkProcessor> pInterf = Create<LteChunkProcessor> ();
+  pInterf->AddCallback (MakeCallback (&LteUePhy::ReportInterference, phy));
+  dlPhy->AddInterferenceCtrlChunkProcessor (pInterf); // for RSRQ evaluation of UE Measurements
+
+  Ptr<LteChunkProcessor> pCtrl = Create<LteChunkProcessor> ();
+  pCtrl->AddCallback (MakeCallback (&LteSpectrumPhy::UpdateSinrPerceived, dlPhy));
+  dlPhy->AddCtrlSinrChunkProcessor (pCtrl);
+
+  Ptr<LteChunkProcessor> pData = Create<LteChunkProcessor> ();
+  pData->AddCallback (MakeCallback (&LteSpectrumPhy::UpdateSinrPerceived, dlPhy));
+  dlPhy->AddDataSinrChunkProcessor (pData);
+
+  if (m_usePdschForCqiGeneration)
+    {
+      // CQI calculation based on PDCCH for signal and PDSCH for interference
+      pCtrl->AddCallback (MakeCallback (&LteUePhy::GenerateMixedCqiReport, phy));
+      Ptr<LteChunkProcessor> pDataInterf = Create<LteChunkProcessor> ();      
+      pDataInterf->AddCallback (MakeCallback (&LteUePhy::ReportDataInterference, phy));
+      dlPhy->AddInterferenceDataChunkProcessor (pDataInterf);
     }
-
-  for (std::map<uint8_t, Ptr<ComponentCarrierUe> >::iterator it = ueCcMap.begin (); it != ueCcMap.end (); ++it)
+  else
     {
-      Ptr<LteSpectrumPhy> dlPhy = CreateObject<LteSpectrumPhy> ();
-      Ptr<LteSpectrumPhy> ulPhy = CreateObject<LteSpectrumPhy> ();
-
-      Ptr<LteUePhy> phy = CreateObject<LteUePhy> (dlPhy, ulPhy);
-
-      Ptr<LteHarqPhy> harq = Create<LteHarqPhy> ();
-      dlPhy->SetHarqPhyModule (harq);
-      ulPhy->SetHarqPhyModule (harq);
-      phy->SetHarqPhyModule (harq);
-
-      Ptr<LteChunkProcessor> pRs = Create<LteChunkProcessor> ();
-      pRs->AddCallback (MakeCallback (&LteUePhy::ReportRsReceivedPower, phy));
-      dlPhy->AddRsPowerChunkProcessor (pRs);
-
-      Ptr<LteChunkProcessor> pInterf = Create<LteChunkProcessor> ();
-      pInterf->AddCallback (MakeCallback (&LteUePhy::ReportInterference, phy));
-      dlPhy->AddInterferenceCtrlChunkProcessor (pInterf);   // for RSRQ evaluation of UE Measurements
+      // CQI calculation based on PDCCH for both signal and interference
+      pCtrl->AddCallback (MakeCallback (&LteUePhy::GenerateCtrlCqiReport, phy));
+    }
 
-      Ptr<LteChunkProcessor> pCtrl = Create<LteChunkProcessor> ();
-      pCtrl->AddCallback (MakeCallback (&LteSpectrumPhy::UpdateSinrPerceived, dlPhy));
-      dlPhy->AddCtrlSinrChunkProcessor (pCtrl);
 
-      Ptr<LteChunkProcessor> pData = Create<LteChunkProcessor> ();
-      pData->AddCallback (MakeCallback (&LteSpectrumPhy::UpdateSinrPerceived, dlPhy));
-      dlPhy->AddDataSinrChunkProcessor (pData);
 
-      if (m_usePdschForCqiGeneration)
-        {
-          // CQI calculation based on PDCCH for signal and PDSCH for interference
-          pCtrl->AddCallback (MakeCallback (&LteUePhy::GenerateMixedCqiReport, phy));
-          Ptr<LteChunkProcessor> pDataInterf = Create<LteChunkProcessor> ();
-          pDataInterf->AddCallback (MakeCallback (&LteUePhy::ReportDataInterference, phy));
-          dlPhy->AddInterferenceDataChunkProcessor (pDataInterf);
-        }
-      else
-        {
-          // CQI calculation based on PDCCH for both signal and interference
-          pCtrl->AddCallback (MakeCallback (&LteUePhy::GenerateCtrlCqiReport, phy));
-        }
+  dlPhy->SetChannel (m_downlinkChannel);
+  ulPhy->SetChannel (m_uplinkChannel);
 
-      dlPhy->SetChannel (m_downlinkChannel);
-      ulPhy->SetChannel (m_uplinkChannel);
+  Ptr<MobilityModel> mm = n->GetObject<MobilityModel> ();
+  NS_ASSERT_MSG (mm, "MobilityModel needs to be set on node before calling LteHelper::InstallUeDevice ()");
+  dlPhy->SetMobility (mm);
+  ulPhy->SetMobility (mm);
 
-      Ptr<MobilityModel> mm = n->GetObject<MobilityModel> ();
-      NS_ASSERT_MSG (mm, "MobilityModel needs to be set on node before calling LteHelper::InstallUeDevice ()");
-      dlPhy->SetMobility (mm);
-      ulPhy->SetMobility (mm);
-
-      Ptr<AntennaModel> antenna = (m_ueAntennaModelFactory.Create ())->GetObject<AntennaModel> ();
-      NS_ASSERT_MSG (antenna, "error in creating the AntennaModel object");
-      dlPhy->SetAntenna (antenna);
-      ulPhy->SetAntenna (antenna);
-
-      it->second->SetPhy(phy);
-    }
-  Ptr<LteUeComponentCarrierManager> ccmUe = m_ueComponentCarrierManagerFactory.Create<LteUeComponentCarrierManager> ();
-  ccmUe->SetNumberOfComponentCarriers (m_noOfCcs);
+  Ptr<AntennaModel> antenna = (m_ueAntennaModelFactory.Create ())->GetObject<AntennaModel> ();
+  NS_ASSERT_MSG (antenna, "error in creating the AntennaModel object");
+  dlPhy->SetAntenna (antenna);
+  ulPhy->SetAntenna (antenna);
 
+  Ptr<LteUeMac> mac = CreateObject<LteUeMac> ();
   Ptr<LteUeRrc> rrc = CreateObject<LteUeRrc> ();
-  rrc->m_numberOfComponentCarriers = m_noOfCcs;
-  // run intializeSap to create the proper number of sap provider/users
-  rrc->InitializeSap();
-  rrc->SetLteMacSapProvider (ccmUe->GetLteMacSapProvider ());
-  // setting ComponentCarrierManager SAP
-  rrc->SetLteCcmRrcSapProvider (ccmUe->GetLteCcmRrcSapProvider ());
-  ccmUe->SetLteCcmRrcSapUser (rrc->GetLteCcmRrcSapUser ());
 
   if (m_useIdealRrc)
     {
@@ -878,54 +668,37 @@
   nas->SetAsSapProvider (rrc->GetAsSapProvider ());
   rrc->SetAsSapUser (nas->GetAsSapUser ());
 
-  for (std::map<uint8_t, Ptr<ComponentCarrierUe> >::iterator it = ueCcMap.begin (); it != ueCcMap.end (); ++it)
-    {
-      rrc->SetLteUeCmacSapProvider (it->second->GetMac ()->GetLteUeCmacSapProvider (), it->first);
-      it->second->GetMac ()->SetLteUeCmacSapUser (rrc->GetLteUeCmacSapUser (it->first));
-      it->second->GetMac ()->SetComponentCarrierId (it->first);
-
-      it->second->GetPhy ()->SetLteUeCphySapUser (rrc->GetLteUeCphySapUser (it->first));
-      rrc->SetLteUeCphySapProvider (it->second->GetPhy ()->GetLteUeCphySapProvider (), it->first);
-      it->second->GetPhy ()->SetComponentCarrierId (it->first);
-      
-      it->second->GetPhy ()->SetLteUePhySapUser (it->second->GetMac ()->GetLteUePhySapUser ());
-      it->second->GetMac ()->SetLteUePhySapProvider (it->second->GetPhy ()->GetLteUePhySapProvider ());
-      
-      bool ccmTest = ccmUe->SetComponentCarrierMacSapProviders (it->first, it->second->GetMac ()->GetLteMacSapProvider());
+  rrc->SetLteUeCmacSapProvider (mac->GetLteUeCmacSapProvider ());
+  mac->SetLteUeCmacSapUser (rrc->GetLteUeCmacSapUser ());
+  rrc->SetLteMacSapProvider (mac->GetLteMacSapProvider ());
 
-      if (ccmTest == false)
-        {
-          NS_FATAL_ERROR ("Error in SetComponentCarrierMacSapProviders");
-        }
-    }
+  phy->SetLteUePhySapUser (mac->GetLteUePhySapUser ());
+  mac->SetLteUePhySapProvider (phy->GetLteUePhySapProvider ());
+
+  phy->SetLteUeCphySapUser (rrc->GetLteUeCphySapUser ());
+  rrc->SetLteUeCphySapProvider (phy->GetLteUeCphySapProvider ());
 
   NS_ABORT_MSG_IF (m_imsiCounter >= 0xFFFFFFFF, "max num UEs exceeded");
   uint64_t imsi = ++m_imsiCounter;
 
-
+  Ptr<LteUeNetDevice> dev = m_ueNetDeviceFactory.Create<LteUeNetDevice> ();
   dev->SetNode (n);
   dev->SetAttribute ("Imsi", UintegerValue (imsi));
-  dev->SetCcMap (ueCcMap);
+  dev->SetAttribute ("LteUePhy", PointerValue (phy));
+  dev->SetAttribute ("LteUeMac", PointerValue (mac));
   dev->SetAttribute ("LteUeRrc", PointerValue (rrc));
   dev->SetAttribute ("EpcUeNas", PointerValue (nas));
-  dev->SetAttribute ("LteUeComponentCarrierManager", PointerValue (ccmUe));
-
-  for (std::map<uint8_t, Ptr<ComponentCarrierUe> >::iterator it = ueCcMap.begin (); it != ueCcMap.end (); ++it)
-    {
-      Ptr<LteUePhy> ccPhy = it->second->GetPhy ();
-      ccPhy->SetDevice (dev);
-      ccPhy->GetUlSpectrumPhy ()->SetDevice (dev);
-      ccPhy->GetDlSpectrumPhy ()->SetDevice (dev);
-      ccPhy->GetDlSpectrumPhy ()->SetLtePhyRxDataEndOkCallback (MakeCallback (&LteUePhy::PhyPduReceived, ccPhy));
-      ccPhy->GetDlSpectrumPhy ()->SetLtePhyRxCtrlEndOkCallback (MakeCallback (&LteUePhy::ReceiveLteControlMessageList, ccPhy));
-      ccPhy->GetDlSpectrumPhy ()->SetLtePhyRxPssCallback (MakeCallback (&LteUePhy::ReceivePss, ccPhy));
-      ccPhy->GetDlSpectrumPhy ()->SetLtePhyDlHarqFeedbackCallback (MakeCallback (&LteUePhy::ReceiveLteDlHarqFeedback, ccPhy));
-    }
 
+  phy->SetDevice (dev);
+  dlPhy->SetDevice (dev);
+  ulPhy->SetDevice (dev);
   nas->SetDevice (dev);
 
   n->AddDevice (dev);
-
+  dlPhy->SetLtePhyRxDataEndOkCallback (MakeCallback (&LteUePhy::PhyPduReceived, phy));
+  dlPhy->SetLtePhyRxCtrlEndOkCallback (MakeCallback (&LteUePhy::ReceiveLteControlMessageList, phy));
+  dlPhy->SetLtePhyRxPssCallback (MakeCallback (&LteUePhy::ReceivePss, phy));
+  dlPhy->SetLtePhyDlHarqFeedbackCallback (MakeCallback (&LteUePhy::ReceiveLteDlHarqFeedback, phy));
   nas->SetForwardUpCallback (MakeCallback (&LteUeNetDevice::Receive, dev));
 
   if (m_epcHelper != 0)
@@ -968,7 +741,7 @@
   // initiate cell selection
   Ptr<EpcUeNas> ueNas = ueLteDevice->GetNas ();
   NS_ASSERT (ueNas != 0);
-  uint32_t dlEarfcn = ueLteDevice->GetDlEarfcn ();
+  uint16_t dlEarfcn = ueLteDevice->GetDlEarfcn ();
   ueNas->StartCellSelection (dlEarfcn);
 
   // instruct UE to immediately enter CONNECTED mode after camping
@@ -1229,23 +1002,15 @@
 {
   NS_LOG_FUNCTION (this << ueDev << sourceEnbDev << targetEnbDev);
   NS_ASSERT_MSG (m_epcHelper, "Handover requires the use of the EPC - did you forget to call LteHelper::SetEpcHelper () ?");
-  uint16_t targetCellId = targetEnbDev->GetObject<LteEnbNetDevice> ()->GetCellId ();
-  Simulator::Schedule (hoTime, &LteHelper::DoHandoverRequest, this, ueDev, sourceEnbDev, targetCellId);
-}
-
-void
-LteHelper::HandoverRequest (Time hoTime, Ptr<NetDevice> ueDev, Ptr<NetDevice> sourceEnbDev, uint16_t targetCellId)
-{
-  NS_LOG_FUNCTION (this << ueDev << sourceEnbDev << targetCellId);
-  NS_ASSERT_MSG (m_epcHelper, "Handover requires the use of the EPC - did you forget to call LteHelper::SetEpcHelper () ?");
-  Simulator::Schedule (hoTime, &LteHelper::DoHandoverRequest, this, ueDev, sourceEnbDev, targetCellId);
+  Simulator::Schedule (hoTime, &LteHelper::DoHandoverRequest, this, ueDev, sourceEnbDev, targetEnbDev);
 }
 
 void
-LteHelper::DoHandoverRequest (Ptr<NetDevice> ueDev, Ptr<NetDevice> sourceEnbDev, uint16_t targetCellId)
+LteHelper::DoHandoverRequest (Ptr<NetDevice> ueDev, Ptr<NetDevice> sourceEnbDev, Ptr<NetDevice> targetEnbDev)
 {
-  NS_LOG_FUNCTION (this << ueDev << sourceEnbDev << targetCellId);
+  NS_LOG_FUNCTION (this << ueDev << sourceEnbDev << targetEnbDev);
 
+  uint16_t targetCellId = targetEnbDev->GetObject<LteEnbNetDevice> ()->GetCellId ();
   Ptr<LteEnbRrc> sourceRrc = sourceEnbDev->GetObject<LteEnbNetDevice> ()->GetRrc ();
   uint16_t rnti = ueDev->GetObject<LteUeNetDevice> ()->GetRrc ()->GetRnti ();
   sourceRrc->SendHandoverRequest (rnti, targetCellId);
@@ -1276,19 +1041,6 @@
   enbRrc->DoSendReleaseDataRadioBearer (imsi,rnti,bearerId);
 }
 
-void
-LteHelper::DoComponentCarrierConfigure (uint32_t ulEarfcn, uint32_t dlEarfcn, uint8_t ulbw, uint8_t dlbw)
-{
-  NS_ASSERT_MSG (m_componentCarrierPhyParams.size()==0, "Cc map already exists.");
-  Ptr<CcHelper> ccHelper = CreateObject<CcHelper> ();
-  ccHelper->SetNumberOfComponentCarriers (m_noOfCcs);
-  ccHelper->SetUlEarfcn (ulEarfcn);
-  ccHelper->SetDlEarfcn (dlEarfcn);
-  ccHelper->SetDlBandwidth (dlbw);
-  ccHelper->SetUlBandwidth (ulbw);
-  m_componentCarrierPhyParams = ccHelper->EquallySpacedCcs ();
-  m_componentCarrierPhyParams.at(0).SetAsPrimary(true);
-}
 
 void 
 LteHelper::ActivateDataRadioBearer (NetDeviceContainer ueDevices, EpsBearer bearer)
@@ -1322,7 +1074,7 @@
   LogComponentEnable ("LteInterference", LOG_LEVEL_ALL);
   LogComponentEnable ("LteChunkProcessor", LOG_LEVEL_ALL);
 
-  std::string propModelStr = m_pathlossModelFactory.GetTypeId ().GetName ().erase (0,5).c_str ();
+  std::string propModelStr = m_dlPathlossModelFactory.GetTypeId ().GetName ().erase (0,5).c_str ();
   LogComponentEnable ("LteNetDevice", LOG_LEVEL_ALL);
   LogComponentEnable ("LteUeNetDevice", LOG_LEVEL_ALL);
   LogComponentEnable ("LteEnbNetDevice", LOG_LEVEL_ALL);
@@ -1374,22 +1126,16 @@
       Ptr<LteEnbNetDevice> lteEnb = DynamicCast<LteEnbNetDevice> (netDevice);
       if (lteEnb)
         {
-          std::map< uint8_t, Ptr <ComponentCarrierEnb> > tmpMap = lteEnb->GetCcMap ();
-          std::map< uint8_t, Ptr <ComponentCarrierEnb> >::iterator it;
-          it = tmpMap.begin ();
-          Ptr<LteSpectrumPhy> dlPhy = it->second->GetPhy ()->GetDownlinkSpectrumPhy ();
-          Ptr<LteSpectrumPhy> ulPhy = it->second->GetPhy ()->GetUplinkSpectrumPhy ();
+          Ptr<LteSpectrumPhy> dlPhy = lteEnb->GetPhy ()->GetDownlinkSpectrumPhy ();
+          Ptr<LteSpectrumPhy> ulPhy = lteEnb->GetPhy ()->GetUplinkSpectrumPhy ();
           currentStream += dlPhy->AssignStreams (currentStream);
           currentStream += ulPhy->AssignStreams (currentStream);
         }
       Ptr<LteUeNetDevice> lteUe = DynamicCast<LteUeNetDevice> (netDevice);
       if (lteUe)
         {
-          std::map< uint8_t, Ptr <ComponentCarrierUe> > tmpMap = lteUe->GetCcMap ();
-          std::map< uint8_t, Ptr <ComponentCarrierUe> >::iterator it;
-          it = tmpMap.begin ();
-          Ptr<LteSpectrumPhy> dlPhy = it->second->GetPhy ()->GetDownlinkSpectrumPhy ();
-          Ptr<LteSpectrumPhy> ulPhy = it->second->GetPhy ()->GetUplinkSpectrumPhy ();
+          Ptr<LteSpectrumPhy> dlPhy = lteUe->GetPhy ()->GetDownlinkSpectrumPhy ();
+          Ptr<LteSpectrumPhy> ulPhy = lteUe->GetPhy ()->GetUplinkSpectrumPhy ();
           Ptr<LteUeMac> ueMac = lteUe->GetMac ();
           currentStream += dlPhy->AssignStreams (currentStream);
           currentStream += ulPhy->AssignStreams (currentStream);
@@ -1414,28 +1160,28 @@
 void
 LteHelper::EnableDlTxPhyTraces (void)
 {
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbPhy/DlPhyTransmission",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteEnbPhy/DlPhyTransmission",
                    MakeBoundCallback (&PhyTxStatsCalculator::DlPhyTransmissionCallback, m_phyTxStats));
 }
 
 void
 LteHelper::EnableUlTxPhyTraces (void)
 {
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMapUe/*/LteUePhy/UlPhyTransmission",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteUePhy/UlPhyTransmission",
                    MakeBoundCallback (&PhyTxStatsCalculator::UlPhyTransmissionCallback, m_phyTxStats));
 }
 
 void
 LteHelper::EnableDlRxPhyTraces (void)
 {
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMapUe/*/LteUePhy/DlSpectrumPhy/DlPhyReception",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteUePhy/DlSpectrumPhy/DlPhyReception",
                    MakeBoundCallback (&PhyRxStatsCalculator::DlPhyReceptionCallback, m_phyRxStats));
 }
 
 void
 LteHelper::EnableUlRxPhyTraces (void)
 {
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbPhy/UlSpectrumPhy/UlPhyReception",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteEnbPhy/UlSpectrumPhy/UlPhyReception",
                    MakeBoundCallback (&PhyRxStatsCalculator::UlPhyReceptionCallback, m_phyRxStats));
 }
 
@@ -1452,7 +1198,7 @@
 LteHelper::EnableDlMacTraces (void)
 {
   NS_LOG_FUNCTION_NOARGS ();
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbMac/DlScheduling",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteEnbMac/DlScheduling",
                    MakeBoundCallback (&MacStatsCalculator::DlSchedulingCallback, m_macStats));
 }
 
@@ -1460,7 +1206,7 @@
 LteHelper::EnableUlMacTraces (void)
 {
   NS_LOG_FUNCTION_NOARGS ();
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbMac/UlScheduling",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteEnbMac/UlScheduling",
                    MakeBoundCallback (&MacStatsCalculator::UlSchedulingCallback, m_macStats));
 }
 
@@ -1468,7 +1214,7 @@
 LteHelper::EnableDlPhyTraces (void)
 {
   NS_LOG_FUNCTION_NOARGS ();
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMapUe/*/LteUePhy/ReportCurrentCellRsrpSinr",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteUePhy/ReportCurrentCellRsrpSinr",
                    MakeBoundCallback (&PhyStatsCalculator::ReportCurrentCellRsrpSinrCallback, m_phyStats));
 }
 
@@ -1476,9 +1222,9 @@
 LteHelper::EnableUlPhyTraces (void)
 {
   NS_LOG_FUNCTION_NOARGS ();
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbPhy/ReportUeSinr",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteEnbPhy/ReportUeSinr",
                    MakeBoundCallback (&PhyStatsCalculator::ReportUeSinr, m_phyStats));
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbPhy/ReportInterference",
+  Config::Connect ("/NodeList/*/DeviceList/*/LteEnbPhy/ReportInterference",
                    MakeBoundCallback (&PhyStatsCalculator::ReportInterference, m_phyStats));
 
 }
diff -Naru a/helper/lte-helper.h b/helper/lte-helper.h
--- a/helper/lte-helper.h	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/lte-helper.h	2017-10-05 11:47:22.294601711 +0200
@@ -16,8 +16,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
- * Modified by: Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation) 
  */
 
 #ifndef LTE_HELPER_H
@@ -39,9 +37,6 @@
 #include <ns3/radio-bearer-stats-connector.h>
 #include <ns3/epc-tft.h>
 #include <ns3/mobility-model.h>
-#include <ns3/component-carrier-enb.h>
-#include <ns3/cc-helper.h>
-#include <map>
 
 namespace ns3 {
 
@@ -81,7 +76,6 @@
  *     * Handover algorithm
  *     * FFR (frequency reuse) algorithm
  *     * ANR (automatic neighbour relation)
- *     * CCM (Carrier Component Manager) 
  *   + EPC related models (EPC application, Internet stack, X2 interface)
  * - UE node(s)
  *   + Mobility model
@@ -134,7 +128,7 @@
    *             inheriting from ns3::PropagationLossModel, for example:
    *             "ns3::FriisPropagationLossModel"
    */
-  void SetPathlossModelType (TypeId type);
+  void SetPathlossModelType (std::string type);
 
   /**
    * Set an attribute for the path loss models to be created.
@@ -269,15 +263,7 @@
    */
   void SetUeAntennaModelAttribute (std::string n, const AttributeValue &v);
 
-  /**
-   * This method is used to send the ComponentCarrier map created with CcHelper
-   * to the helper, the structure will be used within InstallSingleEnbDevice
-   *
-   * \param ccmap the component carrier map
-   */
-   void SetCcPhyParams (std::map< uint8_t, ComponentCarrier> ccmap);
-
-  /**
+  /** 
    * Set the type of spectrum channel to be used in both DL and UL.
    *
    * \param type type of spectrum channel model, must be a type name of any
@@ -295,51 +281,6 @@
   void SetSpectrumChannelAttribute (std::string n, const AttributeValue &v);
 
   /**
-   * Set the type of carrier component algorithm to be used by eNodeB devices.
-   *
-   * \param type type of carrier component manager
-   *
-   */
-  void SetEnbComponentCarrierManagerType (std::string type);
-
-  /**
-   *
-   * \return the carrier enb component carrier manager type
-   */
-  std::string GetEnbComponentCarrierManagerType () const;
-
-  /**
-   * Set an attribute for the enb component carrier manager to be created.
-   *
-   * \param n the name of the attribute
-   * \param v the value of the attribute
-   */
-  void SetEnbComponentCarrierManagerAttribute (std::string n, const AttributeValue &v);
-
-  /**
-   * Set the type of Component Carrier Manager to be used by Ue devices.
-   *
-   * \param type type of UE Component Carrier Manager
-   *
-   */
-  void SetUeComponentCarrierManagerType (std::string type);
-
-
-  /**
-   *
-   * \return the carrier ue component carrier manager type
-   */
-  std::string GetUeComponentCarrierManagerType () const;
-
-  /**
-   * Set an attribute for the ue component carrier manager to be created.
-   *
-   * \param n the name of the attribute
-   * \param v the value of the attribute
-   */
-  void SetUeComponentCarrierManagerAttribute (std::string n, const AttributeValue &v);
-
-  /**
    * Create a set of eNodeB devices.
    *
    * \param c the node container where the devices are to be installed
@@ -460,7 +401,6 @@
    * \param ueDevices the set of UE devices
    * \param bearer the characteristics of the bearer to be activated
    * \param tft the Traffic Flow Template that identifies the traffic to go on this bearer
-   * \returns bearer ID
    */
   uint8_t ActivateDedicatedEpsBearer (NetDeviceContainer ueDevices, EpsBearer bearer, Ptr<EpcTft> tft);
 
@@ -470,7 +410,6 @@
    * \param ueDevice the UE device
    * \param bearer the characteristics of the bearer to be activated
    * \param tft the Traffic Flow Template that identifies the traffic to go on this bearer.
-   * \returns bearer ID
    */
   uint8_t ActivateDedicatedEpsBearer (Ptr<NetDevice> ueDevice, EpsBearer bearer, Ptr<EpcTft> tft);
 
@@ -516,21 +455,6 @@
                         Ptr<NetDevice> sourceEnbDev, Ptr<NetDevice> targetEnbDev);
 
 
-  /**
-   * Manually trigger an X2-based handover.
-   *
-   * \param hoTime when the handover shall be initiated
-   * \param ueDev the UE that hands off, must be of the type LteUeNetDevice
-   * \param sourceEnbDev source eNB, must be of the type LteEnbNetDevice
-   *                     (originally the UE is attached to this eNB)
-   * \param targetCellId target CellId (the UE primary component carrier will
-   *                     be connected to this cell after the handover)
-   *
-   * \warning Requires the use of EPC mode. See SetEpcHelper() method
-   */
-  void HandoverRequest (Time hoTime, Ptr<NetDevice> ueDev,
-                        Ptr<NetDevice> sourceEnbDev, uint16_t targetCellId);
-
   /** 
    * Activate a Data Radio Bearer on a given UE devices (for LTE-only simulation).
    * 
@@ -666,33 +590,11 @@
   */
   int64_t AssignStreams (NetDeviceContainer c, int64_t stream);
 
-  /** 
-   * \return a pointer to the SpectrumChannel instance used for the uplink
-   */
-  Ptr<SpectrumChannel> GetUplinkSpectrumChannel (void) const;
-
-
-  /** 
-   * \return a pointer to the SpectrumChannel instance used for the downlink
-   */
-  Ptr<SpectrumChannel> GetDownlinkSpectrumChannel (void) const;
-
-
 protected:
   // inherited from Object
   virtual void DoInitialize (void);
 
 private:
-
-  /**
-   * A private function used for component carrier configuration.
-   *
-   * \param ulEarfcn uplink EARFCN - not control on the validity at this point
-   * \param dlEarfcn downlink EARFCN - not control on the validity at this point	
-   * \param ulbw uplink bandwidth for the current CC
-   * \param dlbw downlink bandwidth for the current CC
-   */
-  void DoComponentCarrierConfigure (uint32_t ulEarfcn, uint32_t dlEarfcn, uint8_t ulbw, uint8_t dlbw);
   /**
    * Create an eNodeB device (LteEnbNetDevice) on the given node.
    * \param n the node where the device is to be installed
@@ -712,15 +614,16 @@
    * \param ueDev the UE that hands off, must be of the type LteUeNetDevice
    * \param sourceEnbDev source eNB, must be of the type LteEnbNetDevice
    *                     (originally the UE is attached to this eNB)
-   * \param targetCellId target CellId (the UE primary component carrier will
-   *                     be connected to this cell after the handover)
+   * \param targetEnbDev target eNB, must be of the type LteEnbNetDevice
+   *                     (the UE would be connected to this eNB after the
+   *                     handover)
    *
    * This method is normally scheduled by HandoverRequest() to run at a specific
    * time where a manual handover is desired by the simulation user.
    */
   void DoHandoverRequest (Ptr<NetDevice> ueDev,
                           Ptr<NetDevice> sourceEnbDev,
-                          uint16_t targetCellId);
+                          Ptr<NetDevice> targetEnbDev);
 
 
   /**
@@ -734,19 +637,13 @@
    */
   void DoDeActivateDedicatedEpsBearer (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice, uint8_t bearerId);
 
-  /// Function that performs a channel model initialization of all component carriers
-  void ChannelModelInitialization (void);
-
-  /**
-   * \brief This function create the component carrier based on provided configuration parameters
-   */
 
   /// The downlink LTE channel used in the simulation.
   Ptr<SpectrumChannel> m_downlinkChannel;
   /// The uplink LTE channel used in the simulation.
   Ptr<SpectrumChannel> m_uplinkChannel;
   /// The path loss model used in the downlink channel.
-  Ptr<Object>  m_downlinkPathlossModel;
+  Ptr<Object> m_downlinkPathlossModel;
   /// The path loss model used in the uplink channel.
   Ptr<Object> m_uplinkPathlossModel;
 
@@ -756,10 +653,6 @@
   ObjectFactory m_ffrAlgorithmFactory;
   /// Factory of handover algorithm object.
   ObjectFactory m_handoverAlgorithmFactory;
-  /// Factory of enb component carrier manager object.
-  ObjectFactory m_enbComponentCarrierManagerFactory;
-  /// Factory of ue component carrier manager object.
-  ObjectFactory m_ueComponentCarrierManagerFactory;
   /// Factory of LteEnbNetDevice objects.
   ObjectFactory m_enbNetDeviceFactory;
   /// Factory of antenna object for eNodeB.
@@ -768,8 +661,10 @@
   ObjectFactory m_ueNetDeviceFactory;
   /// Factory of antenna object for UE.
   ObjectFactory m_ueAntennaModelFactory;
-  /// Factory of path loss model object.
-  ObjectFactory m_pathlossModelFactory;
+  /// Factory of path loss model object for the downlink channel.
+  ObjectFactory m_dlPathlossModelFactory;
+  /// Factory of path loss model object for the uplink channel.
+  ObjectFactory m_ulPathlossModelFactory;
   /// Factory of both the downlink and uplink LTE channels.
   ObjectFactory m_channelFactory;
 
@@ -837,25 +732,7 @@
    */
   bool m_usePdschForCqiGeneration;
 
-  /**
-   * The `UseCa` attribute. If true, Carrier Aggregation is enabled.
-   * Hence, the helper will expect a valid component carrier map
-   * If it is false, the component carrier will be created within the LteHelper
-   * this is to maintain the backwards compatibility with user script
-   */
-  bool m_useCa;
-
-  /**
-   * This contains all the information about each component carrier
-   */
-  std::map< uint8_t, ComponentCarrier > m_componentCarrierPhyParams;
-
-  /**
-   * Number of component carriers that will be installed by default at eNodeB and UE devices.
-   */
-  uint16_t m_noOfCcs;
-
-};   // end of `class LteHelper`
+}; // end of `class LteHelper`
 
 
 } // namespace ns3
diff -Naru a/helper/mac-stats-calculator.cc b/helper/mac-stats-calculator.cc
--- a/helper/mac-stats-calculator.cc	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/mac-stats-calculator.cc	2017-10-05 11:47:22.294601711 +0200
@@ -16,8 +16,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Jaume Nin <jnin@cttc.es>
- * Modified by: Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation) 
  */
 
 #include "mac-stats-calculator.h"
@@ -90,10 +88,10 @@
 }
 
 void
-MacStatsCalculator::DlScheduling (uint16_t cellId, uint64_t imsi, DlSchedulingCallbackInfo dlSchedulingCallbackInfo)
+MacStatsCalculator::DlScheduling (uint16_t cellId, uint64_t imsi, uint32_t frameNo, uint32_t subframeNo,
+                                  uint16_t rnti, uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2)
 {
-  NS_LOG_FUNCTION (this << cellId << imsi << dlSchedulingCallbackInfo.frameNo << dlSchedulingCallbackInfo.subframeNo <<
-		  dlSchedulingCallbackInfo.rnti << (uint32_t) dlSchedulingCallbackInfo.mcsTb1 << dlSchedulingCallbackInfo.sizeTb1 << (uint32_t) dlSchedulingCallbackInfo.mcsTb2 << dlSchedulingCallbackInfo.sizeTb2);
+  NS_LOG_FUNCTION (this << cellId << imsi << frameNo << subframeNo << rnti << (uint32_t) mcsTb1 << sizeTb1 << (uint32_t) mcsTb2 << sizeTb2);
   NS_LOG_INFO ("Write DL Mac Stats in " << GetDlOutputFilename ().c_str ());
 
   std::ofstream outFile;
@@ -106,7 +104,7 @@
           return;
         }
       m_dlFirstWrite = false;
-      outFile << "% time\tcellId\tIMSI\tframe\tsframe\tRNTI\tmcsTb1\tsizeTb1\tmcsTb2\tsizeTb2\tccId";
+      outFile << "% time\tcellId\tIMSI\tframe\tsframe\tRNTI\tmcsTb1\tsizeTb1\tmcsTb2\tsizeTb2";
       outFile << std::endl;
     }
   else
@@ -122,20 +120,19 @@
   outFile << Simulator::Now ().GetNanoSeconds () / (double) 1e9 << "\t";
   outFile << (uint32_t) cellId << "\t";
   outFile << imsi << "\t";
-  outFile << dlSchedulingCallbackInfo.frameNo << "\t";
-  outFile << dlSchedulingCallbackInfo.subframeNo << "\t";
-  outFile << dlSchedulingCallbackInfo.rnti << "\t";
-  outFile << (uint32_t) dlSchedulingCallbackInfo.mcsTb1 << "\t";
-  outFile << dlSchedulingCallbackInfo.sizeTb1 << "\t";
-  outFile << (uint32_t) dlSchedulingCallbackInfo.mcsTb2 << "\t";
-  outFile << dlSchedulingCallbackInfo.sizeTb2 << "\t";
-  outFile << (uint32_t) dlSchedulingCallbackInfo.componentCarrierId << std::endl;
+  outFile << frameNo << "\t";
+  outFile << subframeNo << "\t";
+  outFile << rnti << "\t";
+  outFile << (uint32_t) mcsTb1 << "\t";
+  outFile << sizeTb1 << "\t";
+  outFile << (uint32_t) mcsTb2 << "\t";
+  outFile << sizeTb2 << std::endl;
   outFile.close ();
 }
 
 void
 MacStatsCalculator::UlScheduling (uint16_t cellId, uint64_t imsi, uint32_t frameNo,
-                                  uint32_t subframeNo, uint16_t rnti,uint8_t mcsTb, uint16_t size, uint8_t componentCarrierId)
+                                  uint32_t subframeNo, uint16_t rnti,uint8_t mcsTb, uint16_t size)
 {
   NS_LOG_FUNCTION (this << cellId << imsi << frameNo << subframeNo << rnti << (uint32_t) mcsTb << size);
   NS_LOG_INFO ("Write UL Mac Stats in " << GetUlOutputFilename ().c_str ());
@@ -150,7 +147,7 @@
           return;
         }
       m_ulFirstWrite = false;
-      outFile << "% time\tcellId\tIMSI\tframe\tsframe\tRNTI\tmcs\tsize\tccId";
+      outFile << "% time\tcellId\tIMSI\tframe\tsframe\tRNTI\tmcs\tsize";
       outFile << std::endl;
     }
   else
@@ -170,28 +167,30 @@
   outFile << subframeNo << "\t";
   outFile << rnti << "\t";
   outFile << (uint32_t) mcsTb << "\t";
-  outFile << size << "\t";
-  outFile << (uint32_t) componentCarrierId << std::endl;
+  outFile << size << std::endl;
   outFile.close ();
 }
 
 void
-MacStatsCalculator::DlSchedulingCallback (Ptr<MacStatsCalculator> macStats, std::string path, DlSchedulingCallbackInfo dlSchedulingCallbackInfo)
+MacStatsCalculator::DlSchedulingCallback (Ptr<MacStatsCalculator> macStats,
+                      std::string path, uint32_t frameNo, uint32_t subframeNo,
+                      uint16_t rnti, uint8_t mcsTb1, uint16_t sizeTb1,
+                      uint8_t mcsTb2, uint16_t sizeTb2)
 {
   NS_LOG_FUNCTION (macStats << path);
   uint64_t imsi = 0;
   std::ostringstream pathAndRnti;
-  std::string pathEnb  = path.substr (0, path.find ("/ComponentCarrierMap"));
-  pathAndRnti << pathEnb << "/LteEnbRrc/UeMap/" << dlSchedulingCallbackInfo.rnti;
+  pathAndRnti << path << "/" << rnti;
   if (macStats->ExistsImsiPath (pathAndRnti.str ()) == true)
     {
       imsi = macStats->GetImsiPath (pathAndRnti.str ());
     }
   else
     {
-      imsi = FindImsiFromEnbRlcPath (pathAndRnti.str ());
+      imsi = FindImsiFromEnbMac (path, rnti);
       macStats->SetImsiPath (pathAndRnti.str (), imsi);
     }
+
   uint16_t cellId = 0;
   if (macStats->ExistsCellIdPath (pathAndRnti.str ()) == true)
     {
@@ -199,31 +198,30 @@
     }
   else
     {
-      cellId = FindCellIdFromEnbRlcPath (pathAndRnti.str ());
+      cellId = FindCellIdFromEnbMac (path, rnti);
       macStats->SetCellIdPath (pathAndRnti.str (), cellId);
     }
 
-  macStats->DlScheduling (cellId, imsi, dlSchedulingCallbackInfo);
+  macStats->DlScheduling (cellId, imsi, frameNo, subframeNo, rnti, mcsTb1, sizeTb1, mcsTb2, sizeTb2);
 }
 
 void
 MacStatsCalculator::UlSchedulingCallback (Ptr<MacStatsCalculator> macStats, std::string path,
                       uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
-                      uint8_t mcs, uint16_t size, uint8_t componentCarrierId)
+                      uint8_t mcs, uint16_t size)
 {
   NS_LOG_FUNCTION (macStats << path);
 
   uint64_t imsi = 0;
   std::ostringstream pathAndRnti;
-  std::string pathEnb  = path.substr (0, path.find ("/ComponentCarrierMap"));
-  pathAndRnti << pathEnb << "/LteEnbRrc/UeMap/" << rnti;
+  pathAndRnti << path << "/" << rnti;
   if (macStats->ExistsImsiPath (pathAndRnti.str ()) == true)
     {
       imsi = macStats->GetImsiPath (pathAndRnti.str ());
     }
   else
     {
-      imsi = FindImsiFromEnbRlcPath (pathAndRnti.str ());
+      imsi = FindImsiFromEnbMac (path, rnti);
       macStats->SetImsiPath (pathAndRnti.str (), imsi);
     }
   uint16_t cellId = 0;
@@ -233,11 +231,11 @@
     }
   else
     {
-      cellId = FindCellIdFromEnbRlcPath (pathAndRnti.str ());
+      cellId = FindCellIdFromEnbMac (path, rnti);
       macStats->SetCellIdPath (pathAndRnti.str (), cellId);
     }
 
-  macStats->UlScheduling (cellId, imsi, frameNo, subframeNo, rnti, mcs, size, componentCarrierId);
+  macStats->UlScheduling (cellId, imsi, frameNo, subframeNo, rnti, mcs, size);
 }
 
 
diff -Naru a/helper/mac-stats-calculator.h b/helper/mac-stats-calculator.h
--- a/helper/mac-stats-calculator.h	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/mac-stats-calculator.h	2017-10-05 11:47:22.294601711 +0200
@@ -16,8 +16,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Jaume Nin <jnin@cttc.es>
- * Modified by: Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *              Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation) 
  */
 
 #ifndef MAC_STATS_CALCULATOR_H_
@@ -28,7 +26,6 @@
 #include "ns3/uinteger.h"
 #include <string>
 #include <fstream>
-#include "ns3/lte-enb-mac.h"
 
 namespace ns3 {
 
@@ -95,18 +92,16 @@
    * Notifies the stats calculator that an downlink scheduling has occurred.
    * @param cellId Cell ID of the attached Enb
    * @param imsi IMSI of the scheduled UE
-   * @param dlSchedulingCallbackInfo the structure that contains downlink scheduling fields:
-   * frameNo Frame number
-   * subframeNo Subframe number
-   * rnti C-RNTI scheduled
-   * mcsTb1 MCS for transport block 1
-   * sizeTb1 Size of transport block 1
-   * mcsTb2 MCS for transport block 2 (0 if not used)
-   * sizeTb2 Size of transport block 2 (0 if not used)
-   * componentCarrierId component carrier ID
+   * @param frameNo Frame number
+   * @param subframeNo Subframe number
+   * @param rnti C-RNTI scheduled
+   * @param mcsTb1 MCS for transport block 1
+   * @param sizeTb1 Size of transport block 1
+   * @param mcsTb2 MCS for transport block 2 (0 if not used)
+   * @param sizeTb2 Size of transport block 2 (0 if not used)
    */
-
-  void DlScheduling (uint16_t cellId, uint64_t imsi, DlSchedulingCallbackInfo dlSchedulingCallbackInfo);
+  void DlScheduling (uint16_t cellId, uint64_t imsi, uint32_t frameNo, uint32_t subframeNo,
+                     uint16_t rnti, uint8_t mcsTb1, uint16_t sizeTb1, uint8_t mcsTb2, uint16_t sizeTb2);
 
   /**
    * Notifies the stats calculator that an uplink scheduling has occurred.
@@ -117,10 +112,9 @@
    * @param rnti C-RNTI scheduled
    * @param mcsTb MCS for transport block
    * @param sizeTb Size of transport block
-   * @param componentCarrierId component carrier ID
    */
   void UlScheduling (uint16_t cellId, uint64_t imsi,uint32_t frameNo, uint32_t subframeNo,
-                     uint16_t rnti, uint8_t mcsTb, uint16_t sizeTb, uint8_t componentCarrierId);
+                     uint16_t rnti, uint8_t mcsTb, uint16_t sizeTb);
 
   
   /** 
@@ -128,9 +122,18 @@
    * 
    * \param macStats 
    * \param path 
-   * \param dlSchedulingCallbackInfo DlSchedulingCallbackInfo structure containing all downlink information that is generated what DlScheduling traces is fired
-   */
-  static void DlSchedulingCallback (Ptr<MacStatsCalculator> macStats, std::string path, DlSchedulingCallbackInfo dlSchedulingCallbackInfo);
+   * \param frameNo 
+   * \param subframeNo 
+   * \param rnti 
+   * \param mcsTb1 
+   * \param sizeTb1 
+   * \param mcsTb2 
+   * \param sizeTb2 
+   */
+  static void DlSchedulingCallback (Ptr<MacStatsCalculator> macStats,
+                             std::string path, uint32_t frameNo, uint32_t subframeNo,
+                             uint16_t rnti, uint8_t mcsTb1, uint16_t sizeTb1,
+                             uint8_t mcsTb2, uint16_t sizeTb2);
 
   /** 
    * Trace sink for the ns3::LteEnbMac::UlScheduling trace source
@@ -142,11 +145,10 @@
    * \param rnti 
    * \param mcs 
    * \param size 
-   * \param componentCarrierId
    */
   static void UlSchedulingCallback (Ptr<MacStatsCalculator> macStats, std::string path,
                              uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
-                             uint8_t mcs, uint16_t size, uint8_t componentCarrierId);
+                             uint8_t mcs, uint16_t size);
 
 
 private:
diff -Naru a/helper/mac-tx-stats-calculator.cc b/helper/mac-tx-stats-calculator.cc
--- a/helper/mac-tx-stats-calculator.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/mac-tx-stats-calculator.cc	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,98 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "mac-tx-stats-calculator.h"
+#include "ns3/string.h"
+#include "ns3/nstime.h"
+#include <ns3/log.h>
+#include <vector>
+#include <algorithm>
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("MacTxStatsCalculator");
+
+NS_OBJECT_ENSURE_REGISTERED ( MacTxStatsCalculator);
+
+MacTxStatsCalculator::MacTxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+
+MacTxStatsCalculator::~MacTxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+MacTxStatsCalculator::GetTypeId (void)
+{
+  static TypeId tid =
+    TypeId ("ns3::MacTxStatsCalculator")
+    .SetParent<Object> ().AddConstructor<MacTxStatsCalculator> ()
+    .SetGroupName("Lte")
+    .AddAttribute ("DlMacTxFilename",
+                   "Name of the file where the MAC downlink tx results will be saved.",
+                   StringValue ("DlMacTx.txt"),
+                   MakeStringAccessor (&MacTxStatsCalculator::m_retxDlFilename),
+                   MakeStringChecker ())
+    .AddAttribute ("UlMacTxFilename",
+                   "Name of the file where the MAC uplink tx results will be saved.",
+                   StringValue ("UlMacTx.txt"),
+                   MakeStringAccessor (&MacTxStatsCalculator::m_retxUlFilename),
+                   MakeStringChecker ())
+    ;
+  return tid;
+}
+
+void
+MacTxStatsCalculator::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+MacTxStatsCalculator::RegisterMacTxDl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx)
+{
+	if(!m_retxDlFile.is_open())
+	{
+	    m_retxDlFile.open(m_retxDlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+	}
+  NS_LOG_LOGIC(rnti << cellId << packetSize << numRetx);
+	m_retxDlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << rnti << " "  << packetSize << " " << (uint32_t)numRetx << std::endl;
+}
+
+void
+MacTxStatsCalculator::RegisterMacTxUl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx)
+{
+	if(!m_retxUlFile.is_open())
+	{
+	    m_retxUlFile.open(m_retxUlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+	}
+  m_retxUlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << rnti << " "  << packetSize << " " << (uint32_t)numRetx << std::endl;
+}
+
+}
\ No newline at end of file
diff -Naru a/helper/mac-tx-stats-calculator.h b/helper/mac-tx-stats-calculator.h
--- a/helper/mac-tx-stats-calculator.h	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/mac-tx-stats-calculator.h	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,73 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef MAC_TX_STATS_CALCULATOR_H_
+#define MAC_TX_STATS_CALCULATOR_H_
+
+#include "ns3/lte-common.h"
+#include "ns3/uinteger.h"
+#include "ns3/object.h"
+#include "ns3/basic-data-calculators.h"
+#include "ns3/lte-common.h"
+#include <string>
+#include <map>
+#include <fstream>
+
+namespace ns3
+{
+
+class MacTxStatsCalculator : public Object
+{
+public:
+  /**
+   * Class constructor
+   */
+  MacTxStatsCalculator ();
+
+  /**
+   * Class destructor
+   */
+  virtual
+  ~MacTxStatsCalculator ();
+
+  // Inherited from ns3::Object
+  /**
+   *  Register this type.
+   *  \return The object TypeId.
+   */
+  static TypeId GetTypeId (void);
+  void DoDispose ();
+
+  void RegisterMacTxDl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx);
+  void RegisterMacTxUl(uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx);
+
+  std::ofstream m_retxDlFile;
+  std::string m_retxDlFilename;
+
+  std::ofstream m_retxUlFile;
+  std::string m_retxUlFilename;
+};
+
+}
+
+#endif /* MAC_TX_STATS_CALCULATOR_H_ */
diff -Naru a/helper/phy-rx-stats-calculator.cc b/helper/phy-rx-stats-calculator.cc
--- a/helper/phy-rx-stats-calculator.cc	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/phy-rx-stats-calculator.cc	2017-10-05 11:47:22.294601711 +0200
@@ -105,7 +105,7 @@
           return;
         }
       m_dlRxFirstWrite = false;
-      outFile << "% time\tcellId\tIMSI\tRNTI\ttxMode\tlayer\tmcs\tsize\trv\tndi\tcorrect\tccId";
+      outFile << "% time\tcellId\tIMSI\tRNTI\ttxMode\tlayer\tmcs\tsize\trv\tndi\tcorrect";
       outFile << std::endl;
     }
   else
@@ -129,8 +129,7 @@
   outFile << params.m_size << "\t";
   outFile << (uint32_t) params.m_rv << "\t";
   outFile << (uint32_t) params.m_ndi << "\t";
-  outFile << (uint32_t) params.m_correctness << "\t";
-  outFile << (uint32_t) params.m_ccId << std::endl;
+  outFile << (uint32_t) params.m_correctness << std::endl;
   outFile.close ();
 }
 
@@ -150,7 +149,7 @@
           return;
         }
       m_ulRxFirstWrite = false;
-      outFile << "% time\tcellId\tIMSI\tRNTI\tlayer\tmcs\tsize\trv\tndi\tcorrect\tccId";
+      outFile << "% time\tcellId\tIMSI\tRNTI\tlayer\tmcs\tsize\trv\tndi\tcorrect";
       outFile << std::endl;
     }
   else
@@ -173,8 +172,7 @@
   outFile << params.m_size << "\t";
   outFile << (uint32_t) params.m_rv << "\t";
   outFile << (uint32_t) params.m_ndi << "\t";
-  outFile << (uint32_t) params.m_correctness << "\t";
-  outFile << (uint32_t) params.m_ccId <<std::endl;
+  outFile << (uint32_t) params.m_correctness << std::endl;
   outFile.close ();
 }
 
@@ -186,14 +184,13 @@
   uint64_t imsi = 0;
   std::ostringstream pathAndRnti;
   pathAndRnti << path << "/" << params.m_rnti;
-  std::string pathUePhy  = path.substr (0, path.find ("/ComponentCarrierMapUe"));
   if (phyRxStats->ExistsImsiPath (pathAndRnti.str ()) == true)
     {
       imsi = phyRxStats->GetImsiPath (pathAndRnti.str ());
     }
   else
     {
-      imsi = FindImsiFromLteNetDevice (pathUePhy);
+      imsi = FindImsiForUe (path, params.m_rnti);
       phyRxStats->SetImsiPath (pathAndRnti.str (), imsi);
     }
 
@@ -208,15 +205,14 @@
   NS_LOG_FUNCTION (phyRxStats << path);
   uint64_t imsi = 0;
   std::ostringstream pathAndRnti;
-  std::string pathEnb  = path.substr (0, path.find ("/ComponentCarrierMap"));
-  pathAndRnti << pathEnb << "/LteEnbRrc/UeMap/" << params.m_rnti;
+  pathAndRnti << path << "/" << params.m_rnti;
   if (phyRxStats->ExistsImsiPath (pathAndRnti.str ()) == true)
     {
       imsi = phyRxStats->GetImsiPath (pathAndRnti.str ());
     }
   else
     {
-      imsi = FindImsiFromEnbRlcPath (pathAndRnti.str ());
+      imsi = FindImsiForEnb (path, params.m_rnti);
       phyRxStats->SetImsiPath (pathAndRnti.str (), imsi);
     }
 
diff -Naru a/helper/phy-stats-calculator.cc b/helper/phy-stats-calculator.cc
--- a/helper/phy-stats-calculator.cc	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/phy-stats-calculator.cc	2017-10-05 11:47:22.294601711 +0200
@@ -16,7 +16,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Jaume Nin <jnin@cttc.es>
- *         Danilo Abrignani <danilo.abrignani@unibo.it> (Modification due to new Architecture - Carrier Aggregation - GSoC 2015)
  */
 
 #include "phy-stats-calculator.h"
@@ -110,7 +109,7 @@
 
 void
 PhyStatsCalculator::ReportCurrentCellRsrpSinr (uint16_t cellId, uint64_t imsi, uint16_t rnti,
-                                               double rsrp, double sinr, uint8_t componentCarrierId)
+                                               double rsrp, double sinr)
 {
   NS_LOG_FUNCTION (this << cellId <<  imsi << rnti  << rsrp << sinr);
   NS_LOG_INFO ("Write RSRP/SINR Phy Stats in " << GetCurrentCellRsrpSinrFilename ().c_str ());
@@ -125,7 +124,7 @@
           return;
         }
       m_RsrpSinrFirstWrite = false;
-      outFile << "% time\tcellId\tIMSI\tRNTI\trsrp\tsinr\tComponentCarrierId";
+      outFile << "% time\tcellId\tIMSI\tRNTI\trsrp\tsinr";
       outFile << std::endl;
     }
   else
@@ -143,13 +142,12 @@
   outFile << imsi << "\t";
   outFile << rnti << "\t";
   outFile << rsrp << "\t";
-  outFile << sinr << "\t";
-  outFile << (uint32_t)componentCarrierId << std::endl;
+  outFile << sinr << std::endl;
   outFile.close ();
 }
 
 void
-PhyStatsCalculator::ReportUeSinr (uint16_t cellId, uint64_t imsi, uint16_t rnti,  double sinrLinear, uint8_t componentCarrierId)
+PhyStatsCalculator::ReportUeSinr (uint16_t cellId, uint64_t imsi, uint16_t rnti,  double sinrLinear)
 {
   NS_LOG_FUNCTION (this << cellId <<  imsi << rnti  << sinrLinear);
   NS_LOG_INFO ("Write SINR Linear Phy Stats in " << GetUeSinrFilename ().c_str ());
@@ -164,7 +162,7 @@
           return;
         }
       m_UeSinrFirstWrite = false;
-      outFile << "% time\tcellId\tIMSI\tRNTI\tsinrLinear\tcomponentCarrierId";
+      outFile << "% time\tcellId\tIMSI\tRNTI\tsinrLinear";
       outFile << std::endl;
     }
   else
@@ -181,8 +179,7 @@
   outFile << cellId << "\t";
   outFile << imsi << "\t";
   outFile << rnti << "\t";
-  outFile << sinrLinear << "\t";
-  outFile << (uint32_t)componentCarrierId << std::endl;
+  outFile << sinrLinear << std::endl;
   outFile.close ();
 }
 
@@ -225,35 +222,35 @@
 void
 PhyStatsCalculator::ReportCurrentCellRsrpSinrCallback (Ptr<PhyStatsCalculator> phyStats,
                       std::string path, uint16_t cellId, uint16_t rnti,
-                      double rsrp, double sinr, uint8_t componentCarrierId)
+                      double rsrp, double sinr)
 {
   NS_LOG_FUNCTION (phyStats << path);
   uint64_t imsi = 0;
-  std::string pathUePhy  = path.substr (0, path.find ("/ComponentCarrierMapUe"));
+  std::string pathUePhy  = path.substr (0, path.find ("/ReportCurrentCellRsrpSinr"));
   if (phyStats->ExistsImsiPath (pathUePhy) == true)
     {
       imsi = phyStats->GetImsiPath (pathUePhy);
     }
   else
     {
-      imsi = FindImsiFromLteNetDevice (pathUePhy);
+      imsi = FindImsiFromUePhy (pathUePhy);
       phyStats->SetImsiPath (pathUePhy, imsi);
     }
 
-  phyStats->ReportCurrentCellRsrpSinr (cellId, imsi, rnti, rsrp, sinr, componentCarrierId);
+  phyStats->ReportCurrentCellRsrpSinr (cellId, imsi, rnti, rsrp,sinr);
 }
 
 void
 PhyStatsCalculator::ReportUeSinr (Ptr<PhyStatsCalculator> phyStats, std::string path,
-                                  uint16_t cellId, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId)
+              uint16_t cellId, uint16_t rnti, double sinrLinear)
 {
   NS_LOG_FUNCTION (phyStats << path);
 
   uint64_t imsi = 0;
   std::ostringstream pathAndRnti;
   pathAndRnti << path << "/" << rnti;
-  std::string pathEnbMac  = path.substr (0, path.find ("/ComponentCarrierMap"));
-  pathEnbMac += "/LteEnbMac/DlScheduling";
+  std::string pathEnbMac  = path.substr (0, path.find ("LteEnbPhy/ReportUeSinr"));
+  pathEnbMac += "LteEnbMac/DlScheduling";
   if (phyStats->ExistsImsiPath (pathAndRnti.str ()) == true)
     {
       imsi = phyStats->GetImsiPath (pathAndRnti.str ());
@@ -264,7 +261,7 @@
       phyStats->SetImsiPath (pathAndRnti.str (), imsi);
     }
 
-  phyStats->ReportUeSinr (cellId, imsi, rnti, sinrLinear, componentCarrierId);
+  phyStats->ReportUeSinr (cellId, imsi, rnti, sinrLinear);
 }
 
 void
diff -Naru a/helper/phy-stats-calculator.h b/helper/phy-stats-calculator.h
--- a/helper/phy-stats-calculator.h	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/phy-stats-calculator.h	2017-10-05 11:47:22.294601711 +0200
@@ -40,14 +40,12 @@
  *   - C-RNTI
  *   - RSRP
  *   - SINR
- *   - componentCarrierId
  * - UE SINR
  *   - Timestamp (in seconds)
  *   - Cell ID of the reported Enb
  *   - IMSI
  *   - C-RNTI
  *   - measured and reported SINR value in linear
- *   - componentCarrierId
  * - Interference for UL
  *   - Cell ID of the reported Enb
  *   - IMSI of the scheduled UE
@@ -120,9 +118,8 @@
    * @param rnti C-RNTI scheduled
    * @param rsrp Reference Signal Received Power
    * @param sinr SINR averaged among RBs
-   * @param componentCarrierId
    */
-  void ReportCurrentCellRsrpSinr (uint16_t cellId, uint64_t imsi, uint16_t rnti, double rsrp, double sinr, uint8_t componentCarrierId);
+  void ReportCurrentCellRsrpSinr (uint16_t cellId, uint64_t imsi, uint16_t rnti, double rsrp, double sinr);
 
   /**
    * Notifies the stats calculator that an UE SINR report has occurred.
@@ -130,9 +127,8 @@
    * @param imsi IMSI of the scheduled UE
    * @param rnti C-RNTI scheduled
    * @param sinrLinear measured and reported SINR value in linear
-   * @param componentCarrierId
    */
-  void ReportUeSinr (uint16_t cellId, uint64_t imsi, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId);
+  void ReportUeSinr (uint16_t cellId, uint64_t imsi, uint16_t rnti, double sinrLinear);
 
   /**
    * Notifies the stats calculator that an interference report has occurred.
@@ -150,11 +146,10 @@
    * \param rnti 
    * \param rsrp 
    * \param sinr 
-   * \param componentCarrierId
    */
   static void ReportCurrentCellRsrpSinrCallback (Ptr<PhyStatsCalculator> phyStats,
                                           std::string path, uint16_t cellId, uint16_t rnti,
-                                          double rsrp, double sinr, uint8_t componentCarrierId);
+                                          double rsrp, double sinr);
   
   /** 
    * trace sink
@@ -163,11 +158,10 @@
    * \param path 
    * \param cellId 
    * \param rnti 
-   * \param sinrLinear
-   * \param componentCarrierId
+   * \param sinrLinear 
    */
   static void ReportUeSinr (Ptr<PhyStatsCalculator> phyStats, std::string path,
-                     uint16_t cellId, uint16_t rnti, double sinrLinear, uint8_t componentCarrierId);
+                     uint16_t cellId, uint16_t rnti, double sinrLinear);
 
   /** 
    * trace sink
diff -Naru a/helper/phy-tx-stats-calculator.cc b/helper/phy-tx-stats-calculator.cc
--- a/helper/phy-tx-stats-calculator.cc	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/phy-tx-stats-calculator.cc	2017-10-05 11:47:22.294601711 +0200
@@ -106,7 +106,7 @@
         }
       m_dlTxFirstWrite = false;
       //outFile << "% time\tcellId\tIMSI\tRNTI\tlayer\tmcs\tsize\trv\tndi"; // txMode is not available at dl tx side
-      outFile << "% time\tcellId\tIMSI\tRNTI\tlayer\tmcs\tsize\trv\tndi\tccId";
+      outFile << "% time\tcellId\tIMSI\tRNTI\tlayer\tmcs\tsize\trv\tndi";
       outFile << std::endl;
     }
   else
@@ -129,8 +129,7 @@
   outFile << (uint32_t) params.m_mcs << "\t";
   outFile << params.m_size << "\t";
   outFile << (uint32_t) params.m_rv << "\t";
-  outFile << (uint32_t) params.m_ndi << "\t";
-  outFile << (uint32_t) params.m_ccId << std::endl;
+  outFile << (uint32_t) params.m_ndi << std::endl;
   outFile.close ();
 }
 
@@ -151,7 +150,7 @@
         }
       m_ulTxFirstWrite = false;
 //       outFile << "% time\tcellId\tIMSI\tRNTI\ttxMode\tlayer\tmcs\tsize\trv\tndi";
-      outFile << "% time\tcellId\tIMSI\tRNTI\tlayer\tmcs\tsize\trv\tndi\tccId";
+      outFile << "% time\tcellId\tIMSI\tRNTI\tlayer\tmcs\tsize\trv\tndi";
       outFile << std::endl;
     }
   else
@@ -174,8 +173,7 @@
   outFile << (uint32_t) params.m_mcs << "\t";
   outFile << params.m_size << "\t";
   outFile << (uint32_t) params.m_rv << "\t";
-  outFile << (uint32_t) params.m_ndi << "\t";
-  outFile << (uint32_t) params.m_ccId << std::endl;
+  outFile << (uint32_t) params.m_ndi << std::endl;
   outFile.close ();
 }
 
@@ -186,15 +184,14 @@
   NS_LOG_FUNCTION (phyTxStats << path);
   uint64_t imsi = 0;
   std::ostringstream pathAndRnti;
-  std::string pathEnb  = path.substr (0, path.find ("/ComponentCarrierMap"));
-  pathAndRnti << pathEnb << "/LteEnbRrc/UeMap/" << params.m_rnti;
+  pathAndRnti << path << "/" << params.m_rnti;
   if (phyTxStats->ExistsImsiPath (pathAndRnti.str ()) == true)
     {
       imsi = phyTxStats->GetImsiPath (pathAndRnti.str ());
     }
   else
     {
-      imsi = FindImsiFromEnbRlcPath (pathAndRnti.str ());
+      imsi = FindImsiForEnb (path, params.m_rnti);
       phyTxStats->SetImsiPath (pathAndRnti.str (), imsi);
     }
 
@@ -210,14 +207,13 @@
   uint64_t imsi = 0;
   std::ostringstream pathAndRnti;
   pathAndRnti << path << "/" << params.m_rnti;
-  std::string pathUePhy  = path.substr (0, path.find ("/ComponentCarrierMapUe"));
   if (phyTxStats->ExistsImsiPath (pathAndRnti.str ()) == true)
     {
       imsi = phyTxStats->GetImsiPath (pathAndRnti.str ());
     }
   else
     {
-      imsi = FindImsiFromLteNetDevice (pathUePhy);
+      imsi = FindImsiForUe (path, params.m_rnti);
       phyTxStats->SetImsiPath (pathAndRnti.str (), imsi);
     }
 
diff -Naru a/helper/point-to-point-epc-helper.cc b/helper/point-to-point-epc-helper.cc
--- a/helper/point-to-point-epc-helper.cc	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/point-to-point-epc-helper.cc	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Support for real S1AP link
  */
 
 #include <ns3/point-to-point-epc-helper.h>
@@ -35,9 +39,10 @@
 
 #include <ns3/lte-enb-rrc.h>
 #include <ns3/epc-x2.h>
+#include <ns3/epc-s1ap.h>
 #include <ns3/lte-enb-net-device.h>
 #include <ns3/lte-ue-net-device.h>
-#include <ns3/epc-mme.h>
+#include <ns3/epc-mme-application.h>
 #include <ns3/epc-ue-nas.h>
 
 namespace ns3 {
@@ -48,15 +53,16 @@
 
 
 PointToPointEpcHelper::PointToPointEpcHelper () 
-  : m_gtpuUdpPort (2152)  // fixed by the standard
+  : m_gtpuUdpPort (2152),  // fixed by the standard
+    m_s1apUdpPort (36412)
 {
   NS_LOG_FUNCTION (this);
 
-  // since we use point-to-point links for all S1-U links, 
+  // since we use point-to-point links for all S1-U and S1-AP links, 
   // we use a /30 subnet which can hold exactly two addresses 
   // (remember that net broadcast and null address are not valid)
   m_s1uIpv4AddressHelper.SetBase ("10.0.0.0", "255.255.255.252");
-
+  m_s1apIpv4AddressHelper.SetBase ("11.0.0.0", "255.255.255.252");
   m_x2Ipv4AddressHelper.SetBase ("12.0.0.0", "255.255.255.252");
 
   // we use a /8 net for all UEs
@@ -66,12 +72,21 @@
   m_sgwPgw = CreateObject<Node> ();
   InternetStackHelper internet;
   internet.Install (m_sgwPgw);
+
+  // create MmeNode
+  m_mmeNode = CreateObject<Node> ();
+  internet.Install (m_mmeNode);
   
-  // create S1-U socket
+  // create S1-U socket for SgwPgwNode
   Ptr<Socket> sgwPgwS1uSocket = Socket::CreateSocket (m_sgwPgw, TypeId::LookupByName ("ns3::UdpSocketFactory"));
   int retval = sgwPgwS1uSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_gtpuUdpPort));
   NS_ASSERT (retval == 0);
 
+  // create S1-AP socket for MmeNode
+  Ptr<Socket> mmeS1apSocket = Socket::CreateSocket (m_mmeNode, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = mmeS1apSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_s1apUdpPort)); // it listens on any IP, port m_s1apUdpPort
+  NS_ASSERT (retval == 0);
+
   // create TUN device implementing tunneling of user data over GTP-U/UDP/IP 
   m_tunDevice = CreateObject<VirtualNetDevice> ();
   // allow jumbo packets
@@ -96,10 +111,18 @@
   // connect SgwPgwApplication and virtual net device for tunneling
   m_tunDevice->SetSendCallback (MakeCallback (&EpcSgwPgwApplication::RecvFromTunDevice, m_sgwPgwApp));
 
-  // Create MME and connect with SGW via S11 interface
-  m_mme = CreateObject<EpcMme> ();
-  m_mme->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
-  m_sgwPgwApp->SetS11SapMme (m_mme->GetS11SapMme ());
+  // create S1apMme object and aggregate it with the m_mmeNode
+  Ptr<EpcS1apMme> s1apMme = CreateObject<EpcS1apMme> (mmeS1apSocket, 1); // for now, only one mme!
+  m_mmeNode->AggregateObject(s1apMme);
+
+  // create EpcMmeApplication and connect with SGW via S11 interface
+  m_mmeApp = CreateObject<EpcMmeApplication> ();
+  m_mmeNode->AddApplication (m_mmeApp);
+  m_mmeApp->SetS11SapSgw (m_sgwPgwApp->GetS11SapSgw ());
+  m_sgwPgwApp->SetS11SapMme (m_mmeApp->GetS11SapMme ());
+  // connect m_mmeApp to the s1apMme
+  m_mmeApp->SetS1apSapMmeProvider(s1apMme->GetEpcS1apSapMmeProvider());
+  s1apMme->SetEpcS1apSapMmeUser(m_mmeApp->GetS1apSapMme());
 }
 
 PointToPointEpcHelper::~PointToPointEpcHelper ()
@@ -129,6 +152,21 @@
                    UintegerValue (2000),
                    MakeUintegerAccessor (&PointToPointEpcHelper::m_s1uLinkMtu),
                    MakeUintegerChecker<uint16_t> ())
+    .AddAttribute ("S1apLinkDataRate", 
+                   "The data rate to be used for the S1-AP link to be created",
+                   DataRateValue (DataRate ("10Mb/s")),
+                   MakeDataRateAccessor (&PointToPointEpcHelper::m_s1apLinkDataRate),
+                   MakeDataRateChecker ())
+    .AddAttribute ("S1apLinkDelay", 
+                   "The delay to be used for the S1-AP link to be created",
+                   TimeValue (Seconds (0.2)),
+                   MakeTimeAccessor (&PointToPointEpcHelper::m_s1apLinkDelay),
+                   MakeTimeChecker ())
+    .AddAttribute ("S1apLinkMtu", 
+                   "The MTU of the next S1-AP link to be created",
+                   UintegerValue (2000),
+                   MakeUintegerAccessor (&PointToPointEpcHelper::m_s1apLinkMtu),
+                   MakeUintegerChecker<uint16_t> ())
     .AddAttribute ("X2LinkDataRate",
                    "The data rate to be used for the next X2 link to be created",
                    DataRateValue (DataRate ("10Gb/s")),
@@ -195,7 +233,31 @@
   Ptr<Socket> enbS1uSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::UdpSocketFactory"));
   int retval = enbS1uSocket->Bind (InetSocketAddress (enbAddress, m_gtpuUdpPort));
   NS_ASSERT (retval == 0);
+
+
+  // create a point to point link between the new eNB and the MME with
+  // the corresponding new NetDevices on each side
+  NodeContainer enbMmeNodes;
+  enbMmeNodes.Add (m_mmeNode);
+  enbMmeNodes.Add (enb);
+  PointToPointHelper p2ph_mme;
+  p2ph_mme.SetDeviceAttribute ("DataRate", DataRateValue (m_s1apLinkDataRate));
+  p2ph_mme.SetDeviceAttribute ("Mtu", UintegerValue (m_s1apLinkMtu));
+  p2ph_mme.SetChannelAttribute ("Delay", TimeValue (m_s1apLinkDelay));  
+  NetDeviceContainer enbMmeDevices = p2ph_mme.Install (enb, m_mmeNode);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after installing p2p dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());  
+
+  m_s1apIpv4AddressHelper.NewNetwork ();
+  Ipv4InterfaceContainer enbMmeIpIfaces = m_s1apIpv4AddressHelper.Assign (enbMmeDevices);
+  NS_LOG_LOGIC ("number of Ipv4 ifaces of the eNB after assigning Ipv4 addr to S1 dev: " << enb->GetObject<Ipv4> ()->GetNInterfaces ());
   
+  Ipv4Address mme_enbAddress = enbMmeIpIfaces.GetAddress (0);
+  Ipv4Address mmeAddress = enbMmeIpIfaces.GetAddress (1);
+
+  // create S1-AP socket for the ENB
+  Ptr<Socket> enbS1apSocket = Socket::CreateSocket (enb, TypeId::LookupByName ("ns3::UdpSocketFactory"));
+  retval = enbS1apSocket->Bind (InetSocketAddress (mme_enbAddress, m_s1apUdpPort));
+  NS_ASSERT (retval == 0);
 
   // give PacketSocket powers to the eNB
   //PacketSocketHelper packetSocket;
@@ -229,9 +291,18 @@
   enb->AggregateObject (x2);
 
   NS_LOG_INFO ("connect S1-AP interface");
-  m_mme->AddEnb (cellId, enbAddress, enbApp->GetS1apSapEnb ());
+
+  uint16_t mmeId = 1;
+  Ptr<EpcS1apEnb> s1apEnb = CreateObject<EpcS1apEnb> (enbS1apSocket, mme_enbAddress, mmeAddress, cellId, mmeId); // only one mme!
+  enb->AggregateObject(s1apEnb);
+  enbApp->SetS1apSapMme (s1apEnb->GetEpcS1apSapEnbProvider ());
+  s1apEnb->SetEpcS1apSapEnbUser (enbApp->GetS1apSapEnb());
+  m_mmeApp->AddEnb (cellId, mme_enbAddress); // TODO consider if this can be removed
+  // add the interface to the S1AP endpoint on the MME
+  Ptr<EpcS1apMme> s1apMme = m_mmeNode->GetObject<EpcS1apMme> ();
+  s1apMme->AddS1apInterface (cellId, mme_enbAddress);
+  
   m_sgwPgwApp->AddEnb (cellId, enbAddress, sgwAddress);
-  enbApp->SetS1apSapMme (m_mme->GetS1apSapMme ());
 }
 
 
@@ -287,7 +358,7 @@
 {
   NS_LOG_FUNCTION (this << imsi << ueDevice );
   
-  m_mme->AddUe (imsi);
+  m_mmeApp->AddUe (imsi);
   m_sgwPgwApp->AddUe (imsi);
   
 
@@ -308,14 +379,38 @@
   NS_ASSERT (interface >= 0);
   NS_ASSERT (ueIpv4->GetNAddresses (interface) == 1);
   Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
-  NS_LOG_LOGIC (" UE IP address: " << ueAddr);  m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
+  NS_LOG_LOGIC (" UE IP address: " << ueAddr);  
+  m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
   
-  uint8_t bearerId = m_mme->AddBearer (imsi, tft, bearer);
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
   Ptr<LteUeNetDevice> ueLteDevice = ueDevice->GetObject<LteUeNetDevice> ();
   if (ueLteDevice)
     {
       ueLteDevice->GetNas ()->ActivateEpsBearer (bearer, tft);
     }
+  NS_LOG_LOGIC("Bearer Id added in mmeApp " << bearerId);
+  return bearerId;
+}
+
+uint8_t
+PointToPointEpcHelper::ActivateEpsBearer (Ptr<NetDevice> ueDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer)
+{
+  NS_LOG_FUNCTION (this << ueDevice << imsi);
+
+  // we now retrieve the IPv4 address of the UE and notify it to the SGW;
+  // we couldn't do it before since address assignment is triggered by
+  // the user simulation program, rather than done by the EPC   
+  Ptr<Node> ueNode = ueDevice->GetNode (); 
+  Ptr<Ipv4> ueIpv4 = ueNode->GetObject<Ipv4> ();
+  NS_ASSERT_MSG (ueIpv4 != 0, "UEs need to have IPv4 installed before EPS bearers can be activated");
+  int32_t interface =  ueIpv4->GetInterfaceForDevice (ueDevice);
+  NS_ASSERT (interface >= 0);
+  NS_ASSERT (ueIpv4->GetNAddresses (interface) == 1);
+  Ipv4Address ueAddr = ueIpv4->GetAddress (interface, 0).GetLocal ();
+  NS_LOG_LOGIC (" UE IP address: " << ueAddr);  m_sgwPgwApp->SetUeAddress (imsi, ueAddr);
+  
+  uint8_t bearerId = m_mmeApp->AddBearer (imsi, tft, bearer);
+  ueNas->ActivateEpsBearer (bearer, tft);
   return bearerId;
 }
 
@@ -326,6 +421,13 @@
   return m_sgwPgw;
 }
 
+Ptr<Node>
+PointToPointEpcHelper::GetMmeNode ()
+{
+  return m_mmeNode;
+}
+
+
 
 Ipv4InterfaceContainer 
 PointToPointEpcHelper::AssignUeIpv4Address (NetDeviceContainer ueDevices)
diff -Naru a/helper/point-to-point-epc-helper.h b/helper/point-to-point-epc-helper.h
--- a/helper/point-to-point-epc-helper.h	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/point-to-point-epc-helper.h	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011-2013 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Jaume Nin <jnin@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *        Support for real S1AP link
  */
 
 #ifndef POINT_TO_POINT_EPC_HELPER_H
@@ -38,6 +42,10 @@
 class EpcSgwPgwApplication;
 class EpcX2;
 class EpcMme;
+class EpcUeNas;
+class EpcMmeApplication;
+class EpcS1apEnb;
+class EpcS1apMme;
 
 /**
  * \ingroup lte
@@ -45,7 +53,7 @@
  *
  * This Helper will create an EPC network topology comprising of a
  * single node that implements both the SGW and PGW functionality, and
- * an MME node. The S1-U, X2-U and X2-C interfaces are realized over
+ * an MME node. The S1-U, S1-AP, X2-U and X2-C interfaces are realized over
  * PointToPoint links. 
  */
 class PointToPointEpcHelper : public EpcHelper
@@ -75,7 +83,9 @@
   virtual void AddUe (Ptr<NetDevice> ueLteDevice, uint64_t imsi);
   virtual void AddX2Interface (Ptr<Node> enbNode1, Ptr<Node> enbNode2);
   virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
+  virtual uint8_t ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, Ptr<EpcUeNas> ueNas, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
   virtual Ptr<Node> GetPgwNode ();
+  virtual Ptr<Node> GetMmeNode ();
   virtual Ipv4InterfaceContainer AssignUeIpv4Address (NetDeviceContainer ueDevices);
   virtual Ipv4Address GetUeDefaultGatewayAddress ();
 
@@ -106,7 +116,12 @@
   /**
    * MME network element
    */
-  Ptr<EpcMme> m_mme;
+  Ptr<Node> m_mmeNode;
+
+  /**
+   * MME application
+   */
+  Ptr<EpcMmeApplication> m_mmeApp;
 
   /**
    * S1-U interfaces
@@ -144,6 +159,42 @@
    * Map storing for each IMSI the corresponding eNB NetDevice
    */
   std::map<uint64_t, Ptr<NetDevice> > m_imsiEnbDeviceMap;
+
+  /**
+   * S1-AP interfaces
+   */
+
+  /** 
+   * helper to assign addresses to S1-AP NetDevices 
+   */
+  Ipv4AddressHelper m_s1apIpv4AddressHelper; 
+
+  /**
+   * The data rate to be used for the next S1-AP link to be created
+   */
+  DataRate m_s1apLinkDataRate;
+
+  /**
+   * The delay to be used for the next S1-AP link to be created
+   */
+  Time     m_s1apLinkDelay;
+
+  /**
+   * The MTU of the next S1-AP link to be created. 
+   */
+  uint16_t m_s1apLinkMtu;
+
+  /**
+   * UDP port where the UDP Socket is bound, fixed by the standard as 
+   * 36412 (it should be sctp, but it is not supported in ns-3)
+   */
+  uint16_t m_s1apUdpPort;
+
+  /**
+   * Map storing for each eNB the corresponding MME NetDevice
+   */
+  std::map<uint16_t, Ptr<NetDevice> > m_cellIdMmeDeviceMap;
+
   
   /** 
    * helper to assign addresses to X2 NetDevices 
diff -Naru a/helper/radio-bearer-stats-calculator.h b/helper/radio-bearer-stats-calculator.h
--- a/helper/radio-bearer-stats-calculator.h	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/radio-bearer-stats-calculator.h	2017-10-05 11:47:22.294601711 +0200
@@ -77,7 +77,6 @@
 
   /**
     * Class constructor
-    * \param protocolType the name of the protocol type
     */
   RadioBearerStatsCalculator (std::string protocolType);
 
diff -Naru a/helper/radio-bearer-stats-connector.cc b/helper/radio-bearer-stats-connector.cc
--- a/helper/radio-bearer-stats-connector.cc	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/radio-bearer-stats-connector.cc	2017-10-05 11:47:22.294601711 +0200
@@ -56,13 +56,27 @@
   uint16_t cellId; //!< cellId
 };
 
+struct BoundCallbackArgumentRetx : public SimpleRefCount<BoundCallbackArgumentRetx>
+{
+public:
+  Ptr<RetxStatsCalculator> stats;  //!< statistics calculator
+  uint64_t imsi; //!< imsi
+  uint16_t cellId; //!< cellId
+};
+
+struct BoundCallbackArgumentMacTx : public SimpleRefCount<BoundCallbackArgumentMacTx>
+{
+public:
+  Ptr<MacTxStatsCalculator> stats;  //!< statistics calculator
+};
+
 /**
  * Callback function for DL TX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
  */
 void
 DlTxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
@@ -74,12 +88,12 @@
 
 /**
  * Callback function for DL RX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
- * \param delay
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
+ * /param delay
  */
 void
 DlRxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
@@ -91,11 +105,11 @@
 
 /**
  * Callback function for UL TX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
  */
 void
 UlTxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
@@ -108,12 +122,12 @@
 
 /**
  * Callback function for UL RX statistics for both RLC and PDCP
- * \param arg
- * \param path
- * \param rnti
- * \param lcid
- * \param packetSize
- * \param delay
+ * /param arg
+ * /param path
+ * /param rnti
+ * /param lcid
+ * /param packetSize
+ * /param delay
  */
 void
 UlRxPduCallback (Ptr<BoundCallbackArgument> arg, std::string path,
@@ -124,11 +138,35 @@
   arg->stats->UlRxPdu (arg->cellId, arg->imsi, rnti, lcid, packetSize, delay);
 }
 
+void
+DlRetxCallback (Ptr<BoundCallbackArgumentRetx> arg, std::string path,
+                 uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+  NS_LOG_FUNCTION(path << arg->stats << arg->imsi);
+  arg->stats->RegisterRetxDl(arg->imsi, arg->cellId, rnti, lcid, packetSize, numRetx);
+}
+
+void
+UlRetxCallback (Ptr<BoundCallbackArgumentRetx> arg, std::string path,
+                 uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+  NS_LOG_FUNCTION(path << arg->stats << arg->imsi);
+  arg->stats->RegisterRetxUl(arg->imsi, arg->cellId, rnti, lcid, packetSize, numRetx);
+}
+
+void
+NotifyDlMacTx (Ptr<BoundCallbackArgumentMacTx> arg, std::string path, uint16_t rnti, uint16_t cellId, uint32_t packetSize, uint8_t numRetx)
+{
+  NS_LOG_FUNCTION(path << rnti << cellId << packetSize << (uint32_t)numRetx);
+  arg->stats->RegisterMacTxDl(rnti, cellId, packetSize, numRetx);
+}
 
 
 RadioBearerStatsConnector::RadioBearerStatsConnector ()
   : m_connected (false)
 {
+  m_retxStats = CreateObject<RetxStatsCalculator> ();
+  m_macTxStats = CreateObject<MacTxStatsCalculator> ();
 }
 
 void 
@@ -145,6 +183,17 @@
   EnsureConnected ();
 }
 
+// TypeId
+// RadioBearerStatsConnector::GetTypeId (void)
+// {
+//   static TypeId tid =
+//     TypeId ("ns3::RadioBearerStatsConnector") 
+//     .SetParent<Object> ()
+//     .AddConstructor<RadioBearerStatsConnector> ()
+//     .SetGroupName("Lte");
+//   return tid; 
+// }
+
 void 
 RadioBearerStatsConnector::EnsureConnected ()
 {
@@ -167,6 +216,14 @@
 		       MakeBoundCallback (&RadioBearerStatsConnector::NotifyHandoverEndOkEnb, this));
       Config::Connect ("/NodeList/*/DeviceList/*/LteUeRrc/HandoverEndOk",
 		       MakeBoundCallback (&RadioBearerStatsConnector::NotifyHandoverEndOkUe, this));
+      // MAC related callback
+      if(m_macTxStats)
+      {
+        Ptr<BoundCallbackArgumentMacTx> arg = Create<BoundCallbackArgumentMacTx>();
+        arg->stats = m_macTxStats;
+        Config::Connect ("/NodeList/*/DeviceList/*/MmWaveEnbMac/DlMacTxCallback",
+           MakeBoundCallback (&NotifyDlMacTx, arg));
+      }
       m_connected = true;
     }
 }
@@ -386,6 +443,15 @@
       Config::Connect (basePath + "/Srb1/LtePdcp/TxPDU",
 		       MakeBoundCallback (&UlTxPduCallback, arg));
     }
+  if (m_retxStats) // TODO set condition
+    {
+      Ptr<BoundCallbackArgumentRetx> arg = Create<BoundCallbackArgumentRetx> ();
+      arg->imsi = imsi;
+      arg->cellId = cellId; 
+      arg->stats = m_retxStats;
+      Config::Connect (basePath + "/DataRadioBearerMap/*/LteRlc/TxCompletedCallback",
+         MakeBoundCallback (&UlRetxCallback, arg));
+    }
 }
 
 void 
@@ -429,6 +495,15 @@
       Config::Connect (basePath.str () + "/Srb1/LtePdcp/RxPDU",
 		       MakeBoundCallback (&UlRxPduCallback, arg));
     }
+  if (m_retxStats) 
+    {
+      Ptr<BoundCallbackArgumentRetx> arg = Create<BoundCallbackArgumentRetx> ();
+      arg->imsi = imsi;
+      arg->cellId = cellId; 
+      arg->stats = m_retxStats;
+      Config::Connect (basePath.str () + "/DataRadioBearerMap/*/LteRlc/TxCompletedCallback",
+         MakeBoundCallback (&DlRetxCallback, arg));
+    }
 }
 
 void 
diff -Naru a/helper/radio-bearer-stats-connector.h b/helper/radio-bearer-stats-connector.h
--- a/helper/radio-bearer-stats-connector.h	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/radio-bearer-stats-connector.h	2017-10-05 11:47:22.294601711 +0200
@@ -28,9 +28,13 @@
 #include <ns3/config.h>
 #include <ns3/simple-ref-count.h>
 #include <ns3/ptr.h>
-
+#include <ns3/object.h>
+#include <fstream>
 #include <set>
 #include <map>
+#include "retx-stats-calculator.h"
+#include "mac-tx-stats-calculator.h"
+
 
 namespace ns3 {
 
@@ -40,9 +44,9 @@
  * \ingroup lte
  *
  * This class is very useful when user needs to collect
- * statistics from PDCP and RLC. It automatically connects
+ * statistics from PDCD and RLC. It automatically connects
  * RadioBearerStatsCalculator to appropriate trace sinks.
- * Usually user does not use this class. All he/she needs
+ * Usually user do not use this class. All he/she needs to
  * to do is to call: LteHelper::EnablePdcpTraces() and/or
  * LteHelper::EnableRlcTraces().
  */
@@ -262,6 +266,9 @@
 
   Ptr<RadioBearerStatsCalculator> m_rlcStats; //!< Calculator for RLC Statistics
   Ptr<RadioBearerStatsCalculator> m_pdcpStats; //!< Calculator for PDCP Statistics
+  Ptr<RetxStatsCalculator> m_retxStats;
+  Ptr<MacTxStatsCalculator> m_macTxStats;        
+
 
   bool m_connected; //!< true if traces are connected to sinks, initially set to false
   std::set<uint64_t> m_imsiSeenUe; //!< stores all UEs for which RLC and PDCP traces were connected
@@ -278,10 +285,6 @@
 
   /**
    * Less than operator for CellIdRnti, because it is used as key in map
-   *
-   * \param a the lhs operand
-   * \param b the rhs operand
-   * \returns true if less than
    */
   friend bool operator < (const CellIdRnti &a, const CellIdRnti &b);
 
diff -Naru a/helper/radio-environment-map-helper.cc b/helper/radio-environment-map-helper.cc
--- a/helper/radio-environment-map-helper.cc	2017-10-05 11:46:52.078493487 +0200
+++ b/helper/radio-environment-map-helper.cc	2017-10-05 11:47:22.294601711 +0200
@@ -282,8 +282,8 @@
 {
   NS_LOG_FUNCTION (this << xMin << xMax << yMin << yMax);
   std::list<RemPoint>::iterator remIt = m_rem.begin ();
-  double x = 0.0;
-  double y = 0.0;
+  double x;
+  double y;
   for (x = xMin; x < xMax + 0.5*m_xStep; x += m_xStep)
     {
       for (y = (x == xMin) ? yMin : m_yMin;
diff -Naru a/helper/retx-stats-calculator.cc b/helper/retx-stats-calculator.cc
--- a/helper/retx-stats-calculator.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/retx-stats-calculator.cc	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,101 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "retx-stats-calculator.h"
+#include "ns3/string.h"
+#include "ns3/nstime.h"
+#include <ns3/log.h>
+#include <vector>
+#include <algorithm>
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("RetxStatsCalculator");
+
+NS_OBJECT_ENSURE_REGISTERED ( RetxStatsCalculator);
+
+RetxStatsCalculator::RetxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+
+RetxStatsCalculator::~RetxStatsCalculator ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+RetxStatsCalculator::GetTypeId (void)
+{
+  static TypeId tid =
+    TypeId ("ns3::RetxStatsCalculator")
+    .SetParent<Object> ().AddConstructor<RetxStatsCalculator> ()
+    .SetGroupName("Lte")
+    .AddAttribute ("DlRlcRetxFilename",
+                   "Name of the file where the downlink retx results will be saved.",
+                   StringValue ("DlRlcRetx.txt"),
+                   MakeStringAccessor (&RetxStatsCalculator::m_retxDlFilename),
+                   MakeStringChecker ())
+    .AddAttribute ("UlRlcRetxFilename",
+                   "Name of the file where the uplink retx results will be saved.",
+                   StringValue ("UlRlcRetx.txt"),
+                   MakeStringAccessor (&RetxStatsCalculator::m_retxUlFilename),
+                   MakeStringChecker ())
+    ;
+  return tid;
+}
+
+void
+RetxStatsCalculator::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+RetxStatsCalculator::RegisterRetxDl(uint64_t imsi, uint16_t cellId, 
+	uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+	if(!m_retxDlFile.is_open())
+	{
+	    m_retxDlFile.open(m_retxDlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+  	}
+	m_retxDlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << imsi << " "
+		<< rnti << " " << (uint16_t) lcid << " " << packetSize << " " << numRetx << std::endl;
+}
+
+void
+RetxStatsCalculator::RegisterRetxUl(uint64_t imsi, uint16_t cellId, 
+	uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx)
+{
+	if(!m_retxUlFile.is_open())
+	{
+	    m_retxUlFile.open(m_retxUlFilename.c_str());
+	    NS_LOG_LOGIC("File opened");
+  	}
+	m_retxUlFile << Simulator::Now().GetSeconds() << " " << cellId << " " << imsi << " "
+		<< rnti << " " << (uint16_t) lcid << " " << packetSize << " " << numRetx << std::endl;
+}
+
+}
\ No newline at end of file
diff -Naru a/helper/retx-stats-calculator.h b/helper/retx-stats-calculator.h
--- a/helper/retx-stats-calculator.h	1970-01-01 01:00:00.000000000 +0100
+++ b/helper/retx-stats-calculator.h	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,73 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017 SIGNET Lab, Dept. of Information Engineering, UNIPD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jnin@cttc.es>
+ *         Nicola Baldo <nbaldo@cttc.es>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef RETX_STATS_CALCULATOR_H_
+#define RETX_STATS_CALCULATOR_H_
+
+#include "ns3/lte-common.h"
+#include "ns3/uinteger.h"
+#include "ns3/object.h"
+#include "ns3/basic-data-calculators.h"
+#include "ns3/lte-common.h"
+#include <string>
+#include <map>
+#include <fstream>
+
+namespace ns3
+{
+
+class RetxStatsCalculator : public Object
+{
+public:
+  /**
+   * Class constructor
+   */
+  RetxStatsCalculator ();
+
+  /**
+   * Class destructor
+   */
+  virtual
+  ~RetxStatsCalculator ();
+
+  // Inherited from ns3::Object
+  /**
+   *  Register this type.
+   *  \return The object TypeId.
+   */
+  static TypeId GetTypeId (void);
+  void DoDispose ();
+
+  void RegisterRetxDl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx);
+  void RegisterRetxUl(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t lcid, uint32_t packetSize, uint32_t numRetx);
+
+  std::ofstream m_retxDlFile;
+  std::string m_retxDlFilename;
+
+  std::ofstream m_retxUlFile;
+  std::string m_retxUlFilename;
+};
+
+}
+
+#endif /* RETX_STATS_CALCULATOR_H_ */
diff -Naru a/model/a2-a4-rsrq-handover-algorithm.h b/model/a2-a4-rsrq-handover-algorithm.h
--- a/model/a2-a4-rsrq-handover-algorithm.h	2017-10-05 11:46:52.078493487 +0200
+++ b/model/a2-a4-rsrq-handover-algorithm.h	2017-10-05 11:47:22.294601711 +0200
@@ -85,17 +85,14 @@
 
   virtual ~A2A4RsrqHandoverAlgorithm ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
+  // inherited from Object
   static TypeId GetTypeId ();
 
   // inherited from LteHandoverAlgorithm
   virtual void SetLteHandoverManagementSapUser (LteHandoverManagementSapUser* s);
   virtual LteHandoverManagementSapProvider* GetLteHandoverManagementSapProvider ();
 
-  /// let the forwarder class access the protected and private members
+  // let the forwarder class access the protected and private members
   friend class MemberLteHandoverManagementSapProvider<A2A4RsrqHandoverAlgorithm>;
 
 protected:
diff -Naru a/model/a3-rsrp-handover-algorithm.h b/model/a3-rsrp-handover-algorithm.h
--- a/model/a3-rsrp-handover-algorithm.h	2017-10-05 11:46:52.078493487 +0200
+++ b/model/a3-rsrp-handover-algorithm.h	2017-10-05 11:47:22.294601711 +0200
@@ -70,17 +70,14 @@
 
   virtual ~A3RsrpHandoverAlgorithm ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
+  // inherited from Object
   static TypeId GetTypeId ();
 
   // inherited from LteHandoverAlgorithm
   virtual void SetLteHandoverManagementSapUser (LteHandoverManagementSapUser* s);
   virtual LteHandoverManagementSapProvider* GetLteHandoverManagementSapProvider ();
 
-  /// let the forwarder class access the protected and private members
+  // let the forwarder class access the protected and private members
   friend class MemberLteHandoverManagementSapProvider<A3RsrpHandoverAlgorithm>;
 
 protected:
diff -Naru a/model/component-carrier.cc b/model/component-carrier.cc
--- a/model/component-carrier.cc	2017-10-05 11:46:52.082493501 +0200
+++ b/model/component-carrier.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,237 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- */
-
-#include "component-carrier.h"
-#include <ns3/uinteger.h>
-#include <ns3/boolean.h>
-#include <ns3/simulator.h>
-#include <ns3/log.h>
-#include <ns3/abort.h>
-#include <ns3/lte-enb-phy.h>
-#include <ns3/pointer.h>
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("ComponentCarrier");
-
-NS_OBJECT_ENSURE_REGISTERED ( ComponentCarrier);
-
-TypeId ComponentCarrier::GetTypeId (void)
-{
-  static TypeId
-    tid =
-    TypeId ("ns3::ComponentCarrier")
-    .SetParent<Object> ()
-    .AddConstructor<ComponentCarrier> ()
-    .AddAttribute ("UlBandwidth",
-                   "Uplink Transmission Bandwidth Configuration in number of Resource Blocks",
-                   UintegerValue (25),
-                   MakeUintegerAccessor (&ComponentCarrier::SetUlBandwidth,
-                                         &ComponentCarrier::GetUlBandwidth),
-                   MakeUintegerChecker<uint8_t> ())
-    .AddAttribute ("DlBandwidth",
-                   "Downlink Transmission Bandwidth Configuration in number of Resource Blocks",
-                   UintegerValue (25),
-                   MakeUintegerAccessor (&ComponentCarrier::SetDlBandwidth,
-                                         &ComponentCarrier::GetDlBandwidth),
-                   MakeUintegerChecker<uint8_t> ())
-    .AddAttribute ("DlEarfcn",
-                   "Downlink E-UTRA Absolute Radio Frequency Channel Number (EARFCN) "
-                   "as per 3GPP 36.101 Section 5.7.3. ",
-                   UintegerValue (100),
-                   MakeUintegerAccessor (&ComponentCarrier::m_dlEarfcn),
-                   MakeUintegerChecker<uint32_t> (0, 262143))
-    .AddAttribute ("UlEarfcn",
-                   "Uplink E-UTRA Absolute Radio Frequency Channel Number (EARFCN) "
-                   "as per 3GPP 36.101 Section 5.7.3. ",
-                   UintegerValue (18100),
-                   MakeUintegerAccessor (&ComponentCarrier::m_ulEarfcn),
-                   MakeUintegerChecker<uint32_t> (18000, 262143))
-    .AddAttribute ("CsgId",
-                   "The Closed Subscriber Group (CSG) identity that this eNodeB belongs to",
-                   UintegerValue (0),
-                   MakeUintegerAccessor (&ComponentCarrier::SetCsgId,
-                                         &ComponentCarrier::GetCsgId),
-                   MakeUintegerChecker<uint32_t> ())
-    .AddAttribute ("CsgIndication",
-                   "If true, only UEs which are members of the CSG (i.e. same CSG ID) "
-                   "can gain access to the eNodeB, therefore enforcing closed access mode. "
-                   "Otherwise, the eNodeB operates as a non-CSG cell and implements open access mode.",
-                   BooleanValue (false),
-                   MakeBooleanAccessor (&ComponentCarrier::SetCsgIndication,
-                                        &ComponentCarrier::GetCsgIndication),
-                   MakeBooleanChecker ())
-    .AddAttribute ("PrimaryCarrier",
-                   "If true, this Carrier Component will be the Primary Carrier Component (PCC) "
-                   "Only one PCC per eNodeB is (currently) allowed",
-                   BooleanValue (false),
-                   MakeBooleanAccessor (&ComponentCarrier::SetAsPrimary,
-                                        &ComponentCarrier::IsPrimary),
-                   MakeBooleanChecker ())
-  ;
-  return tid;
-}
-ComponentCarrier::ComponentCarrier ()
-  : m_isConstructed (false)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-ComponentCarrier::~ComponentCarrier (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-void
-ComponentCarrier::DoDispose ()
-{
-  NS_LOG_FUNCTION (this);
-  Object::DoDispose ();
-}
-
-uint8_t
-ComponentCarrier::GetUlBandwidth () const
-{
-  return m_ulBandwidth;
-}
-
-void
-ComponentCarrier::SetUlBandwidth (uint8_t bw)
-{
-  NS_LOG_FUNCTION (this << uint16_t (bw));
-  switch (bw)
-    {
-    case 6:
-    case 15:
-    case 25:
-    case 50:
-    case 75:
-    case 100:
-      m_ulBandwidth = bw;
-      break;
-
-    default:
-      NS_FATAL_ERROR ("Invalid bandwidth value " << (uint16_t) bw);
-      break;
-    }
-}
-
-uint8_t
-ComponentCarrier::GetDlBandwidth () const
-{
-  return m_dlBandwidth;
-}
-
-void
-ComponentCarrier::SetDlBandwidth (uint8_t bw)
-{
-  NS_LOG_FUNCTION (this << uint16_t (bw));
-  switch (bw)
-    {
-    case 6:
-    case 15:
-    case 25:
-    case 50:
-    case 75:
-    case 100:
-      m_dlBandwidth = bw;
-      break;
-
-    default:
-      NS_FATAL_ERROR ("Invalid bandwidth value " << (uint16_t) bw);
-      break;
-    }
-}
-
-uint32_t
-ComponentCarrier::GetDlEarfcn () const
-{
-  return m_dlEarfcn;
-}
-
-void
-ComponentCarrier::SetDlEarfcn (uint32_t earfcn)
-{
-  NS_LOG_FUNCTION (this << earfcn);
-  m_dlEarfcn = earfcn;
-}
-
-uint32_t
-ComponentCarrier::GetUlEarfcn () const
-{
-  return m_ulEarfcn;
-}
-
-void
-ComponentCarrier::SetUlEarfcn (uint32_t earfcn)
-{
-  NS_LOG_FUNCTION (this << earfcn);
-  m_ulEarfcn = earfcn;
-}
-
-uint32_t
-ComponentCarrier::GetCsgId () const
-{
-  return m_csgId;
-}
-
-void
-ComponentCarrier::SetCsgId (uint32_t csgId)
-{
-  NS_LOG_FUNCTION (this << csgId);
-  m_csgId = csgId;
-}
-
-bool
-ComponentCarrier::GetCsgIndication () const
-{
-  return m_csgIndication;
-}
-
-void
-ComponentCarrier::SetCsgIndication (bool csgIndication)
-{
-  NS_LOG_FUNCTION (this << csgIndication);
-  m_csgIndication = csgIndication;
-}
-
-bool
-ComponentCarrier::IsPrimary () const
-{
-  return m_primaryCarrier;
-}
-
-void
-ComponentCarrier::SetAsPrimary (bool primaryCarrier)
-{
-  NS_LOG_FUNCTION (this << primaryCarrier);
-  m_primaryCarrier = primaryCarrier;
-}
-
-void
-ComponentCarrier::DoInitialize (void)
-{
-  NS_LOG_FUNCTION (this);
-  m_isConstructed = true;
-}
-
-} // namespace ns3
-
-
diff -Naru a/model/component-carrier-enb.cc b/model/component-carrier-enb.cc
--- a/model/component-carrier-enb.cc	2017-10-05 11:46:52.082493501 +0200
+++ b/model/component-carrier-enb.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,189 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- */
-
-#include "component-carrier-enb.h"
-#include <ns3/uinteger.h>
-#include <ns3/boolean.h>
-#include <ns3/simulator.h>
-#include <ns3/log.h>
-#include <ns3/abort.h>
-#include <ns3/lte-enb-phy.h>
-#include <ns3/pointer.h>
-#include <ns3/lte-enb-mac.h>
-#include <ns3/lte-ffr-algorithm.h>
-#include <ns3/ff-mac-scheduler.h>
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("ComponentCarrierEnb");
-NS_OBJECT_ENSURE_REGISTERED (ComponentCarrierEnb);
-
-TypeId ComponentCarrierEnb::GetTypeId (void)
-{
-  static TypeId
-    tid =
-    TypeId ("ns3::ComponentCarrierEnb")
-    .SetParent<ComponentCarrier> ()
-    .AddConstructor<ComponentCarrierEnb> ()
-    .AddAttribute ("LteEnbPhy",
-                   "The PHY associated to this EnbNetDevice",
-                   PointerValue (),
-                   MakePointerAccessor (&ComponentCarrierEnb::m_phy),
-                   MakePointerChecker <LteEnbPhy> ())
-    .AddAttribute ("LteEnbMac",
-                   "The MAC associated to this EnbNetDevice",
-                   PointerValue (),
-                   MakePointerAccessor (&ComponentCarrierEnb::m_mac),
-                   MakePointerChecker <LteEnbMac> ())
-    .AddAttribute ("FfMacScheduler",
-                   "The scheduler associated to this EnbNetDevice",
-                   PointerValue (),
-                   MakePointerAccessor (&ComponentCarrierEnb::m_scheduler),
-                   MakePointerChecker <FfMacScheduler> ())
-    .AddAttribute ("LteFfrAlgorithm",
-                   "The FFR algorithm associated to this EnbNetDevice",
-                   PointerValue (),
-                   MakePointerAccessor (&ComponentCarrierEnb::m_ffrAlgorithm),
-                   MakePointerChecker <LteFfrAlgorithm> ())
-  ;
-  return tid;
-}
-ComponentCarrierEnb::ComponentCarrierEnb ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-ComponentCarrierEnb::~ComponentCarrierEnb (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-void
-ComponentCarrierEnb::DoDispose ()
-{
-  NS_LOG_FUNCTION (this);
-  if (m_phy)
-    {
-      m_phy->Dispose ();
-      m_phy = 0;
-    }
-  if (m_mac)
-    {
-      m_mac->Dispose ();
-      m_mac = 0;
-    }
-  if (m_scheduler)
-    {
-      m_scheduler->Dispose ();
-      m_scheduler = 0;
-    }
-  if (m_ffrAlgorithm)
-    {
-      m_ffrAlgorithm->Dispose ();
-      m_ffrAlgorithm = 0;
-    }
-
-  Object::DoDispose ();
-}
-
-
-void
-ComponentCarrierEnb::DoInitialize (void)
-{
-  NS_LOG_FUNCTION (this);
-  m_isConstructed = true;
-  m_phy->Initialize ();
-  m_mac->Initialize ();
-  m_ffrAlgorithm->Initialize ();
-  m_scheduler->Initialize();
-
-}
-
-uint16_t
-ComponentCarrierEnb::GetCellId ()
-{
-  return m_cellId;
-}
-
-Ptr<LteEnbPhy>
-ComponentCarrierEnb::GetPhy ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_phy;
-}
-
-void
-ComponentCarrierEnb::SetCellId (uint16_t cellId)
-{
-  NS_LOG_FUNCTION (this << cellId);
-  m_cellId = cellId;
-}
-
-void 
-ComponentCarrierEnb::SetPhy (Ptr<LteEnbPhy> s)
-{
-  NS_LOG_FUNCTION (this);
-  m_phy = s;
-}
-
-Ptr<LteEnbMac>
-ComponentCarrierEnb::GetMac ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_mac;
-}
-void 
-ComponentCarrierEnb::SetMac (Ptr<LteEnbMac> s)
-{
-  NS_LOG_FUNCTION (this);
-  m_mac = s;
-}
-
-Ptr<LteFfrAlgorithm>
-ComponentCarrierEnb::GetFfrAlgorithm ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_ffrAlgorithm;
-}
-
-void 
-ComponentCarrierEnb::SetFfrAlgorithm (Ptr<LteFfrAlgorithm> s)
-{
-  NS_LOG_FUNCTION (this);
-  m_ffrAlgorithm = s;
-}
-
-Ptr<FfMacScheduler>
-ComponentCarrierEnb::GetFfMacScheduler ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_scheduler;
-}
-
-void
-ComponentCarrierEnb::SetFfMacScheduler (Ptr<FfMacScheduler> s)
-{
-  NS_LOG_FUNCTION (this);
-  m_scheduler = s;
-} 
-
-} // namespace ns3
-
-
diff -Naru a/model/component-carrier-enb.h b/model/component-carrier-enb.h
--- a/model/component-carrier-enb.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/component-carrier-enb.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- */
-
-
-#ifndef COMPONENT_CARRIER_ENB_H
-#define COMPONENT_CARRIER_ENB_H
-
-#include "component-carrier.h"
-#include <ns3/object.h>
-#include <ns3/packet.h>
-#include <ns3/nstime.h>
-#include "ns3/lte-phy.h"
-#include <ns3/lte-enb-phy.h>
-#include <ns3/pointer.h>
-//#include <ns3/lte-enb-mac.h>
-
-
-namespace ns3 {
-
-class LteEnbMac;
-class FfMacScheduler;
-class LteFfrAlgorithm;
-
-/**
- * \ingroup lte
- *
- * Defines a single carrier for enb, and contains pointers to LteEnbPhy,
- * LteEnbMac, LteFfrAlgorithm, and FfMacScheduler objects.
- *
- */
-class ComponentCarrierEnb : public ComponentCarrier
-{
-public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
-
-  ComponentCarrierEnb ();
-
-  virtual ~ComponentCarrierEnb (void);
-  virtual void DoDispose (void);
-
-  /**
-   * Get cell identifier
-   * \return cell identifer
-   */
-  uint16_t GetCellId ();
-
-  /**
-   * \return a pointer to the physical layer.
-   */
-  Ptr<LteEnbPhy> GetPhy (void);
-
-  /**
-   * \return a pointer to the MAC layer.
-   */
-  Ptr<LteEnbMac> GetMac (void);
-
-  /**
-   * \return a pointer to the Ffr Algorithm.
-   */
-  Ptr<LteFfrAlgorithm> GetFfrAlgorithm ();
-
-  /**
-   * \return a pointer to the Mac Scheduler.
-   */
-  Ptr<FfMacScheduler> GetFfMacScheduler ();
-
-  /**
-   * Set physical cell identifier
-   * \param cellId cell identifier
-   */
-  void SetCellId (uint16_t cellId);
-
-  /**
-   * Set the LteEnbPhy
-   * \param s a pointer to the LteEnbPhy
-   */
-  void SetPhy (Ptr<LteEnbPhy> s);
-  /**
-   * Set the LteEnbMac
-   * \param s a pointer to the LteEnbMac
-   */
-  void SetMac (Ptr<LteEnbMac> s);
-
-  /**
-   * Set the FfMacScheduler Algorithm
-   * \param s a pointer to the FfMacScheduler
-   */
-  void SetFfMacScheduler (Ptr<FfMacScheduler> s);
-
-  /**
-   * Set the LteFfrAlgorithm
-   * \param s a pointer to the LteFfrAlgorithm
-   */
-  void SetFfrAlgorithm (Ptr<LteFfrAlgorithm> s);
-  
-protected:
-
-  virtual void DoInitialize (void);
-
-private:
-
-  uint16_t m_cellId; ///< Cell identifer
-  Ptr<LteEnbPhy> m_phy; ///< the Phy instance of this eNodeB component carrier
-  Ptr<LteEnbMac> m_mac; ///< the MAC instance of this eNodeB component carrier
-  Ptr<FfMacScheduler> m_scheduler; ///< the scheduler instance of this eNodeB component carrier
-  Ptr<LteFfrAlgorithm> m_ffrAlgorithm; ///< the FFR algorithm instance of this eNodeB component carrier
- 
-
-};
-
-} // namespace ns3
-
-
-
-#endif /* COMPONENT_CARRIER_H */
diff -Naru a/model/component-carrier.h b/model/component-carrier.h
--- a/model/component-carrier.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/component-carrier.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,181 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- */
-
-
-#ifndef COMPONENT_CARRIER_H
-#define COMPONENT_CARRIER_H
-
-#include <ns3/object.h>
-#include <ns3/packet.h>
-#include <ns3/nstime.h>
-#include "ns3/lte-phy.h"
-#include <ns3/lte-enb-phy.h>
-#include <ns3/pointer.h>
-
-namespace ns3 {
-
-/**
- * \ingroup lte
- *
- * ComponentCarrier Object, it defines a single Carrier
- * This is the parent class for both ComponentCarrierEnb
- * and ComponentCarrierUe.
- * This class contains the main physical configuration
- * parameters for a carrier. Does not contain pointers to
- * the MAC/PHY objects of the carrier.
-
- */
-class ComponentCarrier : public Object
-{
-public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
-
-  ComponentCarrier ();
-
-  virtual ~ComponentCarrier (void);
-  virtual void DoDispose (void);
-
-  /**
-   * \return the uplink bandwidth in RBs
-   */
-  uint8_t GetUlBandwidth () const;
-
-  /**
-   * \param bw the uplink bandwidth in RBs
-   */
-  void SetUlBandwidth (uint8_t bw);
-
-  /**
-   * \return the downlink bandwidth in RBs
-   */
-  uint8_t GetDlBandwidth () const;
-
-  /**
-   * \param bw the downlink bandwidth in RBs
-   */
-  void SetDlBandwidth (uint8_t bw);
-
-  /**
-   * \return the downlink carrier frequency (EARFCN)
-   */
-  uint32_t GetDlEarfcn () const;
-
-  /**
-   * \param earfcn the downlink carrier frequency (EARFCN)
-   */
-  void SetDlEarfcn (uint32_t earfcn);
-
-  /**
-   * \return the uplink carrier frequency (EARFCN)
-   */
-  uint32_t GetUlEarfcn () const;
-
-  /**
-   * \param earfcn the uplink carrier frequency (EARFCN)
-   */
-  void SetUlEarfcn (uint32_t earfcn);
-
-  /**
-   * \brief Returns the CSG ID of the eNodeB.
-   * \return the Closed Subscriber Group identity
-   * \sa LteEnbNetDevice::SetCsgId
-   */
-  uint32_t GetCsgId () const;
-
-  /**
-   * \brief Associate the eNodeB device with a particular CSG.
-   * \param csgId the intended Closed Subscriber Group identity
-   *
-   * CSG identity is a number identifying a Closed Subscriber Group which the
-   * cell belongs to. eNodeB is associated with a single CSG identity.
-   *
-   * The same CSG identity can also be associated to several UEs, which is
-   * equivalent as enlisting these UEs as the members of this particular CSG.
-   *
-   * \sa LteEnbNetDevice::SetCsgIndication
-   */
-  void SetCsgId (uint32_t csgId);
-
-  /**
-   * \brief Returns the CSG indication flag of the eNodeB.
-   * \return the CSG indication flag
-   * \sa LteEnbNetDevice::SetCsgIndication
-   */
-  bool GetCsgIndication () const;
-
-  /**
-   * \brief Enable or disable the CSG indication flag.
-   * \param csgIndication if TRUE, only CSG members are allowed to access this
-   *                      cell
-   *
-   * When the CSG indication field is set to TRUE, only UEs which are members of
-   * the CSG (i.e. same CSG ID) can gain access to the eNodeB, therefore
-   * enforcing closed access mode. Otherwise, the eNodeB operates as a non-CSG
-   * cell and implements open access mode.
-   *
-   * \note This restriction only applies to initial cell selection and
-   *       EPC-enabled simulation.
-   *
-   * \sa LteEnbNetDevice::SetCsgIndication
-   */
-  void SetCsgIndication (bool csgIndication);
-
-  /**
-   * \brief Set as primary carrier 
-   * \param primaryCarrier true to set as primary carrier
-   */
-  void SetAsPrimary (bool primaryCarrier);
-
-  /**
-   * \brief Checks if the carrier is the primary carrier
-   * \returns true if the carrier is primary
-   */
-  bool IsPrimary () const;
-
-
-  uint8_t m_dlBandwidth;   /**< downlink bandwidth in RBs */
-  uint8_t m_ulBandwidth;   /**< uplink bandwidth in RBs */
-
-  uint32_t m_dlEarfcn;    /**< downlink carrier frequency */
-  uint32_t m_ulEarfcn;    /**< uplink carrier frequency */
-
-protected:
-  // inherited from Object
-  virtual void DoInitialize (void);
-  uint16_t m_csgId; ///< CSG ID
-  bool m_csgIndication; ///< CSG indication
-
-  bool m_primaryCarrier; ///< whether the carrier is primary
-  bool m_isConstructed; ///< whether the instance is constructed
-//    bool m_isConfigured;
-
-};
-
-
-
-} // namespace ns3
-
-
-
-#endif /* COMPONENT_CARRIER_H */
diff -Naru a/model/component-carrier-ue.cc b/model/component-carrier-ue.cc
--- a/model/component-carrier-ue.cc	2017-10-05 11:46:52.082493501 +0200
+++ b/model/component-carrier-ue.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,119 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- */
-
-#include "component-carrier-ue.h"
-#include <ns3/uinteger.h>
-#include <ns3/boolean.h>
-#include <ns3/simulator.h>
-#include <ns3/log.h>
-#include <ns3/abort.h>
-#include <ns3/lte-ue-phy.h>
-#include <ns3/lte-ue-mac.h>
-#include <ns3/pointer.h>
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("ComponentCarrierUe");
-
-NS_OBJECT_ENSURE_REGISTERED ( ComponentCarrierUe);
-
-TypeId ComponentCarrierUe::GetTypeId (void)
-{
-  static TypeId
-    tid =
-    TypeId ("ns3::ComponentCarrierUe")
-    .SetParent<ComponentCarrier> ()
-    .AddConstructor<ComponentCarrierUe> ()
-    .AddAttribute ("LteUePhy",
-                   "The PHY associated to this EnbNetDevice",
-                   PointerValue (),
-                   MakePointerAccessor (&ComponentCarrierUe::m_phy),
-                   MakePointerChecker <LteUePhy> ())
-    .AddAttribute ("LteUeMac",
-                   "The MAC associated to this UeNetDevice",
-                   PointerValue (),
-                   MakePointerAccessor (&ComponentCarrierUe::m_mac),
-                   MakePointerChecker <LteUeMac> ())
-  ;
-  return tid;
-}
-ComponentCarrierUe::ComponentCarrierUe ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-ComponentCarrierUe::~ComponentCarrierUe (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-void
-ComponentCarrierUe::DoDispose ()
-{
-  NS_LOG_FUNCTION (this);
-  m_phy->Dispose ();
-  m_phy = 0;
-  m_mac->Dispose ();
-  m_mac = 0;
-  Object::DoDispose ();
-}
-
-
-void
-ComponentCarrierUe::DoInitialize (void)
-{
-  NS_LOG_FUNCTION (this);
-  m_isConstructed = true;
-  m_phy->Initialize ();
-  m_mac->Initialize();
-}
-
-void
-ComponentCarrierUe::SetPhy (Ptr<LteUePhy> s)
-{
-  NS_LOG_FUNCTION (this);
-  m_phy = s;
-}
-
-
-Ptr<LteUePhy>
-ComponentCarrierUe::GetPhy () const
-{
-  NS_LOG_FUNCTION (this);
-  return m_phy;
-}
-
-void 
-ComponentCarrierUe::SetMac (Ptr<LteUeMac> s)
-{
-  NS_LOG_FUNCTION (this);
-  m_mac = s;
-}
-
-Ptr<LteUeMac>
-ComponentCarrierUe::GetMac () const
-{
-  NS_LOG_FUNCTION (this);
-  return m_mac;
-}
-
-} // namespace ns3
-
-
diff -Naru a/model/component-carrier-ue.h b/model/component-carrier-ue.h
--- a/model/component-carrier-ue.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/component-carrier-ue.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- */
-
-
-#ifndef COMPONENT_CARRIER_UE_H
-#define COMPONENT_CARRIER_UE_H
-
-#include <ns3/object.h>
-#include <ns3/packet.h>
-#include <ns3/nstime.h>
-#include "ns3/lte-phy.h"
-#include <ns3/lte-ue-phy.h>
-#include <ns3/component-carrier.h>
-
-namespace ns3 {
-
-class LteUeMac;
-/**
- * \ingroup lte
- *
- * ComponentCarrierUe Object, it defines a single Carrier for the Ue
- */
-class ComponentCarrierUe : public ComponentCarrier
-{
-public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
-
-  ComponentCarrierUe ();
-
-  virtual ~ComponentCarrierUe (void);
-  virtual void DoDispose (void);
-
-
-  /**
-   * \return a pointer to the physical layer.
-   */
-  Ptr<LteUePhy> GetPhy (void) const;
-
-  /**
-   * \return a pointer to the MAC layer.
-   */
-  Ptr<LteUeMac> GetMac (void) const;
-
-  /**
-   * Set LteUePhy
-   * \param s a pointer to the LteUePhy
-   */  
-  void SetPhy (Ptr<LteUePhy> s);
-
-  /**
-   * Set the LteEnbMac
-   * \param s a pointer to the LteEnbMac
-   */ 
-  void SetMac (Ptr<LteUeMac> s);
-  
-protected:
-  // inherited from Object
-  virtual void DoInitialize (void);
-
-private:
-
-  Ptr<LteUePhy> m_phy; ///< the Phy instance of this eNodeB component carrier
-  Ptr<LteUeMac> m_mac; ///< the MAC instance of this eNodeB component carrier
-
-};
-
-
-
-} // namespace ns3
-
-
-
-#endif /* COMPONENT_CARRIER_UE_H */
diff -Naru a/model/epc-enb-application.cc b/model/epc-enb-application.cc
--- a/model/epc-enb-application.cc	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-enb-application.cc	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Jaume Nin <jnin@cttc.cat>
  *         Nicola Baldo <nbaldo@cttc.cat>
+ *
+ * Modified by Michele Polese <michele.polese@gmail.com>
+ *     (support for RRC_CONNECTED->RRC_IDLE state transition + support for real S1AP link)
  */
 
 
@@ -85,7 +89,7 @@
     m_sgwS1uAddress (sgwS1uAddress),
     m_gtpuUdpPort (2152), // fixed by the standard
     m_s1SapUser (0),
-    m_s1apSapMme (0),
+    m_s1apSapEnbProvider (0),
     m_cellId (cellId)
 {
   NS_LOG_FUNCTION (this << lteSocket << s1uSocket << sgwS1uAddress);
@@ -108,7 +112,7 @@
   m_s1SapUser = s;
 }
 
-  
+
 EpcEnbS1SapProvider* 
 EpcEnbApplication::GetS1SapProvider ()
 {
@@ -116,9 +120,9 @@
 }
 
 void 
-EpcEnbApplication::SetS1apSapMme (EpcS1apSapMme * s)
+EpcEnbApplication::SetS1apSapMme (EpcS1apSapEnbProvider * s)
 {
-  m_s1apSapMme = s;
+  m_s1apSapEnbProvider = s;
 }
 
   
@@ -134,7 +138,7 @@
   NS_LOG_FUNCTION (this);
   // side effect: create entry if not exist
   m_imsiRntiMap[imsi] = rnti;
-  m_s1apSapMme->InitialUeMessage (imsi, rnti, imsi, m_cellId);
+  m_s1apSapEnbProvider->SendInitialUeMessage (imsi, rnti, imsi, m_cellId); // TODO if more than one MME is used, extend this call
 }
 
 void 
@@ -170,7 +174,7 @@
 
       erabToBeSwitchedInDownlinkList.push_back (erab);
     }
-  m_s1apSapMme->PathSwitchRequest (enbUeS1Id, mmeUeS1Id, gci, erabToBeSwitchedInDownlinkList);
+  m_s1apSapEnbProvider->SendPathSwitchRequest (enbUeS1Id, mmeUeS1Id, gci, erabToBeSwitchedInDownlinkList);
 }
 
 void 
@@ -195,13 +199,13 @@
 EpcEnbApplication::DoInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapEnb::ErabToBeSetupItem> erabToBeSetupList)
 {
   NS_LOG_FUNCTION (this);
-  
+  NS_LOG_INFO("In EnpEnbApplication DoInitialContextSetupRequest size of the erabToBeSetupList is " << erabToBeSetupList.size());
+
   for (std::list<EpcS1apSapEnb::ErabToBeSetupItem>::iterator erabIt = erabToBeSetupList.begin ();
        erabIt != erabToBeSetupList.end ();
        ++erabIt)
     {
       // request the RRC to setup a radio bearer
-
       uint64_t imsi = mmeUeS1Id;
       std::map<uint64_t, uint16_t>::iterator imsiIt = m_imsiRntiMap.find (imsi);
       NS_ASSERT_MSG (imsiIt != m_imsiRntiMap.end (), "unknown IMSI");
@@ -243,6 +247,11 @@
   NS_ASSERT (socket == m_lteSocket);
   Ptr<Packet> packet = socket->Recv ();
 
+  /// \internal
+  /// Workaround for \bugid{231}
+  //SocketAddressTag satag;
+  //packet->RemovePacketTag (satag);
+
   EpsBearerTag tag;
   bool found = packet->RemovePacketTag (tag);
   NS_ASSERT (found);
@@ -252,7 +261,7 @@
   std::map<uint16_t, std::map<uint8_t, uint32_t> >::iterator rntiIt = m_rbidTeidMap.find (rnti);
   if (rntiIt == m_rbidTeidMap.end ())
     {
-      NS_LOG_WARN ("UE context not found, discarding packet");
+      NS_LOG_WARN ("UE context not found, discarding packet when receiving from lteSocket");
     }
   else
     {
@@ -272,10 +281,22 @@
   GtpuHeader gtpu;
   packet->RemoveHeader (gtpu);
   uint32_t teid = gtpu.GetTeid ();
-  std::map<uint32_t, EpsFlowId_t>::iterator it = m_teidRbidMap.find (teid);
-  NS_ASSERT (it != m_teidRbidMap.end ());
 
-  SendToLteSocket (packet, it->second.m_rnti, it->second.m_bid);
+  /// \internal
+  /// Workaround for \bugid{231}
+  //SocketAddressTag tag;
+  //packet->RemovePacketTag (tag);
+
+  std::map<uint32_t, EpsFlowId_t>::iterator it = m_teidRbidMap.find (teid);
+  if (it != m_teidRbidMap.end ())
+    {
+      SendToLteSocket (packet, it->second.m_rnti, it->second.m_bid);
+    }
+  else
+    {
+      packet = 0;
+      NS_LOG_DEBUG("UE context not found, discarding packet when receiving from s1uSocket");
+    }  
 }
 
 void 
@@ -312,6 +333,6 @@
   erab.erabId = bearerId;
   erabToBeReleaseIndication.push_back (erab);
   //From 3GPP TS 23401-950 Section 5.4.4.2, enB sends EPS bearer Identity in Bearer Release Indication message to MME
-  m_s1apSapMme->ErabReleaseIndication (imsi, rnti, erabToBeReleaseIndication);
+  m_s1apSapEnbProvider->SendErabReleaseIndication (imsi, rnti, erabToBeReleaseIndication);
 }
 }  // namespace ns3
diff -Naru a/model/epc-enb-application.h b/model/epc-enb-application.h
--- a/model/epc-enb-application.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-enb-application.h	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Jaume Nin <jnin@cttc.cat>
  *         Nicola Baldo <nbaldo@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com> 
+ *          Support for real S1AP link
  */
 
 #ifndef EPC_ENB_APPLICATION_H
@@ -49,17 +53,12 @@
 class EpcEnbApplication : public Application
 {
 
-  /// allow MemberEpcEnbS1SapProvider<EpcEnbApplication> class friend access
   friend class MemberEpcEnbS1SapProvider<EpcEnbApplication>;
-  /// allow MemberEpcS1apSapEnb<EpcEnbApplication> class friend access
   friend class MemberEpcS1apSapEnb<EpcEnbApplication>;
 
 
+  // inherited from Object
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 protected:
   void DoDispose (void);
@@ -101,11 +100,11 @@
   EpcEnbS1SapProvider* GetS1SapProvider ();
 
   /** 
-   * Set the MME side of the S1-AP SAP 
+   * Set the S1AP provider for the S1AP eNB endpoint 
    * 
-   * \param s the MME side of the S1-AP SAP 
+   * \param s the S1AP provider
    */
-  void SetS1apSapMme (EpcS1apSapMme * s);
+  void SetS1apSapMme (EpcS1apSapEnbProvider * s);
 
   /** 
    * 
@@ -129,39 +128,16 @@
   void RecvFromS1uSocket (Ptr<Socket> socket);
 
 
-  /**
-   * EPS flow ID structure
-   */
   struct EpsFlowId_t
   {
-    uint16_t  m_rnti; ///< RNTI
-    uint8_t   m_bid; ///< Bid, the EPS Bearer IDentifier
+    uint16_t  m_rnti;
+    uint8_t   m_bid;
 
   public:
     EpsFlowId_t ();
-    /**
-     * Constructor
-     *
-     * \param a RNTI
-     * \param b bid
-     */
     EpsFlowId_t (const uint16_t a, const uint8_t b);
 
-    /**
-     * Comparison operator
-     *
-     * \param a first application
-     * \param b second application
-     * \returns true is the applications are "equal"
-     */
     friend bool operator == (const EpsFlowId_t &a, const EpsFlowId_t &b);
-    /**
-     * Less than operator
-     *
-     * \param a first application
-     * \param b second application
-     * \returns true is the applications are "equal"
-     */
     friend bool operator < (const EpsFlowId_t &a, const EpsFlowId_t &b);
   };
 
@@ -169,38 +145,12 @@
 private:
 
   // ENB S1 SAP provider methods
-  /**
-   * Initial UE message function
-   * \param imsi the IMSI
-   * \param rnti the RNTI
-   */
   void DoInitialUeMessage (uint64_t imsi, uint16_t rnti);
-  /**
-   * Path switch request function
-   * \param params PathSwitchRequestParameters
-   */
   void DoPathSwitchRequest (EpcEnbS1SapProvider::PathSwitchRequestParameters params);
-  /**
-   * UE Context Release function
-   * \param rnti the RNTI
-   */
   void DoUeContextRelease (uint16_t rnti);
   
   // S1-AP SAP ENB methods
-  /**
-   * Initial Context Setup Request 
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param erabToBeSetupList the ERAB setup list
-   */
   void DoInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapEnb::ErabToBeSetupItem> erabToBeSetupList);
-  /**
-   * Path Switch Request Acknowledge 
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param cgi the CGI
-   * \param erabToBeSwitchedInUplinkList the ERAB switched in uplink list
-   */
   void DoPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<EpcS1apSapEnb::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
 
   /** 
@@ -216,7 +166,6 @@
    * Send a packet to the UE via the LTE radio interface of the eNB
    * 
    * \param packet t
-   * \param rnti maps to enbUeS1Id
    * \param bid the EPS Bearer IDentifier
    */
   void SendToLteSocket (Ptr<Packet> packet, uint16_t rnti, uint8_t bid);
@@ -231,12 +180,13 @@
   void SendToS1uSocket (Ptr<Packet> packet, uint32_t teid);
 
 
+  
   /** 
    * internal method used for the actual setup of the S1 Bearer
    * 
-   * \param teid the Tunnel Endpoint IDentifier
-   * \param rnti maps to enbUeS1Id
-   * \param bid the S1-U Bearer IDentifier
+   * \param teid 
+   * \param rnti 
+   * \param bid 
    */
   void SetupS1Bearer (uint32_t teid, uint16_t rnti, uint8_t bid);
 
@@ -288,13 +238,13 @@
   EpcEnbS1SapUser* m_s1SapUser;
 
   /**
-   * MME side of the S1-AP SAP
+   * Provider for the methods of S1AP eNB endpoint
    * 
    */
-  EpcS1apSapMme* m_s1apSapMme;
+  EpcS1apSapEnbProvider* m_s1apSapEnbProvider;
 
   /**
-   * ENB side of the S1-AP SAP
+   * ENB side of the S1-AP SAP eNB endpoint
    * 
    */
   EpcS1apSapEnb* m_s1apSapEnb;
@@ -305,7 +255,7 @@
    */
   std::map<uint64_t, uint16_t> m_imsiRntiMap;
 
-  uint16_t m_cellId; ///< cell ID
+  uint16_t m_cellId;
 
 };
 
diff -Naru a/model/epc-enb-s1-sap.h b/model/epc-enb-s1-sap.h
--- a/model/epc-enb-s1-sap.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-enb-s1-sap.h	2017-10-05 11:47:22.294601711 +0200
@@ -57,27 +57,20 @@
    */
   virtual void DoSendReleaseIndication (uint64_t imsi, uint16_t rnti, uint8_t bearerId) = 0;
 
-  /// BearerToBeSwitched structure
   struct BearerToBeSwitched
   {
-    uint8_t epsBearerId; ///< Bearer ID
-    uint32_t teid; ///< TEID
+    uint8_t epsBearerId;
+    uint32_t teid;
   };
   
-  /// PathSwitchRequestParameters structure
   struct PathSwitchRequestParameters
   {
-    uint16_t rnti; ///< RNTI
-    uint16_t cellId; ///< cell ID
-    uint32_t mmeUeS1Id; ///< mmeUeS1Id in practice, we use the IMSI
-    std::list<BearerToBeSwitched> bearersToBeSwitched; ///< list of bearers to be switched 
+    uint16_t rnti;
+    uint16_t cellId;
+    uint32_t mmeUeS1Id;
+    std::list<BearerToBeSwitched> bearersToBeSwitched;
   };
 
-  /** 
-   * Path Switch Request 
-   * 
-   * \param params 
-   */
   virtual void PathSwitchRequest (PathSwitchRequestParameters params) = 0;
 
 
@@ -124,22 +117,15 @@
   /**
    * request the setup of a DataRadioBearer
    * 
-   *  \param params
    */
   virtual void DataRadioBearerSetupRequest (DataRadioBearerSetupRequestParameters params) = 0;
 
   
-  /// PathSwitchRequestAcknowledgeParameters structure
   struct PathSwitchRequestAcknowledgeParameters
   {
-    uint16_t rnti; ///< RNTI
+    uint16_t rnti;
   };
 
-  /**
-   * request a path switch acknowledge
-   * 
-   *  \param params
-   */
   virtual void PathSwitchRequestAcknowledge (PathSwitchRequestAcknowledgeParameters params) = 0;
   
 };
@@ -156,11 +142,6 @@
 class MemberEpcEnbS1SapProvider : public EpcEnbS1SapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberEpcEnbS1SapProvider (C* owner);
 
   // inherited from EpcEnbS1SapProvider
@@ -172,7 +153,7 @@
 
 private:
   MemberEpcEnbS1SapProvider ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -220,11 +201,6 @@
 class MemberEpcEnbS1SapUser : public EpcEnbS1SapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberEpcEnbS1SapUser (C* owner);
 
   // inherited from EpcEnbS1SapUser
@@ -233,7 +209,7 @@
 
 private:
   MemberEpcEnbS1SapUser ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
diff -Naru a/model/epc-mme-application.cc b/model/epc-mme-application.cc
--- a/model/epc-mme-application.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-mme-application.cc	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,298 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by Michele Polese <michele.polese@gmail.com>
+ *     (support for RRC_CONNECTED->RRC_IDLE state transition + fix for bug 2161
+ *      + extension to application & support for real S1AP link)
+ */
+
+#include <ns3/fatal-error.h>
+#include <ns3/log.h>
+
+#include "epc-s1ap-sap.h"
+#include "epc-s11-sap.h"
+
+#include "epc-mme-application.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("EpcMmeApplication");
+
+NS_OBJECT_ENSURE_REGISTERED (EpcMmeApplication);
+
+EpcMmeApplication::EpcMmeApplication ()
+  : m_s11SapSgw (0)
+{
+  NS_LOG_FUNCTION (this);
+  m_s1apSapMme = new MemberEpcS1apSapMme<EpcMmeApplication> (this);
+  m_s11SapMme = new MemberEpcS11SapMme<EpcMmeApplication> (this);
+}
+
+
+EpcMmeApplication::~EpcMmeApplication ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+EpcMmeApplication::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  delete m_s1apSapMme;
+  delete m_s11SapMme;
+}
+
+TypeId
+EpcMmeApplication::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcMmeApplication")
+    .SetParent<Object> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcMmeApplication> ()
+    ;
+  return tid;
+}
+
+EpcS1apSapMme* 
+EpcMmeApplication::GetS1apSapMme ()
+{
+  return m_s1apSapMme;
+}
+
+void 
+EpcMmeApplication::SetS1apSapMmeProvider(EpcS1apSapMmeProvider* provider)
+{
+  m_s1apSapMmeProvider = provider;
+}
+
+
+void 
+EpcMmeApplication::SetS11SapSgw (EpcS11SapSgw * s)
+{
+  m_s11SapSgw = s;
+}
+
+EpcS11SapMme* 
+EpcMmeApplication::GetS11SapMme ()
+{
+  return m_s11SapMme;
+}
+
+void 
+EpcMmeApplication::AddEnb (uint16_t gci, Ipv4Address enbS1uAddr)
+{
+  NS_LOG_FUNCTION (this << gci << enbS1uAddr);
+  Ptr<EnbInfo> enbInfo = Create<EnbInfo> ();
+  enbInfo->gci = gci;
+  enbInfo->s1uAddr = enbS1uAddr;
+  m_enbInfoMap[gci] = enbInfo;
+}
+
+void 
+EpcMmeApplication::AddUe (uint64_t imsi)
+{
+  NS_LOG_FUNCTION (this << imsi);
+  Ptr<UeInfo> ueInfo = Create<UeInfo> ();
+  ueInfo->imsi = imsi;
+  ueInfo->mmeUeS1Id = imsi;
+  m_ueInfoMap[imsi] = ueInfo;
+  ueInfo->bearerCounter = 0;
+}
+
+uint8_t
+EpcMmeApplication::AddBearer (uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer)
+{
+  NS_LOG_FUNCTION (this << imsi);
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  NS_ASSERT_MSG (it->second->bearerCounter < 11, "too many bearers already! " << it->second->bearerCounter);
+  BearerInfo bearerInfo;
+  bearerInfo.bearerId = ++(it->second->bearerCounter);
+  bearerInfo.tft = tft;
+  bearerInfo.bearer = bearer;  
+  it->second->bearersToBeActivated.push_back (bearerInfo);
+  return bearerInfo.bearerId;
+}
+
+
+// S1-AP SAP MME forwarded methods
+
+void 
+EpcMmeApplication::DoInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t gci)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id << imsi << gci);
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  it->second->cellId = gci;
+  EpcS11SapSgw::CreateSessionRequestMessage msg;
+  msg.imsi = imsi;
+  msg.uli.gci = gci;
+  for (std::list<BearerInfo>::iterator bit = it->second->bearersToBeActivated.begin ();
+       bit != it->second->bearersToBeActivated.end ();
+       ++bit)
+    {
+      EpcS11SapSgw::BearerContextToBeCreated bearerContext;
+      bearerContext.epsBearerId =  bit->bearerId;
+      NS_LOG_INFO("Mme: sending as bearerId " << (uint32_t) bit->bearerId);
+      bearerContext.bearerLevelQos = bit->bearer; 
+      bearerContext.tft = bit->tft;
+      msg.bearerContextsToBeCreated.push_back (bearerContext);
+    }
+  m_s11SapSgw->CreateSessionRequest (msg);
+}
+
+void 
+EpcMmeApplication::DoInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabSetupItem> erabSetupList)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id);
+  NS_FATAL_ERROR ("unimplemented");
+}
+
+void 
+EpcMmeApplication::DoPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<EpcS1apSapMme::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id << gci);
+
+  uint64_t imsi = mmeUeS1Id; 
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  NS_LOG_INFO ("IMSI " << imsi << " old eNB: " << it->second->cellId << ", new eNB: " << gci);
+  it->second->cellId = gci;
+  it->second->enbUeS1Id = enbUeS1Id;
+
+  EpcS11SapSgw::ModifyBearerRequestMessage msg;
+  msg.teid = imsi; // trick to avoid the need for allocating TEIDs on the S11 interface
+  msg.uli.gci = gci;
+  // bearer modification is not supported for now
+  m_s11SapSgw->ModifyBearerRequest (msg);
+}
+
+
+// S11 SAP MME forwarded methods
+
+void 
+EpcMmeApplication::DoCreateSessionResponse (EpcS11SapMme::CreateSessionResponseMessage msg)
+{
+  NS_LOG_FUNCTION (this << msg.teid);
+  uint64_t imsi = msg.teid;
+  std::list<EpcS1apSapEnb::ErabToBeSetupItem> erabToBeSetupList;
+  for (std::list<EpcS11SapMme::BearerContextCreated>::iterator bit = msg.bearerContextsCreated.begin ();
+       bit != msg.bearerContextsCreated.end ();
+       ++bit)
+    {
+      EpcS1apSapEnb::ErabToBeSetupItem erab;
+      erab.erabId = bit->epsBearerId;
+      erab.erabLevelQosParameters = bit->bearerLevelQos;
+      erab.transportLayerAddress = bit->sgwFteid.address;
+      erab.sgwTeid = bit->sgwFteid.teid;      
+      erabToBeSetupList.push_back (erab);
+    }
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  uint16_t cellId = it->second->cellId;
+  uint16_t enbUeS1Id = it->second->enbUeS1Id;
+  uint64_t mmeUeS1Id = it->second->mmeUeS1Id;
+  std::map<uint16_t, Ptr<EnbInfo> >::iterator jt = m_enbInfoMap.find (cellId);
+  NS_ASSERT_MSG (jt != m_enbInfoMap.end (), "could not find any eNB with CellId " << cellId);
+  m_s1apSapMmeProvider->SendInitialContextSetupRequest (mmeUeS1Id, enbUeS1Id, erabToBeSetupList, cellId);
+}
+
+
+void 
+EpcMmeApplication::DoModifyBearerResponse (EpcS11SapMme::ModifyBearerResponseMessage msg)
+{
+  NS_LOG_FUNCTION (this << msg.teid);
+  NS_ASSERT (msg.cause == EpcS11SapMme::ModifyBearerResponseMessage::REQUEST_ACCEPTED);
+  uint64_t imsi = msg.teid;
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  uint64_t enbUeS1Id = it->second->enbUeS1Id;
+  uint64_t mmeUeS1Id = it->second->mmeUeS1Id;
+  uint16_t cgi = it->second->cellId;
+  std::list<EpcS1apSapEnb::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList; // unused for now
+  std::map<uint16_t, Ptr<EnbInfo> >::iterator jt = m_enbInfoMap.find (it->second->cellId);
+  NS_ASSERT_MSG (jt != m_enbInfoMap.end (), "could not find any eNB with CellId " << it->second->cellId);
+  m_s1apSapMmeProvider->SendPathSwitchRequestAcknowledge (enbUeS1Id, mmeUeS1Id, cgi, erabToBeSwitchedInUplinkList);
+}
+
+void
+EpcMmeApplication::DoErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabToBeReleasedIndication> erabToBeReleaseIndication)
+{
+  NS_LOG_FUNCTION (this << mmeUeS1Id << enbUeS1Id);
+  uint64_t imsi = mmeUeS1Id;
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+
+  EpcS11SapSgw::DeleteBearerCommandMessage msg;
+  // trick to avoid the need for allocating TEIDs on the S11 interface
+  msg.teid = imsi;
+
+  for (std::list<EpcS1apSapMme::ErabToBeReleasedIndication>::iterator bit = erabToBeReleaseIndication.begin (); bit != erabToBeReleaseIndication.end (); ++bit)
+    {
+      EpcS11SapSgw::BearerContextToBeRemoved bearerContext;
+      bearerContext.epsBearerId =  bit->erabId;
+      msg.bearerContextsToBeRemoved.push_back (bearerContext);
+    }
+  //Delete Bearer command towards epc-sgw-pgw-application
+  m_s11SapSgw->DeleteBearerCommand (msg);
+}
+
+void
+EpcMmeApplication::DoDeleteBearerRequest (EpcS11SapMme::DeleteBearerRequestMessage msg)
+{
+  NS_LOG_FUNCTION (this);
+  uint64_t imsi = msg.teid;
+  std::map<uint64_t, Ptr<UeInfo> >::iterator it = m_ueInfoMap.find (imsi);
+  NS_ASSERT_MSG (it != m_ueInfoMap.end (), "could not find any UE with IMSI " << imsi);
+  EpcS11SapSgw::DeleteBearerResponseMessage res;
+
+  res.teid = imsi;
+
+  for (std::list<EpcS11SapMme::BearerContextRemoved>::iterator bit = msg.bearerContextsRemoved.begin ();
+       bit != msg.bearerContextsRemoved.end ();
+       ++bit)
+    {
+      EpcS11SapSgw::BearerContextRemovedSgwPgw bearerContext;
+      bearerContext.epsBearerId = bit->epsBearerId;
+      res.bearerContextsRemoved.push_back (bearerContext);
+
+      RemoveBearer (it->second, bearerContext.epsBearerId); //schedules function to erase, context of de-activated bearer
+    }
+  //schedules Delete Bearer Response towards epc-sgw-pgw-application
+  m_s11SapSgw->DeleteBearerResponse (res);
+}
+
+void EpcMmeApplication::RemoveBearer (Ptr<UeInfo> ueInfo, uint8_t epsBearerId)
+{
+  NS_LOG_FUNCTION (this << epsBearerId);
+  for (std::list<BearerInfo>::iterator bearerIterator = ueInfo->bearersToBeActivated.begin ();
+       bearerIterator != ueInfo->bearersToBeActivated.end ();
+       ++bearerIterator)
+    {
+      if (bearerIterator->bearerId == epsBearerId)
+        {
+          ueInfo->bearersToBeActivated.erase (bearerIterator);
+          ueInfo->bearerCounter = ueInfo->bearerCounter - 1;
+          break;
+        }
+    }
+}
+
+} // namespace ns3
diff -Naru a/model/epc-mme-application.h b/model/epc-mme-application.h
--- a/model/epc-mme-application.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-mme-application.h	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,205 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Nicola Baldo <nbaldo@cttc.es> wrote the EpcMme class
+ * Author: Michele Polese <michele.polese@gmail.com> wrote the Application version
+ */
+
+#ifndef EPC_MME_APPLICATION_H
+#define EPC_MME_APPLICATION_H
+
+#include <ns3/object.h>
+#include <ns3/epc-s1ap-sap.h>
+#include <ns3/epc-s11-sap.h>
+#include <ns3/application.h>
+
+
+#include <map>
+#include <list>
+
+namespace ns3 {
+
+class Node;
+class NetDevice;
+
+/**
+ * \brief This object implements as an application the MME functionality.
+ *
+ */
+class EpcMmeApplication : public Application
+{
+
+  friend class MemberEpcS1apSapMme<EpcMmeApplication>;
+  friend class MemberEpcS11SapMme<EpcMmeApplication>;
+  
+public:
+  
+  /** 
+   * Constructor
+   */
+  EpcMmeApplication ();
+
+  /** 
+   * Destructor
+   */  
+  virtual ~EpcMmeApplication ();
+  
+  // inherited from Object  
+  static TypeId GetTypeId (void);
+protected:
+  virtual void DoDispose ();
+
+public:
+
+
+  /** 
+   * 
+   * \return the MME side of the S1-AP SAP 
+   */
+  EpcS1apSapMme* GetS1apSapMme ();
+
+  /**
+   * \param the MME provider, given by the S1AP object associated to this application
+   */
+  void SetS1apSapMmeProvider(EpcS1apSapMmeProvider* provider);
+
+  /** 
+   * Set the SGW side of the S11 SAP 
+   * 
+   * \param s the SGW side of the S11 SAP 
+   */
+  void SetS11SapSgw (EpcS11SapSgw * s);
+
+  /** 
+   * 
+   * \return the MME side of the S11 SAP 
+   */
+  EpcS11SapMme* GetS11SapMme ();
+
+  /** 
+   * Add a new ENB to the MME. 
+   * \param ecgi E-UTRAN Cell Global ID, the unique identifier of the eNodeB
+   * \param the eNB S1UAddr 
+   */
+  void AddEnb (uint16_t ecgi, Ipv4Address enbS1UAddr);
+  
+  /** 
+   * Add a new UE to the MME. This is the equivalent of storing the UE
+   * credentials before the UE is ever turned on. 
+   * 
+   * \param imsi the unique identifier of the UE
+   */
+  void AddUe (uint64_t imsi);
+
+  /** 
+   * Add an EPS bearer to the list of bearers to be activated for this
+   * UE. The bearer will be activated when the UE enters the ECM
+   * connected state.
+   * 
+   * \param imsi UE identifier
+   * \param tft traffic flow template of the bearer
+   * \param bearer QoS characteristics of the bearer
+   */
+  uint8_t AddBearer (uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
+
+
+private:
+
+  // S1-AP SAP MME forwarded methods
+  void DoInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
+  void DoInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabSetupItem> erabSetupList);
+  void DoPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<EpcS1apSapMme::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
+  void DoErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabToBeReleasedIndication> erabToBeReleaseIndication);
+
+  // S11 SAP MME forwarded methods
+  void DoCreateSessionResponse (EpcS11SapMme::CreateSessionResponseMessage msg);
+  void DoModifyBearerResponse (EpcS11SapMme::ModifyBearerResponseMessage msg);
+  void DoDeleteBearerRequest (EpcS11SapMme::DeleteBearerRequestMessage msg);
+
+
+  /**
+   * Hold info on an EPS bearer to be activated
+   * 
+   */
+  struct BearerInfo
+  {
+    Ptr<EpcTft> tft;
+    EpsBearer bearer;
+    uint8_t bearerId;
+  };
+  
+  /**
+   * Hold info on a UE
+   * 
+   */
+  struct UeInfo : public SimpleRefCount<UeInfo>
+  {
+    uint64_t mmeUeS1Id;
+    uint16_t enbUeS1Id;
+    uint64_t imsi;
+    uint16_t cellId;
+    std::list<BearerInfo> bearersToBeActivated;
+    uint16_t bearerCounter;
+  };
+
+  /**
+   * UeInfo stored by IMSI
+   * 
+   */  
+  std::map<uint64_t, Ptr<UeInfo> > m_ueInfoMap;
+
+  /**
+   * \brief This Function erases all contexts of bearer from MME side
+   * \param ueInfo UE information pointer
+   * \param epsBearerId Bearer Id which need to be removed corresponding to UE
+   */
+  void RemoveBearer (Ptr<UeInfo> ueInfo, uint8_t epsBearerId);
+
+  /**
+   * Hold info on a ENB
+   * 
+   */
+  struct EnbInfo : public SimpleRefCount<EnbInfo>
+  {
+    uint16_t gci;
+    Ipv4Address s1uAddr;
+  };
+
+  /**
+   * EnbInfo stored by EGCI
+   * 
+   */
+  std::map<uint16_t, Ptr<EnbInfo> > m_enbInfoMap;
+
+
+  
+
+  EpcS1apSapMme* m_s1apSapMme;
+  EpcS1apSapMmeProvider* m_s1apSapMmeProvider;
+
+  EpcS11SapMme* m_s11SapMme;
+  EpcS11SapSgw* m_s11SapSgw;
+  
+};
+
+
+
+
+} // namespace ns3
+
+#endif // EPC_MME_APPLICATION_H
diff -Naru a/model/epc-mme.cc b/model/epc-mme.cc
--- a/model/epc-mme.cc	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-mme.cc	2017-10-05 11:47:22.294601711 +0200
@@ -132,8 +132,7 @@
   it->second->cellId = gci;
   EpcS11SapSgw::CreateSessionRequestMessage msg;
   msg.imsi = imsi;
-  msg.uli.gci = gci;
-  msg.teid = 0;
+  msg. uli.gci = gci;
   for (std::list<BearerInfo>::iterator bit = it->second->bearersToBeActivated.begin ();
        bit != it->second->bearersToBeActivated.end ();
        ++bit)
diff -Naru a/model/epc-mme.h b/model/epc-mme.h
--- a/model/epc-mme.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-mme.h	2017-10-05 11:47:22.294601711 +0200
@@ -40,9 +40,7 @@
 class EpcMme : public Object
 {
 
-  /// allow MemberEpcS1apSapMme<EpcMme> class friend access
   friend class MemberEpcS1apSapMme<EpcMme>;
-  /// allow MemberEpcS11SapMme<EpcMme> class friend access
   friend class MemberEpcS11SapMme<EpcMme>;
   
 public:
@@ -57,10 +55,7 @@
    */  
   virtual ~EpcMme ();
   
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
+  // inherited from Object  
   static TypeId GetTypeId (void);
 protected:
   virtual void DoDispose ();
@@ -90,7 +85,6 @@
   /** 
    * Add a new ENB to the MME. 
    * \param ecgi E-UTRAN Cell Global ID, the unique identifier of the eNodeB
-   * \param enbS1UAddr address of the eNB for S1-U communications
    * \param enbS1apSap the ENB side of the S1-AP SAP 
    */
   void AddEnb (uint16_t ecgi, Ipv4Address enbS1UAddr, EpcS1apSapEnb* enbS1apSap);
@@ -111,7 +105,6 @@
    * \param imsi UE identifier
    * \param tft traffic flow template of the bearer
    * \param bearer QoS characteristics of the bearer
-   * \returns bearer ID 
    */
   uint8_t AddBearer (uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer);
 
@@ -119,52 +112,14 @@
 private:
 
   // S1-AP SAP MME forwarded methods
-  /**
-   * Initial UE Message function 
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param imsi the IMSI
-   * \param ecgi the ECGI
-   */
   void DoInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
-  /**
-   * Initial Context Setup Response function 
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param erabSetupList the ERAB setup list
-   */
   void DoInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabSetupItem> erabSetupList);
-  /**
-   * Path Switch Request function
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param cgi the CGI
-   * \param erabToBeSwitchedInDownlinkList the ERAB to be switched in downlink list
-   */
   void DoPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<EpcS1apSapMme::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
-  /**
-   * ERAB Release Indication function
-   * \param mmeUeS1Id the MME UE S1 ID
-   * \param enbUeS1Id the ENB UE S1 ID
-   * \param erabToBeReleaseIndication the ERAB to be release indication list
-   */
   void DoErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSapMme::ErabToBeReleasedIndication> erabToBeReleaseIndication);
 
   // S11 SAP MME forwarded methods
-  /**
-   * Create Session Response function
-   * \param msg EpcS11SapMme::CreateSessionResponseMessage
-   */
   void DoCreateSessionResponse (EpcS11SapMme::CreateSessionResponseMessage msg);
-  /**
-   * Modify Bearer Response function
-   * \param msg EpcS11SapMme::ModifyBearerResponseMessage
-   */
   void DoModifyBearerResponse (EpcS11SapMme::ModifyBearerResponseMessage msg);
-  /**
-   * Delete Bearer Request function
-   * \param msg EpcS11SapMme::DeleteBearerRequestMessage
-   */
   void DoDeleteBearerRequest (EpcS11SapMme::DeleteBearerRequestMessage msg);
 
 
@@ -174,9 +129,9 @@
    */
   struct BearerInfo
   {
-    Ptr<EpcTft> tft;  ///< traffic flow template
-    EpsBearer bearer; ///< bearer QOS characteristics 
-    uint8_t bearerId; ///< bearer ID
+    Ptr<EpcTft> tft;
+    EpsBearer bearer;
+    uint8_t bearerId;
   };
   
   /**
@@ -185,12 +140,12 @@
    */
   struct UeInfo : public SimpleRefCount<UeInfo>
   {
-    uint64_t mmeUeS1Id; ///< mmeUeS1Id
-    uint16_t enbUeS1Id; ///< enbUeS1Id
-    uint64_t imsi; ///< UE identifier
-    uint16_t cellId; ///< cell ID
-    std::list<BearerInfo> bearersToBeActivated; ///< list of bearers to be activated
-    uint16_t bearerCounter; ///< bearer counter
+    uint64_t mmeUeS1Id;
+    uint16_t enbUeS1Id;
+    uint64_t imsi;
+    uint16_t cellId;
+    std::list<BearerInfo> bearersToBeActivated;
+    uint16_t bearerCounter;
   };
 
   /**
@@ -212,9 +167,9 @@
    */
   struct EnbInfo : public SimpleRefCount<EnbInfo>
   {
-    uint16_t gci; ///< GCI
-    Ipv4Address s1uAddr; ///< IP address
-    EpcS1apSapEnb* s1apSapEnb; ///< EpcS1apSapEnb
+    uint16_t gci;
+    Ipv4Address s1uAddr;
+    EpcS1apSapEnb* s1apSapEnb;
   };
 
   /**
@@ -226,10 +181,10 @@
 
   
 
-  EpcS1apSapMme* m_s1apSapMme; ///< EpcS1apSapMme
+  EpcS1apSapMme* m_s1apSapMme;
 
-  EpcS11SapMme* m_s11SapMme; ///< EpcS11SapMme
-  EpcS11SapSgw* m_s11SapSgw; ///< EpcS11SapSgw
+  EpcS11SapMme* m_s11SapMme;
+  EpcS11SapSgw* m_s11SapSgw;
   
 };
 
diff -Naru a/model/epc-s1ap.cc b/model/epc-s1ap.cc
--- a/model/epc-s1ap.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap.cc	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,620 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com> 
+ *          Support for real S1AP link
+ */
+
+#include "ns3/log.h"
+#include "ns3/inet-socket-address.h"
+#include "ns3/packet.h"
+#include "ns3/node.h"
+#include "ns3/epc-gtpu-header.h"
+#include <ns3/simulator.h>
+
+#include "ns3/epc-s1ap-header.h"
+#include "ns3/epc-s1ap.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("EpcS1ap");
+
+S1apIfaceInfo::S1apIfaceInfo (Ipv4Address remoteIpAddr, Ptr<Socket> localCtrlPlaneSocket)
+{
+  m_remoteIpAddr = remoteIpAddr;
+  m_localCtrlPlaneSocket = localCtrlPlaneSocket;
+}
+
+S1apIfaceInfo::~S1apIfaceInfo (void)
+{
+  m_localCtrlPlaneSocket = 0;
+}
+
+S1apIfaceInfo& 
+S1apIfaceInfo::operator= (const S1apIfaceInfo& value)
+{
+  NS_LOG_FUNCTION (this);
+  m_remoteIpAddr = value.m_remoteIpAddr;
+  m_localCtrlPlaneSocket = value.m_localCtrlPlaneSocket;
+  return *this;
+}
+
+///////////////////////////////////////////
+
+S1apConnectionInfo::S1apConnectionInfo (uint16_t enbId, uint16_t mmeId)
+{
+  m_enbId = enbId;
+  m_mmeId = mmeId;
+}
+
+S1apConnectionInfo::~S1apConnectionInfo (void)
+{
+  m_enbId = 0;
+  m_mmeId = 0;
+}
+
+S1apConnectionInfo& 
+S1apConnectionInfo::operator= (const S1apConnectionInfo& value)
+{
+  NS_LOG_FUNCTION (this);
+  m_enbId = value.m_enbId;
+  m_mmeId = value.m_mmeId;
+  return *this;
+}
+
+///////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1apEnb);
+
+EpcS1apEnb::EpcS1apEnb (Ptr<Socket> localSocket, Ipv4Address enbAddress, Ipv4Address mmeAddress, uint16_t cellId, uint16_t mmeId)
+  : m_s1apUdpPort (36412) // As defined by IANA
+{
+  NS_LOG_FUNCTION (this);
+  AddS1apInterface(cellId, enbAddress, mmeId, mmeAddress, localSocket);
+  m_s1apSapProvider = new MemberEpcS1apSapEnbProvider<EpcS1apEnb> (this);
+}
+
+EpcS1apEnb::~EpcS1apEnb ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+EpcS1apEnb::DoDispose (void)
+{
+  NS_LOG_FUNCTION (this);
+
+  m_s1apInterfaceSockets.clear ();
+  m_s1apInterfaceCellIds.clear ();
+  delete m_s1apSapProvider;
+}
+
+TypeId
+EpcS1apEnb::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1apEnb")
+    .SetParent<Object> ()
+    .SetGroupName("Lte");
+  return tid;
+}
+
+void
+EpcS1apEnb::SetEpcS1apSapEnbUser (EpcS1apSapEnb * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_s1apSapUser = s;
+}
+
+EpcS1apSapEnbProvider*
+EpcS1apEnb::GetEpcS1apSapEnbProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_s1apSapProvider;
+}
+
+
+void
+EpcS1apEnb::AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress,
+                       uint16_t mmeId, Ipv4Address mmeAddress,
+                       Ptr<Socket> localS1apSocket)
+{
+  NS_LOG_FUNCTION (this << enbId << enbAddress << mmeId << mmeAddress);
+
+  localS1apSocket->SetRecvCallback (MakeCallback (&EpcS1apEnb::RecvFromS1apSocket, this));
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (mmeId) == m_s1apInterfaceSockets.end (),
+                 "Mapping for mmeId = " << mmeId << " is already known");
+  m_s1apInterfaceSockets [mmeId] = Create<S1apIfaceInfo> (mmeAddress, localS1apSocket);
+
+  // TODO m_mmeId is initialized once since one mme is connected to this enb interface, consider when extending
+  m_mmeId = mmeId;
+}
+
+
+void 
+EpcS1apEnb::RecvFromS1apSocket (Ptr<Socket> socket)
+{
+  NS_LOG_FUNCTION (this << socket);
+
+  NS_LOG_LOGIC ("Recv S1ap message: S1AP eNB: from Socket at time " << Simulator::Now ().GetSeconds());
+  Ptr<Packet> packet = socket->Recv ();
+  NS_LOG_LOGIC ("packetLen = " << packet->GetSize ());
+
+  EpcS1APHeader s1apHeader;
+  packet->RemoveHeader (s1apHeader);
+
+  NS_LOG_LOGIC ("S1ap header: " << s1apHeader);
+
+  uint8_t procedureCode = s1apHeader.GetProcedureCode ();
+
+  if (procedureCode == EpcS1APHeader::InitialContextSetupRequest)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: INITIAL CONTEXT SETUP REQUEST");
+    EpcS1APInitialContextSetupRequestHeader reqHeader;
+    packet->RemoveHeader(reqHeader);
+
+    NS_LOG_INFO ("S1ap Initial Context Setup Request " << reqHeader);
+
+    uint64_t mmeUeS1apId = reqHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1apId = reqHeader.GetEnbUeS1Id();
+    std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetup = reqHeader.GetErabToBeSetupItem ();
+    
+    NS_LOG_LOGIC ("mmeUeS1apId " << mmeUeS1apId);
+    NS_LOG_LOGIC ("enbUeS1apId " << enbUeS1apId);
+
+    m_s1apSapUser->InitialContextSetupRequest(mmeUeS1apId, enbUeS1apId, erabToBeSetup);
+  } 
+  else if (procedureCode == EpcS1APHeader::PathSwitchRequestAck)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: PATH SWITCH REQUEST ACK");
+    EpcS1APPathSwitchRequestAcknowledgeHeader reqHeader;
+    packet->RemoveHeader(reqHeader);
+
+    NS_LOG_INFO ("S1ap Path Switch Request Acknowledge Header " << reqHeader);
+
+    uint64_t mmeUeS1apId = reqHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1apId = reqHeader.GetEnbUeS1Id();
+    uint16_t ecgi = reqHeader.GetEcgi();
+    std::list<EpcS1apSap::ErabSwitchedInUplinkItem> pathErab = reqHeader.GetErabSwitchedInUplinkItemList ();
+    
+    NS_LOG_LOGIC ("mmeUeS1apId " << mmeUeS1apId);
+    NS_LOG_LOGIC ("enbUeS1apId " << enbUeS1apId);
+    NS_LOG_LOGIC ("ecgi " << ecgi);
+
+    m_s1apSapUser->PathSwitchRequestAcknowledge(enbUeS1apId, mmeUeS1apId, ecgi, pathErab);
+  }  
+  else
+  {
+    NS_ASSERT_MSG (false, "ProcedureCode NOT SUPPORTED!!!");
+  }
+}
+
+
+//
+// Implementation of the S1ap SAP Provider
+//
+void
+EpcS1apEnb::DoSendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) 
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("stmsi = " << stmsi);
+  NS_LOG_LOGIC("ecgi = " << ecgi);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: INITIAL UE MESSAGE " << Simulator::Now ().GetSeconds());
+
+  // build the header
+  EpcS1APInitialUeMessageHeader initialMessage;
+  initialMessage.SetMmeUeS1Id(mmeUeS1Id);
+  initialMessage.SetEnbUeS1Id(enbUeS1Id);
+  initialMessage.SetSTmsi(stmsi);
+  initialMessage.SetEcgi(ecgi);
+  NS_LOG_INFO ("S1ap Initial Message header " << initialMessage);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::InitialUeMessage);
+  s1apHeader.SetLengthOfIes (initialMessage.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (initialMessage.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (initialMessage);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apEnb::DoSendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication )
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: E-RAB RELEASE INDICATION " << Simulator::Now ().GetSeconds());
+
+  EpcS1APErabReleaseIndicationHeader indHeader;
+  
+  indHeader.SetMmeUeS1Id(mmeUeS1Id);
+  indHeader.SetEnbUeS1Id(enbUeS1Id);
+  indHeader.SetErabReleaseIndication(erabToBeReleaseIndication);
+  NS_LOG_INFO ("S1ap E-rab Release Indication header " << indHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::ErabReleaseIndication);
+  s1apHeader.SetLengthOfIes (indHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (indHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (indHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apEnb::DoSendInitialContextSetupResponse (uint64_t mmeUeS1Id,
+              uint16_t enbUeS1Id,
+              std::list<EpcS1apSap::ErabSetupItem> erabSetupList) 
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: INITIAL CONTEXT SETUP RESPONSE " << Simulator::Now ().GetSeconds());
+
+  EpcS1APInitialContextSetupResponseHeader indHeader;
+  
+  indHeader.SetMmeUeS1Id(mmeUeS1Id);
+  indHeader.SetEnbUeS1Id(enbUeS1Id);
+  indHeader.SetErabSetupItem(erabSetupList);
+  NS_LOG_INFO ("S1AP Initial Context Setup Response header " << indHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::InitialContextSetupResponse);
+  s1apHeader.SetLengthOfIes (indHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (indHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (indHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apEnb::DoSendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, 
+            std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("ecgi = " << gci);
+
+  // TODO check if an assert is needed
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [m_mmeId]; // in case of multiple mme, extend the call
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address mmeIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("mmeIpAddr = " << mmeIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: PATH SWITCH REQUEST " << Simulator::Now ().GetSeconds());
+
+  EpcS1APPathSwitchRequestHeader indHeader;
+  
+  indHeader.SetMmeUeS1Id(mmeUeS1Id);
+  indHeader.SetEnbUeS1Id(enbUeS1Id);
+  indHeader.SetEcgi(gci);
+  indHeader.SetErabSwitchedInDownlinkItemList(erabToBeSwitchedInDownlinkList);
+  NS_LOG_INFO ("S1AP Path Switch Request header " << indHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::PathSwitchRequest);
+  s1apHeader.SetLengthOfIes (indHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (indHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (indHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (mmeIpAddr, m_s1apUdpPort));
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////
+NS_OBJECT_ENSURE_REGISTERED (EpcS1apMme);
+
+EpcS1apMme::EpcS1apMme (const Ptr<Socket> s1apSocket, uint16_t mmeId)
+  : m_s1apUdpPort (36412) // As defined by IANA
+{
+  NS_LOG_FUNCTION (this);
+  m_localS1APSocket = s1apSocket;
+  m_s1apSapProvider = new MemberEpcS1apSapMmeProvider<EpcS1apMme> (this);
+  m_localS1APSocket->SetRecvCallback (MakeCallback (&EpcS1apMme::RecvFromS1apSocket, this));
+  m_mmeId = mmeId;
+}
+
+EpcS1apMme::~EpcS1apMme ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+void
+EpcS1apMme::DoDispose (void)
+{
+  NS_LOG_FUNCTION (this);
+
+  m_s1apInterfaceSockets.clear ();
+  m_s1apInterfaceCellIds.clear ();
+  delete m_s1apSapProvider;
+}
+
+TypeId
+EpcS1apMme::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1apMme")
+    .SetParent<Object> ()
+    .SetGroupName("Lte");
+  return tid;
+}
+
+void
+EpcS1apMme::SetEpcS1apSapMmeUser (EpcS1apSapMme * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_s1apSapUser = s;
+}
+
+EpcS1apSapMmeProvider*
+EpcS1apMme::GetEpcS1apSapMmeProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_s1apSapProvider;
+}
+
+
+void
+EpcS1apMme::AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress)
+{
+  NS_LOG_FUNCTION (this << enbId << enbAddress << m_mmeId);
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (enbId) == m_s1apInterfaceSockets.end (),
+                 "Mapping for enbId = " << enbId << " is already known");
+  m_s1apInterfaceSockets [enbId] = Create<S1apIfaceInfo> (enbAddress, m_localS1APSocket); // TODO m_localS1APSocket is useless
+}
+
+
+void 
+EpcS1apMme::RecvFromS1apSocket (Ptr<Socket> socket)
+{
+  NS_LOG_FUNCTION (this << socket);
+
+  NS_LOG_LOGIC ("Recv S1ap message: S1AP MME: from Socket " << Simulator::Now ().GetSeconds());
+  Ptr<Packet> packet = socket->Recv ();
+  NS_LOG_LOGIC ("packetLen = " << packet->GetSize ());
+
+  EpcS1APHeader s1apHeader;
+  packet->RemoveHeader (s1apHeader);
+
+  NS_LOG_LOGIC ("S1ap header: " << s1apHeader);
+
+  uint8_t procedureCode = s1apHeader.GetProcedureCode ();
+
+  if (procedureCode == EpcS1APHeader::InitialUeMessage)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: INITIAL UE MESSAGE");
+    EpcS1APInitialUeMessageHeader initialMessage;
+    packet->RemoveHeader(initialMessage);
+    NS_LOG_INFO ("S1ap Initial Message header " << initialMessage);
+
+    uint64_t mmeUeS1Id = initialMessage.GetMmeUeS1Id();
+    uint16_t enbUeS1Id = initialMessage.GetEnbUeS1Id();
+    uint64_t stmsi = initialMessage.GetSTmsi();
+    uint16_t ecgi = initialMessage.GetEcgi();
+
+    NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+    NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+    NS_LOG_LOGIC("stmsi = " << stmsi);
+    NS_LOG_LOGIC("ecgi = " << ecgi);
+
+    // TODO check if ASSERT is needed
+
+    m_s1apSapUser->InitialUeMessage(mmeUeS1Id, enbUeS1Id, stmsi, ecgi);
+
+  }
+  else if (procedureCode == EpcS1APHeader::PathSwitchRequest)
+  {
+    NS_LOG_LOGIC ("Recv S1ap message: PATH SWITCH REQUEST " << Simulator::Now ().GetSeconds());
+    EpcS1APPathSwitchRequestHeader psrHeader;
+    packet->RemoveHeader(psrHeader);
+    NS_LOG_INFO ("S1ap Path Switch Request header " << psrHeader);
+    
+    uint64_t mmeUeS1Id = psrHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1Id = psrHeader.GetEnbUeS1Id();
+    uint16_t ecgi = psrHeader.GetEcgi();
+
+    std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitched = psrHeader.GetErabSwitchedInDownlinkItemList ();
+
+
+    NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+    NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+    NS_LOG_LOGIC("ecgi = " << ecgi);
+
+    m_s1apSapUser->PathSwitchRequest (enbUeS1Id, mmeUeS1Id, ecgi, erabToBeSwitched);
+  }
+  else if (procedureCode == EpcS1APHeader::ErabReleaseIndication)
+  {
+   NS_LOG_LOGIC ("Recv S1ap message: E-RAB RELEASE INDICATION " << Simulator::Now ().GetSeconds());
+    EpcS1APErabReleaseIndicationHeader eriHeader;
+    packet->RemoveHeader(eriHeader);
+    NS_LOG_INFO ("S1ap Erab Release Indication header " << eriHeader);
+    
+    uint64_t mmeUeS1Id = eriHeader.GetMmeUeS1Id();
+    uint16_t enbUeS1Id = eriHeader.GetEnbUeS1Id();
+
+    std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication = eriHeader.GetErabToBeReleaseIndication ();
+
+    NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+    NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+
+    m_s1apSapUser->ErabReleaseIndication (mmeUeS1Id, enbUeS1Id, erabToBeReleaseIndication);
+  }
+  else
+  {
+    NS_ASSERT_MSG (false, "ProcedureCode NOT SUPPORTED!!!");
+  }
+}
+
+void 
+EpcS1apMme::DoSendInitialContextSetupRequest (uint64_t mmeUeS1Id,
+                                           uint16_t enbUeS1Id,
+                                           std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetupList,
+                                           uint16_t cellId)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("eNB id = " << cellId);
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (cellId) != m_s1apInterfaceSockets.end (),
+               "Missing infos for cellId = " << cellId);
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [cellId];
+  Ipv4Address enbIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("enbIpAddr = " << enbIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: INITIAL CONTEXT SETUP REQUEST " << Simulator::Now ().GetSeconds());
+
+  EpcS1APInitialContextSetupRequestHeader reqHeader;
+  
+  reqHeader.SetMmeUeS1Id(mmeUeS1Id);
+  reqHeader.SetEnbUeS1Id(enbUeS1Id);
+  reqHeader.SetErabToBeSetupItem(erabToBeSetupList);
+  NS_LOG_INFO ("S1AP Initial Context Setup Request header " << reqHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::InitialContextSetupRequest);
+  s1apHeader.SetLengthOfIes (reqHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (reqHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (reqHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  m_localS1APSocket->SendTo (packet, 0, InetSocketAddress (enbIpAddr, m_s1apUdpPort));
+}
+
+void 
+EpcS1apMme::DoSendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, 
+                                        std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList)
+{
+  // cgi is the cellId of the other endpoint of this interface
+  uint16_t cellId = cgi;
+
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC("mmeUeS1apId = " << mmeUeS1Id);
+  NS_LOG_LOGIC("enbUeS1apId = " << enbUeS1Id);
+  NS_LOG_LOGIC("eNB id = " << cellId);
+
+  NS_ASSERT_MSG (m_s1apInterfaceSockets.find (cellId) != m_s1apInterfaceSockets.end (),
+               "Missing infos for cellId = " << cellId);
+
+  Ptr<S1apIfaceInfo> socketInfo = m_s1apInterfaceSockets [cellId];
+  Ipv4Address enbIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("enbIpAddr = " << enbIpAddr);
+
+  NS_LOG_INFO ("Send S1ap message: PATH SWITCH REQUEST ACKNOWLEDGE " << Simulator::Now ().GetSeconds());
+
+  EpcS1APPathSwitchRequestAcknowledgeHeader reqHeader;
+  
+  reqHeader.SetMmeUeS1Id(mmeUeS1Id);
+  reqHeader.SetEnbUeS1Id(enbUeS1Id);
+  reqHeader.SetEcgi(cgi);
+  reqHeader.SetErabSwitchedInUplinkItemList(erabToBeSwitchedInUplinkList);
+  NS_LOG_INFO ("S1AP PathSwitchRequestAcknowledge header " << reqHeader);
+
+  EpcS1APHeader s1apHeader;
+  s1apHeader.SetProcedureCode (EpcS1APHeader::PathSwitchRequestAck);
+  s1apHeader.SetLengthOfIes (reqHeader.GetLengthOfIes ());
+  s1apHeader.SetNumberOfIes (reqHeader.GetNumberOfIes ());
+  NS_LOG_INFO ("S1ap header: " << s1apHeader);
+
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (reqHeader);
+  packet->AddHeader (s1apHeader);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the S1ap message through the socket
+  m_localS1APSocket->SendTo (packet, 0, InetSocketAddress (enbIpAddr, m_s1apUdpPort));
+}
+
+
+
+} // namespace ns3
diff -Naru a/model/epc-s1ap.h b/model/epc-s1ap.h
--- a/model/epc-s1ap.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap.h	2017-10-05 11:47:22.298601725 +0200
@@ -0,0 +1,256 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com> 
+ */
+
+#ifndef EPC_S1AP_H
+#define EPC_S1AP_H
+
+#include "ns3/socket.h"
+#include "ns3/callback.h"
+#include "ns3/ptr.h"
+#include "ns3/object.h"
+
+#include "ns3/epc-s1ap-sap.h"
+
+#include <map>
+
+namespace ns3 {
+
+
+class S1apIfaceInfo : public SimpleRefCount<S1apIfaceInfo>
+{
+public:
+  S1apIfaceInfo (Ipv4Address remoteIpAddr, Ptr<Socket> localCtrlPlaneSocket);
+  virtual ~S1apIfaceInfo (void);
+
+  S1apIfaceInfo& operator= (const S1apIfaceInfo &);
+
+public:
+  Ipv4Address   m_remoteIpAddr;
+  Ptr<Socket>   m_localCtrlPlaneSocket;
+};
+
+
+class S1apConnectionInfo : public SimpleRefCount<S1apConnectionInfo>
+{
+public:
+  S1apConnectionInfo (uint16_t enbId, uint16_t mmeId);
+  virtual ~S1apConnectionInfo (void);
+
+  S1apConnectionInfo& operator= (const S1apConnectionInfo &);
+
+public:
+  uint16_t m_enbId;
+  uint16_t m_mmeId;
+};
+
+
+/**
+ * \ingroup lte
+ *
+ * This entity is installed inside an eNB and provides the functionality for the S1AP interface
+ */
+class EpcS1apEnb : public Object
+{
+  friend class MemberEpcS1apSapEnbProvider<EpcS1apEnb>;
+
+public:
+  /** 
+   * Constructor
+   */
+  EpcS1apEnb (Ptr<Socket> localSocket, Ipv4Address enbAddress, Ipv4Address mmeAddress, uint16_t cellId, uint16_t mmeId);
+
+  /**
+   * Destructor
+   */
+  virtual ~EpcS1apEnb (void);
+
+  static TypeId GetTypeId (void);
+  virtual void DoDispose (void);
+
+
+  /**
+   * \param s the S1ap SAP User to be used by this EPC S1ap eNB entity in order to call methods of epcEnbApplication
+   */
+  void SetEpcS1apSapEnbUser (EpcS1apSapEnb * s);
+
+  /**
+   * \return the S1ap SAP Provider interface offered by this EPC S1ap entity
+   */
+  EpcS1apSapEnbProvider* GetEpcS1apSapEnbProvider ();
+
+
+  /**
+   * Add an S1ap interface to this EPC S1ap entity
+   * \param enbId the cell ID of the eNodeB on which this is installed
+   * \param enbAddress the address of the eNodeB on which this is installed
+   * \param mmeId the ID of the MME to which the eNB is connected
+   * \param mmeAddress the address of the MME to which the eNB is connected
+   * \param the socket created in the Epc Helper
+   */
+  void AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress,
+                       uint16_t mmeId, Ipv4Address mmeAddress, Ptr<Socket> localS1apSocket);
+
+
+  /** 
+   * Method to be assigned to the recv callback of the S1ap-C (S1ap Control Plane) socket.
+   * It is called when the eNB receives a packet from the MME on the S1ap interface
+   * 
+   * \param socket socket of the S1ap interface
+   */
+  void RecvFromS1apSocket (Ptr<Socket> socket);
+
+
+protected:
+  // Interface provided by EpcS1apSapEnbProvider
+  virtual void DoSendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi);
+  virtual void DoSendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication );
+  virtual void DoSendInitialContextSetupResponse (uint64_t mmeUeS1Id,
+                                                  uint16_t enbUeS1Id,
+                                                  std::list<EpcS1apSap::ErabSetupItem> erabSetupList);
+  virtual void DoSendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+  ;
+
+  EpcS1apSapEnb* m_s1apSapUser;
+  EpcS1apSapEnbProvider* m_s1apSapProvider;
+
+
+private:
+
+  /**
+   * Map the mmeId to the corresponding (sourceSocket, remoteIpAddr) to be used
+   * to send the S1ap message
+   */
+  std::map < uint16_t, Ptr<S1apIfaceInfo> > m_s1apInterfaceSockets;
+
+  /**
+   * Map the localSocket (the one receiving the S1ap message) 
+   * to the corresponding (sourceCellId, targetCellId) associated with the S1ap interface
+   */
+  std::map < Ptr<Socket>, Ptr<S1apConnectionInfo> > m_s1apInterfaceCellIds;
+
+  /**
+   * UDP port to be used for the S1ap interfaces: S1ap
+   */
+  uint16_t m_s1apUdpPort;
+
+  /**
+   * Mme ID, stored as a private variable until more than one MME will be implemented
+   */
+  uint16_t m_mmeId; 
+
+};
+
+
+/**
+ * \ingroup lte
+ *
+ * This entity is installed inside an eNB and provides the functionality for the S1AP interface
+ */
+class EpcS1apMme : public Object
+{
+  friend class MemberEpcS1apSapMmeProvider<EpcS1apMme>;
+
+public:
+  /** 
+   * Constructor
+   * \param the socket opened on the node in which this object is installed
+   */
+  EpcS1apMme (const Ptr<Socket> s1apSocket, uint16_t mmeId);
+
+  /**
+   * Destructor
+   */
+  virtual ~EpcS1apMme (void);
+
+  static TypeId GetTypeId (void);
+  virtual void DoDispose (void);
+
+
+  /**
+   * \param s the S1ap SAP User to be used by this EPC S1ap Mme entity in order to call methods of epcMmeApplication
+   */
+  void SetEpcS1apSapMmeUser (EpcS1apSapMme * s);
+
+  /**
+   * \return the S1ap SAP Provider interface offered by this EPC S1ap entity
+   */
+  EpcS1apSapMmeProvider* GetEpcS1apSapMmeProvider ();
+
+
+  /**
+   * Add an S1ap interface to this EPC S1ap entity
+   * \param enbId the cell ID of the eNodeB which the MME is connected to
+   * \param enbAddress the address of the eNodeB which the MME is connected to
+   */
+  void AddS1apInterface (uint16_t enbId, Ipv4Address enbAddress);
+
+
+  /** 
+   * Method to be assigned to the recv callback of the S1ap-C (S1ap Control Plane) socket.
+   * It is called when the MME receives a packet from the eNB on the S1ap interface
+   * 
+   * \param socket socket of the S1ap interface
+   */
+  void RecvFromS1apSocket (Ptr<Socket> socket);
+
+
+protected:
+  // Interface provided by EpcS1apSapMmeProvider
+  virtual void DoSendInitialContextSetupRequest (uint64_t mmeUeS1Id,
+                                           uint16_t enbUeS1Id,
+                                           std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetupList,
+                                           uint16_t cellId);
+
+  virtual void DoSendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, 
+                                        std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
+
+  EpcS1apSapMme* m_s1apSapUser;
+  EpcS1apSapMmeProvider* m_s1apSapProvider;
+
+
+private:
+
+  /**
+   * Map the enbId to the corresponding (sourceSocket, remoteIpAddr) to be used
+   * to send the S1ap message
+   */
+  std::map < uint16_t, Ptr<S1apIfaceInfo> > m_s1apInterfaceSockets;
+
+  /**
+   * Map the localSocket (the one receiving the S1ap message) 
+   * to the corresponding (sourceCellId, targetCellId) associated with the S1ap interface
+   */
+  std::map < Ptr<Socket>, Ptr<S1apConnectionInfo> > m_s1apInterfaceCellIds;
+
+  /**
+   * UDP port to be used for the S1ap interfaces: S1ap
+   */
+  uint16_t m_s1apUdpPort;
+
+  uint16_t m_mmeId; // ID of the MME to which this S1AP endpoint is installed
+
+  Ptr<Socket> m_localS1APSocket; // local socket to receive from the eNBs S1AP endpoints
+
+};
+
+} //namespace ns3
+
+#endif // EPC_S1AP_H
diff -Naru a/model/epc-s1ap-header.cc b/model/epc-s1ap-header.cc
--- a/model/epc-s1ap-header.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap-header.cc	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,1303 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ * Inspired by epc-x2-header.cc
+ */
+
+#include "ns3/log.h"
+#include "ns3/epc-s1ap-header.h"
+#include <list>
+
+
+// TODO 
+// According to 36.413 9.2.3.4: enbUeS1Id should be 3 byte, but in the SAP interface 
+// already defined in the ns-3 release is 2 byte
+// The same holds for mmeUeS1Id, which should be 4 byte, but is 8 byte in the SAP interface
+
+namespace ns3 {
+
+
+NS_LOG_COMPONENT_DEFINE ("EpcS1APHeader");
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APHeader);
+
+EpcS1APHeader::EpcS1APHeader ()
+  : m_procedureCode (0xfa),
+    m_lengthOfIes (0xfa),
+    m_numberOfIes (0xfa)
+{
+}
+
+EpcS1APHeader::~EpcS1APHeader ()
+{
+  m_procedureCode = 0xfb;
+  m_lengthOfIes = 0xfb;
+  m_numberOfIes = 0xfb;
+}
+
+TypeId
+EpcS1APHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APHeader::GetSerializedSize (void) const
+{
+  return 6; // 6 bytes in this header
+}
+
+void
+EpcS1APHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteU8 (m_procedureCode);
+
+  i.WriteU8 (0x00); // 36.413 9.1.2.2 Criticality - if not recognized, 0 == reject
+  i.WriteU8 (m_lengthOfIes + 3);
+  i.WriteHtonU16 (0);
+  i.WriteU8 (m_numberOfIes);
+}
+
+uint32_t
+EpcS1APHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_procedureCode = i.ReadU8 ();
+
+  i.ReadU8 ();
+  m_lengthOfIes = i.ReadU8 () - 3;
+  i.ReadNtohU16 ();
+  m_numberOfIes = i.ReadU8 ();
+  
+  return GetSerializedSize ();
+}
+
+void
+EpcS1APHeader::Print (std::ostream &os) const
+{
+  os << " ProcedureCode=" << (uint32_t) m_procedureCode;
+  os << " LengthOfIEs=" << (uint32_t) m_lengthOfIes;
+  os << " NumberOfIEs=" << (uint32_t) m_numberOfIes;
+}
+
+uint8_t
+EpcS1APHeader::GetProcedureCode () const
+{
+  return m_procedureCode;
+}
+
+void
+EpcS1APHeader::SetProcedureCode (uint8_t procedureCode)
+{
+  m_procedureCode = procedureCode;
+}
+
+
+void
+EpcS1APHeader::SetLengthOfIes (uint32_t lengthOfIes)
+{
+  m_lengthOfIes = lengthOfIes;
+}
+
+void
+EpcS1APHeader::SetNumberOfIes (uint32_t numberOfIes)
+{
+  m_numberOfIes = numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APInitialUeMessageHeader);
+
+EpcS1APInitialUeMessageHeader::EpcS1APInitialUeMessageHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1 + 1 + 1),
+    m_headerLength (3 + 2 + 6 + 4 + 2 + 9 + 9),
+    m_stmsi (0xfffffffa),
+    m_mmeUeS1Id (0xfffffffa),
+    m_enbUeS1Id (0xfffa),
+    m_ecgi (0xfffa)
+{
+}
+
+EpcS1APInitialUeMessageHeader::~EpcS1APInitialUeMessageHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_stmsi = 0xfffffffb;
+  m_enbUeS1Id = 0xfffb;
+  m_ecgi = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+}
+
+TypeId
+EpcS1APInitialUeMessageHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APInitialUeMessageHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APInitialUeMessageHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APInitialUeMessageHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APInitialUeMessageHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteU8 (0);                    // NAS PDU, not implemented
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteU32 (0);                   // TAI, not implemented
+  i.WriteU8 (0);
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteHtonU16 (m_ecgi);          // E-UTRAN CGI, it should have a different size
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteU8 (0);                    // RRC Establishment cause
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteU64 (m_stmsi);             // S-TMSI
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id, not in the standard?
+  i.WriteU8 (0);                    // criticality = REJECT
+
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();
+  i.ReadU8 ();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU8();
+  i.ReadU8();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  i.ReadU32 ();                   // TAI, not implemented
+  i.ReadU8 ();
+  i.ReadU8 ();                    
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  m_ecgi = i.ReadNtohU16 ();    // E-UTRAN CGI, it should have a different size
+  i.ReadU8();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU8();
+  i.ReadU8();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_stmsi = i.ReadU64 ();             // S-TMSI
+  i.ReadU8 ();      
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_mmeUeS1Id = i.ReadU64 ();             // MME UE ID
+  i.ReadU8 ();      
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  return GetSerializedSize();
+}
+
+void
+EpcS1APInitialUeMessageHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " ECGI = " << m_ecgi;
+  os << " S-TMSI = " << m_stmsi;
+}
+
+uint64_t 
+EpcS1APInitialUeMessageHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APInitialUeMessageHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+uint64_t 
+EpcS1APInitialUeMessageHeader::GetSTmsi () const 
+{
+  return m_stmsi;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetSTmsi (uint64_t stmsi) 
+{
+  m_stmsi = stmsi;
+}
+
+uint16_t 
+EpcS1APInitialUeMessageHeader::GetEcgi () const 
+{
+  return m_ecgi;
+}
+
+void 
+EpcS1APInitialUeMessageHeader::SetEcgi (uint16_t ecgi)
+{
+  m_ecgi = ecgi;
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APInitialUeMessageHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APErabReleaseIndicationHeader);
+
+EpcS1APErabReleaseIndicationHeader::EpcS1APErabReleaseIndicationHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (9 + 3 + 4 + 1),
+    m_enbUeS1Id (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabToBeReleaseIndication.clear();
+}
+
+EpcS1APErabReleaseIndicationHeader::~EpcS1APErabReleaseIndicationHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabToBeReleaseIndication.clear();
+}
+
+TypeId
+EpcS1APErabReleaseIndicationHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APErabReleaseIndicationHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APErabReleaseIndicationHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APErabReleaseIndicationHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APErabReleaseIndicationHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);                    // criticality = REJECT
+
+  std::list <EpcS1apSap::ErabToBeReleasedIndication>::size_type sz = m_erabToBeReleaseIndication.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabToBeReleasedIndication>::const_iterator l_iter = m_erabToBeReleaseIndication.begin(); l_iter != m_erabToBeReleaseIndication.end(); ++l_iter) // content of ErabToBeReleasedIndication
+  {
+    i.WriteU8 (l_iter->erabId);
+  }
+  i.WriteU8(0); // criticality = REJECT, just one for the whole list
+
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabToBeReleasedIndication erabItem;
+    erabItem.erabId = i.ReadU8 ();
+
+    m_erabToBeReleaseIndication.push_back(erabItem);
+    m_headerLength += 1;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+  
+  return GetSerializedSize();
+}
+
+void
+EpcS1APErabReleaseIndicationHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  for(std::list <EpcS1apSap::ErabToBeReleasedIndication>::const_iterator l_iter = m_erabToBeReleaseIndication.begin(); l_iter != m_erabToBeReleaseIndication.end(); ++l_iter)
+  { 
+    os << " ErabId " << l_iter->erabId;
+  }
+
+}
+
+uint64_t 
+EpcS1APErabReleaseIndicationHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APErabReleaseIndicationHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APErabReleaseIndicationHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APErabReleaseIndicationHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabToBeReleasedIndication>
+EpcS1APErabReleaseIndicationHeader::GetErabToBeReleaseIndication () const 
+{
+  return m_erabToBeReleaseIndication;
+}
+
+void 
+EpcS1APErabReleaseIndicationHeader::SetErabReleaseIndication (std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication)
+{
+  m_headerLength += erabToBeReleaseIndication.size();
+  m_erabToBeReleaseIndication = erabToBeReleaseIndication;
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APErabReleaseIndicationHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APInitialContextSetupResponseHeader);
+
+EpcS1APInitialContextSetupResponseHeader::EpcS1APInitialContextSetupResponseHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (9 + 3 + 4 + 1),
+    m_enbUeS1Id (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabSetupList.clear();
+}
+
+EpcS1APInitialContextSetupResponseHeader::~EpcS1APInitialContextSetupResponseHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabSetupList.clear();
+}
+
+TypeId
+EpcS1APInitialContextSetupResponseHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APInitialContextSetupResponseHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APInitialContextSetupResponseHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APInitialContextSetupResponseHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APInitialContextSetupResponseHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  std::list <EpcS1apSap::ErabSetupItem>::size_type sz = m_erabSetupList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabSetupItem>::const_iterator l_iter = m_erabSetupList.begin(); l_iter != m_erabSetupList.end(); ++l_iter) // content of m_erabSetupList
+  {
+    i.WriteU8 (l_iter->erabId);
+    i.WriteHtonU32 (l_iter->enbTransportLayerAddress.Get ());
+    i.WriteHtonU32 (l_iter->enbTeid);
+    i.WriteU8 (1 << 6);               // criticality = IGNORE each
+  }
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabSetupItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+    erabItem.enbTransportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.enbTeid = i.ReadNtohU32 ();
+    i.ReadU8 ();
+
+    m_erabSetupList.push_back(erabItem);
+    m_headerLength += 10;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+  
+  return GetSerializedSize();
+}
+
+void
+EpcS1APInitialContextSetupResponseHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  for (std::list <EpcS1apSap::ErabSetupItem>::const_iterator l_iter = m_erabSetupList.begin(); l_iter != m_erabSetupList.end(); ++l_iter) // content of m_erabSetupList
+  {
+    os << " ErabId " << l_iter->erabId;
+    os << " enbTransportLayerAddress " << l_iter->enbTransportLayerAddress;
+    os << " enbTeid " << l_iter->enbTeid;
+  }
+
+}
+
+uint64_t 
+EpcS1APInitialContextSetupResponseHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupResponseHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APInitialContextSetupResponseHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupResponseHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabSetupItem>
+EpcS1APInitialContextSetupResponseHeader::GetErabSetupItem () const 
+{
+  return m_erabSetupList;
+}
+
+void 
+EpcS1APInitialContextSetupResponseHeader::SetErabSetupItem (std::list<EpcS1apSap::ErabSetupItem> erabSetupList)
+{
+  m_headerLength += erabSetupList.size() * 10;
+  m_erabSetupList = erabSetupList;
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APInitialContextSetupResponseHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APPathSwitchRequestHeader);
+
+EpcS1APPathSwitchRequestHeader::EpcS1APPathSwitchRequestHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1),
+    m_headerLength (3 + 4 + 1 +9 + 3 + 6),
+    m_enbUeS1Id (0xfffa),
+    m_ecgi (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabToBeSwitchedInDownlinkList.clear();
+}
+
+EpcS1APPathSwitchRequestHeader::~EpcS1APPathSwitchRequestHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_ecgi = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabToBeSwitchedInDownlinkList.clear();
+}
+
+TypeId
+EpcS1APPathSwitchRequestHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APPathSwitchRequestHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APPathSwitchRequestHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APPathSwitchRequestHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+
+void
+EpcS1APPathSwitchRequestHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader 
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  std::list <EpcS1apSap::ErabSwitchedInDownlinkItem>::size_type sz = m_erabToBeSwitchedInDownlinkList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabSwitchedInDownlinkItem>::const_iterator l_iter = m_erabToBeSwitchedInDownlinkList.begin(); l_iter != m_erabToBeSwitchedInDownlinkList.end(); ++l_iter) // content of ErabToBeReleasedIndication // content of m_erabToBeSwitchedInDownlinkList
+  {
+    i.WriteU8 (l_iter->erabId);
+    i.WriteHtonU32 (l_iter->enbTransportLayerAddress.Get ());
+    i.WriteHtonU32 (l_iter->enbTeid);
+    i.WriteU8 (0);               // criticality = REJECT each
+  }
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU16 (m_ecgi);      // ecgi
+  i.WriteU8 (1 << 6);       // criticality = IGNORE
+
+  i.WriteU32 (0);                   // TAI, not implemented
+  i.WriteU8 (0);
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  // TODO add 9.2.1.40
+
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabSwitchedInDownlinkItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+    erabItem.enbTransportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.enbTeid = i.ReadNtohU32 ();
+    i.ReadU8 ();
+
+    m_erabToBeSwitchedInDownlinkList.push_back(erabItem);
+    m_headerLength += 10;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_ecgi = i.ReadU16 ();      // ecgi
+  i.ReadU8();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU32 ();                   // TAI, not implemented
+  i.ReadU8 ();
+  i.ReadU8 ();               // criticality = IGNORE
+
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  return GetSerializedSize();
+}
+
+void
+EpcS1APPathSwitchRequestHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " ECGI = " << m_ecgi; 
+  for (std::list <EpcS1apSap::ErabSwitchedInDownlinkItem>::const_iterator l_iter = m_erabToBeSwitchedInDownlinkList.begin(); l_iter != m_erabToBeSwitchedInDownlinkList.end(); ++l_iter) // content of ErabToBeReleasedIndication // content of m_erabToBeSwitchedInDownlinkList
+  {
+    os << " ErabId " << l_iter->erabId;
+    os << " enbTransportLayerAddress " << l_iter->enbTransportLayerAddress;
+    os << " enbTeid " << l_iter->enbTeid;
+  }
+
+}
+
+uint64_t 
+EpcS1APPathSwitchRequestHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APPathSwitchRequestHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabSwitchedInDownlinkItem>
+EpcS1APPathSwitchRequestHeader::GetErabSwitchedInDownlinkItemList () const 
+{
+  return m_erabToBeSwitchedInDownlinkList;
+}
+
+void 
+EpcS1APPathSwitchRequestHeader::SetErabSwitchedInDownlinkItemList (std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabSetupList)
+{
+	m_headerLength += erabSetupList.size()*10;
+  m_erabToBeSwitchedInDownlinkList = erabSetupList;
+}
+
+uint16_t
+EpcS1APPathSwitchRequestHeader::GetEcgi() const
+{
+  return m_ecgi;
+}
+
+void
+EpcS1APPathSwitchRequestHeader::SetEcgi(uint16_t ecgi) 
+{
+  m_ecgi = ecgi;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APInitialContextSetupRequestHeader);
+
+EpcS1APInitialContextSetupRequestHeader::EpcS1APInitialContextSetupRequestHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (9 + 3 + 9 + 4 + 1),
+    m_enbUeS1Id (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabsToBeSetupList.clear();
+}
+
+EpcS1APInitialContextSetupRequestHeader::~EpcS1APInitialContextSetupRequestHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabsToBeSetupList.clear();
+}
+
+TypeId
+EpcS1APInitialContextSetupRequestHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APInitialContextSetupRequestHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APInitialContextSetupRequestHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APInitialContextSetupRequestHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcS1APInitialContextSetupRequestHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  i.WriteHtonU64 (0);               // aggregate maximum bitrate, not implemented
+  i.WriteU8 (0);
+
+  std::list <EpcS1apSap::ErabToBeSetupItem>::size_type sz = m_erabsToBeSetupList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabToBeSetupItem>::const_iterator l_iter = m_erabsToBeSetupList.begin(); l_iter != m_erabsToBeSetupList.end(); ++l_iter) // content of m_erabsToBeSetupList
+    {
+      i.WriteU8 (l_iter->erabId);
+      i.WriteHtonU16 (l_iter->erabLevelQosParameters.qci);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.gbrDl);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.gbrUl);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.mbrDl);
+      i.WriteHtonU64 (l_iter->erabLevelQosParameters.gbrQosInfo.mbrUl);
+      i.WriteU8 (l_iter->erabLevelQosParameters.arp.priorityLevel);
+      i.WriteU8 (l_iter->erabLevelQosParameters.arp.preemptionCapability);
+      i.WriteU8 (l_iter->erabLevelQosParameters.arp.preemptionVulnerability);
+      i.WriteHtonU32 (l_iter->transportLayerAddress.Get ());
+      i.WriteHtonU32 (l_iter->sgwTeid);
+
+      i.WriteU8(0); // a criticaloty each, REJECT
+    }
+  i.WriteU8 (0);               // criticality = REJECT
+
+  //TODO 9.2.140, 9.2.1.41
+
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU64 ();               // aggregate maximum bitrate, not implemented
+  i.ReadU8 ();
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of m_erabToBeSetupList
+  {
+    EpcS1apSap::ErabToBeSetupItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+ 
+    erabItem.erabLevelQosParameters = EpsBearer ((EpsBearer::Qci) i.ReadNtohU16 ());
+    erabItem.erabLevelQosParameters.gbrQosInfo.gbrDl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.gbrQosInfo.gbrUl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.gbrQosInfo.mbrDl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.gbrQosInfo.mbrUl = i.ReadNtohU64 ();
+    erabItem.erabLevelQosParameters.arp.priorityLevel = i.ReadU8 ();
+    erabItem.erabLevelQosParameters.arp.preemptionCapability = i.ReadU8 ();
+    erabItem.erabLevelQosParameters.arp.preemptionVulnerability = i.ReadU8 ();
+
+    erabItem.transportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.sgwTeid = i.ReadNtohU32 ();
+
+    i.ReadU8 ();
+
+    m_erabsToBeSetupList.push_back (erabItem);
+    m_headerLength += 46;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+  
+  return GetSerializedSize();
+}
+
+void
+EpcS1APInitialContextSetupRequestHeader::Print (std::ostream &os) const
+{
+  os << " MmeUeS1Id = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " NumOfBearers = " << m_erabsToBeSetupList.size ();
+
+  std::list <EpcS1apSap::ErabToBeSetupItem>::size_type sz = m_erabsToBeSetupList.size ();
+  if (sz > 0)
+    {
+      os << " [";
+    }
+  int j = 0;  
+  for (std::list <EpcS1apSap::ErabToBeSetupItem>::const_iterator l_iter = m_erabsToBeSetupList.begin(); l_iter != m_erabsToBeSetupList.end(); ++l_iter) // content of m_erabsToBeSetupList
+  {
+    os << l_iter->erabId;
+    if (j < (int) sz - 1)
+      {
+        os << ", ";
+      }
+    else
+      {
+        os << "]";
+      }
+    j++;  
+  }
+}
+
+uint64_t 
+EpcS1APInitialContextSetupRequestHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupRequestHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APInitialContextSetupRequestHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APInitialContextSetupRequestHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabToBeSetupItem>
+EpcS1APInitialContextSetupRequestHeader::GetErabToBeSetupItem () const 
+{
+  return m_erabsToBeSetupList;
+}
+
+void 
+EpcS1APInitialContextSetupRequestHeader::SetErabToBeSetupItem (std::list<EpcS1apSap::ErabToBeSetupItem> erabSetupList)
+{
+  m_headerLength += erabSetupList.size()*47;
+  m_erabsToBeSetupList = erabSetupList;
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APInitialContextSetupRequestHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcS1APPathSwitchRequestAcknowledgeHeader);
+
+EpcS1APPathSwitchRequestAcknowledgeHeader::EpcS1APPathSwitchRequestAcknowledgeHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1),
+    m_headerLength (3 + 4 + 1 + 9 + 3 + 6),
+    m_enbUeS1Id (0xfffa),
+    m_ecgi (0xfffa),
+    m_mmeUeS1Id (0xfffffffa)
+{
+  m_erabToBeSwitchedInUplinkList.clear();
+}
+
+EpcS1APPathSwitchRequestAcknowledgeHeader::~EpcS1APPathSwitchRequestAcknowledgeHeader ()
+{ 
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_enbUeS1Id = 0xfffb;
+  m_ecgi = 0xfffb;
+  m_mmeUeS1Id = 0xfffffffb;
+  m_erabToBeSwitchedInUplinkList.clear();
+}
+
+TypeId
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcS1APPathSwitchRequestAcknowledgeHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcS1APPathSwitchRequestAcknowledgeHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+
+void
+EpcS1APPathSwitchRequestAcknowledgeHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  // message type is already in EpcS1APHeader 
+  i.WriteHtonU16 (m_enbUeS1Id);     // m_enbUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  std::vector <EpcS1apSap::ErabSwitchedInUplinkItem>::size_type sz = m_erabToBeSwitchedInUplinkList.size (); 
+  i.WriteHtonU32 (sz);              // number of bearers
+  for (std::list <EpcS1apSap::ErabSwitchedInUplinkItem>::const_iterator l_iter = m_erabToBeSwitchedInUplinkList.begin(); l_iter != m_erabToBeSwitchedInUplinkList.end(); ++l_iter) // content of m_erabsToBeSetupList
+  {
+    i.WriteU8 (l_iter->erabId);
+    i.WriteHtonU32 (l_iter->transportLayerAddress.Get ());
+    i.WriteHtonU32 (l_iter->enbTeid);
+    i.WriteU8 (0);               // criticality = REJECT each
+  }
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU64 (m_mmeUeS1Id);         // mmeUeS1Id
+  i.WriteU8 (0);               // criticality = REJECT
+
+  i.WriteU16 (m_ecgi);      // ecgi
+  i.WriteU8 (1 << 6);       // criticality = IGNORE
+
+  i.WriteU32 (0);                   // TAI, not implemented
+  i.WriteU8 (0);
+  i.WriteU8 (1 << 6);               // criticality = IGNORE
+
+  // TODO add 9.2.1.40
+
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_enbUeS1Id = i.ReadNtohU16 ();     // m_enbUeS1Id
+  i.ReadU8 ();           
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  int sz = i.ReadNtohU32(); // number of bearers
+  m_headerLength += 4;
+
+  for (int j = 0; j < (int) sz; j++) // content of ErabToBeReleasedIndication
+  {
+    EpcS1apSap::ErabSwitchedInUplinkItem erabItem;
+    erabItem.erabId = i.ReadU8 ();
+    erabItem.transportLayerAddress = Ipv4Address (i.ReadNtohU32 ());
+    erabItem.enbTeid = i.ReadNtohU32 ();
+    i.ReadU8 ();
+
+    m_erabToBeSwitchedInUplinkList.push_back(erabItem);
+    m_headerLength += 9;
+  }
+  i.ReadU8();
+  m_headerLength += 1;
+  m_numberOfIes++;
+
+  m_mmeUeS1Id = i.ReadU64 ();         // mmeUeS1Id
+  i.ReadU8 ();                 
+  m_headerLength += 9;
+  m_numberOfIes++;
+
+  m_ecgi = i.ReadU16 ();      // ecgi
+  i.ReadU8();
+  m_headerLength += 3;
+  m_numberOfIes++;
+
+  i.ReadU32 ();                   // TAI, not implemented
+  i.ReadU8 ();
+  i.ReadU8 ();               // criticality = IGNORE
+
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  return GetSerializedSize();
+}
+
+void
+EpcS1APPathSwitchRequestAcknowledgeHeader::Print (std::ostream &os) const
+{
+  os << "MmeUeS1apId = " << m_mmeUeS1Id;
+  os << " EnbUeS1Id = " << m_enbUeS1Id;
+  os << " ECGI = " << m_ecgi; 
+  for (std::list <EpcS1apSap::ErabSwitchedInUplinkItem>::const_iterator l_iter = m_erabToBeSwitchedInUplinkList.begin(); l_iter != m_erabToBeSwitchedInUplinkList.end(); ++l_iter) // content of m_erabsToBeSetupList
+  {
+    os << " ErabId " << l_iter->erabId;
+    os << " TransportLayerAddress " << l_iter->transportLayerAddress;
+    os << " enbTeid " << l_iter->enbTeid;
+  }
+
+}
+
+uint64_t 
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetMmeUeS1Id () const 
+{
+  return m_mmeUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetMmeUeS1Id (uint64_t mmeUeS1Id) 
+{
+  m_mmeUeS1Id = mmeUeS1Id;
+}
+
+uint16_t 
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetEnbUeS1Id () const
+{
+  return m_enbUeS1Id;
+}
+
+void 
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetEnbUeS1Id (uint16_t enbUeS1Id)
+{
+  m_enbUeS1Id = enbUeS1Id;
+}
+
+std::list<EpcS1apSap::ErabSwitchedInUplinkItem>
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetErabSwitchedInUplinkItemList () const 
+{
+  return m_erabToBeSwitchedInUplinkList;
+}
+
+void 
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetErabSwitchedInUplinkItemList (std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabSetupList)
+{
+  m_headerLength += erabSetupList.size() * 10;
+  m_erabToBeSwitchedInUplinkList = erabSetupList;
+}
+
+uint16_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetEcgi() const
+{
+  return m_ecgi;
+}
+
+void
+EpcS1APPathSwitchRequestAcknowledgeHeader::SetEcgi(uint16_t ecgi) 
+{
+  m_ecgi = ecgi;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcS1APPathSwitchRequestAcknowledgeHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+}; // end of namespace ns3
\ No newline at end of file
diff -Naru a/model/epc-s1ap-header.h b/model/epc-s1ap-header.h
--- a/model/epc-s1ap-header.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-s1ap-header.h	2017-10-05 11:47:22.294601711 +0200
@@ -0,0 +1,295 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Michele Polese <michele.polese@gmail.com>
+ * Inspired by epc-x2-header.h
+ */
+
+#ifndef EPC_S1AP_HEADER_H
+#define EPC_S1AP_HEADER_H
+
+#include "ns3/epc-s1ap-sap.h"
+#include "ns3/header.h"
+
+#include <list>
+
+
+namespace ns3 {
+
+
+class EpcS1APHeader : public Header
+{
+public:
+  EpcS1APHeader ();
+  virtual ~EpcS1APHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint8_t GetProcedureCode () const;
+  void SetProcedureCode (uint8_t procedureCode);
+
+  void SetLengthOfIes (uint32_t lengthOfIes);
+  void SetNumberOfIes (uint32_t numberOfIes);
+
+
+  enum ProcedureCode_t {
+    InitialUeMessage        = 71,
+    PathSwitchRequest       = 58,
+    ErabReleaseIndication   = 37,
+    InitialContextSetupResponse = 43,
+    InitialContextSetupRequest = 41,
+    PathSwitchRequestAck = 59
+  };
+
+
+private:
+  uint8_t m_procedureCode;
+
+  uint32_t m_lengthOfIes;
+  uint32_t m_numberOfIes;
+};
+
+
+// Header for initial Ue message
+class EpcS1APInitialUeMessageHeader : public Header
+{
+public:
+  EpcS1APInitialUeMessageHeader ();
+  virtual ~EpcS1APInitialUeMessageHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  uint64_t GetSTmsi () const;
+  void SetSTmsi (uint64_t stmsi);
+
+  uint16_t GetEcgi () const;
+  void SetEcgi (uint16_t ecgi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint64_t          m_stmsi;
+  uint64_t          m_mmeUeS1Id;
+  uint16_t          m_enbUeS1Id;
+  uint16_t          m_ecgi;
+};
+
+
+
+class EpcS1APErabReleaseIndicationHeader : public Header
+{
+public:
+  EpcS1APErabReleaseIndicationHeader ();
+  virtual ~EpcS1APErabReleaseIndicationHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  std::list<EpcS1apSap::ErabToBeReleasedIndication> GetErabToBeReleaseIndication () const;
+  void SetErabReleaseIndication (std::list<EpcS1apSap::ErabToBeReleasedIndication> erabToBeReleaseIndication);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabToBeReleasedIndication> m_erabToBeReleaseIndication;
+};
+
+
+class EpcS1APInitialContextSetupResponseHeader : public Header
+{
+public:
+  EpcS1APInitialContextSetupResponseHeader ();
+  virtual ~EpcS1APInitialContextSetupResponseHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  std::list<EpcS1apSap::ErabSetupItem> GetErabSetupItem () const;
+  void SetErabSetupItem (std::list<EpcS1apSap::ErabSetupItem> erabSetupList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabSetupItem> m_erabSetupList;
+};
+
+class EpcS1APPathSwitchRequestHeader : public Header
+{
+public:
+  EpcS1APPathSwitchRequestHeader ();
+  virtual ~EpcS1APPathSwitchRequestHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  uint16_t GetEcgi () const;
+  void SetEcgi (uint16_t ecgi);
+
+  std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> GetErabSwitchedInDownlinkItemList () const;
+  void SetErabSwitchedInDownlinkItemList (std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint16_t          m_ecgi;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabSwitchedInDownlinkItem> m_erabToBeSwitchedInDownlinkList;
+};
+
+class EpcS1APInitialContextSetupRequestHeader : public Header
+{
+public:
+  EpcS1APInitialContextSetupRequestHeader ();
+  virtual ~EpcS1APInitialContextSetupRequestHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  std::list<EpcS1apSap::ErabToBeSetupItem> GetErabToBeSetupItem () const;
+  void SetErabToBeSetupItem (std::list<EpcS1apSap::ErabToBeSetupItem> erabToBeSetupList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabToBeSetupItem> m_erabsToBeSetupList;
+};
+
+class EpcS1APPathSwitchRequestAcknowledgeHeader : public Header
+{
+public:
+  EpcS1APPathSwitchRequestAcknowledgeHeader ();
+  virtual ~EpcS1APPathSwitchRequestAcknowledgeHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint64_t GetMmeUeS1Id () const;
+  void SetMmeUeS1Id (uint64_t mmeUeS1Id);
+
+  uint16_t GetEnbUeS1Id () const;
+  void SetEnbUeS1Id (uint16_t enbUeS1Id);
+
+  uint16_t GetEcgi () const;
+  void SetEcgi (uint16_t ecgi);
+
+  std::list<EpcS1apSap::ErabSwitchedInUplinkItem> GetErabSwitchedInUplinkItemList () const;
+  void SetErabSwitchedInUplinkItemList (std::list<EpcS1apSap::ErabSwitchedInUplinkItem> erabToBeSwitchedInDownlinkList);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+  uint16_t          m_enbUeS1Id;
+  uint16_t          m_ecgi;
+  uint64_t          m_mmeUeS1Id;
+  std::list<EpcS1apSap::ErabSwitchedInUplinkItem> m_erabToBeSwitchedInUplinkList;
+};
+
+}
+
+#endif //EPC_S1AP_HEADER_H
\ No newline at end of file
diff -Naru a/model/epc-s1ap-sap.h b/model/epc-s1ap-sap.h
--- a/model/epc-s1ap-sap.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-s1ap-sap.h	2017-10-05 11:47:22.294601711 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.cat>
+ * Modified by: Michele Polese <michele.polese@gmail.com>
  */
 
 #ifndef EPC_S1AP_SAP_H
@@ -31,31 +33,80 @@
 
 namespace ns3 {
 
-/**
- * \ingroup lte
- *
- * Base class that defines EPC S1-AP Service Access Point (SAP) interface.
- */
 class EpcS1apSap
 {
 public:
   virtual ~EpcS1apSap ();
 
+  // useful structures as defined in 3GPP ts 36.413 
+
+  /**
+   *  E-RAB Release Indication Item IEs, 3GPP TS 36.413 version 9.8.0 section 9.1.3.7
+   *
+   */
+  struct ErabToBeReleasedIndication
+  {
+    uint8_t erabId;
+  };
+
+  /**
+   *  E-RAB Setup Item IEs, see 3GPP TS 36.413 9.1.4.2 
+   * 
+   */
+  struct ErabSetupItem
+  {
+    uint16_t    erabId;
+    Ipv4Address enbTransportLayerAddress;
+    uint32_t    enbTeid;    
+  };
+
+
+  /**
+   * E-RABs Switched in Downlink Item IE, see 3GPP TS 36.413 9.1.5.8
+   * 
+   */
+  struct ErabSwitchedInDownlinkItem
+  {
+    uint16_t    erabId;
+    Ipv4Address enbTransportLayerAddress;
+    uint32_t    enbTeid;    
+  };
+
+  struct ErabToBeSetupItem
+  {
+    uint8_t    erabId;
+    EpsBearer   erabLevelQosParameters;
+    Ipv4Address transportLayerAddress;
+    uint32_t    sgwTeid;    
+  };
+
+  /**
+   * E-RABs Switched in Uplink Item IE, see 3GPP TS 36.413 9.1.5.9
+   * 
+   */
+  struct ErabSwitchedInUplinkItem
+  {
+    uint8_t    erabId;
+    Ipv4Address transportLayerAddress;
+    uint32_t    enbTeid;    
+  };
+
 };
 
 
 /**
  * \ingroup lte
  *
- * MME side of the S1-AP Service Access Point (SAP), provides the MME
- * methods to be called when an S1-AP message is received by the MME. 
+ * MME side of the S1-AP Service Access Point (SAP) user, provides the MME
+ * methods to be called when an S1-AP message is received by the MME S1-AP object. 
+ * S1-AP ---> MME
  */
 class EpcS1apSapMme : public EpcS1apSap
 {
 public:
 
   /** 
-   * 
+   * 3GPP TS 36.413 V13.1.0 section 9.1.7.1
    * \param mmeUeS1Id in practice, we use the IMSI
    * \param enbUeS1Id in practice, we use the RNTI
    * \param stmsi in practice, the imsi
@@ -64,37 +115,16 @@
    */
   virtual void InitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) = 0;
 
-
-  /**
-   *  E-RAB Release Indication Item IEs, 3GPP TS 36.413 version 9.8.0 section 9.1.3.7
-   *
-   */
-  struct ErabToBeReleasedIndication
-  {
-    uint8_t erabId; ///< E-RAB ID
-  };
-
   /**
     * \brief As per 3GPP TS 23.401 Release 9 V9.5.0 Figure 5.4.4.2-1  eNB sends indication of Bearer Release to MME
     * \brief As per 3GPP TS version 9.8.0 section 8.2.3.2.2, the eNB initiates the procedure by sending an E-RAB RELEASE INDICATION message towards MME
     * \param mmeUeS1Id in practice, we use the IMSI
     * \param enbUeS1Id in practice, we use the RNTI
-    * \param erabToBeReleaseIndication the List of bearers to be deactivated
+    * \param erabToBeReleaseIndication, List of bearers to be deactivated
     *
     */
   virtual void ErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication ) = 0;
 
-  /**
-   *  E-RAB Setup Item IEs, see 3GPP TS 36.413 9.1.4.2 
-   * 
-   */
-  struct ErabSetupItem
-  {
-    uint16_t    erabId; ///< E-RAB ID
-    Ipv4Address enbTransportLayerAddress; ///< transport layer address
-    uint32_t    enbTeid; ///< TEID
-  };
-
   /** 
    * INITIAL CONTEXT SETUP RESPONSE message,  see 3GPP TS 36.413 9.1.4.2 
    * 
@@ -107,82 +137,66 @@
                                             uint16_t enbUeS1Id,
                                             std::list<ErabSetupItem> erabSetupList) = 0;
 
-
-  /**
-   * E-RABs Switched in Downlink Item IE, see 3GPP TS 36.413 9.1.5.8
-   * 
-   */
-  struct ErabSwitchedInDownlinkItem
-  {
-    uint16_t    erabId; ///< ERAB ID
-    Ipv4Address enbTransportLayerAddress; ///< address 
-    uint32_t    enbTeid; ///< TEID   
-  };
-
   /**
    * PATH SWITCH REQUEST message, see 3GPP TS 36.413 9.1.5.8
    * 
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param gci
-   * \param erabToBeSwitchedInDownlinkList
    */
   virtual void PathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList) = 0;
 };
 
 
+/**
+ * \ingroup lte
+ *
+ * eNB side of the S1-AP Service Access Point (SAP) provider, provides the S1-AP methods 
+ * to be called when the eNB wants to send an S1-AP message
+ * eNB ---> S1-AP 
+ */
+class EpcS1apSapEnbProvider : public EpcS1apSap
+{
+public: 
+   
+  virtual void SendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t stmsi, uint16_t ecgi) = 0;
+
+  virtual void SendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication ) = 0;
+
+  virtual void SendInitialContextSetupResponse (uint64_t mmeUeS1Id,
+                                            uint16_t enbUeS1Id,
+                                            std::list<ErabSetupItem> erabSetupList) = 0;
+
+  virtual void SendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t gci, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList) = 0;
+
+};
+
+
 
 /**
  * \ingroup lte
  *
- * eNB side of the S1-AP Service Access Point (SAP), provides the eNB
- * methods to be called when an S1-AP message is received by the eNB. 
+ * eNB side of the S1-AP Service Access Point (SAP) user, provides the eNB
+ * methods to be called when an S1-AP message is received by the eNB S1-AP object.
+ * S1-AP ---> eNB 
  */
 class EpcS1apSapEnb : public EpcS1apSap
 {
 public:
 
-
-  /// ErabToBeSetupItem structure
-  struct ErabToBeSetupItem
-  {
-    uint8_t    erabId; ///< ERAB iD
-    EpsBearer   erabLevelQosParameters; ///< Level QOS parameters
-    Ipv4Address transportLayerAddress; ///< transport layer address
-    uint32_t    sgwTeid; ///< TEID
-  };
-
   /** 
-   * Initial context setup request
    * 
+   * 3GPP TS 36.413 9.1.4.1
    * \param mmeUeS1Id in practice, we use the IMSI
    * \param enbUeS1Id in practice, we use the RNTI
    * \param erabToBeSetupList
+   * \param cellId, to select the enb to which the MME wants to communicate
    * 
    */
   virtual void InitialContextSetupRequest (uint64_t mmeUeS1Id,
                                            uint16_t enbUeS1Id,
                                            std::list<ErabToBeSetupItem> erabToBeSetupList) = 0;
 
-
-  /**
-   * E-RABs Switched in Uplink Item IE, see 3GPP TS 36.413 9.1.5.9
-   * 
-   */
-  struct ErabSwitchedInUplinkItem
-  {
-    uint8_t    erabId; ///< E_RAB ID
-    Ipv4Address transportLayerAddress; ///< transport layer address
-    uint32_t    enbTeid; ///< TEID
-  };
-
   /**
    * PATH SWITCH REQUEST ACKNOWLEDGE message, see 3GPP TS 36.413 9.1.5.9
    * 
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param cgi
-   * \param erabToBeSwitchedInUplinkList
    */
   virtual void PathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList) = 0;
 
@@ -190,12 +204,31 @@
 };
 
 
+/**
+ * \ingroup lte
+ *
+ * MME side of the S1-AP Service Access Point (SAP) provider, provides the S1-AP methods 
+ * to be called when the MME wants to send an S1-AP message
+ * MME ---> S1-AP
+ */
+class EpcS1apSapMmeProvider : public EpcS1apSap
+{
+public:
+  
+  virtual void SendInitialContextSetupRequest (uint64_t mmeUeS1Id,
+                                           uint16_t enbUeS1Id,
+                                           std::list<ErabToBeSetupItem> erabToBeSetupList,
+                                           uint16_t cellId) = 0;
+
+  virtual void SendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList) = 0;
+
+};
 
 
 
 
 /**
- * Template for the implementation of the EpcS1apSapMme as a member
+ * Template for the implementation of the EpcS1apSapMmeUser as a member
  * of an owner class of type C to which all methods are forwarded
  * 
  */
@@ -203,49 +236,18 @@
 class MemberEpcS1apSapMme : public EpcS1apSapMme
 {
 public:
-/**
- * Constructor
- *
- * \param owner the owner class
- */
   MemberEpcS1apSapMme (C* owner);
 
   // inherited from EpcS1apSapMme
-  /**
-   * Initial UE Message function
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param imsi the IMSI
-   * \param ecgi
-   */
   virtual void InitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
-  /**
-   * ERAB Release Indiation function
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param erabToBeReleaseIndication
-   */
   virtual void ErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication );
 
-  /**
-   * Initial context setup response
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param erabSetupList
-   */
   virtual void InitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabSetupItem> erabSetupList);
-  /**
-   * Path switch request
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param cgi
-   * \param erabToBeSwitchedInDownlinkList
-   */
   virtual void PathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
 
 private:
   MemberEpcS1apSapMme ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -285,7 +287,63 @@
 
 
 
+/**
+ * Template for the implementation of the EpcS1apSapEnbProvider as a member
+ * of an owner class of type C to which all methods are forwarded
+ * 
+ */
+template <class C>
+class MemberEpcS1apSapEnbProvider : public EpcS1apSapEnbProvider
+{
+public:
+  MemberEpcS1apSapEnbProvider (C* owner);
+
+  // inherited from MemberEpcS1apSapEnbProvider
+  virtual void SendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi);
+  virtual void SendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication );
+
+  virtual void SendInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabSetupItem> erabSetupList);
+  virtual void SendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList);
+
+private:
+  MemberEpcS1apSapEnbProvider ();
+  C* m_owner;
+};
 
+template <class C>
+MemberEpcS1apSapEnbProvider<C>::MemberEpcS1apSapEnbProvider (C* owner)
+  : m_owner (owner)
+{
+}
+
+template <class C>
+MemberEpcS1apSapEnbProvider<C>::MemberEpcS1apSapEnbProvider ()
+{
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendInitialUeMessage (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, uint64_t imsi, uint16_t ecgi)
+{
+  m_owner->DoSendInitialUeMessage (mmeUeS1Id, enbUeS1Id, imsi, ecgi);
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendErabReleaseIndication (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeReleasedIndication> erabToBeReleaseIndication)
+{
+  m_owner->DoSendErabReleaseIndication (mmeUeS1Id, enbUeS1Id, erabToBeReleaseIndication);
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendInitialContextSetupResponse (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabSetupItem> erabSetupList)
+{
+  m_owner->DoSendInitialContextSetupResponse (mmeUeS1Id, enbUeS1Id, erabSetupList);
+}
+
+template <class C>
+void MemberEpcS1apSapEnbProvider<C>::SendPathSwitchRequest (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInDownlinkItem> erabToBeSwitchedInDownlinkList)
+{
+  m_owner->DoSendPathSwitchRequest (enbUeS1Id, mmeUeS1Id, cgi, erabToBeSwitchedInDownlinkList);
+}
 
 
 
@@ -298,33 +356,15 @@
 class MemberEpcS1apSapEnb : public EpcS1apSapEnb
 {
 public:
-/**
- * Constructor
- *
- * \param owner the owner class
- */
   MemberEpcS1apSapEnb (C* owner);
 
   // inherited from EpcS1apSapEnb
-  /**
-   * Initial context setup request function
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param erabToBeSetupList
-   */
   virtual void InitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeSetupItem> erabToBeSetupList);
-  /**
-   * Path switch request acknowledge function
-   * \param enbUeS1Id in practice, we use the RNTI
-   * \param mmeUeS1Id in practice, we use the IMSI
-   * \param cgi
-   * \param erabToBeSwitchedInUplinkList
-   */
   virtual void PathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
 
 private:
   MemberEpcS1apSapEnb ();
-  C* m_owner; ///< owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -351,7 +391,48 @@
 }
 
 
+/**
+ * Template for the implementation of the EpcS1apSapMmeProvider as a member
+ * of an owner class of type C to which all methods are forwarded
+ * 
+ */
+template <class C>
+class MemberEpcS1apSapMmeProvider : public EpcS1apSapMmeProvider
+{
+public:
+  MemberEpcS1apSapMmeProvider (C* owner);
+
+  // inherited from EpcS1apSapMmeProvider
+  virtual void SendInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeSetupItem> erabToBeSetupList, uint16_t cellId);
+  virtual void SendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList);
 
+private:
+  MemberEpcS1apSapMmeProvider ();
+  C* m_owner;
+};
+
+template <class C>
+MemberEpcS1apSapMmeProvider<C>::MemberEpcS1apSapMmeProvider (C* owner)
+  : m_owner (owner)
+{
+}
+
+template <class C>
+MemberEpcS1apSapMmeProvider<C>::MemberEpcS1apSapMmeProvider ()
+{
+}
+
+template <class C>
+void MemberEpcS1apSapMmeProvider<C>::SendInitialContextSetupRequest (uint64_t mmeUeS1Id, uint16_t enbUeS1Id, std::list<ErabToBeSetupItem> erabToBeSetupList, uint16_t cellId)
+{
+  m_owner->DoSendInitialContextSetupRequest (mmeUeS1Id, enbUeS1Id, erabToBeSetupList, cellId);
+}
+
+template <class C>
+void MemberEpcS1apSapMmeProvider<C>::SendPathSwitchRequestAcknowledge (uint64_t enbUeS1Id, uint64_t mmeUeS1Id, uint16_t cgi, std::list<ErabSwitchedInUplinkItem> erabToBeSwitchedInUplinkList)
+{
+  m_owner->DoSendPathSwitchRequestAcknowledge (enbUeS1Id, mmeUeS1Id, cgi, erabToBeSwitchedInUplinkList);
+}
 
 
 
diff -Naru a/model/epc-sgw-pgw-application.cc b/model/epc-sgw-pgw-application.cc
--- a/model/epc-sgw-pgw-application.cc	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-sgw-pgw-application.cc	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Jaume Nin <jnin@cttc.cat>
  *         Nicola Baldo <nbaldo@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -183,6 +187,11 @@
   packet->RemoveHeader (gtpu);
   uint32_t teid = gtpu.GetTeid ();
 
+  /// \internal
+  /// Workaround for \bugid{231}
+  //SocketAddressTag tag;
+  //packet->RemovePacketTag (tag);
+
   SendToTunDevice (packet, teid);
 }
 
diff -Naru a/model/epc-sgw-pgw-application.h b/model/epc-sgw-pgw-application.h
--- a/model/epc-sgw-pgw-application.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-sgw-pgw-application.h	2017-10-05 11:47:22.298601725 +0200
@@ -47,15 +47,11 @@
  */
 class EpcSgwPgwApplication : public Application
 {
-  /// allow MemberEpcS11SapSgw<EpcSgwPgwApplication> class friend access
   friend class MemberEpcS11SapSgw<EpcSgwPgwApplication>;
 
 public:
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
+  // inherited from Object
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
@@ -102,7 +98,6 @@
    * Send a packet to the internet via the Gi interface of the SGW/PGW
    * 
    * \param packet 
-   * \param teid the Tunnel Enpoint Identifier
    */
   void SendToTunDevice (Ptr<Packet> packet, uint32_t teid);
 
@@ -158,26 +153,10 @@
 private:
 
   // S11 SAP SGW methods
-  /**
-   * Create session request function
-   * \param msg EpcS11SapSgw::CreateSessionRequestMessage
-   */
   void DoCreateSessionRequest (EpcS11SapSgw::CreateSessionRequestMessage msg);
-  /**
-   * Modify bearer request function
-   * \param msg EpcS11SapSgw::ModifyBearerRequestMessage
-   */
   void DoModifyBearerRequest (EpcS11SapSgw::ModifyBearerRequestMessage msg);  
 
-  /**
-   * Delete bearer command function
-   * \param req EpcS11SapSgw::DeleteBearerCommandMessage
-   */
   void DoDeleteBearerCommand (EpcS11SapSgw::DeleteBearerCommandMessage req);
-  /**
-   * Delete bearer response function
-   * \param req EpcS11SapSgw::DeleteBearerResponseMessage
-   */
   void DoDeleteBearerResponse (EpcS11SapSgw::DeleteBearerResponseMessage req);
 
 
@@ -199,7 +178,7 @@
 
     /** 
      * \brief Function, deletes contexts of bearer on SGW and PGW side
-     * \param bearerId the Bearer Id whose contexts to be removed
+     * \param bearerId, the Bearer Id whose contexts to be removed
      */
     void RemoveBearer (uint8_t bearerId);
 
@@ -240,10 +219,10 @@
 
 
   private:
-    EpcTftClassifier m_tftClassifier; ///< TFT classifier
-    Ipv4Address m_enbAddr; ///< ENB address
-    Ipv4Address m_ueAddr; ///< UE address
-    std::map<uint8_t, uint32_t> m_teidByBearerIdMap; ///< TEID By bearer ID Map
+    EpcTftClassifier m_tftClassifier;
+    Ipv4Address m_enbAddr;
+    Ipv4Address m_ueAddr;
+    std::map<uint8_t, uint32_t> m_teidByBearerIdMap;
   };
 
 
@@ -273,9 +252,6 @@
    */
   uint16_t m_gtpuUdpPort;
 
-  /**
-   * TEID count
-   */
   uint32_t m_teidCount;
 
   /**
@@ -290,14 +266,13 @@
    */
   EpcS11SapSgw* m_s11SapSgw;
 
-  /// EnbInfo structure
   struct EnbInfo
   {
-    Ipv4Address enbAddr; ///< eNB address
-    Ipv4Address sgwAddr; ///< SGW address
+    Ipv4Address enbAddr;
+    Ipv4Address sgwAddr;    
   };
 
-  std::map<uint16_t, EnbInfo> m_enbInfoByCellId; ///< eNB info by cell ID
+  std::map<uint16_t, EnbInfo> m_enbInfoByCellId;
 };
 
 } //namespace ns3
diff -Naru a/model/epc-ue-nas.cc b/model/epc-ue-nas.cc
--- a/model/epc-ue-nas.cc	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-ue-nas.cc	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/fatal-error.h>
@@ -65,6 +69,7 @@
 {
   NS_LOG_FUNCTION (this);
   m_asSapUser = new MemberLteAsSapUser<EpcUeNas> (this);
+  m_mmWaveAsSapProvider = 0;
 }
 
 
@@ -139,6 +144,13 @@
 }
 
 void
+EpcUeNas::SetMmWaveAsSapProvider (LteAsSapProvider* s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveAsSapProvider = s;
+}
+
+void
 EpcUeNas::SetForwardUpCallback (Callback <void, Ptr<Packet> > cb)
 {
   NS_LOG_FUNCTION (this);
@@ -146,7 +158,7 @@
 }
 
 void
-EpcUeNas::StartCellSelection (uint32_t dlEarfcn)
+EpcUeNas::StartCellSelection (uint16_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << dlEarfcn);
   m_asSapProvider->StartCellSelection (dlEarfcn);
@@ -162,7 +174,19 @@
 }
 
 void
-EpcUeNas::Connect (uint16_t cellId, uint32_t dlEarfcn)
+EpcUeNas::Connect (uint16_t cellId, uint16_t dlEarfcn)
+{
+  NS_LOG_FUNCTION (this << cellId << dlEarfcn);
+
+  // force the UE RRC to be camped on a specific eNB
+  m_asSapProvider->ForceCampedOnEnb (cellId, dlEarfcn);
+
+  // tell RRC to go into connected mode
+  m_asSapProvider->Connect ();
+}
+
+void
+EpcUeNas::ConnectMc (uint16_t cellId, uint16_t dlEarfcn, uint16_t mmWaveCellId)
 {
   NS_LOG_FUNCTION (this << cellId << dlEarfcn);
 
@@ -171,6 +195,9 @@
 
   // tell RRC to go into connected mode
   m_asSapProvider->Connect ();
+
+  m_mmWaveCellId = mmWaveCellId;
+  m_dlEarfcn = dlEarfcn;
 }
 
 
@@ -234,11 +261,78 @@
 }
 
 void 
-EpcUeNas::DoNotifyConnectionSuccessful ()
+EpcUeNas::DoNotifyConnectionSuccessful (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this);
+  switch (m_state)
+  {
+    case ACTIVE: // this means the Master LTE Cell was already connected 
+      {
+        // notify the LTE eNB RRC that a secondary cell is available
+        m_asSapProvider->NotifySecondaryCellConnected(rnti, m_mmWaveCellId);
+      }
+      break;
+
+    default:
+      SwitchToState (ACTIVE); // will eventually activate dedicated bearers
+      break;
+  }
+}
+
+void
+EpcUeNas::DoNotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId)
 {
+  m_mmWaveCellId = mmWaveCellId;
   NS_LOG_FUNCTION (this);
+  switch (m_state)
+  {
+    case ACTIVE: // this means the Master LTE Cell was already connected 
+      {
+        // notify the LTE eNB RRC that a secondary cell is available
+        m_asSapProvider->NotifySecondaryCellConnected(rnti, m_mmWaveCellId);
+      }
+      break;
+
+    default:
+      SwitchToState (ACTIVE); // will eventually activate dedicated bearers
+      break;
+  } 
+}
+
+void
+EpcUeNas::DoNotifyConnectToMmWave(uint16_t mmWaveCellId)
+{
+  NS_LOG_LOGIC(mmWaveCellId);  
+  m_mmWaveCellId = mmWaveCellId;
+
+  if(m_mmWaveAsSapProvider != 0) {
 
-  SwitchToState (ACTIVE); // will eventually activate dedicated bearers
+    NS_ASSERT_MSG(mmWaveCellId > 0, "Invalid CellId");
+
+    NS_LOG_INFO("Connect to cell " << mmWaveCellId);
+    // force the UE RRC to be camped on a specific eNB
+    m_mmWaveAsSapProvider->ForceCampedOnEnb (mmWaveCellId, m_dlEarfcn); // TODO probably the second argument is useless
+
+    // tell RRC to go into connected mode
+    m_mmWaveAsSapProvider->Connect ();
+  } else {
+    NS_LOG_WARN("Trying to connect to a secondary cell a non MC capable device");
+  }
+  
+}
+
+void
+EpcUeNas::DoNotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd)
+{
+  m_mmWaveCellId = mmWaveCellId;
+  NS_ASSERT(m_asSapProvider != 0); 
+  
+  NS_ASSERT_MSG(mmWaveCellId > 0, "Invalid CellId");
+
+  NS_LOG_INFO("Notify the LTE RRC of the secondary cell HO to " << mmWaveCellId);
+  // Notify the LTE RRC of the secondary cell HO
+  m_asSapProvider->NotifySecondaryCellHandover(oldRnti, newRnti, mmWaveCellId, rrcd);
+   
 }
 
 void
diff -Naru a/model/epc-ue-nas.h b/model/epc-ue-nas.h
--- a/model/epc-ue-nas.h	2017-10-05 11:46:52.082493501 +0200
+++ b/model/epc-ue-nas.h	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_UE_NAS_H
@@ -33,7 +37,6 @@
 
 class EpcUeNas : public Object
 {
-  /// allow MemberLteAsSapUser<EpcUeNas> class friend access
   friend class MemberLteAsSapUser<EpcUeNas>;
 public:
 
@@ -49,10 +52,6 @@
 
   // inherited from Object
   virtual void DoDispose (void);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
 
@@ -96,6 +95,13 @@
   LteAsSapUser* GetAsSapUser ();
 
   /**
+   * Set the SAP provider to interact with the MmWave light RRC entity (if set)
+   *
+   * \param s the AS SAP provider
+   */
+  void SetMmWaveAsSapProvider (LteAsSapProvider* s);
+
+  /**
    * set the callback used to forward data packets up the stack
    *
    * \param cb the callback
@@ -107,7 +113,7 @@
    *
    * \param dlEarfcn the DL frequency of the eNB
    */
-  void StartCellSelection (uint32_t dlEarfcn);
+  void StartCellSelection (uint16_t dlEarfcn);
 
   /**
    * \brief Causes NAS to tell AS to go to ACTIVE state.
@@ -126,7 +132,18 @@
    * Since RRC Idle Mode cell selection is not supported yet, we force the UE
    * RRC to be camped on a specific eNB.
    */
-  void Connect (uint16_t cellId, uint32_t dlEarfcn);
+  void Connect (uint16_t cellId, uint16_t dlEarfcn);
+
+  /**
+   * \brief Causes NAS to tell AS to camp to a specific cell and go to ACTIVE
+   *        state. It also specify which is the cellId for the MmWave BS to which 
+   *        the UE will connect later on
+   * \param cellId the id of the eNB to camp on
+   * \param dlEarfcn the DL frequency of the eNB
+   * \param mmWaveCellId the id of the MmWave cell
+   *
+   */
+  void ConnectMc (uint16_t cellId, uint16_t dlEarfcn, uint16_t mmWaveCellId);
  
   /** 
    * instruct the NAS to disconnect
@@ -177,7 +194,7 @@
    * TracedCallback signature for state change events.
    *
    * \param [in] oldState The old State.
-   * \param [in] newState the new State.
+   * \pararm [in] newState the new State.
    */
   typedef void (* StateTracedCallback)
     (const State oldState, const State newState);
@@ -185,24 +202,16 @@
 private:
 
   // LTE AS SAP methods
-  /// Notify successful connection
-  void DoNotifyConnectionSuccessful ();
-  /// Notify connection failed
+  void DoNotifyConnectionSuccessful (uint16_t rnti);
+  void DoNotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId);
+  void DoNotifyConnectToMmWave (uint16_t mmWaveCellId);
   void DoNotifyConnectionFailed ();
-  /// Notify connection released
   void DoNotifyConnectionReleased ();
-  /**
-   * Receive data
-   * \param packet the packet
-   */
   void DoRecvData (Ptr<Packet> packet);
+  void DoNotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd);
+
 
   // internal methods
-  /**
-   * Activate EPS Bearer
-   * \param bearer the EPS bearer
-   * \param tft the EPC TFT
-   */
   void DoActivateEpsBearer (EpsBearer bearer, Ptr<EpcTft> tft);
   /**
    * Switch the UE RRC to the given state.
@@ -229,24 +238,25 @@
   /// Closed Subscriber Group identity.
   uint32_t m_csgId;
 
-  /// LTE SAP provider
   LteAsSapProvider* m_asSapProvider;
-  /// LTE SAP user
   LteAsSapUser* m_asSapUser;
+  LteAsSapProvider* m_mmWaveAsSapProvider;
 
-  uint8_t m_bidCounter; ///< bid counter
-  EpcTftClassifier m_tftClassifier; ///< tft classifier
+  uint8_t m_bidCounter;
+  EpcTftClassifier m_tftClassifier;
 
-  Callback <void, Ptr<Packet> > m_forwardUpCallback; ///< upward callback
+  Callback <void, Ptr<Packet> > m_forwardUpCallback;
 
-  /// BearerToBeActivated structure
   struct BearerToBeActivated
   {
-    EpsBearer bearer; ///< EPS bearer
-    Ptr<EpcTft> tft; ///< TFT
+    EpsBearer bearer;
+    Ptr<EpcTft> tft;
   };
 
-  std::list<BearerToBeActivated> m_bearersToBeActivatedList; ///< bearers to be activated list
+  std::list<BearerToBeActivated> m_bearersToBeActivatedList;
+
+  uint16_t m_mmWaveCellId;
+  uint16_t m_dlEarfcn; // TODO maybe useless
 
 };
 
diff -Naru a/model/epc-x2.cc b/model/epc-x2.cc
--- a/model/epc-x2.cc	2017-10-05 11:46:52.086493515 +0200
+++ b/model/epc-x2.cc	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -23,6 +27,8 @@
 #include "ns3/packet.h"
 #include "ns3/node.h"
 #include "ns3/epc-gtpu-header.h"
+#include "ns3/epc-x2-tag.h"
+#include "ns3/lte-pdcp-tag.h"
 
 #include "ns3/epc-x2-header.h"
 #include "ns3/epc-x2.h"
@@ -88,6 +94,8 @@
   NS_LOG_FUNCTION (this);
 
   m_x2SapProvider = new EpcX2SpecificEpcX2SapProvider<EpcX2> (this);
+  m_x2PdcpProvider = new EpcX2PdcpSpecificProvider<EpcX2> (this);
+  m_x2RlcProvider = new EpcX2RlcSpecificProvider<EpcX2> (this);
 }
 
 EpcX2::~EpcX2 ()
@@ -102,7 +110,11 @@
 
   m_x2InterfaceSockets.clear ();
   m_x2InterfaceCellIds.clear ();
+  m_x2RlcUserMap.clear ();
+  m_x2PdcpUserMap.clear ();
   delete m_x2SapProvider;
+  delete m_x2RlcProvider;
+  delete m_x2PdcpProvider;
 }
 
 TypeId
@@ -110,7 +122,11 @@
 {
   static TypeId tid = TypeId ("ns3::EpcX2")
     .SetParent<Object> ()
-    .SetGroupName("Lte");
+    .SetGroupName("Lte")
+    .AddTraceSource ("RxPDU",
+                     "PDU received.",
+                     MakeTraceSourceAccessor (&EpcX2::m_rxPdu),
+                     "ns3::EpcX2::ReceiveTracedCallback");
   return tid;
 }
 
@@ -128,8 +144,42 @@
   return m_x2SapProvider;
 }
 
+// Get and Set interfaces with PDCP and RLC
+EpcX2PdcpProvider*
+EpcX2::GetEpcX2PdcpProvider ()
+{
+  NS_LOG_FUNCTION(this);
+  return m_x2PdcpProvider;
+}
+
+EpcX2RlcProvider*
+EpcX2::GetEpcX2RlcProvider ()
+{
+  return m_x2RlcProvider;
+}
 
 void
+EpcX2::SetMcEpcX2RlcUser (uint32_t teid, EpcX2RlcUser* rlcUser)
+{
+  // TODO it may change (for the same teid) on handover between secondary cells, as in LteEnbRrc::RecvRlcSetupRequest
+  //NS_ASSERT_MSG(m_x2RlcUserMap.find(teid) == m_x2RlcUserMap.end(), "Teid " << teid
+  //  << " is already setup\n");
+  NS_LOG_INFO("Add EpcX2RlcUser for teid " << teid);
+  m_x2RlcUserMap[teid] = rlcUser;
+}
+
+void
+EpcX2::SetMcEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser* pdcpUser)
+{
+  // TODO it may change (for the same teid) on handover between secondary cells, as in LteEnbRrc::RecvRlcSetupRequest
+  //NS_ASSERT_MSG(m_x2PdcpUserMap.find(teid) == m_x2PdcpUserMap.end(), "Teid " << teid
+  //  << " is already setup\n");
+  NS_LOG_INFO("Add EpcX2PdcpUser for teid " << teid);
+  m_x2PdcpUserMap[teid] = pdcpUser;
+}
+
+// Add X2 endpoint
+void
 EpcX2::AddX2Interface (uint16_t localCellId, Ipv4Address localX2Address, uint16_t remoteCellId, Ipv4Address remoteX2Address)
 {
   NS_LOG_FUNCTION (this << localCellId << localX2Address << remoteCellId << remoteX2Address);
@@ -165,6 +215,22 @@
   m_x2InterfaceCellIds [localX2uSocket] = Create<X2CellInfo> (localCellId, remoteCellId);
 }
 
+void
+EpcX2::DoAddTeidToBeForwarded(uint32_t gtpTeid, uint16_t targetCellId)
+{
+  NS_LOG_FUNCTION(this << " add an entry to the map of teids to be forwarded: teid " << gtpTeid << " targetCellId " << targetCellId);
+  NS_ASSERT_MSG(m_teidToBeForwardedMap.find(gtpTeid) == m_teidToBeForwardedMap.end(), "TEID already in the map");
+  m_teidToBeForwardedMap.insert(std::pair<uint32_t, uint16_t> (gtpTeid, targetCellId));
+}
+
+void 
+EpcX2::DoRemoveTeidToBeForwarded(uint32_t gtpTeid)
+{
+  NS_LOG_FUNCTION(this << " remove and entry from the map of teids to be forwarded: teid " << gtpTeid);
+  NS_ASSERT_MSG(m_teidToBeForwardedMap.find(gtpTeid) != m_teidToBeForwardedMap.end(), "TEID not in the map");
+  m_teidToBeForwardedMap.erase(m_teidToBeForwardedMap.find(gtpTeid));
+}
+
 
 void 
 EpcX2::RecvFromX2cSocket (Ptr<Socket> socket)
@@ -179,6 +245,16 @@
                  "Missing infos of local and remote CellId");
   Ptr<X2CellInfo> cellsInfo = m_x2InterfaceCellIds [socket];
 
+  EpcX2Tag epcX2Tag;
+  Time delay;
+  if (packet->PeekPacketTag(epcX2Tag))
+    {
+      delay = Simulator::Now() - epcX2Tag.GetSenderTimestamp ();
+      packet->RemovePacketTag(epcX2Tag);
+    }
+
+  m_rxPdu(cellsInfo->m_remoteCellId, cellsInfo->m_localCellId, packet->GetSize (), delay.GetNanoSeconds (), 0);
+
   EpcX2Header x2Header;
   packet->RemoveHeader (x2Header);
 
@@ -207,7 +283,10 @@
           params.ueAggregateMaxBitRateDownlink = x2HoReqHeader.GetUeAggregateMaxBitRateDownlink ();
           params.ueAggregateMaxBitRateUplink   = x2HoReqHeader.GetUeAggregateMaxBitRateUplink ();
           params.bearers        = x2HoReqHeader.GetBearers ();
+          // RlcRequests for secondary cell HO
+          params.rlcRequests    = x2HoReqHeader.GetRlcSetupRequests();
           params.rrcContext     = packet;
+          params.isMc           = x2HoReqHeader.GetIsMc ();
 
           NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
           NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
@@ -329,6 +408,7 @@
           EpcX2SapUser::UeContextReleaseParams params;
           params.oldEnbUeX2apId = x2UeCtxReleaseHeader.GetOldEnbUeX2apId ();
           params.newEnbUeX2apId = x2UeCtxReleaseHeader.GetNewEnbUeX2apId ();
+          params.sourceCellId = cellsInfo->m_remoteCellId;
 
           NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
           NS_LOG_LOGIC ("newEnbUeX2apId = " << params.newEnbUeX2apId);
@@ -360,6 +440,132 @@
           m_x2SapUser->RecvResourceStatusUpdate (params);
         }
     }
+  else if (procedureCode == EpcX2Header::RlcSetupRequest)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: RLC SETUP REQUEST");
+
+      EpcX2RlcSetupRequestHeader x2RlcHeader;
+      packet->RemoveHeader (x2RlcHeader);
+
+      NS_LOG_INFO ("X2 RlcSetupRequest header: " << x2RlcHeader);
+
+      EpcX2SapUser::RlcSetupRequest params;
+      params.targetCellId = x2RlcHeader.GetTargetCellId();
+      params.sourceCellId = x2RlcHeader.GetSourceCellId ();
+      params.mmWaveRnti = x2RlcHeader.GetMmWaveRnti ();
+      params.gtpTeid = x2RlcHeader.GetGtpTeid ();
+      params.lteRnti = x2RlcHeader.GetLteRnti ();
+      params.drbid = x2RlcHeader.GetDrbid ();
+      params.lcinfo = x2RlcHeader.GetLcInfo();
+      params.rlcConfig = x2RlcHeader.GetRlcConfig();
+      params.logicalChannelConfig = x2RlcHeader.GetLogicalChannelConfig();
+
+      NS_LOG_LOGIC ("GtpTeid = " << params.gtpTeid);
+      NS_LOG_LOGIC ("MmWaveRnti = " << params.mmWaveRnti);
+      NS_LOG_LOGIC ("SourceCellID = " << params.sourceCellId);
+      NS_LOG_LOGIC ("TargetCellID = " << params.targetCellId);
+      NS_LOG_LOGIC ("Drbid = " << params.drbid);
+
+      m_x2SapUser->RecvRlcSetupRequest (params);
+    }
+  else if (procedureCode == EpcX2Header::RlcSetupCompleted)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: RLC SETUP COMPLETED");
+
+      EpcX2RlcSetupCompletedHeader x2RlcHeader;
+      packet->RemoveHeader (x2RlcHeader);
+
+      NS_LOG_INFO ("X2 RlcSetupCompleted header: " << x2RlcHeader);
+
+      EpcX2SapUser::UeDataParams params;
+      params.targetCellId = x2RlcHeader.GetTargetCellId();
+      params.sourceCellId = x2RlcHeader.GetSourceCellId ();
+      params.gtpTeid = x2RlcHeader.GetGtpTeid ();
+
+      NS_LOG_LOGIC ("GtpTeid = " << params.gtpTeid);
+      NS_LOG_LOGIC ("SourceCellID = " << params.sourceCellId);
+      NS_LOG_LOGIC ("TargetCellID = " << params.targetCellId);
+
+      m_x2SapUser->RecvRlcSetupCompleted (params);
+    }
+  else if(procedureCode == EpcX2Header::UpdateUeSinr)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: UPDATE UE SINR");
+      
+      EpcX2UeImsiSinrUpdateHeader x2ueSinrUpdateHeader;
+      packet->RemoveHeader(x2ueSinrUpdateHeader);
+
+      NS_LOG_INFO ("X2 SinrUpdateHeader header: " << x2ueSinrUpdateHeader);
+
+      EpcX2SapUser::UeImsiSinrParams params;
+      params.ueImsiSinrMap = x2ueSinrUpdateHeader.GetUeImsiSinrMap();
+      params.sourceCellId = x2ueSinrUpdateHeader.GetSourceCellId();
+
+      m_x2SapUser->RecvUeSinrUpdate(params);  
+    }
+  else if (procedureCode == EpcX2Header::RequestMcHandover)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: REQUEST MC HANDOVER");
+      
+      EpcX2McHandoverHeader x2mcHeader;
+      packet->RemoveHeader(x2mcHeader);
+
+      NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+      EpcX2SapUser::SecondaryHandoverParams params;
+      params.targetCellId = x2mcHeader.GetTargetCellId();
+      params.imsi = x2mcHeader.GetImsi();
+      params.oldCellId = x2mcHeader.GetOldCellId();
+
+      m_x2SapUser->RecvMcHandoverRequest(params);  
+    }
+  else if (procedureCode == EpcX2Header::NotifyMmWaveLteHandover)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: NOTIFY MMWAVE HANDOVER TO LTE");
+      
+      EpcX2McHandoverHeader x2mcHeader;
+      packet->RemoveHeader(x2mcHeader);
+
+      NS_LOG_INFO ("X2 McHandover header: " << x2mcHeader);
+
+      EpcX2SapUser::SecondaryHandoverParams params;
+      params.targetCellId = x2mcHeader.GetTargetCellId(); // the new MmWave cell to which the UE is connected
+      params.imsi = x2mcHeader.GetImsi(); 
+      params.oldCellId = x2mcHeader.GetOldCellId(); // actually, the LTE cell ID
+
+      m_x2SapUser->RecvLteMmWaveHandoverCompleted(params);  
+    }
+  else if (procedureCode == EpcX2Header::SwitchConnection)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: SWITCH CONNECTION");
+      
+      EpcX2ConnectionSwitchHeader x2mcHeader;
+      packet->RemoveHeader(x2mcHeader);
+
+      NS_LOG_INFO ("X2 SwitchConnection header: " << x2mcHeader);
+
+      EpcX2SapUser::SwitchConnectionParams params;
+      params.mmWaveRnti = x2mcHeader.GetMmWaveRnti();
+      params.useMmWaveConnection = x2mcHeader.GetUseMmWaveConnection();
+      params.drbid = x2mcHeader.GetDrbid();
+
+      m_x2SapUser->RecvConnectionSwitchToMmWave(params);
+    }
+  else if (procedureCode == EpcX2Header::SecondaryCellHandoverCompleted)
+    {
+      NS_LOG_LOGIC ("Recv X2 message: SECONDARY CELL HANDOVER COMPLETED");
+
+      EpcX2SecondaryCellHandoverCompletedHeader x2hoHeader;
+      packet->RemoveHeader(x2hoHeader);
+
+      EpcX2SapUser::SecondaryHandoverCompletedParams params;
+      params.mmWaveRnti = x2hoHeader.GetMmWaveRnti();
+      params.imsi = x2hoHeader.GetImsi();
+      params.oldEnbUeX2apId = x2hoHeader.GetOldEnbUeX2apId();
+      params.cellId = cellsInfo->m_remoteCellId;
+
+      m_x2SapUser->RecvSecondaryCellHandoverCompleted(params);
+    }
   else
     {
       NS_ASSERT_MSG (false, "ProcedureCode NOT SUPPORTED!!!");
@@ -380,8 +586,22 @@
                  "Missing infos of local and remote CellId");
   Ptr<X2CellInfo> cellsInfo = m_x2InterfaceCellIds [socket];
 
+  NS_LOG_INFO("localCellId = " << cellsInfo->m_localCellId);
+  NS_LOG_INFO("remoteCellId = " << cellsInfo->m_remoteCellId);
+
+  EpcX2Tag epcX2Tag;
+  Time delay;
+  if (packet->PeekPacketTag(epcX2Tag))
+    {
+      delay = Simulator::Now() - epcX2Tag.GetSenderTimestamp ();
+      packet->RemovePacketTag(epcX2Tag);
+    }
+  m_rxPdu(cellsInfo->m_localCellId, cellsInfo->m_remoteCellId, packet->GetSize (), delay.GetNanoSeconds (), 1);
+
   GtpuHeader gtpu;
   packet->RemoveHeader (gtpu);
+  //SocketAddressTag satag;
+  //packet->RemovePacketTag(satag);
 
   NS_LOG_LOGIC ("GTP-U header: " << gtpu);
 
@@ -391,9 +611,46 @@
   params.gtpTeid = gtpu.GetTeid ();
   params.ueData = packet;
 
-  m_x2SapUser->RecvUeData (params);
-}
+  NS_LOG_LOGIC("Received packet on X2 u, size " << packet->GetSize() 
+    << " source " << params.sourceCellId << " target " << params.targetCellId << " type " << gtpu.GetMessageType());
 
+  if(m_teidToBeForwardedMap.find(params.gtpTeid) == m_teidToBeForwardedMap.end())
+  {
+    if(gtpu.GetMessageType() == EpcX2Header::McForwardDownlinkData)
+    {
+      // add PdcpTag
+      PdcpTag pdcpTag (Simulator::Now ());
+      params.ueData->AddByteTag (pdcpTag);
+      // call rlc interface
+      EpcX2RlcUser* user = m_x2RlcUserMap.find(params.gtpTeid)->second;
+      if(user != 0)
+      {
+        user -> SendMcPdcpSdu(params);
+      }
+      else
+      {
+        NS_LOG_INFO("Not implemented: Forward to the other cell or to LTE");
+      }
+    } 
+    else if (gtpu.GetMessageType() == EpcX2Header::McForwardUplinkData)
+    {
+      // call pdcp interface
+      NS_LOG_INFO("Call PDCP interface");
+      m_x2PdcpUserMap[params.gtpTeid] -> ReceiveMcPdcpPdu(params);
+    }
+    else
+    {
+      m_x2SapUser->RecvUeData (params);
+    }
+  }
+  else // the packet was received during a secondary cell HO, forward to the target cell
+  {
+    params.sourceCellId = cellsInfo->m_remoteCellId;
+    params.targetCellId = m_teidToBeForwardedMap.find(params.gtpTeid)->second;
+    NS_LOG_LOGIC("Forward from " << cellsInfo->m_localCellId << " to " << params.targetCellId);
+    DoSendMcPdcpPdu(params);
+  }
+}
 
 //
 // Implementation of the X2 SAP Provider
@@ -428,6 +685,9 @@
   x2HoReqHeader.SetUeAggregateMaxBitRateDownlink (params.ueAggregateMaxBitRateDownlink);
   x2HoReqHeader.SetUeAggregateMaxBitRateUplink (params.ueAggregateMaxBitRateUplink);
   x2HoReqHeader.SetBearers (params.bearers);
+  // For secondary cell handover
+  x2HoReqHeader.SetRlcSetupRequests (params.rlcRequests);
+  x2HoReqHeader.SetIsMc (params.isMc);
 
   EpcX2Header x2Header;
   x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
@@ -442,6 +702,66 @@
   Ptr<Packet> packet = (params.rrcContext != 0) ? (params.rrcContext) : (Create <Packet> ());
   packet->AddHeader (x2HoReqHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoSendRlcSetupRequest (EpcX2SapProvider::RlcSetupRequest params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("teid  = " << params.gtpTeid);
+  NS_LOG_LOGIC ("rnti = " << params.mmWaveRnti);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: RLC SETUP REQUEST");
+
+  // Build the X2 message
+  EpcX2RlcSetupRequestHeader x2RlcHeader;
+  x2RlcHeader.SetSourceCellId(params.sourceCellId);
+  x2RlcHeader.SetTargetCellId(params.targetCellId);
+  x2RlcHeader.SetGtpTeid(params.gtpTeid);
+  x2RlcHeader.SetMmWaveRnti(params.mmWaveRnti);
+  x2RlcHeader.SetLteRnti(params.lteRnti);
+  x2RlcHeader.SetDrbid(params.drbid);
+  x2RlcHeader.SetLcInfo(params.lcinfo);
+  x2RlcHeader.SetRlcConfig(params.rlcConfig);
+  x2RlcHeader.SetLogicalChannelConfig(params.logicalChannelConfig);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::RlcSetupRequest);
+  x2Header.SetLengthOfIes (x2RlcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2RlcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RlcSetupRequest header: " << x2RlcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2RlcHeader);
+  packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -450,6 +770,55 @@
 
 
 void
+EpcX2::DoSendRlcSetupCompleted (EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("teid  = " << params.gtpTeid);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: RLC SETUP COMPLETED");
+
+  // Build the X2 message
+  EpcX2RlcSetupCompletedHeader x2RlcHeader;
+  x2RlcHeader.SetSourceCellId(params.sourceCellId);
+  x2RlcHeader.SetTargetCellId(params.targetCellId);
+  x2RlcHeader.SetGtpTeid(params.gtpTeid);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::RlcSetupCompleted);
+  x2Header.SetLengthOfIes (x2RlcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2RlcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RlcSetupCompleted header: " << x2RlcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2RlcHeader);
+  packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
 EpcX2::DoSendHandoverRequestAck (EpcX2SapProvider::HandoverRequestAckParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -491,6 +860,10 @@
   Ptr<Packet> packet = (params.rrcContext != 0) ? (params.rrcContext) : (Create <Packet> ());
   packet->AddHeader (x2HoAckHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -539,6 +912,60 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2HoPrepFailHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  // Send the X2 message through the socket
+  localSocket->SendTo (packet, 0, InetSocketAddress (remoteIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoNotifyCoordinatorHandoverFailed(EpcX2SapProvider::HandoverFailedParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("coordinator cellId " << params.coordinatorId);
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("imsi = " << params.imsi);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.coordinatorId) != m_x2InterfaceSockets.end (),
+                 "Socket infos not defined for coordinatorId = " << params.coordinatorId);
+
+  Ptr<Socket> localSocket = m_x2InterfaceSockets [params.coordinatorId]->m_localCtrlPlaneSocket;
+  Ipv4Address remoteIpAddr = m_x2InterfaceSockets [params.coordinatorId]->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("localSocket = " << localSocket);
+  NS_LOG_LOGIC ("remoteIpAddr = " << remoteIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: NOTIFY HANDOVER FAILED");
+
+  // Build the X2 message
+  EpcX2NotifyCoordinatorHandoverFailedHeader x2failHeader;
+  x2failHeader.SetSourceCellId (params.sourceCellId);
+  x2failHeader.SetTargetCellId (params.targetCellId);
+  x2failHeader.SetImsi (params.imsi);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::UnsuccessfulOutcome);
+  x2Header.SetProcedureCode (EpcX2Header::NotifyCoordinatorHandoverFailed);
+  x2Header.SetLengthOfIes (x2failHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2failHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 HandoverPrepFail header: " << x2failHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2failHeader);
+  packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -587,6 +1014,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2SnStatusXferHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -632,6 +1063,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2UeCtxReleaseHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -675,6 +1110,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2LoadInfoHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -723,6 +1162,10 @@
   Ptr<Packet> packet = Create <Packet> ();
   packet->AddHeader (x2ResourceStatUpdHeader);
   packet->AddHeader (x2Header);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("packetLen = " << packet->GetSize ());
 
   // Send the X2 message through the socket
@@ -757,8 +1200,319 @@
   Ptr<Packet> packet = params.ueData;
   packet->AddHeader (gtpu);
 
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
   NS_LOG_INFO ("Forward UE DATA through X2 interface");
   sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2uUdpPort));
 }
 
+void
+EpcX2::DoSendMcPdcpPdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localUserPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  // add a message type to the gtpu header, so that it is possible to distinguish at receiver
+  GtpuHeader gtpu;
+  gtpu.SetTeid (params.gtpTeid);
+  gtpu.SetMessageType(EpcX2Header::McForwardDownlinkData);
+  gtpu.SetLength (params.ueData->GetSize () + gtpu.GetSerializedSize () - 8); /// \todo This should be done in GtpuHeader
+  NS_LOG_INFO ("GTP-U header: " << gtpu);
+
+  Ptr<Packet> packet = params.ueData;
+  packet->AddHeader (gtpu);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("Forward MC UE DATA through X2 interface");
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2uUdpPort));  
+}
+
+void
+EpcX2::DoReceiveMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+  NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localUserPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  // add a message type to the gtpu header, so that it is possible to distinguish at receiver
+  GtpuHeader gtpu;
+  gtpu.SetTeid (params.gtpTeid);
+  gtpu.SetMessageType(EpcX2Header::McForwardUplinkData);
+  gtpu.SetLength (params.ueData->GetSize () + gtpu.GetSerializedSize () - 8); /// \todo This should be done in GtpuHeader
+  NS_LOG_INFO ("GTP-U header: " << gtpu);
+
+  Ptr<Packet> packet = params.ueData;
+  packet->AddHeader (gtpu);
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  NS_LOG_INFO ("Forward MC UE DATA through X2 interface");
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2uUdpPort));  
+}
+
+void
+EpcX2::DoSendUeSinrUpdate(EpcX2Sap::UeImsiSinrParams params)
+{
+  NS_LOG_FUNCTION(this);
+
+  NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+  NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.targetCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for targetCellId = " << params.targetCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.targetCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localUserPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  // Build the X2 message
+  EpcX2UeImsiSinrUpdateHeader x2imsiSinrHeader;
+  x2imsiSinrHeader.SetUeImsiSinrMap (params.ueImsiSinrMap);
+  x2imsiSinrHeader.SetSourceCellId (params.sourceCellId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::UpdateUeSinr);
+  x2Header.SetLengthOfIes (x2imsiSinrHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2imsiSinrHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 UeImsiSinrUpdate header: " << x2imsiSinrHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2imsiSinrHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+
+void
+EpcX2::DoSendMcHandoverRequest (EpcX2SapProvider::SecondaryHandoverParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("oldCellId = " << params.oldCellId);
+  NS_LOG_LOGIC ("imsi = " << params.imsi);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.oldCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for oldCellId = " << params.oldCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.oldCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: REQUEST MC HANDOVER");
+
+  // Build the X2 message
+  EpcX2McHandoverHeader x2mcHeader;
+  x2mcHeader.SetTargetCellId(params.targetCellId);
+  x2mcHeader.SetImsi(params.imsi);
+  x2mcHeader.SetOldCellId(params.oldCellId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::RequestMcHandover);
+  x2Header.SetLengthOfIes (x2mcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2mcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2mcHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoNotifyLteMmWaveHandoverCompleted (EpcX2SapProvider::SecondaryHandoverParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("lteCellId = " << params.oldCellId);
+  NS_LOG_LOGIC ("imsi = " << params.imsi);
+  NS_LOG_LOGIC ("MmWave cellId = " << params.targetCellId);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.oldCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for oldCellId = " << params.oldCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.oldCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: NOTIFY MMWAVE HANDOVER TO LTE");
+
+  // Build the X2 message
+  EpcX2McHandoverHeader x2mcHeader;
+  x2mcHeader.SetTargetCellId(params.targetCellId);
+  x2mcHeader.SetImsi(params.imsi);
+  x2mcHeader.SetOldCellId(params.oldCellId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::NotifyMmWaveLteHandover);
+  x2Header.SetLengthOfIes (x2mcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2mcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2mcHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void
+EpcX2::DoSendSwitchConnectionToMmWave(EpcX2SapProvider::SwitchConnectionParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("MmWaveCellId = " << params.mmWaveCellId);
+  NS_LOG_LOGIC ("MmWaveRnti = " << params.mmWaveRnti);
+  NS_LOG_LOGIC ("UseMmWaveConnection " << params.useMmWaveConnection);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.mmWaveCellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for mmWaveCellId = " << params.mmWaveCellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.mmWaveCellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: SEND CONNECTION SWITCH MESSAGE");
+
+  // Build the X2 message
+  EpcX2ConnectionSwitchHeader x2mcHeader;
+  x2mcHeader.SetMmWaveRnti(params.mmWaveRnti);
+  x2mcHeader.SetUseMmWaveConnection(params.useMmWaveConnection);
+  x2mcHeader.SetDrbid(params.drbid);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::InitiatingMessage);
+  x2Header.SetProcedureCode (EpcX2Header::SwitchConnection);
+  x2Header.SetLengthOfIes (x2mcHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2mcHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 RequestMcHandover header: " << x2mcHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2mcHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+void 
+EpcX2::DoSendSecondaryCellHandoverCompleted(EpcX2SapProvider::SecondaryHandoverCompletedParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("MmWaveRnti = " << params.mmWaveRnti);
+  NS_LOG_LOGIC ("Imsi = " << params.imsi);
+  NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
+  NS_LOG_LOGIC ("Dst cellId = " << params.cellId);
+
+  NS_ASSERT_MSG (m_x2InterfaceSockets.find (params.cellId) != m_x2InterfaceSockets.end (),
+                 "Missing infos for cellId = " << params.cellId);
+  Ptr<X2IfaceInfo> socketInfo = m_x2InterfaceSockets [params.cellId];
+  Ptr<Socket> sourceSocket = socketInfo->m_localCtrlPlaneSocket;
+  Ipv4Address targetIpAddr = socketInfo->m_remoteIpAddr;
+
+  NS_LOG_LOGIC ("sourceSocket = " << sourceSocket);
+  NS_LOG_LOGIC ("targetIpAddr = " << targetIpAddr);
+
+  NS_LOG_INFO ("Send X2 message: SEND SECONDARY CELL HANDOVER COMPLETED MESSAGE");
+
+  // Build the X2 message
+  EpcX2SecondaryCellHandoverCompletedHeader x2hoHeader;
+  x2hoHeader.SetMmWaveRnti(params.mmWaveRnti);
+  x2hoHeader.SetImsi(params.imsi);
+  x2hoHeader.SetOldEnbUeX2apId(params.oldEnbUeX2apId);
+
+  EpcX2Header x2Header;
+  x2Header.SetMessageType (EpcX2Header::SuccessfulOutcome);
+  x2Header.SetProcedureCode (EpcX2Header::SecondaryCellHandoverCompleted);
+  x2Header.SetLengthOfIes (x2hoHeader.GetLengthOfIes ());
+  x2Header.SetNumberOfIes (x2hoHeader.GetNumberOfIes ());
+
+  NS_LOG_INFO ("X2 header: " << x2Header);
+  NS_LOG_INFO ("X2 SecondaryCellHandoverCompleted header: " << x2hoHeader);
+
+  // Build the X2 packet
+  Ptr<Packet> packet = Create <Packet> ();
+  packet->AddHeader (x2hoHeader);
+  packet->AddHeader (x2Header);
+  NS_LOG_INFO ("packetLen = " << packet->GetSize ());
+
+  EpcX2Tag tag (Simulator::Now());
+  packet->AddPacketTag (tag);
+
+  // Send the X2 message through the socket
+  sourceSocket->SendTo (packet, 0, InetSocketAddress (targetIpAddr, m_x2cUdpPort));
+}
+
+
 } // namespace ns3
diff -Naru a/model/epc-x2.h b/model/epc-x2.h
--- a/model/epc-x2.h	2017-10-05 11:46:52.086493515 +0200
+++ b/model/epc-x2.h	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_X2_H
@@ -25,6 +29,8 @@
 #include "ns3/callback.h"
 #include "ns3/ptr.h"
 #include "ns3/object.h"
+ #include "ns3/traced-value.h"
+#include "ns3/trace-source-accessor.h"
 
 #include "ns3/epc-x2-sap.h"
 
@@ -33,61 +39,32 @@
 namespace ns3 {
 
 
-/**
- * X2IfaceInfo
- */
 class X2IfaceInfo : public SimpleRefCount<X2IfaceInfo>
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param remoteIpAddr remote IP address
-   * \param localCtrlPlaneSocket control plane socket
-   * \param localUserPlaneSocket user plane socket
-   */
   X2IfaceInfo (Ipv4Address remoteIpAddr, Ptr<Socket> localCtrlPlaneSocket, Ptr<Socket> localUserPlaneSocket);
   virtual ~X2IfaceInfo (void);
 
-  /**
-   * Assignment operator
-   *
-   * \returns X2IfaceInfo& 
-   */
   X2IfaceInfo& operator= (const X2IfaceInfo &);
 
 public:
-  Ipv4Address   m_remoteIpAddr; ///< remote IP address
-  Ptr<Socket>   m_localCtrlPlaneSocket; ///< local control plane socket
-  Ptr<Socket>   m_localUserPlaneSocket; ///< local user plane socket
+  Ipv4Address   m_remoteIpAddr;
+  Ptr<Socket>   m_localCtrlPlaneSocket;
+  Ptr<Socket>   m_localUserPlaneSocket;
 };
 
 
-/**
- * X2CellInfo
- */
 class X2CellInfo : public SimpleRefCount<X2CellInfo>
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param localCellId local cell ID
-   * \param remoteCellId remote cell ID
-   */
   X2CellInfo (uint16_t localCellId, uint16_t remoteCellId);
   virtual ~X2CellInfo (void);
 
-  /**
-   * Assignment operator
-   *
-   * \returns X2CellInfo&  
-   */
   X2CellInfo& operator= (const X2CellInfo &);
 
 public:
-  uint16_t m_localCellId; ///< local cell ID
-  uint16_t m_remoteCellId; ///< remote cell ID
+  uint16_t m_localCellId;
+  uint16_t m_remoteCellId;
 };
 
 
@@ -98,8 +75,9 @@
  */
 class EpcX2 : public Object
 {
-  /// allow EpcX2SpecificEpcX2SapProvider<EpcX2> class friend access
   friend class EpcX2SpecificEpcX2SapProvider<EpcX2>;
+  friend class EpcX2PdcpSpecificProvider<EpcX2>;
+  friend class EpcX2RlcSpecificProvider<EpcX2>;
 
 public:
   /** 
@@ -112,10 +90,6 @@
    */
   virtual ~EpcX2 (void);
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual void DoDispose (void);
 
@@ -130,6 +104,28 @@
    */
   EpcX2SapProvider* GetEpcX2SapProvider ();
 
+  /**
+   * \return the X2 Pdcp Provider interface offered by this EPC X2 entity
+   */
+  EpcX2PdcpProvider* GetEpcX2PdcpProvider ();
+
+  /**
+   * \return the X2 Rlc Provider interface offered by this EPC X2 entity
+   */
+  EpcX2RlcProvider* GetEpcX2RlcProvider ();
+
+  /**
+   * \param the teid of the MC device
+   * \param the X2 Rlc User interface associated to the teid
+   */
+  void SetMcEpcX2RlcUser (uint32_t teid, EpcX2RlcUser* rlcUser);
+
+  /**
+   * \param the teid of the MC device
+   * \param the X2 Pdcp User interface associated to the teid
+   */
+  void SetMcEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser* pdcpUser);
+
 
   /**
    * Add an X2 interface to this EPC X2 entity
@@ -158,54 +154,57 @@
    */
   void RecvFromX2uSocket (Ptr<Socket> socket);
 
+  /**
+   * TracedCallback signature for
+   *
+   * \param [in] source 
+   * \param [in] target 
+   * \param [in] bytes The packet size.
+   * \param [in] delay Delay since sender timestamp, in ns.
+   */
+  typedef void (* ReceiveTracedCallback)
+    (uint16_t sourceCellId, uint16_t targetCellId, uint32_t bytes, uint64_t delay, bool data);
 
 protected:
   // Interface provided by EpcX2SapProvider
-  /**
-   * Send handover request function
-   * \param params the send handover request parameters
-   */
   virtual void DoSendHandoverRequest (EpcX2SapProvider::HandoverRequestParams params);
-  /**
-   * Send handover request ack function
-   * \param params the send handover request ack parameters
-   */
+  virtual void DoSendRlcSetupRequest (EpcX2SapProvider::RlcSetupRequest params);
+  virtual void DoSendRlcSetupCompleted (EpcX2SapProvider::UeDataParams);
   virtual void DoSendHandoverRequestAck (EpcX2SapProvider::HandoverRequestAckParams params);
-  /**
-   * Send handover preparation failure function
-   * \param params the handover preparation failure parameters
-   */
   virtual void DoSendHandoverPreparationFailure (EpcX2SapProvider::HandoverPreparationFailureParams params);
-  /**
-   * Send SN status transfer function
-   * \param params the SN status transer parameters 
-   */
   virtual void DoSendSnStatusTransfer (EpcX2SapProvider::SnStatusTransferParams params);
-  /**
-   * Send UE context release function
-   * \param params the UE context release parameters
-   */
   virtual void DoSendUeContextRelease (EpcX2SapProvider::UeContextReleaseParams params);
-  /**
-   * Send load information function
-   * \param params the send load information parameters
-   */
   virtual void DoSendLoadInformation (EpcX2SapProvider::LoadInformationParams params);
-  /**
-   * Send resource status update function
-   * \param params the sedn reosurce status update parameters
-   */
   virtual void DoSendResourceStatusUpdate (EpcX2SapProvider::ResourceStatusUpdateParams params);
-  /**
-   * Send UE data function
-   *
-   * \param params EpcX2SapProvider::UeDataParams
-   */
   virtual void DoSendUeData (EpcX2SapProvider::UeDataParams params);
-
-  EpcX2SapUser* m_x2SapUser; ///< X2 SAP user
-  EpcX2SapProvider* m_x2SapProvider; ///< X2 SAP provider
-
+  virtual void DoSendMcPdcpPdu (EpcX2SapProvider::UeDataParams params);
+  virtual void DoReceiveMcPdcpSdu (EpcX2SapProvider::UeDataParams params);
+  virtual void DoSendUeSinrUpdate(EpcX2Sap::UeImsiSinrParams params);
+  virtual void DoSendMcHandoverRequest (EpcX2SapProvider::SecondaryHandoverParams params);
+  virtual void DoNotifyLteMmWaveHandoverCompleted (EpcX2SapProvider::SecondaryHandoverParams params);
+  virtual void DoNotifyCoordinatorHandoverFailed(EpcX2SapProvider::HandoverFailedParams params);
+  virtual void DoSendSwitchConnectionToMmWave(EpcX2SapProvider::SwitchConnectionParams params);
+  virtual void DoSendSecondaryCellHandoverCompleted(EpcX2SapProvider::SecondaryHandoverCompletedParams params);
+
+  // these methods are not used to send messages but to change the internal state of the EpcX2
+  virtual void DoAddTeidToBeForwarded(uint32_t teid, uint16_t targetCellId);
+  virtual void DoRemoveTeidToBeForwarded(uint32_t teid);
+
+  EpcX2SapUser* m_x2SapUser;
+  EpcX2SapProvider* m_x2SapProvider;
+  
+  /**
+   * Map the PdcpUser to a certain teid
+   */
+  std::map < uint32_t, EpcX2PdcpUser* > m_x2PdcpUserMap;
+  // The PdcpProvider offered by this X2 interface
+  EpcX2PdcpProvider* m_x2PdcpProvider;
+  /**
+   * Map the RlcUser to a certain teid
+   */
+  std::map < uint32_t, EpcX2RlcUser* > m_x2RlcUserMap;
+  // The RlcProvider offered by this X2 interface
+  EpcX2RlcProvider* m_x2RlcProvider;
 
 private:
 
@@ -222,13 +221,18 @@
   std::map < Ptr<Socket>, Ptr<X2CellInfo> > m_x2InterfaceCellIds;
 
   /**
-   * UDP ports to be used for the X2-C interface
+   * UDP ports to be used for the X2 interfaces: X2-C and X2-U
    */
   uint16_t m_x2cUdpPort;
+  uint16_t m_x2uUdpPort;
+
+  TracedCallback<uint16_t, uint16_t, uint32_t, uint64_t, bool> m_rxPdu;
+
   /**
-   * UDP ports to be used for the X2-U interface
+   * Map the gtpTeid to the targetCellId to which the packet should be forwarded
+   * during a secondary cell handover
    */
-  uint16_t m_x2uUdpPort;
+  std::map <uint32_t, uint16_t> m_teidToBeForwardedMap;
 
 };
 
diff -Naru a/model/epc-x2-header.cc b/model/epc-x2-header.cc
--- a/model/epc-x2-header.cc	2017-10-05 11:46:52.086493515 +0200
+++ b/model/epc-x2-header.cc	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -148,12 +152,13 @@
 NS_OBJECT_ENSURE_REGISTERED (EpcX2HandoverRequestHeader);
 
 EpcX2HandoverRequestHeader::EpcX2HandoverRequestHeader ()
-  : m_numberOfIes (1 + 1 + 1 + 1),
-    m_headerLength (6 + 5 + 12 + (3 + 4 + 8 + 8 + 4)),
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1 + 1),
+    m_headerLength (6 + 5 + 12 + (3 + 4 + 8 + 8 + 4) + 1 + 4),
     m_oldEnbUeX2apId (0xfffa),
     m_cause (0xfffa),
     m_targetCellId (0xfffa),
-    m_mmeUeS1apId (0xfffffffa)
+    m_mmeUeS1apId (0xfffffffa),
+    m_isMc (0xfa)
 {
   m_erabsToBeSetupList.clear ();
 }
@@ -166,7 +171,9 @@
   m_cause = 0xfffb;
   m_targetCellId = 0xfffb;
   m_mmeUeS1apId = 0xfffffffb;
+  m_isMc = 0xfb;
   m_erabsToBeSetupList.clear ();
+  m_rlcRequestsList.clear();
 }
 
 TypeId
@@ -238,6 +245,40 @@
       i.WriteHtonU32 (m_erabsToBeSetupList [j].gtpTeid);
     }
 
+  // RlcSteupRequest vector - for secondary cell HO
+  std::vector <EpcX2Sap::RlcSetupRequest>::size_type sz_rlc = m_rlcRequestsList.size (); 
+  i.WriteHtonU32 (sz_rlc);              // number of RLCs to be setup
+  for (int j = 0; j < (int) sz_rlc; j++)
+  {
+    i.WriteHtonU16 (m_rlcRequestsList[j].sourceCellId);
+    i.WriteHtonU16 (m_rlcRequestsList[j].targetCellId); 
+    i.WriteHtonU32 (m_rlcRequestsList[j].gtpTeid); 
+    i.WriteHtonU16 (m_rlcRequestsList[j].mmWaveRnti); 
+    i.WriteHtonU16 (m_rlcRequestsList[j].lteRnti);
+    i.WriteU8 (m_rlcRequestsList[j].drbid);
+
+    // LcInfo
+    i.WriteHtonU16  (m_rlcRequestsList[j].lcinfo.rnti); // TODO consider if unnecessary
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.lcId);
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.lcGroup);
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.qci);
+    i.WriteU8       (m_rlcRequestsList[j].lcinfo.isGbr);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.mbrUl);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.mbrDl);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.gbrUl);
+    i.WriteHtonU64  (m_rlcRequestsList[j].lcinfo.gbrDl);
+
+    // RlcConfig
+    i.WriteHtonU32 (m_rlcRequestsList[j].rlcConfig.choice); // TODO check size
+
+    // LogicalChannelConfiguration
+    i.WriteU8      (m_rlcRequestsList[j].logicalChannelConfig.priority);
+    i.WriteHtonU16 (m_rlcRequestsList[j].logicalChannelConfig.prioritizedBitRateKbps);
+    i.WriteHtonU16 (m_rlcRequestsList[j].logicalChannelConfig.bucketSizeDurationMs);
+    i.WriteU8      (m_rlcRequestsList[j].logicalChannelConfig.logicalChannelGroup);
+  }
+
+  i.WriteU8(m_isMc);
 }
 
 uint32_t
@@ -302,6 +343,65 @@
       m_headerLength += 48;
     }
 
+  sz = i.ReadNtohU32 ();  
+ 
+  for (int j = 0; j < sz; j++)
+  {
+    EpcX2Sap::RlcSetupRequest rlcReq;
+
+    rlcReq.sourceCellId = i.ReadNtohU16 ();
+    rlcReq.targetCellId = i.ReadNtohU16 (); 
+    rlcReq.gtpTeid = i.ReadNtohU32 (); 
+    rlcReq.mmWaveRnti = i.ReadNtohU16 (); 
+    rlcReq.lteRnti = i.ReadNtohU16 ();
+    rlcReq.drbid = i.ReadU8 ();
+
+    // LcInfo
+    rlcReq.lcinfo.rnti = i.ReadNtohU16 (); // TODO consider if unnecessary
+    rlcReq.lcinfo.lcId = i.ReadU8      ();
+    rlcReq.lcinfo.lcGroup = i.ReadU8   ();
+    rlcReq.lcinfo.qci = i.ReadU8       ();
+    rlcReq.lcinfo.isGbr = i.ReadU8     ();
+    rlcReq.lcinfo.mbrUl = i.ReadNtohU64();
+    rlcReq.lcinfo.mbrDl = i.ReadNtohU64();
+    rlcReq.lcinfo.gbrUl = i.ReadNtohU64();
+    rlcReq.lcinfo.gbrDl = i.ReadNtohU64();
+
+    // RlcConfig
+    uint32_t val = i.ReadNtohU32 ();
+    if (val == LteRrcSap::RlcConfig::AM) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::AM;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL;
+    }
+    else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT) {
+      rlcReq.rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT;
+    }
+    else {
+      NS_FATAL_ERROR("Unknown value for RlcConfig " << val);
+    }
+
+    // LogicalChannelConfiguration
+    rlcReq.logicalChannelConfig.priority = i.ReadU8     ();
+    rlcReq.logicalChannelConfig.prioritizedBitRateKbps = i.ReadNtohU16();
+    rlcReq.logicalChannelConfig.bucketSizeDurationMs = i.ReadNtohU16();
+    rlcReq.logicalChannelConfig.logicalChannelGroup = i.ReadU8     ();
+
+    m_rlcRequestsList.push_back(rlcReq);
+    m_headerLength += 61;
+  }
+
+  m_isMc = i.ReadU8();
+  m_numberOfIes++;
+  m_headerLength++;
+
   return GetSerializedSize ();
 }
 
@@ -315,6 +415,8 @@
   os << " UeAggrMaxBitRateDownlink = " << m_ueAggregateMaxBitRateDownlink;
   os << " UeAggrMaxBitRateUplink = " << m_ueAggregateMaxBitRateUplink;
   os << " NumOfBearers = " << m_erabsToBeSetupList.size ();
+  os << " NumOfRlcRequests = " << m_rlcRequestsList.size ();
+  os << " isMc = " << m_isMc;
 
   std::vector <EpcX2Sap::ErabToBeSetupItem>::size_type sz = m_erabsToBeSetupList.size ();
   if (sz > 0)
@@ -333,6 +435,7 @@
           os << "]";
         }
     }
+
 }
 
 uint16_t
@@ -347,91 +450,954 @@
   m_oldEnbUeX2apId = x2apId;
 }
 
-uint16_t
-EpcX2HandoverRequestHeader::GetCause () const
+uint16_t
+EpcX2HandoverRequestHeader::GetCause () const
+{
+  return m_cause;
+}
+
+void
+EpcX2HandoverRequestHeader::SetCause (uint16_t cause)
+{
+  m_cause = cause;
+}
+
+bool
+EpcX2HandoverRequestHeader::GetIsMc () const
+{
+  return m_isMc;
+}
+
+void
+EpcX2HandoverRequestHeader::SetIsMc (bool isMc)
+{
+  m_isMc = isMc;
+}
+
+uint16_t
+EpcX2HandoverRequestHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2HandoverRequestHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint32_t
+EpcX2HandoverRequestHeader::GetMmeUeS1apId () const
+{
+  return m_mmeUeS1apId;
+}
+
+void
+EpcX2HandoverRequestHeader::SetMmeUeS1apId (uint32_t mmeUeS1apId)
+{
+  m_mmeUeS1apId = mmeUeS1apId;
+}
+
+std::vector <EpcX2Sap::RlcSetupRequest>
+EpcX2HandoverRequestHeader::GetRlcSetupRequests () const
+{
+  return m_rlcRequestsList;
+}
+
+void
+EpcX2HandoverRequestHeader::SetRlcSetupRequests (std::vector <EpcX2Sap::RlcSetupRequest> rlcRequests)
+{
+  m_headerLength += 61 * rlcRequests.size ();
+  m_rlcRequestsList = rlcRequests;
+}
+
+std::vector <EpcX2Sap::ErabToBeSetupItem>
+EpcX2HandoverRequestHeader::GetBearers () const
+{
+  return m_erabsToBeSetupList;
+}
+
+void
+EpcX2HandoverRequestHeader::SetBearers (std::vector <EpcX2Sap::ErabToBeSetupItem> bearers)
+{
+  m_headerLength += 48 * bearers.size ();
+  m_erabsToBeSetupList = bearers;
+}
+
+uint64_t
+EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateDownlink () const
+{
+  return m_ueAggregateMaxBitRateDownlink;
+}
+
+void
+EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateDownlink (uint64_t bitRate)
+{
+  m_ueAggregateMaxBitRateDownlink = bitRate;
+}
+
+uint64_t
+EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateUplink () const
+{
+  return m_ueAggregateMaxBitRateUplink;
+}
+
+void
+EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateUplink (uint64_t bitRate)
+{
+  m_ueAggregateMaxBitRateUplink = bitRate;
+}
+
+uint32_t
+EpcX2HandoverRequestHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2HandoverRequestHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2RlcSetupRequestHeader);
+
+EpcX2RlcSetupRequestHeader::EpcX2RlcSetupRequestHeader ()
+  : m_numberOfIes (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1),
+    m_headerLength (2 + 2 + 4 + 2 + 2 + 1 + 38 + 4 + 6),
+    m_sourceCellId (0xfffa),
+    m_targetCellId (0xfffa),
+    m_gtpTeid (0xfffffffa),
+    m_mmWaveRnti (0xfffa),
+    m_lteRnti (0xfffa),
+    m_drbid (0xfa)
+{
+}
+
+EpcX2RlcSetupRequestHeader::~EpcX2RlcSetupRequestHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_sourceCellId = 0xfffb;
+  m_targetCellId = 0xfffb;
+  m_gtpTeid = 0xfffffffb;
+  m_mmWaveRnti = 0xfffb;
+  m_lteRnti = 0xfffb;
+  m_drbid = 0xfb;
+}
+
+TypeId
+EpcX2RlcSetupRequestHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2RlcSetupRequestHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2RlcSetupRequestHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2RlcSetupRequestHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2RlcSetupRequestHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_sourceCellId);
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU32 (m_gtpTeid); 
+  i.WriteHtonU16 (m_mmWaveRnti); 
+  i.WriteHtonU16 (m_lteRnti);
+  i.WriteU8 (m_drbid);
+
+  // LcInfo
+  i.WriteHtonU16 (m_lcInfo.rnti); // TODO consider if unnecessary
+  i.WriteU8 (m_lcInfo.lcId);
+  i.WriteU8 (m_lcInfo.lcGroup);
+  i.WriteU8 (m_lcInfo.qci);
+  i.WriteU8 (m_lcInfo.isGbr);
+  i.WriteHtonU64 (m_lcInfo.mbrUl);
+  i.WriteHtonU64 (m_lcInfo.mbrDl);
+  i.WriteHtonU64 (m_lcInfo.gbrUl);
+  i.WriteHtonU64 (m_lcInfo.gbrDl);
+
+  // RlcConfig
+  i.WriteHtonU32 (m_rlcConfig.choice); // TODO check size
+
+  // LogicalChannelConfiguration
+  i.WriteU8 (m_lcConfig.priority);
+  i.WriteHtonU16 (m_lcConfig.prioritizedBitRateKbps);
+  i.WriteHtonU16 (m_lcConfig.bucketSizeDurationMs);
+  i.WriteU8 (m_lcConfig.logicalChannelGroup);
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_sourceCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_gtpTeid = i.ReadNtohU32 ();
+  m_headerLength += 4;
+  m_numberOfIes++;
+
+  m_mmWaveRnti = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_lteRnti = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_drbid = i.ReadU8 ();
+  m_headerLength += 1;
+  m_numberOfIes++;
+
+  m_lcInfo.rnti = i.ReadNtohU16 (); // TODO consider if unnecessary
+  m_lcInfo.lcId = i.ReadU8 ();
+  m_lcInfo.lcGroup = i.ReadU8 ();
+  m_lcInfo.qci = i.ReadU8 ();
+  m_lcInfo.isGbr = i.ReadU8 ();
+  m_lcInfo.mbrUl = i.ReadNtohU64 ();
+  m_lcInfo.mbrDl = i.ReadNtohU64 ();
+  m_lcInfo.gbrUl = i.ReadNtohU64 ();
+  m_lcInfo.gbrDl = i.ReadNtohU64 ();
+  m_headerLength += 38;
+  m_numberOfIes++;
+
+  uint32_t val = i.ReadNtohU32 ();
+  if (val == LteRrcSap::RlcConfig::AM) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::AM;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_UL;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_UNI_DIRECTIONAL_DL;
+  }
+  else if (val == LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT) {
+    m_rlcConfig.choice = LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL_LOWLAT;
+  }
+  else {
+    NS_FATAL_ERROR("Unknown value for RlcConfig " << val);
+  }
+  m_headerLength += 4;
+  m_numberOfIes++;
+
+  // LogicalChannelConfiguration
+  m_lcConfig.priority               = i.ReadU8      ();
+  m_lcConfig.prioritizedBitRateKbps = i.ReadNtohU16 ();
+  m_lcConfig.bucketSizeDurationMs   = i.ReadNtohU16 ();
+  m_lcConfig.logicalChannelGroup    = i.ReadU8      ();
+  m_headerLength += 6;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2RlcSetupRequestHeader::Print (std::ostream &os) const
+{
+  os << "SourceCellId = " << m_sourceCellId;
+  os << " TargetCellId = " << m_targetCellId;
+  os << " gtpTeid = " << m_gtpTeid;
+  os << " MmWaveRnti = " << m_mmWaveRnti;
+  os << " LteRnti = " << m_lteRnti;
+  os << " DrbId = " << (uint32_t)m_drbid;
+  os << " RlcConfig " << m_rlcConfig.choice;
+  os << " bucketSizeDurationMs " << m_lcConfig.bucketSizeDurationMs;
+  // TODO complete print
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetSourceCellId () const
+{
+  return m_sourceCellId;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetSourceCellId (uint16_t cellId)
+{
+  m_sourceCellId = cellId;
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetGtpTeid () const
+{
+  return m_gtpTeid;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetGtpTeid (uint32_t gtpTeid)
+{
+  m_gtpTeid = gtpTeid;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetMmWaveRnti () const
+{
+  return m_mmWaveRnti;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetLteRnti (uint16_t rnti)
+{
+  m_lteRnti = rnti;
+}
+
+uint16_t
+EpcX2RlcSetupRequestHeader::GetLteRnti () const
+{
+  return m_lteRnti;
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2RlcSetupRequestHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+void
+EpcX2RlcSetupRequestHeader::SetDrbid (uint8_t drbid)
+{
+  m_drbid = drbid;
+}
+
+uint8_t
+EpcX2RlcSetupRequestHeader::GetDrbid () const
+{
+  return m_drbid;
+}
+
+LteEnbCmacSapProvider::LcInfo 
+EpcX2RlcSetupRequestHeader::GetLcInfo() const
+{
+  return m_lcInfo;
+}
+
+void 
+EpcX2RlcSetupRequestHeader::SetLcInfo(LteEnbCmacSapProvider::LcInfo lcInfo)
+{
+  m_lcInfo = lcInfo;
+}
+
+LteRrcSap::RlcConfig 
+EpcX2RlcSetupRequestHeader::GetRlcConfig() const
+{
+  return m_rlcConfig;
+}
+
+void 
+EpcX2RlcSetupRequestHeader::SetRlcConfig(LteRrcSap::RlcConfig rlcConfig)
+{
+  m_rlcConfig = rlcConfig;
+}
+
+LteRrcSap::LogicalChannelConfig 
+EpcX2RlcSetupRequestHeader::GetLogicalChannelConfig()
+{
+  return m_lcConfig;
+}
+
+void 
+EpcX2RlcSetupRequestHeader::SetLogicalChannelConfig(LteRrcSap::LogicalChannelConfig conf)
+{
+  m_lcConfig = conf;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2RlcSetupCompletedHeader);
+
+EpcX2RlcSetupCompletedHeader::EpcX2RlcSetupCompletedHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 4),
+    m_sourceCellId (0xfffa),
+    m_targetCellId (0xfffa),
+    m_gtpTeid (0xfffffffa)
+{
+}
+
+EpcX2RlcSetupCompletedHeader::~EpcX2RlcSetupCompletedHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_sourceCellId = 0xfffb;
+  m_targetCellId = 0xfffb;
+  m_gtpTeid = 0xfffffffb;
+}
+
+TypeId
+EpcX2RlcSetupCompletedHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2RlcSetupCompletedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2RlcSetupCompletedHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2RlcSetupCompletedHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_sourceCellId);
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU32 (m_gtpTeid); 
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+
+  m_sourceCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_gtpTeid = i.ReadNtohU32 ();
+  m_headerLength += 4;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2RlcSetupCompletedHeader::Print (std::ostream &os) const
+{
+  os << "SourceCellId = " << m_sourceCellId;
+  os << " TargetCellId = " << m_targetCellId;
+  os << " gtpTeid = " << m_gtpTeid;
+}
+
+uint16_t
+EpcX2RlcSetupCompletedHeader::GetSourceCellId () const
+{
+  return m_sourceCellId;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::SetSourceCellId (uint16_t cellId)
+{
+  m_sourceCellId = cellId;
+}
+
+uint16_t
+EpcX2RlcSetupCompletedHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetGtpTeid () const
+{
+  return m_gtpTeid;
+}
+
+void
+EpcX2RlcSetupCompletedHeader::SetGtpTeid (uint32_t gtpTeid)
+{
+  m_gtpTeid = gtpTeid;
+}
+
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2RlcSetupCompletedHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2McHandoverHeader);
+
+EpcX2McHandoverHeader::EpcX2McHandoverHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 8),
+    m_targetCellId (0xfffa),
+    m_oldCellId (0xfffa),
+    m_imsi (0xfffffffffffffffa)
+{
+}
+
+EpcX2McHandoverHeader::~EpcX2McHandoverHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_targetCellId = 0xfffb;
+  m_oldCellId = 0xfffb;
+  m_imsi = 0xfffffffffffffffb;
+}
+
+TypeId
+EpcX2McHandoverHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2McHandoverHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2McHandoverHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2McHandoverHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2McHandoverHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2McHandoverHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU16 (m_oldCellId); 
+  i.WriteHtonU64 (m_imsi); 
+}
+
+uint32_t
+EpcX2McHandoverHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_oldCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_imsi = i.ReadNtohU64 ();
+  m_headerLength += 8;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2McHandoverHeader::Print (std::ostream &os) const
+{
+  os << " TargetCellId = " << m_targetCellId;
+  os << " oldCellId = " << m_oldCellId;
+  os << " imsi = " << m_imsi;
+}
+
+uint16_t
+EpcX2McHandoverHeader::GetTargetCellId () const
+{
+  return m_targetCellId;
+}
+
+void
+EpcX2McHandoverHeader::SetTargetCellId (uint16_t targetCellId)
+{
+  m_targetCellId = targetCellId;
+}
+
+uint64_t
+EpcX2McHandoverHeader::GetImsi () const
+{
+  return m_imsi;
+}
+
+void
+EpcX2McHandoverHeader::SetImsi (uint64_t imsi)
+{
+  m_imsi = imsi;
+}
+
+uint16_t
+EpcX2McHandoverHeader::GetOldCellId () const
+{
+  return m_oldCellId;
+}
+
+void
+EpcX2McHandoverHeader::SetOldCellId (uint16_t oldCellId)
+{
+  m_oldCellId = oldCellId;
+}
+
+
+uint32_t
+EpcX2McHandoverHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2McHandoverHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2SecondaryCellHandoverCompletedHeader);
+
+EpcX2SecondaryCellHandoverCompletedHeader::EpcX2SecondaryCellHandoverCompletedHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 8),
+    m_mmWaveRnti (0xfffa),
+    m_oldEnbUeX2apId (0xfffa),
+    m_imsi (0xfffffffffffffffa)
+{
+}
+
+EpcX2SecondaryCellHandoverCompletedHeader::~EpcX2SecondaryCellHandoverCompletedHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_mmWaveRnti = 0xfffb;
+  m_oldEnbUeX2apId = 0xfffb;
+  m_imsi = 0xfffffffffffffffb;
+}
+
+TypeId
+EpcX2SecondaryCellHandoverCompletedHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2SecondaryCellHandoverCompletedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2SecondaryCellHandoverCompletedHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2SecondaryCellHandoverCompletedHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_mmWaveRnti); 
+  i.WriteHtonU16 (m_oldEnbUeX2apId); 
+  i.WriteHtonU64 (m_imsi); 
+}
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+  
+  m_mmWaveRnti = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_oldEnbUeX2apId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_imsi = i.ReadNtohU64 ();
+  m_headerLength += 8;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::Print (std::ostream &os) const
+{
+  os << " MmWaveRnti = " << m_mmWaveRnti;
+  os << " oldEnbUeX2apId = " << m_oldEnbUeX2apId;
+  os << " imsi = " << m_imsi;
+}
+
+uint16_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetMmWaveRnti () const
+{
+  return m_mmWaveRnti;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+uint64_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetImsi () const
+{
+  return m_imsi;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::SetImsi (uint64_t imsi)
+{
+  m_imsi = imsi;
+}
+
+uint16_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetOldEnbUeX2apId () const
+{
+  return m_oldEnbUeX2apId;
+}
+
+void
+EpcX2SecondaryCellHandoverCompletedHeader::SetOldEnbUeX2apId (uint16_t oldId)
+{
+  m_oldEnbUeX2apId = oldId;
+}
+
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2SecondaryCellHandoverCompletedHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2NotifyCoordinatorHandoverFailedHeader);
+
+EpcX2NotifyCoordinatorHandoverFailedHeader::EpcX2NotifyCoordinatorHandoverFailedHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 2 + 8),
+    m_targetCellId (0xfffa),
+    m_sourceCellId (0xfffa),
+    m_imsi (0xfffffffffffffffa)
+{
+}
+
+EpcX2NotifyCoordinatorHandoverFailedHeader::~EpcX2NotifyCoordinatorHandoverFailedHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_targetCellId = 0xfffb;
+  m_sourceCellId = 0xfffb;
+  m_imsi = 0xfffffffffffffffb;
+}
+
+TypeId
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetTypeId (void)
 {
-  return m_cause;
+  static TypeId tid = TypeId ("ns3::EpcX2NotifyCoordinatorHandoverFailedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2NotifyCoordinatorHandoverFailedHeader> ()
+  ;
+  return tid;
 }
 
-void
-EpcX2HandoverRequestHeader::SetCause (uint16_t cause)
+TypeId
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetInstanceTypeId (void) const
 {
-  m_cause = cause;
+  return GetTypeId ();
 }
 
-uint16_t
-EpcX2HandoverRequestHeader::GetTargetCellId () const
+uint32_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetSerializedSize (void) const
 {
-  return m_targetCellId;
+  return m_headerLength;
 }
 
 void
-EpcX2HandoverRequestHeader::SetTargetCellId (uint16_t targetCellId)
+EpcX2NotifyCoordinatorHandoverFailedHeader::Serialize (Buffer::Iterator start) const
 {
-  m_targetCellId = targetCellId;
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_targetCellId); 
+  i.WriteHtonU16 (m_sourceCellId); 
+  i.WriteHtonU64 (m_imsi); 
 }
 
 uint32_t
-EpcX2HandoverRequestHeader::GetMmeUeS1apId () const
+EpcX2NotifyCoordinatorHandoverFailedHeader::Deserialize (Buffer::Iterator start)
 {
-  return m_mmeUeS1apId;
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+  m_numberOfIes = 0;
+  
+  m_targetCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_sourceCellId = i.ReadNtohU16 ();
+  m_headerLength += 2;
+  m_numberOfIes++;
+
+  m_imsi = i.ReadNtohU64 ();
+  m_headerLength += 8;
+  m_numberOfIes++;
+
+  return GetSerializedSize ();
 }
 
 void
-EpcX2HandoverRequestHeader::SetMmeUeS1apId (uint32_t mmeUeS1apId)
+EpcX2NotifyCoordinatorHandoverFailedHeader::Print (std::ostream &os) const
 {
-  m_mmeUeS1apId = mmeUeS1apId;
+  os << " TargetCellId = " << m_targetCellId;
+  os << " oldCellId = " << m_sourceCellId;
+  os << " imsi = " << m_imsi;
 }
 
-std::vector <EpcX2Sap::ErabToBeSetupItem>
-EpcX2HandoverRequestHeader::GetBearers () const
+uint16_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetTargetCellId () const
 {
-  return m_erabsToBeSetupList;
+  return m_targetCellId;
 }
 
 void
-EpcX2HandoverRequestHeader::SetBearers (std::vector <EpcX2Sap::ErabToBeSetupItem> bearers)
+EpcX2NotifyCoordinatorHandoverFailedHeader::SetTargetCellId (uint16_t targetCellId)
 {
-  m_headerLength += 48 * bearers.size ();
-  m_erabsToBeSetupList = bearers;
+  m_targetCellId = targetCellId;
 }
 
 uint64_t
-EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateDownlink () const
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetImsi () const
 {
-  return m_ueAggregateMaxBitRateDownlink;
+  return m_imsi;
 }
 
 void
-EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateDownlink (uint64_t bitRate)
+EpcX2NotifyCoordinatorHandoverFailedHeader::SetImsi (uint64_t imsi)
 {
-  m_ueAggregateMaxBitRateDownlink = bitRate;
+  m_imsi = imsi;
 }
 
-uint64_t
-EpcX2HandoverRequestHeader::GetUeAggregateMaxBitRateUplink () const
+uint16_t
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetSourceCellId () const
 {
-  return m_ueAggregateMaxBitRateUplink;
+  return m_sourceCellId;
 }
 
 void
-EpcX2HandoverRequestHeader::SetUeAggregateMaxBitRateUplink (uint64_t bitRate)
+EpcX2NotifyCoordinatorHandoverFailedHeader::SetSourceCellId (uint16_t oldCellId)
 {
-  m_ueAggregateMaxBitRateUplink = bitRate;
+  m_sourceCellId = oldCellId;
 }
 
+
 uint32_t
-EpcX2HandoverRequestHeader::GetLengthOfIes () const
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetLengthOfIes () const
 {
   return m_headerLength;
 }
 
 uint32_t
-EpcX2HandoverRequestHeader::GetNumberOfIes () const
+EpcX2NotifyCoordinatorHandoverFailedHeader::GetNumberOfIes () const
 {
   return m_numberOfIes;
 }
 
+
+
 /////////////////////////////////////////////////////////////////////
 
 NS_OBJECT_ENSURE_REGISTERED (EpcX2HandoverRequestAckHeader);
@@ -1489,4 +2455,325 @@
   return m_numberOfIes;
 }
 
+////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2UeImsiSinrUpdateHeader);
+
+EpcX2UeImsiSinrUpdateHeader::EpcX2UeImsiSinrUpdateHeader ()
+  : m_numberOfIes (1 + 1),
+    m_headerLength (2 + 2)
+{
+  m_map.clear ();
+}
+
+EpcX2UeImsiSinrUpdateHeader::~EpcX2UeImsiSinrUpdateHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_map.clear ();
+}
+
+TypeId
+EpcX2UeImsiSinrUpdateHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2UeImsiSinrUpdateHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2UeImsiSinrUpdateHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2UeImsiSinrUpdateHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_sourceCellId);
+
+  std::map <uint64_t, double>::size_type sz = m_map.size ();
+  i.WriteHtonU16 (sz);              // number of elements in the map
+
+  for (std::map<uint64_t, double>::const_iterator iter = m_map.begin(); iter != m_map.end(); ++iter)
+    {
+      i.WriteHtonU64 (iter->first); // imsi
+      i.WriteHtonU64 (pack754(iter->second)); // sinr
+    }
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_headerLength = 0;
+
+  m_sourceCellId = i.ReadNtohU16();
+  m_headerLength += 2;
+  m_numberOfIes = 1;
+
+  int sz = i.ReadNtohU16 ();
+  for (int j = 0; j < sz; j++)
+    {
+      uint64_t imsi = i.ReadNtohU64();
+      double sinr = unpack754(i.ReadNtohU64());
+      m_map[imsi] = sinr;
+    }
+
+  m_headerLength += 2 + sz * 16;
+  m_numberOfIes += 1 + sz;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::Print (std::ostream &os) const
+{
+  os << "SourceCellId " << m_sourceCellId;
+  for(std::map<uint64_t, double>::const_iterator iter = m_map.begin(); iter != m_map.end(); ++iter)
+  {
+    os << " Imsi " << iter->first << " sinr " << 10*std::log10(iter->second);
+  }
+}
+
+uint16_t 
+EpcX2UeImsiSinrUpdateHeader::GetSourceCellId () const
+{
+  return m_sourceCellId;
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::SetSourceCellId(uint16_t cellId)
+{
+  m_sourceCellId = cellId;
+}
+
+std::map <uint64_t, double>
+EpcX2UeImsiSinrUpdateHeader::GetUeImsiSinrMap () const
+{
+  return m_map;
+}
+
+void
+EpcX2UeImsiSinrUpdateHeader::SetUeImsiSinrMap (std::map <uint64_t, double> map)
+{
+  m_map = map;
+
+  std::map <uint64_t, double>::size_type sz = m_map.size ();
+  m_headerLength += sz * 16;
+  m_numberOfIes += sz;
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2UeImsiSinrUpdateHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+uint64_t 
+EpcX2UeImsiSinrUpdateHeader::pack754(long double f)
+{
+  uint16_t bits = 64;
+  uint16_t expbits = 11;
+  long double fnorm;
+  int shift;
+  long long sign, exp, significand;
+  unsigned significandbits = bits - expbits - 1; // -1 for sign bit
+
+  if (f == 0.0) return 0; // get this special case out of the way
+
+  // check sign and begin normalization
+  if (f < 0) { sign = 1; fnorm = -f; }
+  else { sign = 0; fnorm = f; }
+
+  // get the normalized form of f and track the exponent
+  shift = 0;
+  while(fnorm >= 2.0) { fnorm /= 2.0; shift++; }
+  while(fnorm < 1.0) { fnorm *= 2.0; shift--; }
+  fnorm = fnorm - 1.0;
+
+  // calculate the binary form (non-float) of the significand data
+  significand = fnorm * ((1LL<<significandbits) + 0.5f);
+
+  // get the biased exponent
+  exp = shift + ((1<<(expbits-1)) - 1); // shift + bias
+
+  // return the final answer
+  return (sign<<(bits-1)) | (exp<<(bits-expbits-1)) | significand;
+}
+
+long double 
+EpcX2UeImsiSinrUpdateHeader::unpack754(uint64_t i)
+{
+  uint16_t bits = 64;
+  uint16_t expbits = 11;
+  long double result;
+  long long shift;
+  unsigned bias;
+  unsigned significandbits = bits - expbits - 1; // -1 for sign bit
+
+  if (i == 0) return 0.0;
+
+  // pull the significand
+  result = (i&((1LL<<significandbits)-1)); // mask
+  result /= (1LL<<significandbits); // convert back to float
+  result += 1.0f; // add the one back on
+
+  // deal with the exponent
+  bias = (1<<(expbits-1)) - 1;
+  shift = ((i>>significandbits)&((1LL<<expbits)-1)) - bias;
+  while(shift > 0) { result *= 2.0; shift--; }
+  while(shift < 0) { result /= 2.0; shift++; }
+
+  // sign it
+  result *= (i>>(bits-1))&1? -1.0: 1.0;
+
+  return result;
+}
+
+/////////////////////////////////////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2ConnectionSwitchHeader);
+
+EpcX2ConnectionSwitchHeader::EpcX2ConnectionSwitchHeader ()
+  : m_numberOfIes (1 + 1 + 1),
+    m_headerLength (2 + 1 + 1),
+    m_mmWaveRnti (0xfffa),
+    m_drbid (0xfa),
+    m_useMmWaveConnection (0)
+{
+
+}
+
+EpcX2ConnectionSwitchHeader::~EpcX2ConnectionSwitchHeader ()
+{
+  m_numberOfIes = 0;
+  m_headerLength = 0;
+  m_mmWaveRnti          = 0xfffb;
+  m_drbid = 0xfb;
+  m_useMmWaveConnection = 0;
+}
+
+TypeId
+EpcX2ConnectionSwitchHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2ConnectionSwitchHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2ConnectionSwitchHeader> ()
+  ;
+  return tid;
+}
+
+TypeId
+EpcX2ConnectionSwitchHeader::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::GetSerializedSize (void) const
+{
+  return m_headerLength;
+}
+
+void
+EpcX2ConnectionSwitchHeader::Serialize (Buffer::Iterator start) const
+{
+  Buffer::Iterator i = start;
+
+  i.WriteHtonU16 (m_mmWaveRnti);
+  i.WriteU8 (m_drbid);
+  i.WriteU8 (m_useMmWaveConnection);
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::Deserialize (Buffer::Iterator start)
+{
+  Buffer::Iterator i = start;
+
+  m_mmWaveRnti = i.ReadNtohU16 ();
+  m_drbid = i.ReadU8();
+  m_useMmWaveConnection = (bool)i.ReadU8 ();
+  m_numberOfIes = 3;
+  m_headerLength = 4;
+
+  return GetSerializedSize ();
+}
+
+void
+EpcX2ConnectionSwitchHeader::Print (std::ostream &os) const
+{
+  os << "m_mmWaveRnti = " << m_mmWaveRnti;
+  os << " m_useMmWaveConnection = " << m_useMmWaveConnection;
+  os << " m_drbid = " << (uint16_t)m_drbid;
+}
+
+uint16_t
+EpcX2ConnectionSwitchHeader::GetMmWaveRnti () const
+{
+  return m_mmWaveRnti;
+}
+
+void
+EpcX2ConnectionSwitchHeader::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+bool
+EpcX2ConnectionSwitchHeader::GetUseMmWaveConnection () const
+{
+  return m_useMmWaveConnection;
+}
+
+void
+EpcX2ConnectionSwitchHeader::SetUseMmWaveConnection (bool useMmWaveConnection)
+{
+  m_useMmWaveConnection = useMmWaveConnection;
+}
+
+uint8_t
+EpcX2ConnectionSwitchHeader::GetDrbid () const
+{
+  return m_drbid;
+}
+
+void
+EpcX2ConnectionSwitchHeader::SetDrbid (uint8_t bid)
+{
+  m_drbid = bid;
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::GetLengthOfIes () const
+{
+  return m_headerLength;
+}
+
+uint32_t
+EpcX2ConnectionSwitchHeader::GetNumberOfIes () const
+{
+  return m_numberOfIes;
+}
+
+
 } // namespace ns3
diff -Naru a/model/epc-x2-header.h b/model/epc-x2-header.h
--- a/model/epc-x2-header.h	2017-10-05 11:46:52.086493515 +0200
+++ b/model/epc-x2-header.h	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_X2_HEADER_H
@@ -36,10 +40,6 @@
   EpcX2Header ();
   virtual ~EpcX2Header ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -48,78 +48,57 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get message type function
-   * \returns the message type
-   */
   uint8_t GetMessageType () const;
-  /**
-   * Set message type function
-   * \param messageType the message type
-   */
   void SetMessageType (uint8_t messageType);
 
-  /**
-   * Get procedure code function
-   * \returns the procedure code
-   */
   uint8_t GetProcedureCode () const;
-  /**
-   * Set procedure code function
-   * \param procedureCode the procedure code
-   */
   void SetProcedureCode (uint8_t procedureCode);
 
-  /**
-   * Set length of IEs function
-   * \param lengthOfIes the length of IEs
-   */
   void SetLengthOfIes (uint32_t lengthOfIes);
-  /**
-   * Set number of IEs function
-   * \param numberOfIes the number of IEs
-   */
   void SetNumberOfIes (uint32_t numberOfIes);
 
 
-  /// Procedure code enumeration
   enum ProcedureCode_t {
     HandoverPreparation     = 0,
     LoadIndication          = 2,
     SnStatusTransfer        = 4,
     UeContextRelease        = 5,
-    ResourceStatusReporting = 10
+    ResourceStatusReporting = 10,
+    RlcSetupRequest         = 11, // added for MC functionalities
+    RlcSetupCompleted       = 12,
+    NotifyMcConnection      = 13,
+    UpdateUeSinr            = 14,
+    RequestMcHandover       = 15,
+    NotifyMmWaveLteHandover = 16,
+    NotifyCoordinatorHandoverFailed = 17,
+    SwitchConnection        = 18,
+    SecondaryCellHandoverCompleted = 19
+
   };
 
-  /// Type of message enumeration
   enum TypeOfMessage_t {
     InitiatingMessage       = 0,
     SuccessfulOutcome       = 1,
-    UnsuccessfulOutcome     = 2
+    UnsuccessfulOutcome     = 2,
+    McForwardDownlinkData   = 3, // added for MC functionalities
+    McForwardUplinkData     = 4
   };
 
 private:
-  uint8_t m_messageType; ///< message type
-  uint8_t m_procedureCode; ///< procedure code
+  uint8_t m_messageType;
+  uint8_t m_procedureCode;
 
-  uint32_t m_lengthOfIes; ///< length of IEs
-  uint32_t m_numberOfIes; ///< number of IEs
+  uint32_t m_lengthOfIes;
+  uint32_t m_numberOfIes;
 };
 
 
-/**
- * EpcX2HandoverRequestHeader
- */
 class EpcX2HandoverRequestHeader : public Header
 {
 public:
   EpcX2HandoverRequestHeader ();
   virtual ~EpcX2HandoverRequestHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -128,120 +107,252 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get old ENB X2 AP ID function
-   * \returns the old ENB UE X2 AP ID
-   */
   uint16_t GetOldEnbUeX2apId () const;
-  /**
-   * Set old ENB X2 AP ID function
-   * \param x2apId the X2 AP ID
-   */
   void SetOldEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get cause function
-   * \returns the cause
-   */
   uint16_t GetCause () const;
-  /**
-   * Set cause function
-   * \param cause
-   */
   void SetCause (uint16_t cause);
 
-  /**
-   * Get target cell id function
-   * \returns the target cell ID
-   */
+  bool GetIsMc () const;
+  void SetIsMc (bool isMc);
+
   uint16_t GetTargetCellId () const;
-  /**
-   * Set target cell id function
-   * \param targetCellId the target cell ID
-   */
   void SetTargetCellId (uint16_t targetCellId);
 
-  /**
-   * Get MME UE S1 AP ID function
-   * \returns the MME UE S1 AP ID
-   */
   uint32_t GetMmeUeS1apId () const;
-  /**
-   * Set MME UE S1 AP ID function
-   * \param mmeUeS1apId the MME UE S1 AP ID
-   */
   void SetMmeUeS1apId (uint32_t mmeUeS1apId);
 
-  /**
-   * Get bearers function
-   * \returns <EpcX2Sap::ErabToBeSetupItem>
-   */
   std::vector <EpcX2Sap::ErabToBeSetupItem> GetBearers () const;
-  /**
-   * Set bearers function
-   * \param bearers std::vector <EpcX2Sap::ErabToBeSetupItem>
-   */ 
   void SetBearers (std::vector <EpcX2Sap::ErabToBeSetupItem> bearers);
 
-  /**
-   * Get UE Aggregate Max Bit Rate Downlink function
-   * \returns the UE aggregate max bit rate downlink
-   */
+  std::vector <EpcX2Sap::RlcSetupRequest> GetRlcSetupRequests () const;
+  void SetRlcSetupRequests (std::vector <EpcX2Sap::RlcSetupRequest> rlcRequests);
+
   uint64_t GetUeAggregateMaxBitRateDownlink () const;
-  /**
-   * Set UE Aggregrate Max Bit Rate Downlink function
-   * \param bitRate the bit rate
-   */
   void SetUeAggregateMaxBitRateDownlink (uint64_t bitRate);
 
-  /**
-   * Get UE Aggregrate Max Bit Rate Uplik function
-   * \returns the UE aggregate max bit rate uplink
-   */
   uint64_t GetUeAggregateMaxBitRateUplink () const;
-  /**
-   * Set UE Aggregrate Max Bit Rate Uplik function
-   * \param bitRate the bit rate
-   */
   void SetUeAggregateMaxBitRateUplink (uint64_t bitRate);
 
-  /**
-   * Get length of IEs
-   * \returns the length of IEs
-   */
   uint32_t GetLengthOfIes () const;
-  /**
-   * Get number of IEs
-   * \returns the number of IEs
-   */
   uint32_t GetNumberOfIes () const;
 
 private:
-  uint32_t          m_numberOfIes; ///< number of IEs
-  uint32_t          m_headerLength; ///< header length
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
 
-  uint16_t          m_oldEnbUeX2apId; ///< old ENB UE X1 AP ID
-  uint16_t          m_cause; ///< cause
-  uint16_t          m_targetCellId; ///< target cell ID
-  uint32_t          m_mmeUeS1apId; ///< MME UE S1 AP ID
-  uint64_t          m_ueAggregateMaxBitRateDownlink; ///< aggregate max bit rate downlink
-  uint64_t          m_ueAggregateMaxBitRateUplink; ///< aggregate max bit rate uplink
-  std::vector <EpcX2Sap::ErabToBeSetupItem> m_erabsToBeSetupList; ///< ERAB to be setup list
+  uint16_t          m_oldEnbUeX2apId;
+  uint16_t          m_cause;
+  uint16_t          m_targetCellId;
+  uint32_t          m_mmeUeS1apId;
+  uint64_t          m_ueAggregateMaxBitRateDownlink;
+  uint64_t          m_ueAggregateMaxBitRateUplink;
+  std::vector <EpcX2Sap::ErabToBeSetupItem> m_erabsToBeSetupList;
+  std::vector <EpcX2Sap::RlcSetupRequest> m_rlcRequestsList;
+  bool              m_isMc;
+};
+
+
+class EpcX2RlcSetupRequestHeader : public Header
+{
+public:
+  EpcX2RlcSetupRequestHeader ();
+  virtual ~EpcX2RlcSetupRequestHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t sourceCellId);
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint32_t GetGtpTeid () const;
+  void SetGtpTeid (uint32_t gtpTeid);
+
+  uint16_t GetMmWaveRnti () const;
+  void SetMmWaveRnti (uint16_t rnti);
+
+  uint16_t GetLteRnti () const;
+  void SetLteRnti (uint16_t rnti);
+
+  uint8_t GetDrbid () const;
+  void SetDrbid (uint8_t drbid);
+
+  LteEnbCmacSapProvider::LcInfo GetLcInfo() const;
+  void SetLcInfo(LteEnbCmacSapProvider::LcInfo lcInfo);
+
+  LteRrcSap::RlcConfig GetRlcConfig() const;
+  void SetRlcConfig(LteRrcSap::RlcConfig rlcConfig);
+
+  LteRrcSap::LogicalChannelConfig GetLogicalChannelConfig();
+  void SetLogicalChannelConfig(LteRrcSap::LogicalChannelConfig conf);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_sourceCellId;
+  uint16_t          m_targetCellId;
+  uint32_t          m_gtpTeid;
+  uint16_t          m_mmWaveRnti;
+  uint16_t          m_lteRnti;
+  uint8_t           m_drbid;
+  LteEnbCmacSapProvider::LcInfo m_lcInfo;
+  LteRrcSap::RlcConfig m_rlcConfig;
+  LteRrcSap::LogicalChannelConfig m_lcConfig;
+};
+
+class EpcX2RlcSetupCompletedHeader : public Header
+{
+public:
+  EpcX2RlcSetupCompletedHeader ();
+  virtual ~EpcX2RlcSetupCompletedHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t sourceCellId);
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint32_t GetGtpTeid () const;
+  void SetGtpTeid (uint32_t gtpTeid);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_sourceCellId;
+  uint16_t          m_targetCellId;
+  uint32_t          m_gtpTeid;
+};
+
+class EpcX2McHandoverHeader : public Header
+{
+public:
+  EpcX2McHandoverHeader ();
+  virtual ~EpcX2McHandoverHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint16_t GetOldCellId () const;
+  void SetOldCellId (uint16_t oldCellId);
+
+  uint64_t GetImsi () const;
+  void SetImsi (uint64_t imsi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_targetCellId;
+  uint16_t          m_oldCellId;
+  uint64_t          m_imsi;
+};
+
+class EpcX2SecondaryCellHandoverCompletedHeader : public Header
+{
+public:
+  EpcX2SecondaryCellHandoverCompletedHeader ();
+  virtual ~EpcX2SecondaryCellHandoverCompletedHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetMmWaveRnti () const;
+  void SetMmWaveRnti (uint16_t mmWaveRnti);
+
+  uint16_t GetOldEnbUeX2apId () const;
+  void SetOldEnbUeX2apId (uint16_t oldEnbUeX2apId);
+
+  uint64_t GetImsi () const;
+  void SetImsi (uint64_t imsi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_mmWaveRnti;
+  uint16_t          m_oldEnbUeX2apId;
+  uint64_t          m_imsi;
+};
+
+class EpcX2NotifyCoordinatorHandoverFailedHeader : public Header
+{
+public:
+  EpcX2NotifyCoordinatorHandoverFailedHeader ();
+  virtual ~EpcX2NotifyCoordinatorHandoverFailedHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+  uint16_t GetTargetCellId () const;
+  void SetTargetCellId (uint16_t targetCellId);
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t oldCellId);
+
+  uint64_t GetImsi () const;
+  void SetImsi (uint64_t imsi);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_targetCellId;
+  uint16_t          m_sourceCellId;
+  uint64_t          m_imsi;
 };
 
-/**
- * EpcX2HandoverRequestAckHeader
- */
 class EpcX2HandoverRequestAckHeader : public Header
 {
 public:
   EpcX2HandoverRequestAckHeader ();
   virtual ~EpcX2HandoverRequestAckHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -250,85 +361,38 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get old ENB UE X2 AP ID function
-   * \returns the old ENB UE X2 AP ID
-   */
   uint16_t GetOldEnbUeX2apId () const;
-  /**
-   * Set old ENB UE X2 AP ID function
-   * \param x2apId the old ENB UE X2 AP ID
-   */
   void SetOldEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get new ENB UE X2 AP ID function
-   * \returns the new ENB UE X2 AP ID
-   */
   uint16_t GetNewEnbUeX2apId () const;
-  /**
-   * Set new ENB UE X2 AP ID function
-   * \param x2apId the new ENB UE X2 AP ID
-   */
   void SetNewEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get admittied bearers function
-   * \returns <EpcX2Sap::ErabAdmittedItem>
-   */
   std::vector <EpcX2Sap::ErabAdmittedItem> GetAdmittedBearers () const;
-  /**
-   * Set admitted bearers function
-   * \param bearers the admitted bearers
-   */
   void SetAdmittedBearers (std::vector <EpcX2Sap::ErabAdmittedItem> bearers);
 
-  /**
-   * Get not admitted bearers function
-   * \returns the not admitted bearers
-   */
   std::vector <EpcX2Sap::ErabNotAdmittedItem> GetNotAdmittedBearers () const;
-  /**
-   * Set not admitted bearers function
-   * \param bearers the not admitted bearers
-   */
   void SetNotAdmittedBearers (std::vector <EpcX2Sap::ErabNotAdmittedItem> bearers);
 
-  /**
-   * Get length of IEs function
-   * \returns the length of IEs
-   */
   uint32_t GetLengthOfIes () const;
-  /**
-   * Get number of IEs function
-   * \returns the number of IEs
-   */
   uint32_t GetNumberOfIes () const;
 
 private:
-  uint32_t          m_numberOfIes; ///< number of IEs
-  uint32_t          m_headerLength; ///< header length
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
 
-  uint16_t          m_oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-  uint16_t          m_newEnbUeX2apId; ///< new ENB UE X2 AP ID
-  std::vector <EpcX2Sap::ErabAdmittedItem>     m_erabsAdmittedList; ///< ERABs admitted list
-  std::vector <EpcX2Sap::ErabNotAdmittedItem>  m_erabsNotAdmittedList; ///< ERABs not admitted list
+  uint16_t          m_oldEnbUeX2apId;
+  uint16_t          m_newEnbUeX2apId;
+  std::vector <EpcX2Sap::ErabAdmittedItem>     m_erabsAdmittedList;
+  std::vector <EpcX2Sap::ErabNotAdmittedItem>  m_erabsNotAdmittedList;
 };
 
 
-/**
- * EpcX2HandoverPreparationFailureHeader
- */
 class EpcX2HandoverPreparationFailureHeader : public Header
 {
 public:
   EpcX2HandoverPreparationFailureHeader ();
   virtual ~EpcX2HandoverPreparationFailureHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -337,73 +401,34 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get old ENB UE X2 AP ID function
-   * \returns the old ENB UE X2 AP ID
-   */
   uint16_t GetOldEnbUeX2apId () const;
-  /**
-   * Set old ENB UE X2 AP ID function
-   * \param x2apId the old ENB UE X2 AP ID
-   */
   void SetOldEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get cause function
-   * \returns the cause
-   */
   uint16_t GetCause () const;
-  /**
-   * Set cause function
-   * \param cause
-   */
   void SetCause (uint16_t cause);
 
-  /**
-   * Get criticality diagnostics function
-   * \returns the criticality diagnostics
-   */
   uint16_t GetCriticalityDiagnostics () const;
-  /**
-   * Set criticality diagnostics function
-   * \param criticalityDiagnostics the criticality diagnostics
-   */
   void SetCriticalityDiagnostics (uint16_t criticalityDiagnostics);
 
-  /**
-   * Get length of IEs function
-   * \returns the length of IEs
-   */
   uint32_t GetLengthOfIes () const;
-  /**
-   * Get number of IEs function
-   * \returns the number of IEs
-   */
   uint32_t GetNumberOfIes () const;
 
 private:
-  uint32_t          m_numberOfIes; ///< number of IEs
-  uint32_t          m_headerLength; ///< header length
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
 
-  uint16_t          m_oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-  uint16_t          m_cause; ///< cause
-  uint16_t          m_criticalityDiagnostics; ///< criticality diagnostics
+  uint16_t          m_oldEnbUeX2apId;
+  uint16_t          m_cause;
+  uint16_t          m_criticalityDiagnostics;
 };
 
 
-/**
- * EpcX2SnStatusTransferHeader
- */
 class EpcX2SnStatusTransferHeader : public Header
 {
 public:
   EpcX2SnStatusTransferHeader ();
   virtual ~EpcX2SnStatusTransferHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -412,72 +437,34 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get old ENB UE X2 AP ID function
-   * \returns the old ENB UE X2 AP ID
-   */
   uint16_t GetOldEnbUeX2apId () const;
-  /**
-   * Set old ENB UE X2 AP ID function
-   * \param x2apId the old ENB UE X2 AP ID
-   */
   void SetOldEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get new ENB UE X2 AP ID function
-   * \returns the new ENB UE X2AP ID
-   */
   uint16_t GetNewEnbUeX2apId () const;
-  /**
-   * Set new ENB UE X2 AP ID function
-   * \param x2apId the new ENB UE X2AP ID
-   */
   void SetNewEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get ERABs subject to status transfer list function
-   * \returns std::vector <EpcX2Sap::ErabsSubjectToStatusTransferItem>
-   */
   std::vector <EpcX2Sap::ErabsSubjectToStatusTransferItem> GetErabsSubjectToStatusTransferList () const;
-  /**
-   * Set ERABs subject to status transfer list function
-   * \param erabs std::vector <EpcX2Sap::ErabsSubjectToStatusTransferItem>
-   */
   void SetErabsSubjectToStatusTransferList (std::vector <EpcX2Sap::ErabsSubjectToStatusTransferItem> erabs);
 
-  /**
-   * Get length of IEs function
-   * \returns the length of IEs
-   */
   uint32_t GetLengthOfIes () const;
-  /**
-   * Get number of IEs function
-   * \returns the number of IEs
-   */
   uint32_t GetNumberOfIes () const;
 
 private:
-  uint32_t          m_numberOfIes; ///< number of IEs
-  uint32_t          m_headerLength; ///< header length
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
 
-  uint16_t          m_oldEnbUeX2apId; ///< old ENB UE X2 AP ID 
-  uint16_t          m_newEnbUeX2apId; ///< new ENB UE X2 AP ID
-  std::vector <EpcX2Sap::ErabsSubjectToStatusTransferItem> m_erabsSubjectToStatusTransferList; ///< ERABs subject to status transfer list
+  uint16_t          m_oldEnbUeX2apId;
+  uint16_t          m_newEnbUeX2apId;
+  std::vector <EpcX2Sap::ErabsSubjectToStatusTransferItem> m_erabsSubjectToStatusTransferList;
 };
 
-/**
- * EpcX2UeContextReleaseHeader
- */
+
 class EpcX2UeContextReleaseHeader : public Header
 {
 public:
   EpcX2UeContextReleaseHeader ();
   virtual ~EpcX2UeContextReleaseHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -486,61 +473,30 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get old ENB UE X2 AP ID function
-   * \returns the old ENB UE X2 AP ID
-   */
   uint16_t GetOldEnbUeX2apId () const;
-  /**
-   * Set old ENB UE X2 AP ID function
-   * \param x2apId the old ENB UE X2 AP ID
-   */
   void SetOldEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get new ENB UE X2 AP ID function
-   * \returns the new ENB UE X2 AP ID
-   */
   uint16_t GetNewEnbUeX2apId () const;
-  /**
-   * Set new ENB UE X2 AP ID function
-   * \param x2apId the new ENB UE X2 AP ID
-   */
   void SetNewEnbUeX2apId (uint16_t x2apId);
 
-  /**
-   * Get length of IEs function
-   * \returns the length of IEs
-   */
   uint32_t GetLengthOfIes () const;
-  /**
-   * Set length of IEs function
-   * \returns the number of IEs
-   */
   uint32_t GetNumberOfIes () const;
 
 private:
-  uint32_t          m_numberOfIes; ///< number of IEs
-  uint32_t          m_headerLength; ///< header length
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
 
-  uint16_t          m_oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-  uint16_t          m_newEnbUeX2apId; ///< new ENB UE X2 AP ID
+  uint16_t          m_oldEnbUeX2apId;
+  uint16_t          m_newEnbUeX2apId;
 };
 
 
-/**
- * EpcX2LoadInformationHeader
- */
 class EpcX2LoadInformationHeader : public Header
 {
 public:
   EpcX2LoadInformationHeader ();
   virtual ~EpcX2LoadInformationHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -549,49 +505,26 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get cell information list function
-   * \returns std::vector <EpcX2Sap::CellInformationItem>
-   */
   std::vector <EpcX2Sap::CellInformationItem> GetCellInformationList () const;
-  /**
-   * Set cell information list function
-   * \param cellInformationList std::vector <EpcX2Sap::CellInformationItem> 
-   */
   void SetCellInformationList (std::vector <EpcX2Sap::CellInformationItem> cellInformationList);
 
-  /**
-   * Get length of IEs function
-   * \returns the length of IEs
-   */
   uint32_t GetLengthOfIes () const;
-  /**
-   * Get number of IEs function
-   * \returns the number of IEs
-   */
   uint32_t GetNumberOfIes () const;
 
 private:
-  uint32_t          m_numberOfIes; ///< number of IEs
-  uint32_t          m_headerLength; ///< length of IEs
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
 
-  std::vector <EpcX2Sap::CellInformationItem> m_cellInformationList; ///< cell information list
+  std::vector <EpcX2Sap::CellInformationItem> m_cellInformationList;
 };
 
 
-/**
- * EpcX2ResourceStatusUpdateHeader
- */
 class EpcX2ResourceStatusUpdateHeader : public Header
 {
 public:
   EpcX2ResourceStatusUpdateHeader ();
   virtual ~EpcX2ResourceStatusUpdateHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual uint32_t GetSerializedSize (void) const;
@@ -600,59 +533,97 @@
   virtual void Print (std::ostream &os) const;
 
 
-  /**
-   * Get ENB1 measurement ID function
-   * \returns the ENB1 measurement ID
-   */
   uint16_t GetEnb1MeasurementId () const;
-  /**
-   * Set ENB1 measurement ID function
-   * \param enb1MeasurementId the ENB1 measurement ID
-   */
   void SetEnb1MeasurementId (uint16_t enb1MeasurementId);
 
-  /**
-   * Get ENB2 measurement ID function
-   * \returns the ENB2 measurement ID
-   */
   uint16_t GetEnb2MeasurementId () const;
-  /**
-   * Set ENB2 measurement ID function
-   * \param enb2MeasurementId ENB2 measruement ID
-   */
   void SetEnb2MeasurementId (uint16_t enb2MeasurementId);
 
-  /**
-   * Get cell measurement results list function
-   * \returns the cell measurement results list
-   */ 
   std::vector <EpcX2Sap::CellMeasurementResultItem> GetCellMeasurementResultList () const;
-  /**
-   * Set cell measurement results list function
-   * \param cellMeasurementResultList the cell measurement results list
-   */
   void SetCellMeasurementResultList (std::vector <EpcX2Sap::CellMeasurementResultItem> cellMeasurementResultList);
 
-  /**
-   * Get length of IEs function
-   * \returns the length of IEs
-   */
   uint32_t GetLengthOfIes () const;
-  /**
-   * Get number of IEs function
-   * \returns the number of IEs
-   */
   uint32_t GetNumberOfIes () const;
 
 private:
-  uint32_t          m_numberOfIes; ///< number of IEs
-  uint32_t          m_headerLength; ///< header length
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t          m_enb1MeasurementId;
+  uint16_t          m_enb2MeasurementId;
+  std::vector <EpcX2Sap::CellMeasurementResultItem> m_cellMeasurementResultList;
+};
+
+class EpcX2UeImsiSinrUpdateHeader : public Header
+{
+public:
+  EpcX2UeImsiSinrUpdateHeader ();
+  virtual ~EpcX2UeImsiSinrUpdateHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  std::map <uint64_t, double> GetUeImsiSinrMap () const;
+  void SetUeImsiSinrMap (std::map<uint64_t, double> map);
+
+  uint16_t GetSourceCellId () const;
+  void SetSourceCellId (uint16_t sourceCellId);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
 
-  uint16_t          m_enb1MeasurementId; ///< ENB1 measurement
-  uint16_t          m_enb2MeasurementId; ///< ENB2 measurement
-  std::vector <EpcX2Sap::CellMeasurementResultItem> m_cellMeasurementResultList; ///< cell measurement result list
+  // from http://beej.us/guide/bgnet/examples/ieee754.c, to convert 
+  // uint64_t to double and viceversa according to IEEE754 format
+  static uint64_t pack754(long double f);
+  static long double unpack754(uint64_t i);
+
+  std::map <uint64_t, double> m_map;
+  uint16_t m_sourceCellId;
 };
 
+class EpcX2ConnectionSwitchHeader : public Header
+{
+public:
+  EpcX2ConnectionSwitchHeader ();
+  virtual ~EpcX2ConnectionSwitchHeader ();
+
+  static TypeId GetTypeId (void);
+  virtual TypeId GetInstanceTypeId (void) const;
+  virtual uint32_t GetSerializedSize (void) const;
+  virtual void Serialize (Buffer::Iterator start) const;
+  virtual uint32_t Deserialize (Buffer::Iterator start);
+  virtual void Print (std::ostream &os) const;
+
+
+  uint16_t GetMmWaveRnti () const;
+  void SetMmWaveRnti (uint16_t rnti);
+
+  bool GetUseMmWaveConnection () const;
+  void SetUseMmWaveConnection (bool useMmWaveConnection);
+
+  uint8_t GetDrbid () const;
+  void SetDrbid (uint8_t bid);
+
+  uint32_t GetLengthOfIes () const;
+  uint32_t GetNumberOfIes () const;
+
+private:
+  uint32_t          m_numberOfIes;
+  uint32_t          m_headerLength;
+
+  uint16_t m_mmWaveRnti;
+  uint8_t m_drbid;
+  bool     m_useMmWaveConnection;
+};
 
 } // namespace ns3
 
diff -Naru a/model/epc-x2-sap.cc b/model/epc-x2-sap.cc
--- a/model/epc-x2-sap.cc	2017-10-05 11:46:52.086493515 +0200
+++ b/model/epc-x2-sap.cc	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/epc-x2-sap.h"
@@ -40,4 +44,20 @@
 {
 }
 
+EpcX2PdcpUser::~EpcX2PdcpUser()
+{
+}
+
+EpcX2PdcpProvider::~EpcX2PdcpProvider()
+{
+}
+
+EpcX2RlcUser::~EpcX2RlcUser()
+{
+}
+
+EpcX2RlcProvider::~EpcX2RlcProvider()
+{
+}
+
 } // namespace ns3
diff -Naru a/model/epc-x2-sap.h b/model/epc-x2-sap.h
--- a/model/epc-x2-sap.h	2017-10-05 11:46:52.086493515 +0200
+++ b/model/epc-x2-sap.h	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,16 +17,20 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef EPC_X2_SAP_H
 #define EPC_X2_SAP_H
 
 #include "ns3/packet.h"
-#include "ns3/eps-bearer.h"
 #include "ns3/ipv4-address.h"
-
+#include <ns3/lte-rrc-sap.h>
+#include <ns3/lte-enb-cmac-sap.h>
 #include <bitset>
+#include <map>
 
 namespace ns3 {
 
@@ -58,11 +63,11 @@
    */
   struct ErabToBeSetupItem
   {
-    uint16_t    erabId; ///< E-RAB ID
-    EpsBearer   erabLevelQosParameters; ///< E-RAB level QOS parameters
-    bool        dlForwarding; ///< DL forwarding
-    Ipv4Address transportLayerAddress; ///< transport layer address
-    uint32_t    gtpTeid; ///< TEID
+    uint16_t    erabId;
+    EpsBearer   erabLevelQosParameters;
+    bool        dlForwarding;
+    Ipv4Address transportLayerAddress;
+    uint32_t    gtpTeid;
 
     ErabToBeSetupItem ();
   };
@@ -74,9 +79,9 @@
    */
   struct ErabAdmittedItem
   {
-    uint16_t    erabId; ///< E-RAB ID
-    uint32_t    ulGtpTeid; ///< uplink GTP TEID
-    uint32_t    dlGtpTeid; ///< downlink GTP TEID
+    uint16_t    erabId;
+    uint32_t    ulGtpTeid;
+    uint32_t    dlGtpTeid;
   };
 
   /**
@@ -86,8 +91,8 @@
    */
   struct ErabNotAdmittedItem
   {
-    uint16_t    erabId; ///< E-RAB ID
-    uint16_t    cause; ///< cause
+    uint16_t    erabId;
+    uint16_t    cause;
   };
 
   /**
@@ -96,16 +101,14 @@
    * See section 9.1.1.4 for further info about the parameters
    */
   static const uint16_t m_maxPdcpSn = 4096;
-
-  /// ErabsSubjectToStatusTransferItem structure
   struct ErabsSubjectToStatusTransferItem
   {
-    uint16_t            erabId; ///< ERAB ID
-    std::bitset<m_maxPdcpSn> receiveStatusOfUlPdcpSdus; ///< receive status of UL PDCP SDUs
-    uint16_t            ulPdcpSn; ///< UL PDCP SN
-    uint32_t            ulHfn; ///< UL HFN
-    uint16_t            dlPdcpSn; ///< DL PDCP SN
-    uint32_t            dlHfn; ///< DL HFN
+    uint16_t            erabId;
+    std::bitset<m_maxPdcpSn> receiveStatusOfUlPdcpSdus;
+    uint16_t            ulPdcpSn;
+    uint32_t            ulHfn;
+    uint16_t            dlPdcpSn;
+    uint32_t            dlHfn;
   };
 
   /**
@@ -127,8 +130,8 @@
    */
   struct UlHighInterferenceInformationItem
   {
-    uint16_t    targetCellId; ///< target cell ID
-    std::vector <bool> ulHighInterferenceIndicationList; ///< UL high interference indication list
+    uint16_t    targetCellId;
+    std::vector <bool> ulHighInterferenceIndicationList;
   };
 
   /**
@@ -141,11 +144,11 @@
    */
   struct RelativeNarrowbandTxBand
   {
-    std::vector <bool> rntpPerPrbList; ///< RNTP per prb list
-    int16_t     rntpThreshold; ///< RNTP threshold
-    uint16_t    antennaPorts; ///< antenna ports
-    uint16_t    pB; ///< PB
-    uint16_t    pdcchInterferenceImpact; ///< PDC channel interference list
+    std::vector <bool> rntpPerPrbList;
+    int16_t     rntpThreshold;
+    uint16_t    antennaPorts;
+    uint16_t    pB;
+    uint16_t    pdcchInterferenceImpact;
   };
 
   /**
@@ -155,10 +158,10 @@
    */
   struct CellInformationItem
   {
-    uint16_t    sourceCellId; ///< source cell ID
-    std::vector <UlInterferenceOverloadIndicationItem> ulInterferenceOverloadIndicationList; ///< UL interference overload indication list
-    std::vector <UlHighInterferenceInformationItem> ulHighInterferenceInformationList; ///< UL high interference information list
-    RelativeNarrowbandTxBand relativeNarrowbandTxBand; ///< relative narrow transmit band
+    uint16_t    sourceCellId;
+    std::vector <UlInterferenceOverloadIndicationItem> ulInterferenceOverloadIndicationList;
+    std::vector <UlHighInterferenceInformationItem> ulHighInterferenceInformationList;
+    RelativeNarrowbandTxBand relativeNarrowbandTxBand;
   };
 
   /**
@@ -181,8 +184,8 @@
    */
   struct CompositeAvailCapacity
   {
-    uint16_t    cellCapacityClassValue; ///< cell capacity class value
-    uint16_t    capacityValue; ///< capacity value
+    uint16_t    cellCapacityClassValue;
+    uint16_t    capacityValue;
   };
 
   /**
@@ -192,33 +195,52 @@
    */
   struct CellMeasurementResultItem
   {
-    uint16_t        sourceCellId; ///< source cell id
+    uint16_t        sourceCellId;
 
-    LoadIndicator   dlHardwareLoadIndicator; ///< DL hardware load indicator
-    LoadIndicator   ulHardwareLoadIndicator; ///< UL hardware load indicator
+    LoadIndicator   dlHardwareLoadIndicator;
+    LoadIndicator   ulHardwareLoadIndicator;
 
-    LoadIndicator   dlS1TnlLoadIndicator; ///< DL S1 TNL load indicator
-    LoadIndicator   ulS1TnlLoadIndicator; ///< UL S1 TNL load indicator
+    LoadIndicator   dlS1TnlLoadIndicator;
+    LoadIndicator   ulS1TnlLoadIndicator;
 
-    uint16_t        dlGbrPrbUsage; ///< DL GBR PRB usage
-    uint16_t        ulGbrPrbUsage; ///< UL GBR PRB usage
-    uint16_t        dlNonGbrPrbUsage; ///< DL Non GBR PRB usage
-    uint16_t        ulNonGbrPrbUsage; ///< UL Non GBR PRB usage
-    uint16_t        dlTotalPrbUsage; ///< DL Total PRB usage
-    uint16_t        ulTotalPrbUsage; ///< UL Total PRB usage
+    uint16_t        dlGbrPrbUsage;
+    uint16_t        ulGbrPrbUsage;
+    uint16_t        dlNonGbrPrbUsage;
+    uint16_t        ulNonGbrPrbUsage;
+    uint16_t        dlTotalPrbUsage;
+    uint16_t        ulTotalPrbUsage;
 
-    CompositeAvailCapacity  dlCompositeAvailableCapacity; ///< DL composite available capacity
-    CompositeAvailCapacity  ulCompositeAvailableCapacity; ///< UL composite available capacity
+    CompositeAvailCapacity  dlCompositeAvailableCapacity;
+    CompositeAvailCapacity  ulCompositeAvailableCapacity;
   };
 
 
-  /// Cause ID enumeration
   enum IdCause
   {
     HandoverDesirableForRadioReason,
     TimeCriticalHandover
   };
 
+  /**
+   * \brief Parameters of the RlcSetupRequest to handle MC connectivity
+   *
+   * Forward UE params during the MC setup
+   */
+  struct RlcSetupRequest
+  {
+    uint16_t    sourceCellId;
+    uint16_t    targetCellId;
+    uint32_t    gtpTeid;
+    uint16_t    mmWaveRnti;
+    uint16_t    lteRnti;
+    uint8_t     drbid;
+    LteEnbCmacSapProvider::LcInfo lcinfo;
+    LteRrcSap::RlcConfig rlcConfig;
+    LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+    TypeId      rlcType;
+  };
+
+
 
   /**
    * \brief Parameters of the HANDOVER REQUEST message.
@@ -227,15 +249,18 @@
    */
   struct HandoverRequestParams
   {
-    uint16_t            oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-    uint16_t            cause; ///< cause
-    uint16_t            sourceCellId; ///< source cell ID
-    uint16_t            targetCellId; ///< target cell ID
-    uint32_t            mmeUeS1apId; ///< MME UE S1 AP ID
-    uint64_t            ueAggregateMaxBitRateDownlink; ///< UE aggregrate max bit rate downlink
-    uint64_t            ueAggregateMaxBitRateUplink; ///< UE aggregrate max bit rate uplink 
-    std::vector <ErabToBeSetupItem> bearers; ///< bearers
-    Ptr<Packet>         rrcContext; ///< RRC context
+    uint16_t            oldEnbUeX2apId;
+    uint16_t            cause;
+    uint16_t            sourceCellId;
+    uint16_t            targetCellId;
+    uint32_t            mmeUeS1apId;
+    uint64_t            ueAggregateMaxBitRateDownlink;
+    uint64_t            ueAggregateMaxBitRateUplink;
+    bool                isMc;
+    std::vector <ErabToBeSetupItem> bearers;
+    // list of RlcSetupRequest for secondary cell handovers (otherwise empty)
+    std::vector <RlcSetupRequest> rlcRequests;
+    Ptr<Packet>         rrcContext;
   };
 
   /**
@@ -245,13 +270,13 @@
    */
   struct HandoverRequestAckParams
   {
-    uint16_t            oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-    uint16_t            newEnbUeX2apId; ///< new ENB UE X2 AP ID
-    uint16_t            sourceCellId; ///< source cell ID
-    uint16_t            targetCellId; ///< target cell ID
-    std::vector <ErabAdmittedItem> admittedBearers; ///< admitted bearers
-    std::vector <ErabNotAdmittedItem> notAdmittedBearers; ///< not admitted bearers
-    Ptr<Packet>         rrcContext; ///< RRC context
+    uint16_t            oldEnbUeX2apId;
+    uint16_t            newEnbUeX2apId;
+    uint16_t            sourceCellId;
+    uint16_t            targetCellId;
+    std::vector <ErabAdmittedItem> admittedBearers;
+    std::vector <ErabNotAdmittedItem> notAdmittedBearers;
+    Ptr<Packet>         rrcContext;
   };
 
   /**
@@ -261,11 +286,11 @@
    */
   struct HandoverPreparationFailureParams
   {
-    uint16_t            oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-    uint16_t            sourceCellId; ///< source cell ID
-    uint16_t            targetCellId; ///< target cell ID
-    uint16_t            cause; ///< cause
-    uint16_t            criticalityDiagnostics; ///< criticality diagnostics
+    uint16_t            oldEnbUeX2apId;
+    uint16_t            sourceCellId;
+    uint16_t            targetCellId;
+    uint16_t            cause;
+    uint16_t            criticalityDiagnostics;
   };
 
   /**
@@ -275,11 +300,11 @@
    */
   struct SnStatusTransferParams
   {
-    uint16_t            oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-    uint16_t            newEnbUeX2apId; ///< new ENB UE X2 AP ID
-    uint16_t            sourceCellId; ///< source cell ID
-    uint16_t            targetCellId; ///< target cell ID
-    std::vector <ErabsSubjectToStatusTransferItem> erabsSubjectToStatusTransferList; ///< ERABs subject to status transfer list
+    uint16_t            oldEnbUeX2apId;
+    uint16_t            newEnbUeX2apId;
+    uint16_t            sourceCellId;
+    uint16_t            targetCellId;
+    std::vector <ErabsSubjectToStatusTransferItem> erabsSubjectToStatusTransferList;
   };
 
   /**
@@ -289,10 +314,10 @@
    */
   struct UeContextReleaseParams
   {
-    uint16_t            oldEnbUeX2apId; ///< old ENB UE X2 AP ID
-    uint16_t            newEnbUeX2apId; ///< new ENB UE X2 AP ID
-    uint16_t            sourceCellId; ///< source cell ID
-    uint16_t            targetCellId; ///< target cell ID
+    uint16_t            oldEnbUeX2apId;
+    uint16_t            newEnbUeX2apId;
+    uint16_t            sourceCellId;
+    uint16_t            targetCellId;
   };
 
   /**
@@ -302,8 +327,8 @@
    */
   struct LoadInformationParams
   {
-    uint16_t            targetCellId; ///< target cell ID
-    std::vector <CellInformationItem> cellInformationList; ///< cell information list
+    uint16_t            targetCellId;
+    std::vector <CellInformationItem> cellInformationList;
   };
 
   /**
@@ -313,10 +338,10 @@
    */
   struct ResourceStatusUpdateParams
   {
-    uint16_t            targetCellId; ///< target cell ID
-    uint16_t            enb1MeasurementId; ///< ENB1 measurement ID
-    uint16_t            enb2MeasurementId; ///< ENB2 measurement ID
-    std::vector <CellMeasurementResultItem> cellMeasurementResultList; ///< cell measurement result list
+    uint16_t            targetCellId;
+    uint16_t            enb1MeasurementId;
+    uint16_t            enb2MeasurementId;
+    std::vector <CellMeasurementResultItem> cellMeasurementResultList;
   };
 
   /**
@@ -327,16 +352,117 @@
    */
   struct UeDataParams
   {
-    uint16_t    sourceCellId; ///< source cell ID
-    uint16_t    targetCellId; ///< target cell ID
-    uint32_t    gtpTeid; ///< GTP TEID
-    Ptr<Packet> ueData; ///< UE data
+    uint16_t    sourceCellId;
+    uint16_t    targetCellId;
+    uint32_t    gtpTeid;
+    Ptr<Packet> ueData;
+  };
+
+  struct SecondaryHandoverParams
+  {
+    uint64_t imsi;
+    uint16_t oldCellId;
+    uint16_t targetCellId;
+  };
+
+  struct SecondaryHandoverCompletedParams
+  {
+    uint64_t imsi;
+    uint16_t mmWaveRnti;
+    uint16_t cellId;
+    uint16_t oldEnbUeX2apId;
+  };
+
+  struct UeImsiSinrParams
+  {
+    uint16_t    sourceCellId;
+    uint16_t    targetCellId;
+    std::map<uint64_t, double> ueImsiSinrMap; 
+  };
+
+  struct HandoverFailedParams
+  {
+    uint64_t imsi;
+    uint16_t coordinatorId;
+    uint16_t sourceCellId;
+    uint16_t targetCellId;
   };
 
+  struct SwitchConnectionParams
+  {
+    uint32_t mmWaveRnti;
+    uint16_t mmWaveCellId;
+    uint8_t drbid;
+    bool useMmWaveConnection;
+  }; 
+
+};
+
+
+/**
+ * MC primitives. Part of X2 entity, called by PDCP
+ */
+class EpcX2PdcpProvider : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2PdcpProvider ();
+
+  /*
+   * Service primitives
+   */
+  // X2 sends a Pdcp PDU in downlink to the MmWave eNB for transmission to the UE
+  virtual void SendMcPdcpPdu (UeDataParams params) = 0;
+};
+
+
+/**
+ * MC primitives. Part of PDCP entity, called by X2
+ */
+class EpcX2PdcpUser : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2PdcpUser ();
+
+  /*
+   * Service primitives
+   */
+  // Receive a PDCP PDU in uplink from the MmWave eNB for transmission to CN
+  virtual void ReceiveMcPdcpPdu (UeDataParams params) = 0;
+};
+
+
+/**
+ * MC primitives. Part of X2 entity, called by RLC
+ */
+class EpcX2RlcProvider : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2RlcProvider ();
+
+  /*
+   * Service primitives
+   */
+  // Receive a PDCP SDU from RLC for uplink transmission to PDCP in LTE eNB
+  virtual void ReceiveMcPdcpSdu (UeDataParams params) = 0;
 };
 
 
 /**
+ * MC primitives. Part of RLC entity, called by X2
+ */
+class EpcX2RlcUser : public EpcX2Sap
+{
+public:
+  virtual ~EpcX2RlcUser ();
+
+  /*
+   * Service primitives
+   */
+  // X2 sends a PDCP SDU to RLC for downlink transmission to the UE
+  virtual void SendMcPdcpSdu (UeDataParams params) = 0;
+};
+
+/**
  * These service primitives of this part of the X2 SAP
  * are provided by the X2 entity and issued by RRC entity
  */
@@ -345,57 +471,55 @@
 public:
   virtual ~EpcX2SapProvider ();
 
-  //
-  // Service primitives
-  //
-
   /**
-   * Send handover request function
-   * \param params handover request parameters
+   * Service primitives
    */
+
   virtual void SendHandoverRequest (HandoverRequestParams params) = 0;
 
-  /**
-   * Send handover request ack function
-   * \param params the handover request ack parameters
-   */
   virtual void SendHandoverRequestAck (HandoverRequestAckParams params) = 0;
 
-  /**
-   * Send handover preparation failure function
-   * \param params the handover preparation failure
-   */
   virtual void SendHandoverPreparationFailure (HandoverPreparationFailureParams params) = 0;
 
-  /**
-   * Send SN status transfer function
-   * \param params the SN status transfer parameters
-   */
   virtual void SendSnStatusTransfer (SnStatusTransferParams params) = 0;
 
-  /**
-   * Send UE context release function
-   * \param params the UE context release parameters
-   */
   virtual void SendUeContextRelease (UeContextReleaseParams params) = 0;
 
-  /**
-   * Send load information function
-   * \param params the load information parameters
-   */
   virtual void SendLoadInformation (LoadInformationParams params) = 0;
 
-  /**
-   * Send resource status update function
-   * \param params the resource statue update paramweters
-   */
   virtual void SendResourceStatusUpdate (ResourceStatusUpdateParams params) = 0;
 
-  /**
-   * Send UE data function
-   * \param params the UE data parameters
-   */
   virtual void SendUeData (UeDataParams params) = 0;
+
+  virtual void SetEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser * s) = 0;
+
+  virtual void SetEpcX2RlcUser (uint32_t teid, EpcX2RlcUser * s) = 0;
+
+  virtual void SendRlcSetupRequest (RlcSetupRequest params) = 0;
+
+  virtual void SendRlcSetupCompleted (UeDataParams params) = 0;
+
+  virtual void SendUeSinrUpdate (UeImsiSinrParams params) = 0;
+
+  virtual void NotifyLteMmWaveHandoverCompleted (SecondaryHandoverParams params) = 0;
+
+  virtual void NotifyCoordinatorHandoverFailed (HandoverFailedParams params) = 0;
+
+  // send the switch command to the mmwave eNB
+  virtual void SendSwitchConnectionToMmWave (SwitchConnectionParams params) = 0;
+
+  // for secondary cell HO
+  // the coordinator requests to a mmWave eNB to start an handover
+  virtual void SendMcHandoverRequest (SecondaryHandoverParams params) = 0;
+  // notify the coordinator that the secondary cell handover is completed
+  virtual void SendSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params) = 0;
+  // notify the EpcX2 class that packets for a certain TEID must be forwarded to the targetCell
+  virtual void AddTeidToBeForwarded (uint32_t gtpTeid, uint16_t targetCellId) = 0;
+  // notify the EpcX2 class that packets for a certain TEID must not be forwarded anymore
+  virtual void RemoveTeidToBeForwarded (uint32_t gtpTeid) = 0;
+  // to forward the packets in the RLC buffers in the source cell as if they were generated by a PDCP
+  virtual void ForwardRlcPdu (UeDataParams params) = 0;
+
 };
 
 
@@ -408,130 +532,99 @@
 public:
   virtual ~EpcX2SapUser ();
 
-  /*
+  /**
    * Service primitives
    */
 
-  /**
-   * Receive handover request function
-   * \param params the handover request parameters
-   */
   virtual void RecvHandoverRequest (HandoverRequestParams params) = 0;
 
-  /**
-   * Receive handover request ack function
-   * \param params the handover request ack parameters
-   */
   virtual void RecvHandoverRequestAck (HandoverRequestAckParams params) = 0;
 
-  /**
-   * Receive handover preparation failure function
-   * \param params the handover preparation failure parameters
-   */ 
   virtual void RecvHandoverPreparationFailure (HandoverPreparationFailureParams params) = 0;
 
-  /**
-   * Receive SN status transfer function
-   * \param params the SN status transfer parameters
-   */
   virtual void RecvSnStatusTransfer (SnStatusTransferParams params) = 0;
 
-  /**
-   * Receive UE context release function
-   * \param params the receive UE context release parameters
-   */
   virtual void RecvUeContextRelease (UeContextReleaseParams params) = 0;
 
-  /**
-   * Receive load information function
-   * \param params the load information parameters
-   */
   virtual void RecvLoadInformation (LoadInformationParams params) = 0;
   
-  /**
-   * Receive resource status update function
-   * \param params the resource status update parameters
-   */
   virtual void RecvResourceStatusUpdate (ResourceStatusUpdateParams params) = 0;
 
-  /**
-   * Receive UE data function
-   * \param params UE data parameters
-   */
+  virtual void RecvRlcSetupRequest (RlcSetupRequest params) = 0;
+
+  virtual void RecvRlcSetupCompleted (UeDataParams params) = 0;
+
   virtual void RecvUeData (UeDataParams params) = 0;
+
+  virtual void RecvUeSinrUpdate(UeImsiSinrParams params) = 0;
+
+  virtual void RecvMcHandoverRequest (SecondaryHandoverParams params) = 0;
+
+  virtual void RecvLteMmWaveHandoverCompleted (SecondaryHandoverParams params) = 0;
+
+  virtual void RecvConnectionSwitchToMmWave (SwitchConnectionParams params) = 0;
+
+  virtual void RecvSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params) = 0;
+
 };
 
 ///////////////////////////////////////
 
-/**
- * EpcX2SpecificEpcX2SapProvider
- */
 template <class C>
 class EpcX2SpecificEpcX2SapProvider : public EpcX2SapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param x2 the owner class
-   */
   EpcX2SpecificEpcX2SapProvider (C* x2);
 
   //
   // Interface implemented from EpcX2SapProvider
   //
 
-  /**
-   * Send handover request functon
-   * \param params the hadnover request parameters
-   */
   virtual void SendHandoverRequest (HandoverRequestParams params);
 
-  /**
-   * Send handover request ack function
-   * \param params the handover request ack pararameters
-   */
   virtual void SendHandoverRequestAck (HandoverRequestAckParams params);
 
-  /**
-   * Send handover preparation failure function
-   * \param params the handover preparation failure parameters
-   */
   virtual void SendHandoverPreparationFailure (HandoverPreparationFailureParams params);
 
-  /**
-   * Send SN status transfer function
-   * \param params the SN status transfer parameters
-   */
   virtual void SendSnStatusTransfer (SnStatusTransferParams params);
 
-  /**
-   * Send UE context release function
-   * \param params the UE context release parameters
-   */
   virtual void SendUeContextRelease (UeContextReleaseParams params);
 
-  /**
-   * Send load information function
-   * \param params the load information parameters
-   */
   virtual void SendLoadInformation (LoadInformationParams params);
 
-  /**
-   * Send resource status update function
-   * \param params the resource status update parameters
-   */
   virtual void SendResourceStatusUpdate (ResourceStatusUpdateParams params);
 
-  /**
-   * Send UE data function
-   * \param params the UE data parameters
-   */
   virtual void SendUeData (UeDataParams params);
 
+  virtual void SetEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser * s);
+
+  virtual void SetEpcX2RlcUser (uint32_t teid, EpcX2RlcUser * s);
+
+  virtual void SendRlcSetupRequest (RlcSetupRequest params);
+
+  virtual void SendRlcSetupCompleted (UeDataParams params);
+
+  virtual void SendUeSinrUpdate (UeImsiSinrParams params);
+
+  virtual void SendMcHandoverRequest (SecondaryHandoverParams params);
+
+  virtual void NotifyLteMmWaveHandoverCompleted (SecondaryHandoverParams params);
+
+  virtual void NotifyCoordinatorHandoverFailed (HandoverFailedParams params);
+
+  virtual void SendSwitchConnectionToMmWave (SwitchConnectionParams params);
+
+  virtual void SendSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params);
+
+  virtual void AddTeidToBeForwarded (uint32_t gtpTeid, uint16_t targetCellId);
+  
+  virtual void RemoveTeidToBeForwarded (uint32_t gtpTeid);
+
+  virtual void ForwardRlcPdu (UeDataParams params);
+
 private:
   EpcX2SpecificEpcX2SapProvider ();
-  C* m_x2; ///< owner class
+  C* m_x2;
 };
 
 template <class C>
@@ -601,75 +694,143 @@
   m_x2->DoSendUeData (params);
 }
 
-/**
- * EpcX2SpecificEpcX2SapUser
- */
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SetEpcX2RlcUser (uint32_t teid, EpcX2RlcUser * s)
+{
+  m_x2->SetMcEpcX2RlcUser (teid, s);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SetEpcX2PdcpUser (uint32_t teid, EpcX2PdcpUser * s)
+{
+  m_x2->SetMcEpcX2PdcpUser (teid, s);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendRlcSetupRequest (RlcSetupRequest params)
+{
+  m_x2->DoSendRlcSetupRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendRlcSetupCompleted (UeDataParams params)
+{
+  m_x2->DoSendRlcSetupCompleted (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendUeSinrUpdate (UeImsiSinrParams params)
+{
+  m_x2->DoSendUeSinrUpdate (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendMcHandoverRequest (SecondaryHandoverParams params)
+{
+  m_x2->DoSendMcHandoverRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::NotifyLteMmWaveHandoverCompleted (SecondaryHandoverParams params)
+{
+  m_x2->DoNotifyLteMmWaveHandoverCompleted(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::NotifyCoordinatorHandoverFailed (HandoverFailedParams params)
+{
+  m_x2->DoNotifyCoordinatorHandoverFailed(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendSwitchConnectionToMmWave (SwitchConnectionParams params)
+{
+  m_x2->DoSendSwitchConnectionToMmWave(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::SendSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params)
+{
+  m_x2->DoSendSecondaryCellHandoverCompleted(params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::AddTeidToBeForwarded (uint32_t gtpTeid, uint16_t targetCellId)
+{
+  m_x2->DoAddTeidToBeForwarded(gtpTeid, targetCellId);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::RemoveTeidToBeForwarded (uint32_t gtpTeid)
+{
+  m_x2->DoRemoveTeidToBeForwarded(gtpTeid);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapProvider<C>::ForwardRlcPdu(UeDataParams params)
+{
+  m_x2->DoSendMcPdcpPdu(params);
+}
+
+///////////////////////////////////////
+
 template <class C>
 class EpcX2SpecificEpcX2SapUser : public EpcX2SapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param rrc RRC
-   */
   EpcX2SpecificEpcX2SapUser (C* rrc);
 
   //
   // Interface implemented from EpcX2SapUser
   //
 
-  /**
-   * Receive handover request function
-   * \param params the receive handover request parameters
-   */
   virtual void RecvHandoverRequest (HandoverRequestParams params);
 
-  /**
-   * Receive handover request ack function
-   * \param params the receive handover request ack parameters
-   */
   virtual void RecvHandoverRequestAck (HandoverRequestAckParams params);
 
-  /**
-   * Receive handover preparation failure function
-   * \param params the receive handover preparation failure parameters
-   */
   virtual void RecvHandoverPreparationFailure (HandoverPreparationFailureParams params);
 
-  /**
-   * Receive SN status transfer function
-   * \param params the SN status transfer parameters
-   */
   virtual void RecvSnStatusTransfer (SnStatusTransferParams params);
 
-  /**
-   * Receive UE context release function
-   * \param params the UE context release parameters
-   */
   virtual void RecvUeContextRelease (UeContextReleaseParams params);
 
-  /**
-   * Receive load information function
-   * \param params the load information parameters
-   */
   virtual void RecvLoadInformation (LoadInformationParams params);
 
-  /**
-   * Receive resource status update function
-   * \param params the receive resource status update
-   */
   virtual void RecvResourceStatusUpdate (ResourceStatusUpdateParams params);
 
-  /**
-   * Receive UE data function
-   * \param params the UE data parameters
-   */
+  virtual void RecvRlcSetupRequest (RlcSetupRequest params);
+
+  virtual void RecvRlcSetupCompleted (UeDataParams params);
+
   virtual void RecvUeData (UeDataParams params);
 
+  virtual void RecvUeSinrUpdate (UeImsiSinrParams params);
+
+  virtual void RecvMcHandoverRequest (SecondaryHandoverParams params);
+
+  virtual void RecvLteMmWaveHandoverCompleted (SecondaryHandoverParams params);
+
+  virtual void RecvConnectionSwitchToMmWave (SwitchConnectionParams params);
+
+  virtual void RecvSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params);
+
+
 private:
   EpcX2SpecificEpcX2SapUser ();
-  C* m_rrc; ///< owner class
+  C* m_rrc;
 };
 
 template <class C>
@@ -734,11 +895,193 @@
 
 template <class C>
 void
+EpcX2SpecificEpcX2SapUser<C>::RecvRlcSetupRequest (RlcSetupRequest params)
+{
+  m_rrc->DoRecvRlcSetupRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvRlcSetupCompleted (UeDataParams params)
+{
+  m_rrc->DoRecvRlcSetupCompleted (params);
+}
+
+template <class C>
+void
 EpcX2SpecificEpcX2SapUser<C>::RecvUeData (UeDataParams params)
 {
   m_rrc->DoRecvUeData (params);
 }
 
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvUeSinrUpdate (UeImsiSinrParams params)
+{
+  m_rrc->DoRecvUeSinrUpdate (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvMcHandoverRequest (SecondaryHandoverParams params)
+{
+  m_rrc->DoRecvMcHandoverRequest (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvLteMmWaveHandoverCompleted (SecondaryHandoverParams params)
+{
+  m_rrc->DoRecvLteMmWaveHandoverCompleted (params);
+}
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvConnectionSwitchToMmWave (SwitchConnectionParams params)
+{
+  m_rrc->DoRecvConnectionSwitchToMmWave (params);
+}
+
+
+template <class C>
+void
+EpcX2SpecificEpcX2SapUser<C>::RecvSecondaryCellHandoverCompleted (SecondaryHandoverCompletedParams params)
+{
+  m_rrc->DoRecvSecondaryCellHandoverCompleted(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2PdcpSpecificProvider : public EpcX2PdcpProvider
+{
+public:
+  EpcX2PdcpSpecificProvider (C* x2);
+
+  // Inherited
+  virtual void SendMcPdcpPdu (UeDataParams params);
+
+private:
+  EpcX2PdcpSpecificProvider ();
+  C* m_x2;
+};
+
+template <class C>
+EpcX2PdcpSpecificProvider<C>::EpcX2PdcpSpecificProvider (C* x2)
+  : m_x2 (x2)
+{
+}
+
+template <class C>
+EpcX2PdcpSpecificProvider<C>::EpcX2PdcpSpecificProvider ()
+{
+}
+
+template <class C>
+void
+EpcX2PdcpSpecificProvider<C>::SendMcPdcpPdu(UeDataParams params)
+{
+  m_x2->DoSendMcPdcpPdu(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2RlcSpecificProvider : public EpcX2RlcProvider
+{
+public:
+  EpcX2RlcSpecificProvider (C* x2);
+
+  // Inherited
+  virtual void ReceiveMcPdcpSdu (UeDataParams params);
+
+private:
+  EpcX2RlcSpecificProvider ();
+  C* m_x2;
+};
+
+template <class C>
+EpcX2RlcSpecificProvider<C>::EpcX2RlcSpecificProvider (C* x2)
+  : m_x2 (x2)
+{
+}
+
+template <class C>
+EpcX2RlcSpecificProvider<C>::EpcX2RlcSpecificProvider ()
+{
+}
+
+template <class C>
+void
+EpcX2RlcSpecificProvider<C>::ReceiveMcPdcpSdu(UeDataParams params)
+{
+  m_x2->DoReceiveMcPdcpSdu(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2PdcpSpecificUser : public EpcX2PdcpUser
+{
+public:
+  EpcX2PdcpSpecificUser (C* pdcp);
+
+  // Inherited
+  virtual void ReceiveMcPdcpPdu (UeDataParams params);
+
+private:
+  EpcX2PdcpSpecificUser ();
+  C* m_pdcp;
+};
+
+template <class C>
+EpcX2PdcpSpecificUser<C>::EpcX2PdcpSpecificUser (C* pdcp)
+  : m_pdcp (pdcp)
+{
+}
+
+template <class C>
+EpcX2PdcpSpecificUser<C>::EpcX2PdcpSpecificUser ()
+{
+}
+
+template <class C>
+void
+EpcX2PdcpSpecificUser<C>::ReceiveMcPdcpPdu(UeDataParams params)
+{
+  m_pdcp->DoReceiveMcPdcpPdu(params);
+}
+
+/////////////////////////////////////////////
+template <class C>
+class EpcX2RlcSpecificUser : public EpcX2RlcUser
+{
+public:
+  EpcX2RlcSpecificUser (C* rlc);
+
+  // Inherited
+  virtual void SendMcPdcpSdu (UeDataParams params);
+
+private:
+  EpcX2RlcSpecificUser ();
+  C* m_rlc;
+};
+
+template <class C>
+EpcX2RlcSpecificUser<C>::EpcX2RlcSpecificUser (C* rlc)
+  : m_rlc (rlc)
+{
+}
+
+template <class C>
+EpcX2RlcSpecificUser<C>::EpcX2RlcSpecificUser ()
+{
+}
+
+template <class C>
+void
+EpcX2RlcSpecificUser<C>::SendMcPdcpSdu(UeDataParams params)
+{
+  m_rlc->DoSendMcPdcpSdu(params);
+}
+
 } // namespace ns3
 
 #endif // EPC_X2_SAP_H
diff -Naru a/model/epc-x2-tag.cc b/model/epc-x2-tag.cc
--- a/model/epc-x2-tag.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-x2-tag.cc	2017-10-05 11:47:22.298601725 +0200
@@ -0,0 +1,92 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 CTTC
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jaume.nin@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ */
+
+#include "epc-x2-tag.h"
+#include "ns3/tag.h"
+#include "ns3/uinteger.h"
+
+namespace ns3 {
+
+NS_OBJECT_ENSURE_REGISTERED (EpcX2Tag);
+
+EpcX2Tag::EpcX2Tag ()
+  : m_senderTimestamp (Seconds (0))
+{
+  // Nothing to do here
+}
+
+
+EpcX2Tag::EpcX2Tag (Time senderTimestamp)
+  : m_senderTimestamp (senderTimestamp)
+
+{
+  // Nothing to do here
+}
+
+TypeId
+EpcX2Tag::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::EpcX2Tag")
+    .SetParent<Tag> ()
+    .SetGroupName("Lte")
+    .AddConstructor<EpcX2Tag> ();
+  return tid;
+}
+
+TypeId
+EpcX2Tag::GetInstanceTypeId (void) const
+{
+  return GetTypeId ();
+}
+
+uint32_t
+EpcX2Tag::GetSerializedSize (void) const
+{
+  return sizeof(Time);
+}
+
+void
+EpcX2Tag::Serialize (TagBuffer i) const
+{
+  int64_t senderTimestamp = m_senderTimestamp.GetNanoSeconds ();
+  i.Write ((const uint8_t *)&senderTimestamp, sizeof(int64_t));
+}
+
+void
+EpcX2Tag::Deserialize (TagBuffer i)
+{
+  int64_t senderTimestamp;
+  i.Read ((uint8_t *)&senderTimestamp, 8);
+  m_senderTimestamp   = NanoSeconds (senderTimestamp);
+
+}
+
+void
+EpcX2Tag::Print (std::ostream &os) const
+{
+  os << m_senderTimestamp;
+}
+
+} // namespace ns3
+
diff -Naru a/model/epc-x2-tag.h b/model/epc-x2-tag.h
--- a/model/epc-x2-tag.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/epc-x2-tag.h	2017-10-05 11:47:22.298601725 +0200
@@ -0,0 +1,85 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 CTTC
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Jaume Nin <jaume.nin@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
+ */
+
+#ifndef X2_TAG_H
+#define X2_TAG_H
+
+#include "ns3/packet.h"
+#include "ns3/nstime.h"
+
+
+namespace ns3 {
+
+class Tag;
+
+/**
+ * Tag to calculate the per-PDU delay on X2 links
+ */
+
+class EpcX2Tag : public Tag
+{
+public:
+  static TypeId  GetTypeId (void);
+  virtual TypeId  GetInstanceTypeId (void) const;
+
+  /**
+   * Create an empty X2 tag
+   */
+  EpcX2Tag ();
+  /**
+   * Create an X2 tag with the given senderTimestamp
+   */
+  EpcX2Tag (Time senderTimestamp);
+
+  virtual void  Serialize (TagBuffer i) const;
+  virtual void  Deserialize (TagBuffer i);
+  virtual uint32_t  GetSerializedSize () const;
+  virtual void Print (std::ostream &os) const;
+
+  /**
+   * Get the instant when the X2 delivers the PDU to the MAC SAP provider
+   * @return the sender timestamp
+   */
+  Time  GetSenderTimestamp (void) const
+  {
+    return m_senderTimestamp;
+  }
+
+  /**
+   * Set the sender timestamp
+   * @param senderTimestamp time stamp of the instant when the X2 delivers the PDU
+   */
+  void  SetSenderTimestamp (Time senderTimestamp)
+  {
+    this->m_senderTimestamp = senderTimestamp;
+  }
+
+private:
+  Time m_senderTimestamp;
+
+};
+
+} //namespace ns3
+
+#endif /* X2_TAG_H */
diff -Naru a/model/eps-bearer.cc b/model/eps-bearer.cc
--- a/model/eps-bearer.cc	2017-10-05 11:46:52.086493515 +0200
+++ b/model/eps-bearer.cc	2017-10-05 11:47:22.298601725 +0200
@@ -67,6 +67,7 @@
     case GBR_CONV_VIDEO:
     case GBR_GAMING:
     case GBR_NON_CONV_VIDEO:
+    case GBR_ULTRA_LOW_LAT:
       return true;
     case NGBR_IMS:
     case NGBR_VIDEO_TCP_OPERATOR:
@@ -102,8 +103,8 @@
       return 7;
     case NGBR_VIDEO_TCP_PREMIUM:
       return 8;
-    case NGBR_VIDEO_TCP_DEFAULT:
-      return 9;
+    case GBR_ULTRA_LOW_LAT:
+      return 1;
     default:
       NS_FATAL_ERROR ("unknown QCI value " << qci);
       return 0;
@@ -134,6 +135,8 @@
       return 300;
     case NGBR_VIDEO_TCP_DEFAULT:
       return 300;
+    case GBR_ULTRA_LOW_LAT:
+      return 1;
     default:
       NS_FATAL_ERROR ("unknown QCI value " << qci);
       return 0;
@@ -164,6 +167,8 @@
       return 1.0e-6;
     case NGBR_VIDEO_TCP_DEFAULT:
       return 1.0e-6;
+    case GBR_ULTRA_LOW_LAT:
+    	return 1.0e-6;
     default:
       NS_FATAL_ERROR ("unknown QCI value " << qci);
       return 0;
diff -Naru a/model/eps-bearer.h b/model/eps-bearer.h
--- a/model/eps-bearer.h	2017-10-05 11:46:52.086493515 +0200
+++ b/model/eps-bearer.h	2017-10-05 11:47:22.298601725 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -23,7 +27,7 @@
 #define EPS_BEARER
 
 #include <ns3/uinteger.h>
-
+ 
 namespace ns3 {
 
 /**
@@ -33,7 +37,7 @@
 struct GbrQosInformation
 {
   /** 
-   * Default constructor, initializes member variables to zero or equivalent
+   * Default constructor, inizializes member variables to zero or equivalent
    */
   GbrQosInformation ();
 
@@ -51,12 +55,12 @@
 struct AllocationRetentionPriority
 {
   /** 
-   * Default constructor, initializes member variables to zero or equivalent
+   * Default constructor, inizializes member variables to zero or equivalent
    */
   AllocationRetentionPriority ();
-  uint8_t priorityLevel;     ///< 1-15; 1 = highest
-  bool preemptionCapability; ///< true if bearer can preempt others
-  bool preemptionVulnerability; ///< true if bearer can be preempted by others
+  uint8_t priorityLevel;     // /< 1-15; 1 = highest
+  bool preemptionCapability; // /< true if bearer can preempt others
+  bool preemptionVulnerability; // true if bearer can be preempted by others
 };
 
 /**
@@ -85,13 +89,14 @@
     NGBR_VOICE_VIDEO_GAMING = 7,
     NGBR_VIDEO_TCP_PREMIUM  = 8,
     NGBR_VIDEO_TCP_DEFAULT  = 9,
-  } qci; ///< Qos class indicator
+		GBR_ULTRA_LOW_LAT				= 99,
+  } qci;
 
-  GbrQosInformation gbrQosInfo; ///< GBR QOS information
-  AllocationRetentionPriority arp; ///< allocation retention priority
+  GbrQosInformation gbrQosInfo;
+  AllocationRetentionPriority arp;
 
   /**
-   * Default constructor. QCI will be initialized to NGBR_VIDEO_TCP_DEFAULT
+   * Deault constructor. QCI will be initialized to NGBR_VIDEO_TCP_DEFAULT
    * 
    */
   EpsBearer ();
@@ -103,12 +108,6 @@
    */
   EpsBearer (Qci x);
 
-  /**
-   *
-   * @param x the QoS Class Indicator
-   * @param y the GbrQosInformation
-   *
-   */
   EpsBearer (Qci x, GbrQosInformation y);
 
   /**
diff -Naru a/model/lte-as-sap.h b/model/lte-as-sap.h
--- a/model/lte-as-sap.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-as-sap.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -25,6 +29,7 @@
 #include <stdint.h>
 #include <ns3/ptr.h>
 #include <ns3/packet.h>
+#include <ns3/lte-rrc-sap.h>
 
 namespace ns3 {
 
@@ -56,7 +61,7 @@
    *
    * \param dlEarfcn the downlink carrier frequency (EARFCN)
    */
-  virtual void StartCellSelection (uint32_t dlEarfcn) = 0;
+  virtual void StartCellSelection (uint16_t dlEarfcn) = 0;
 
   /** 
    * \brief Force the RRC entity to stay camped on a certain eNodeB.
@@ -64,7 +69,7 @@
    * \param cellId the cell ID identifying the eNodeB
    * \param dlEarfcn the downlink carrier frequency (EARFCN)
    */
-  virtual void ForceCampedOnEnb (uint16_t cellId, uint32_t dlEarfcn) = 0;
+  virtual void ForceCampedOnEnb (uint16_t cellId, uint16_t dlEarfcn) = 0;
 
   /**
    * \brief Tell the RRC entity to enter Connected mode.
@@ -91,6 +96,19 @@
    */
   virtual void Disconnect () = 0;
 
+  /** 
+   * \brief Tell the RRC that a secondary cell was connected
+   *
+   */
+  virtual void NotifySecondaryCellConnected (uint16_t rnti, uint16_t mmWaveCellId) = 0;
+
+  /** 
+   * \brief Tell the LTE RRC in the UE that a secondary cell handover was performed,
+   * and trigger the RLC instances update
+   *
+   */
+  virtual void NotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) = 0;
+
 };
 
 
@@ -111,7 +129,17 @@
    * \brief Notify the NAS that RRC Connection Establishment was successful.
    * 
    */
-  virtual void NotifyConnectionSuccessful () = 0;
+  virtual void NotifyConnectionSuccessful (uint16_t rnti) = 0;
+
+  virtual void NotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId) = 0;
+
+  virtual void NotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) = 0;
+
+  /** 
+   * \brief Notify the NAS that LTE RRC received an indication to connect to a MmWave eNB
+   * 
+   */
+  virtual void NotifyConnectToMmWave (uint16_t mmWaveCellId) = 0;
 
   /** 
    * \brief Notify the NAS that RRC Connection Establishment failed.
@@ -147,24 +175,21 @@
 class MemberLteAsSapProvider : public LteAsSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteAsSapProvider (C* owner);
 
   // inherited from LteAsSapProvider
   virtual void SetCsgWhiteList (uint32_t csgId);
-  virtual void StartCellSelection (uint32_t dlEarfcn);
-  virtual void ForceCampedOnEnb (uint16_t cellId, uint32_t dlEarfcn);
+  virtual void StartCellSelection (uint16_t dlEarfcn);
+  virtual void ForceCampedOnEnb (uint16_t cellId, uint16_t dlEarfcn);
   virtual void Connect (void);
   virtual void SendData (Ptr<Packet> packet, uint8_t bid);
   virtual void Disconnect ();
+  virtual void NotifySecondaryCellConnected (uint16_t rnti, uint16_t mmWaveCellId);
+  virtual void NotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated);
 
 private:
   MemberLteAsSapProvider ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -187,14 +212,14 @@
 
 template <class C>
 void
-MemberLteAsSapProvider<C>::StartCellSelection (uint32_t dlEarfcn)
+MemberLteAsSapProvider<C>::StartCellSelection (uint16_t dlEarfcn)
 {
   m_owner->DoStartCellSelection (dlEarfcn);
 }
 
 template <class C>
 void
-MemberLteAsSapProvider<C>::ForceCampedOnEnb (uint16_t cellId, uint32_t dlEarfcn)
+MemberLteAsSapProvider<C>::ForceCampedOnEnb (uint16_t cellId, uint16_t dlEarfcn)
 {
   m_owner->DoForceCampedOnEnb (cellId, dlEarfcn);
 }
@@ -220,6 +245,20 @@
   m_owner->DoDisconnect ();
 }
 
+template <class C>
+void 
+MemberLteAsSapProvider<C>::NotifySecondaryCellConnected (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoNotifySecondaryCellConnected (rnti, mmWaveCellId);
+}
+
+template <class C>
+void 
+MemberLteAsSapProvider<C>::NotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated)
+{
+  m_owner->DoNotifySecondaryCellHandover (oldRnti, newRnti, mmWaveCellId, radioResourceConfigDedicated);
+}
+
 
 /**
  * Template for the implementation of the LteAsSapUser as a member
@@ -230,22 +269,20 @@
 class MemberLteAsSapUser : public LteAsSapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteAsSapUser (C* owner);
 
   // inherited from LteAsSapUser
-  virtual void NotifyConnectionSuccessful ();
+  virtual void NotifyConnectionSuccessful (uint16_t rnti);
+  virtual void NotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId);
+  virtual void NotifyConnectToMmWave (uint16_t mmWaveCellId);
   virtual void NotifyConnectionFailed ();
   virtual void RecvData (Ptr<Packet> packet);
   virtual void NotifyConnectionReleased ();
+  virtual void NotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated);
 
 private:
   MemberLteAsSapUser ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -261,9 +298,23 @@
 
 template <class C>
 void 
-MemberLteAsSapUser<C>::NotifyConnectionSuccessful ()
+MemberLteAsSapUser<C>::NotifyConnectionSuccessful (uint16_t rnti)
 {
-  m_owner->DoNotifyConnectionSuccessful ();
+  m_owner->DoNotifyConnectionSuccessful (rnti);
+}
+
+template <class C>
+void 
+MemberLteAsSapUser<C>::NotifyHandoverSuccessful (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoNotifyHandoverSuccessful (rnti, mmWaveCellId);
+}
+
+template <class C>
+void 
+MemberLteAsSapUser<C>::NotifyConnectToMmWave (uint16_t mmWaveCellId)
+{
+  m_owner->DoNotifyConnectToMmWave (mmWaveCellId);
 }
 
 template <class C>
@@ -288,6 +339,13 @@
 }
 
 
+template <class C>
+void 
+MemberLteAsSapUser<C>::NotifySecondaryCellHandoverStarted (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated)
+{
+  m_owner->DoNotifySecondaryCellHandoverStarted (oldRnti, newRnti, mmWaveCellId, radioResourceConfigDedicated);
+}
+
 } // namespace ns3
 
 #endif // LTE_AS_SAP_H
diff -Naru a/model/lte-ccm-mac-sap.cc b/model/lte-ccm-mac-sap.cc
--- a/model/lte-ccm-mac-sap.cc	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-ccm-mac-sap.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#include "lte-ccm-mac-sap.h"
-
-namespace ns3 {
-
-
-LteCcmMacSapProvider::~LteCcmMacSapProvider ()
-{
-}
-
-
-LteCcmMacSapUser::~LteCcmMacSapUser ()
-{
-}
-
-
-} // end of namespace ns3
diff -Naru a/model/lte-ccm-mac-sap.h b/model/lte-ccm-mac-sap.h
--- a/model/lte-ccm-mac-sap.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-ccm-mac-sap.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,187 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#ifndef LTE_CCM_MAC_SAP_H
-#define LTE_CCM_MAC_SAP_H
-
-#include <ns3/lte-rrc-sap.h>
-#include <ns3/eps-bearer.h>
-#include <ns3/lte-enb-cmac-sap.h>
-#include <ns3/lte-mac-sap.h>
-#include <ns3/ff-mac-common.h>
-
-
-namespace ns3 {
-/**
- * \ingroup lte
- *
- * \brief Service Access Point (SAP) offered by the component carrier manager (CCM) 
- *  by MAC to CCM.
- *
- * This is the *Component Carrier Manager SAP Provider*, i.e., the part of the SAP
- * that contains the MAC methods called by the eNodeB CCM
- * instance.
- */
-class LteCcmMacSapProvider
-{
- 
-public:
-  virtual ~LteCcmMacSapProvider ();
-
-  /**
-   * \brief Add the Buffer Status Report to the list.
-   * \param bsr LteEnbComponentCarrierManager used this function to
-   *  send back an uplink BSR to some of the MAC instances
-   */
-  virtual void ReportMacCeToScheduler (MacCeListElement_s bsr) = 0;
-
-}; // end of class LteCcmMacSapProvider
-
-
-/**
- * \ingroup lte
- *
- * \brief Service Access Point (SAP) offered by MAC to the 
- *        component carrier manager (CCM).
- *  
- *
- * This is the *CCM MAC SAP User*, i.e., the part of the SAP
- * that contains the component carrier manager methods called 
- * by the eNodeB MAC instance.
- */
-class LteCcmMacSapUser : public LteMacSapUser
-{
-public:
-  virtual ~LteCcmMacSapUser ();
-  /**
-   * \brief When the Primary Component carrier receive a buffer status report 
-   *  it is sent to the CCM.
-   * \param bsr Buffer Status Report received from a Ue
-   * \param componentCarrierId
-   */
-  virtual void UlReceiveMacCe (MacCeListElement_s bsr, uint8_t componentCarrierId) = 0;
-
-  /**
-   * \brief Notifies component carrier manager about physical resource block occupancy
-   * \param prbOccupancy The physical resource block occupancy
-   * \param componentCarrierId The component carrier id
-   */
-  virtual void NotifyPrbOccupancy (double prbOccupancy, uint8_t componentCarrierId) = 0;
-
-}; // end of class LteCcmMacSapUser
-
-/// MemberLteCcmMacSapProvider class
-template <class C>
-class MemberLteCcmMacSapProvider : public LteCcmMacSapProvider
-{
-public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
-  MemberLteCcmMacSapProvider (C* owner);
-  // inherited from LteCcmRrcSapProvider
-  virtual void ReportMacCeToScheduler (MacCeListElement_s bsr);
-
-private:
-  C* m_owner; ///< the owner class
-};
-
-template <class C>
-MemberLteCcmMacSapProvider<C>::MemberLteCcmMacSapProvider (C* owner)
-  : m_owner (owner)
-{
-}
- 
-template <class C>
-void MemberLteCcmMacSapProvider<C>::ReportMacCeToScheduler (MacCeListElement_s bsr)
-{
-  m_owner->DoReportMacCeToScheduler (bsr);
-}
-
-
-/// MemberLteCcmMacSapUser class
-template <class C>
-class MemberLteCcmMacSapUser : public LteCcmMacSapUser
-{
-public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
-  MemberLteCcmMacSapUser (C* owner);
-  // inherited from LteCcmRrcSapUser
-  virtual void UlReceiveMacCe (MacCeListElement_s bsr, uint8_t componentCarrierId);
-  virtual void NotifyPrbOccupancy (double prbOccupancy, uint8_t componentCarrierId);
-  // inherited from LteMacSapUser
-  virtual void NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
-  virtual void ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
-  virtual void NotifyHarqDeliveryFailure ();
-
-
-private:
-  C* m_owner; ///< the owner class
-};
-
-template <class C>
-MemberLteCcmMacSapUser<C>::MemberLteCcmMacSapUser (C* owner)
-  : m_owner (owner)
-{
-}
-
-template <class C>
-void MemberLteCcmMacSapUser<C>::UlReceiveMacCe (MacCeListElement_s bsr, uint8_t componentCarrierId)
-{
-  m_owner->DoUlReceiveMacCe (bsr, componentCarrierId);
-}
-
-template <class C>
-void MemberLteCcmMacSapUser<C>::NotifyPrbOccupancy (double prbOccupancy, uint8_t componentCarrierId)
-{
-  m_owner->DoNotifyPrbOccupancy (prbOccupancy, componentCarrierId);
-}
-
-template <class C>
-void MemberLteCcmMacSapUser<C>::NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
-{
-  m_owner->DoNotifyTxOpportunity (bytes, layer, harqId, componentCarrierId, rnti, lcid);
-}
-
-template <class C>
-void MemberLteCcmMacSapUser<C>::ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
-{
-  m_owner->DoReceivePdu (p, rnti, lcid);
-}
-
-template <class C>
-void MemberLteCcmMacSapUser<C>::NotifyHarqDeliveryFailure ()
-{
-  m_owner->DoNotifyHarqDeliveryFailure ();
-}
-
-  
-} // end of namespace ns3
-
-
-#endif /* LTE_CCM_MAC_SAP_H */
-
diff -Naru a/model/lte-ccm-rrc-sap.cc b/model/lte-ccm-rrc-sap.cc
--- a/model/lte-ccm-rrc-sap.cc	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-ccm-rrc-sap.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#include "lte-ccm-rrc-sap.h"
-
-namespace ns3 {
-
-
-LteCcmRrcSapProvider::~LteCcmRrcSapProvider ()
-{
-}
-
-
-LteCcmRrcSapUser::~LteCcmRrcSapUser ()
-{
-}
-
-
-} // end of namespace ns3
diff -Naru a/model/lte-ccm-rrc-sap.h b/model/lte-ccm-rrc-sap.h
--- a/model/lte-ccm-rrc-sap.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-ccm-rrc-sap.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,360 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#ifndef LTE_CCM_RRC_SAP_H
-#define LTE_CCM_RRC_SAP_H
-
-#include <ns3/lte-rrc-sap.h>
-#include <ns3/eps-bearer.h>
-#include <ns3/lte-enb-cmac-sap.h>
-#include <ns3/lte-mac-sap.h>
-#include <map>
-
-
-namespace ns3 {
-  class LteUeCmacSapProvider;
-  class UeManager;
-  class LteEnbCmacSapProvider;
-  class LteMacSapUser;
-  class LteRrcSap;
-
-/**
- * \brief Service Access Point (SAP) offered by the Component Carrier Manager (CCM)
- * instance to the eNodeB RRC instance.
- *
- * This is the *Component Carrier Manager SAP Provider*, i.e., the part of the SAP
- * that contains the CCM methods called by the eNodeB RRC instance.
- */
-class LteCcmRrcSapProvider
-{
-
-/// allow UeManager class friend access
-friend class UeManager;
-/// allow LteMacSapUser class friend access
-friend class LteMacSapUser;
- 
-public:
-  
-  virtual ~LteCcmRrcSapProvider ();
-  
-  /// LcsConfig sructure
-  struct LcsConfig
-  {
-    uint16_t componentCarrierId; ///< component carrier ID
-    LteEnbCmacSapProvider::LcInfo lc; ///< LC info
-    LteMacSapUser *msu; ///< MSU
-  };
-
-  /**
-   * \brief Reports UE measurements to the component carrier manager.
-   * \param rnti Radio Network Temporary Identity, an integer identifying 
-   * the UE where the measurement report originates from.
-   * \param measResults a single report of one measurement identity
-   *
-   * The received measurement report is a result of the UE measurements configuration
-   * previously configured by calling LteCcmRrcSapProvider::AddUeMeasReportConfigForComponentCarrier.
-   * The report may be stored and utilized for the purpose of making decision if and when
-   * to use the secondary carriers.
-   */
-  virtual void ReportUeMeas (uint16_t rnti, LteRrcSap::MeasResults measResults) = 0;
-
-  /**
-   * \brief Add a new UE in the LteEnbComponentCarrierManager.
-   * \param rnti Radio Network Temporary Identity, an integer identifying the UE.
-   * \param state The current rrc state of the UE.
-   */
-  virtual void AddUe (uint16_t rnti, uint8_t state) = 0;
-
-  /**
-   * \brief Add a new logical channel.
-   * \param lcInfo - information about newly created logical channel
-   * \param msu - pointer to corresponding rlc interface
-   *
-   */
-  virtual void AddLc (LteEnbCmacSapProvider::LcInfo lcInfo, LteMacSapUser* msu) = 0;
-
-  /**
-   * \brief Remove an existing UE.
-   * \param rnti Radio Network Temporary Identity, an integer identifying the UE
-   *             where the report originates from
-   */
-  virtual void RemoveUe (uint16_t rnti) = 0;
-
-  /**
-   * \brief Add a new Bearer for the Ue in the LteEnbComponentCarrierManager.
-   * \param bearer a pointer to the EpsBearer object
-   * \param bearerId a unique identifier for the bearer
-   * \param rnti Radio Network Temporary Identity, an integer identifying the UE
-   *             where the report originates from
-   * \param lcid the Logical Channel id
-   * \param lcGroup the Logical Channel group
-   * \param msu a pointer to the LteMacSapUser, the LteEnbComponentCarrierManager
-   *             has to store a LteMacSapUser for each Rlc istance, in order to 
-   *             properly redirect the packet
-   * \return vector of LcsConfig contains the lc configuration for each Mac
-   *                the size of the vector is equal to the number of component
-   *                carrier enabled.
-   *
-   * The Logical Channel configurations for each component carrier depend on the 
-   * algorithm used to split the traffic between the component carriers themself.
-   */  
-  virtual std::vector<LteCcmRrcSapProvider::LcsConfig> SetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, LteMacSapUser *msu) = 0;
-
-   /**
-   * \brief Release an existing Data Radio Bearer for a Ue in the LteEnbComponentCarrierManager
-   * \param rnti Radio Network Temporary Identity, an integer identifying the UE
-   *             where the report originates from
-   * \param lcid the Logical Channel Id
-   * \return vector of integer the componentCarrierId of the componentCarrier
-   *                where the bearer is enabled
-   */
-
-  virtual std::vector<uint8_t> ReleaseDataRadioBearer (uint16_t rnti, uint8_t lcid) = 0;
-
-  /**
-   * \brief Add the Signal Bearer for a specif Ue in LteEnbComponenCarrierManager
-   * \param lcInfo this structure it is hard-coded in the LteEnbRrc
-   * \param rlcMacSapUser it is the MacSapUser of the Rlc istance
-   * \return the LteMacSapUser of the ComponentCarrierManager
-   *
-   */
-  virtual LteMacSapUser* ConfigureSignalBearer(LteEnbCmacSapProvider::LcInfo lcInfo,  LteMacSapUser* rlcMacSapUser) = 0;
-
-}; // end of class LteCcmRrcSapProvider
-
-
-/**
- * \brief Service Access Point (SAP) offered by the eNodeB RRC instance to the
- *        component carrier manager (CCM) instance.
- *
- * This is the *Component Carrier Management SAP User*, i.e., the part of the SAP that
- * contains the eNodeB RRC methods called by the CCM.
- */
-class LteCcmRrcSapUser
-{
-  /// allow LteEnbRrc class friend access
-  friend class LteEnbRrc;
-public:
-  virtual ~LteCcmRrcSapUser ();
-
-  /**
-   * \brief Request a certain reporting configuration to be fulfilled by the UEs
-   *        attached to the eNodeB entity.
-   * \param reportConfig the UE measurement reporting configuration
-   * \return the measurement identity associated with this newly added
-   *         reporting configuration
-   *
-   * The eNodeB RRC entity is expected to configure the same reporting
-   * configuration in each of the attached UEs. When later in the simulation a
-   * UE measurement report is received from a UE as a result of this
-   * configuration, the eNodeB RRC entity shall forward this report to the
-   * ComponentCarrier algorithm through the LteCcmRrcSapProvider::ReportUeMeas
-   * SAP function.
-   *
-   * \note This function is only valid before the simulation begins.
-   */
-  virtual uint8_t AddUeMeasReportConfigForComponentCarrier (LteRrcSap::ReportConfigEutra reportConfig) = 0;
-
-  /**
-   * \brief Instruct the eNodeB RRC entity to prepare a component carrier.
-   * \param rnti Radio Network Temporary Identity, an integer identifying the
-   *             UE which shall perform the ComponentCarrier
-   * \param targetCellId the cell ID of the target eNodeB
-   *
-   * This function is used by the ComponentCarrier manager when a decision on 
-   * component carriers configurations.
-   *
-   * The process to produce the decision is up to the implementation of ComponentCarrier
-   * algorithm. It is typically based on the reported UE measurements, which are
-   * received through the LteCcmRrcSapProvider::ReportUeMeas function.
-   */
-  virtual void TriggerComponentCarrier (uint16_t rnti, uint16_t targetCellId) = 0;
-
-  /** 
-   * add a new Logical Channel (LC) 
-   * 
-   * \param lcConfig is a single structure contains logical Channel Id, Logical Channel config and Component Carrier Id
-   */
-  virtual void AddLcs (std::vector<LteEnbRrcSapProvider::LogicalChannelConfig> lcConfig) = 0;
-
-  /** 
-   * remove an existing LC
-   * 
-   * \param rnti 
-   * \param lcid
-   */
-  virtual void ReleaseLcs (uint16_t rnti, uint8_t lcid) = 0;
-
-  /**
-   * Get UE manager by RNTI
-   *
-   * \param rnti RNTI
-   * \return UE manager
-   */
-  virtual Ptr<UeManager> GetUeManager (uint16_t rnti) = 0;
-
-}; // end of class LteCcmRrcSapUser
-
-/// MemberLteCcmRrcSapProvider class
-template <class C>
-class MemberLteCcmRrcSapProvider : public LteCcmRrcSapProvider
-{
-public:
-  /**
-   * Constructor
-   * 
-   * \param owner the owner class
-   */
-  MemberLteCcmRrcSapProvider (C* owner);
-
-  // inherited from LteCcmRrcSapProvider
-  virtual void ReportUeMeas (uint16_t rnti, LteRrcSap::MeasResults measResults);
-  virtual void AddUe (uint16_t rnti, uint8_t state);
-  virtual void AddLc (LteEnbCmacSapProvider::LcInfo lcInfo, LteMacSapUser* msu);
-  virtual void RemoveUe (uint16_t rnti);
-  virtual std::vector<LteCcmRrcSapProvider::LcsConfig> SetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, LteMacSapUser *msu);
-  virtual std::vector<uint8_t> ReleaseDataRadioBearer (uint16_t rnti, uint8_t lcid);
-  virtual LteMacSapUser* ConfigureSignalBearer(LteEnbCmacSapProvider::LcInfo lcInfo,  LteMacSapUser* rlcMacSapUser);
-
-private:
-  C* m_owner; ///< the owner class
-};
-
-template <class C>
-MemberLteCcmRrcSapProvider<C>::MemberLteCcmRrcSapProvider (C* owner)
-  : m_owner (owner)
-{
-}
-
-template <class C>
-void MemberLteCcmRrcSapProvider<C>::ReportUeMeas (uint16_t rnti, LteRrcSap::MeasResults measResults)
-{
-  m_owner->DoReportUeMeas (rnti, measResults);
-}
-
-template <class C>
-void MemberLteCcmRrcSapProvider<C>::AddUe (uint16_t rnti, uint8_t state)
-{
-  m_owner->DoAddUe (rnti, state);
-}
-
-template <class C>
-void MemberLteCcmRrcSapProvider<C>::AddLc (LteEnbCmacSapProvider::LcInfo lcInfo, LteMacSapUser* msu)
-{
-  m_owner->DoAddLc (lcInfo, msu);
-}
-
-template <class C>
-void MemberLteCcmRrcSapProvider<C>::RemoveUe (uint16_t rnti)
-{
-  m_owner->DoRemoveUe (rnti);
-}
-
-template <class C>
-std::vector<LteCcmRrcSapProvider::LcsConfig> MemberLteCcmRrcSapProvider<C>::SetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, LteMacSapUser *msu)
-{
-  return m_owner->DoSetupDataRadioBearer (bearer, bearerId, rnti, lcid, lcGroup, msu);
-}
-
-template <class C>
-std::vector<uint8_t> MemberLteCcmRrcSapProvider<C>::ReleaseDataRadioBearer (uint16_t rnti, uint8_t lcid)
-{
-  return m_owner->DoReleaseDataRadioBearer (rnti, lcid);
-}
-
-template <class C>
-LteMacSapUser* MemberLteCcmRrcSapProvider<C>::ConfigureSignalBearer(LteEnbCmacSapProvider::LcInfo lcInfo,  LteMacSapUser* rlcMacSapUser)
-{
-  return m_owner->DoConfigureSignalBearer (lcInfo, rlcMacSapUser);
-}
-
-
-/// MemberLteCcmRrcSapUser class
-template <class C>
-class MemberLteCcmRrcSapUser : public LteCcmRrcSapUser
-{
-public:
-  /**
-   * Constructor
-   * 
-   * \param owner the owner class
-   */
-  MemberLteCcmRrcSapUser (C* owner);
-
-  // inherited from LteCcmRrcSapUser
-  virtual void AddLcs (std::vector<LteEnbRrcSapProvider::LogicalChannelConfig> lcConfig);
-  virtual void ReleaseLcs (uint16_t rnti, uint8_t lcid);
-  virtual uint8_t AddUeMeasReportConfigForComponentCarrier (LteRrcSap::ReportConfigEutra reportConfig);
-  virtual void TriggerComponentCarrier (uint16_t rnti, uint16_t targetCellId);
-  virtual Ptr<UeManager> GetUeManager (uint16_t rnti);
-
-private:
-  C* m_owner; ///< the owner class
-};
-
-template <class C>
-MemberLteCcmRrcSapUser<C>::MemberLteCcmRrcSapUser (C* owner)
-  : m_owner (owner)
-{
-}
-
-template <class C>
-void MemberLteCcmRrcSapUser<C>::AddLcs (std::vector<LteEnbRrcSapProvider::LogicalChannelConfig> lcConfig)
-{
-  NS_FATAL_ERROR ("Function should not be called because it is not implemented.");
-  //m_owner->DoAddLcs (lcConfig);
-}
-
-template <class C>
-void MemberLteCcmRrcSapUser<C>::ReleaseLcs (uint16_t rnti, uint8_t lcid)
-{
-  NS_FATAL_ERROR ("Function should not be called because it is not implemented.");
-  //m_owner->DoReleaseLcs (rnti, lcid);
-
-}
-
-template <class C>
-uint8_t
-MemberLteCcmRrcSapUser<C>::AddUeMeasReportConfigForComponentCarrier (LteRrcSap::ReportConfigEutra reportConfig)
-{
-  return m_owner->DoAddUeMeasReportConfigForComponentCarrier (reportConfig);
-}
-
-
-template <class C>
-void
-MemberLteCcmRrcSapUser<C>::TriggerComponentCarrier (uint16_t rnti, uint16_t targetCellId)
-{
-  NS_FATAL_ERROR ("Function should not be called because it is not implemented.");
-}
-
-template <class C>
-Ptr<UeManager>
-MemberLteCcmRrcSapUser<C>::GetUeManager (uint16_t rnti)
-{
-  return m_owner->GetUeManager (rnti);
-}
-
-} // end of namespace ns3
-
-
-#endif /* LTE_CCM_RRC_SAP_H */
-
diff -Naru a/model/lte-common.h b/model/lte-common.h
--- a/model/lte-common.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-common.h	2017-10-05 11:47:22.310601768 +0200
@@ -195,7 +195,6 @@
   uint16_t m_size;    ///< Size of transport block
   uint8_t  m_rv;      ///< the redundancy version (HARQ)
   uint8_t  m_ndi;     ///< new data indicator flag
-  uint8_t  m_ccId;    ///< component carrier id
   
   /**
    *  TracedCallback signature.
diff -Naru a/model/lte-enb-cmac-sap.h b/model/lte-enb-cmac-sap.h
--- a/model/lte-enb-cmac-sap.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-cmac-sap.h	2017-10-05 11:47:22.310601768 +0200
@@ -51,11 +51,7 @@
   virtual void ConfigureMac (uint8_t ulBandwidth,
                              uint8_t dlBandwidth) = 0;
 
-  /**
-   * Add UE function
-   *
-   * \param rnti 
-   */
+
   virtual void AddUe (uint16_t rnti) = 0;
 
   /** 
@@ -136,9 +132,9 @@
    */
   struct RachConfig
   {
-    uint8_t numberOfRaPreambles; ///< number of RA preambles
-    uint8_t preambleTransMax; ///< preamble transmit maximum
-    uint8_t raResponseWindowSize; ///< RA response window size
+    uint8_t numberOfRaPreambles;
+    uint8_t preambleTransMax;
+    uint8_t raResponseWindowSize;
   };
 
   /** 
@@ -148,14 +144,14 @@
   virtual RachConfig GetRachConfig () = 0;
 
   /**
-   * \brief AllocateNcRaPreambleReturnValue structure
+   * 
    * 
    */
   struct AllocateNcRaPreambleReturnValue
   {
     bool valid; ///< true if a valid RA config was allocated, false otherwise
     uint8_t raPreambleId; ///< random access preamble id
-    uint8_t raPrachMaskIndex; ///< PRACH mask index
+    uint8_t raPrachMaskIndex; /// PRACH mask index
   };
 
   /** 
diff -Naru a/model/lte-enb-component-carrier-manager.cc b/model/lte-enb-component-carrier-manager.cc
--- a/model/lte-enb-component-carrier-manager.cc	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-component-carrier-manager.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#include "lte-enb-component-carrier-manager.h"
-#include <ns3/log.h>
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("LteEnbComponentCarrierManager");
-NS_OBJECT_ENSURE_REGISTERED (LteEnbComponentCarrierManager);
-
-
-LteEnbComponentCarrierManager::LteEnbComponentCarrierManager ()
-{
-
-}
-
-LteEnbComponentCarrierManager::~LteEnbComponentCarrierManager ()
-{
-}
-
-TypeId
-LteEnbComponentCarrierManager::GetTypeId ()
-{
-  static TypeId tid = TypeId ("ns3::LteEnbComponentCarrierManager")
-    .SetParent<Object> ()
-    .SetGroupName("Lte")
-  ;
-  return tid;
-}
-
-void
-LteEnbComponentCarrierManager::DoDispose ()
-{
-}
-
-void
-LteEnbComponentCarrierManager::SetLteCcmRrcSapUser (LteCcmRrcSapUser* s)
-{
-  NS_LOG_FUNCTION (this << s);
-  m_ccmRrcSapUser = s;
-}
-
-LteCcmRrcSapProvider*
-LteEnbComponentCarrierManager::GetLteCcmRrcSapProvider ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_ccmRrcSapProvider;
-}
-
-LteMacSapProvider*
-LteEnbComponentCarrierManager::GetLteMacSapProvider ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_macSapProvider;
-}
-
-LteCcmMacSapUser*
-LteEnbComponentCarrierManager::GetLteCcmMacSapUser ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_ccmMacSapUser;
-}
-
-bool 
-LteEnbComponentCarrierManager::SetMacSapProvider (uint8_t componentCarrierId, LteMacSapProvider* sap)
-{
-  NS_LOG_FUNCTION (this);
-  bool res = false;
-  std::map <uint8_t, LteMacSapProvider*>::iterator it = m_macSapProvidersMap.find (componentCarrierId);
-  if ((uint16_t) componentCarrierId > m_noOfComponentCarriers)
-    {
-      NS_FATAL_ERROR ("Inconsistent componentCarrierId or you didn't call SetNumberOfComponentCarriers before calling this method");
-    }
-  if (it != m_macSapProvidersMap.end ())
-    {
-      NS_FATAL_ERROR ("Tried to allocated an existing componentCarrierId");
-    }
-  else
-    {
-      m_macSapProvidersMap.insert (std::pair<uint8_t, LteMacSapProvider*>(componentCarrierId, sap));
-      res = true;
-    }
-  return res;
-  
-}
-
-bool 
-LteEnbComponentCarrierManager::SetCcmMacSapProviders (uint8_t componentCarrierId, LteCcmMacSapProvider* sap)
-{
-  NS_LOG_FUNCTION (this);
-  bool res = false;
-  std::map< uint8_t,LteCcmMacSapProvider*>::iterator it =  m_ccmMacSapProviderMap.find (componentCarrierId);
-  
-  if (it == m_ccmMacSapProviderMap.end ())
-    {
-      m_ccmMacSapProviderMap.insert (std::pair <uint8_t,LteCcmMacSapProvider*> (componentCarrierId, sap));
-    }
- 
-  res = true;
-  return res;
-  
-}
-
-void
-LteEnbComponentCarrierManager::SetNumberOfComponentCarriers (uint16_t noOfComponentCarriers)
-{
-  NS_LOG_FUNCTION (this);
-  m_noOfComponentCarriers = noOfComponentCarriers;
-}
-
-void
-LteEnbComponentCarrierManager::SetRrc (const Ptr<LteEnbRrc> rrc)
-{
-  m_rrc = rrc;
-}
-
-} // end of namespace ns3
diff -Naru a/model/lte-enb-component-carrier-manager.h b/model/lte-enb-component-carrier-manager.h
--- a/model/lte-enb-component-carrier-manager.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-component-carrier-manager.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,216 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#ifndef LTE_ENB_COMPONENT_CARRIER_MANAGER_H
-#define LTE_ENB_COMPONENT_CARRIER_MANAGER_H
-
-#include <ns3/object.h>
-#include <ns3/lte-enb-rrc.h>
-#include <ns3/lte-rrc-sap.h>
-#include <ns3/lte-ccm-rrc-sap.h>
-#include <ns3/lte-mac-sap.h>
-#include <ns3/lte-enb-cmac-sap.h>
-#include <ns3/lte-ccm-mac-sap.h>
-#include <map>
-#include <vector>
-
-namespace ns3 {
-
-
-class LteCcmRrcSapUser;
-class LteCcmRrcSapProvider;
-class LteMacSapUser;
-class LteMacSapProvider;
-class LteEnbCmacSapProvider;
-class LteCcmMacSapProvider;
-
-/**
- * \brief The class implements Component Carrier Manager (CCM) that operates
- * using the Component Carrier Manager SAP interfaces.
- *
- * CCM receives measurement reports from an eNode RRC instance and is forwarding
- * calls from RLC to MAC layer, and from MAC to RLC.
- *
- * This class is an abstract class intended to be inherited by subclasses that
- * will implement its virtual methods. The subclasses are compatible with the
- * LteEnbNetDevice class, and are accessible using namespace-based access
- * through ns-3 Config subsystem, and can be installed and configured by
- * LteHelper class.
- *
- * The communication with the eNodeB RRC instance is done through the *Component
- * Carrier Manager SAP* interface. The LteEnbComponentCarrierManager instance
- * corresponds to the "provider" part of this interface, while the eNodeB RRC
- * instance takes the role of the "user" part. The following code skeleton
- * establishes the connection between both instances:
- *
- * Ptr<LteEnbRrc> rrc = ...;
- * Ptr<LteComponentCarrierManager> ccmEnb = ...;
- * rrc->SetLteCcmRrcSapProvider (ccmEnb->GetLteCcmRrcSapProvider ());
- * ccmEnb->SetLteCcmRrcSapUser (rrc->GetLteCcmRrcSapUser ())
- *
- * Similarly, LteEnbComponentCarrierManager instance communicates with MAC, and
- * it takes the role of the "user".
- *
- * However, user rarely needs to use the above code, since it has already been
- * taken care by LteHelper::InstallEnbDevice.
- *
- * \sa LteCcmRrcSapUser, LteCcmRrcSapProvider, LteCcmMacSapUser, LteCcmMacSapProvider
- */
-
-class LteEnbComponentCarrierManager : public Object
-{
-public:
-
-  LteEnbComponentCarrierManager ();
-  virtual ~LteEnbComponentCarrierManager ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId ();
-
-  /**
-   * \brief Set the "user" part of the ComponentCarrier Management SAP interface that
-   *        this ComponentCarrier algorithm instance will interact with.
-   * \param s a reference to the "user" part of the interface, typically a
-   *          member of an LteEnbRrc instance
-   */
-  virtual void SetLteCcmRrcSapUser (LteCcmRrcSapUser* s);
-
-  /**
-   * \brief Export the "provider" part of the ComponentCarrier Management SAP interface.
-   * \return the reference to the "provider" part of the interface, typically to
-   *         be kept by an LteEnbRlc instance
-   */
-  virtual LteCcmRrcSapProvider* GetLteCcmRrcSapProvider ();
-
-  /**
-   * \brief This function returns a pointer to the LteCcmMacSapUser interface, which
-   * is used by MAC to communicate to CCM when e.g. UL buffer status report is
-   * received, or to notify CCM about PRB occupancy, and similar. Functions that are
-   * specific for the communication between MAC and CCM.
-   *
-   * \returns LteCcmMacSapUser* 
-   */
-  virtual LteCcmMacSapUser* GetLteCcmMacSapUser ();
-
-  /**
-   * \brief Returns the pointer to the LteMacSapProvider interface, the
-   * provider of MAC, which is this new architecture served by
-   * LteEnbComponentCarrierManager object which will behave as a
-   * proxy, and will forward calls between to MAC objects of
-   * component carriers based on the logic implemented in the
-   * specific component carrier manager.
-   *
-   * \returns LteMacSapProvider* 
-   */
-  virtual LteMacSapProvider* GetLteMacSapProvider ();
-
-  /**
-   * \brief Set LteMacSapProvider interface for the MAC object of
-   * the specified component carrier.
-   *
-   * \param componentCarrierId component carrier ID
-   * \param sap the MAC SAP provider
-   * \returns true if successful
-   */
-  virtual bool SetMacSapProvider (uint8_t componentCarrierId, LteMacSapProvider* sap);
-
-  /**
-   * \brief Set LteCcmMacSapProvider interface for the MAC object of
-   * the specified component carrier. Through this interface CCM communicates with
-   * MAC, e.g. it notifies MAC of the specific carrier when to scheduler UL BSR.
-   *
-   * \param componentCarrierId component carrier ID
-   * \param sap the MAC SAP provider
-   * \returns true if successful
-   */
-  virtual bool SetCcmMacSapProviders (uint8_t componentCarrierId, LteCcmMacSapProvider* sap);
-
-  /**
-   * \brief Sets the total number of component carriers.
-   * \param noOfComponentCarriers number of component carriers
-   */
-  virtual void SetNumberOfComponentCarriers (uint16_t noOfComponentCarriers);
-
-  /**
-   * \brief Sets a pointer to eNodeB RRC instance
-   * \param rrc the RRC
-   */
-  virtual void SetRrc (const Ptr<LteEnbRrc> rrc);
-
-protected:
-
-  // inherited from Object
-  virtual void DoDispose ();
-
-  /**
-   * \brief Implementation of ReportUeMeas.
-   * \param rnti Radio Network Temporary Identity, an integer identifying the UE
-   *             where the report originates from
-   * \param measResults a single report of one measurement identity
-   */
-  virtual void DoReportUeMeas (uint16_t rnti, LteRrcSap::MeasResults measResults) = 0;
-
-  std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> > m_ueAttached;//!< The map that contains the rnti, lcid, SAP of the RLC instance
-  std::map <uint16_t, std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> > m_rlcLcInstantiated; //!< This map contains logical channel configuration per flow Id (rnti, lcid).
-  std::map <uint16_t, uint8_t> m_enabledComponentCarrier; //!< This map tells for each RNTI the number of enabled component carriers.
-  std::map <uint16_t, uint8_t> m_ueState; //!< Map of RRC states per UE (rnti, state), e.g. CONNECTED_NORMALLY
-  uint16_t m_noOfComponentCarriers; //!< The number component of carriers that are supported by this eNb.
-  // pointer to RRC object for direct function calls, e.g. when CCM needs to obtain
-  // a pointer to RLC object of a specific flow
-  Ptr<LteEnbRrc> m_rrc; //!< A pointer to the RRC instance of this eNb.
-
-  /*
-   * This interface is used to receive API calls from the RLC instance that through
-   * LteMacSapProvider interface. The component carrier manager acts a proxy. This means that all
-   * RLC instances will see as in previous architecture the LteMacSapProvider interface, but the
-   * actual provider in new architecture will be some of child classes of LteEnbComponentCarrierManager.
-   * So, LteEnbComponentCarrierManager class will receive function calls that are meant for MAC, and
-   * will forward them to the MAC of the component carriers based on the logic implemented
-   * in LteComponentCarrierManager. This attribute will be initialized by using class that implements
-   * LteMacSapProvider interface and class that implements LteEnbComponentCarrierManager base class
-   * e.g.:EnbMacMemberLteMacSapProvider <LteEnbComponentCarrierManagerImpl>
-   */
-  LteMacSapProvider* m_macSapProvider;//!< A pointer to main SAP interface of the MAC instance, which is in this case handled by CCM.
-  // This map is initialized in LteHelper when the Component Carrier Manager is initialized, contains
-  // component carrier id and a pointer to the corresponding LteMacSapProvider interface of the
-  // MAC instance
-  std::map <uint8_t, LteMacSapProvider*> m_macSapProvidersMap; //!< A map of pointers to real SAP interfaces of MAC instances.
-  // This map contains pointers to LteCcmMacSapProvider interfaces of the
-  // MAC instances. LteCcmMacSapProvider is new interface added for the
-  // communication between component carrier manager and MAC instance,
-  // to allow CCM to control UL buffer status reporting, and forwarding to
-  // schedulers. Before adding carrier aggregation to LTE module, MAC was
-  // directly forwarding UL buffer status report to scheduler. Now is this
-  // done through CCM, which decides to which MAC scheduler to forward UL BSR.
-  std::map< uint8_t, LteCcmMacSapProvider*> m_ccmMacSapProviderMap; //!< A map of pointers to the SAP interfaces of CCM instance that provides the  CCM specific functionalities to MAC, i.e. ReportMacCeToScheduler.
-  LteCcmMacSapUser* m_ccmMacSapUser; //!< LteCcmMacSapUser is extended version of LteMacSapUser interface. Contains functions that allow reporting of UL BSR from MAC to CCM.
-  LteCcmRrcSapUser* m_ccmRrcSapUser; //!< A pointer to SAP interface of RRC instance, i.e. to configure measurements reporting for CCM.
-  LteCcmRrcSapProvider* m_ccmRrcSapProvider; //!< A pointer to the SAP interface of the CCM instance to receive API calls from the eNodeB RRC instance.
-
-}; // end of class LteEnbComponentCarrierManager
-
-
-} // end of namespace ns3
-
-
-#endif /* LTE_ENB_COMPONENT_CARRIER_MANAGER_H */
diff -Naru a/model/lte-enb-cphy-sap.h b/model/lte-enb-cphy-sap.h
--- a/model/lte-enb-cphy-sap.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-cphy-sap.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,12 +18,16 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>,
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_ENB_CPHY_SAP_H
 #define LTE_ENB_CPHY_SAP_H
 
 #include <stdint.h>
+#include <map>
 #include <ns3/ptr.h>
 
 #include <ns3/lte-rrc-sap.h>
@@ -63,7 +68,7 @@
    * \param ulEarfcn the UL EARFCN
    * \param dlEarfcn the DL EARFCN
    */
-  virtual void SetEarfcn (uint32_t ulEarfcn, uint32_t dlEarfcn) = 0;
+  virtual void SetEarfcn (uint16_t ulEarfcn, uint16_t dlEarfcn) = 0;
   
   /** 
    * Add a new UE to the cell
@@ -73,7 +78,7 @@
   virtual void AddUe (uint16_t rnti) = 0;
 
   /** 
-   * Remove an UE from the cell
+   * Remove an UE from the the cell
    * 
    * \param rnti the UE id relative to this cell
    */
@@ -134,6 +139,13 @@
    */
   virtual ~LteEnbCphySapUser ();
 
+  struct UeAssociatedSinrInfo
+  {
+    std::map<uint64_t, double> ueImsiSinrMap;
+  };
+
+  virtual void UpdateUeSinrEstimate(LteEnbCphySapUser::UeAssociatedSinrInfo info) = 0;
+
 };
 
 
@@ -146,17 +158,12 @@
 class MemberLteEnbCphySapProvider : public LteEnbCphySapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteEnbCphySapProvider (C* owner);
 
   // inherited from LteEnbCphySapProvider
   virtual void SetCellId (uint16_t cellId);
   virtual void SetBandwidth (uint8_t ulBandwidth, uint8_t dlBandwidth);
-  virtual void SetEarfcn (uint32_t ulEarfcn, uint32_t dlEarfcn);
+  virtual void SetEarfcn (uint16_t ulEarfcn, uint16_t dlEarfcn);
   virtual void AddUe (uint16_t rnti);
   virtual void RemoveUe (uint16_t rnti);
   virtual void SetPa (uint16_t rnti, double pa);
@@ -168,7 +175,7 @@
   
 private:
   MemberLteEnbCphySapProvider ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -199,7 +206,7 @@
 
 template <class C>
 void 
-MemberLteEnbCphySapProvider<C>::SetEarfcn (uint32_t ulEarfcn, uint32_t dlEarfcn)
+MemberLteEnbCphySapProvider<C>::SetEarfcn (uint16_t ulEarfcn, uint16_t dlEarfcn)
 {
   m_owner->DoSetEarfcn (ulEarfcn, dlEarfcn);
 }
@@ -269,18 +276,15 @@
 class MemberLteEnbCphySapUser : public LteEnbCphySapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteEnbCphySapUser (C* owner);
+  virtual void UpdateUeSinrEstimate(UeAssociatedSinrInfo info);
+
 
   // methods inherited from LteEnbCphySapUser go here
 
 private:
   MemberLteEnbCphySapUser ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -294,6 +298,14 @@
 {
 }
 
+template <class C>
+void
+MemberLteEnbCphySapUser<C>::UpdateUeSinrEstimate(UeAssociatedSinrInfo info)
+{
+  return m_owner->DoUpdateUeSinrEstimate(info);
+}
+
+
 
 
 
diff -Naru a/model/lte-enb-mac.cc b/model/lte-enb-mac.cc
--- a/model/lte-enb-mac.cc	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-mac.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,9 +18,9 @@
  *
  * Author: Marco Miozzo <marco.miozzo@cttc.es>
  *         Nicola Baldo  <nbaldo@cttc.es>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -38,7 +39,6 @@
 #include <ns3/lte-ue-phy.h>
 
 #include "ns3/lte-mac-sap.h"
-#include "ns3/lte-enb-cmac-sap.h"
 #include <ns3/lte-common.h>
 
 
@@ -55,15 +55,9 @@
 // //////////////////////////////////////
 
 
-/// EnbMacMemberLteEnbCmacSapProvider class
 class EnbMacMemberLteEnbCmacSapProvider : public LteEnbCmacSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the MAC
-   */
   EnbMacMemberLteEnbCmacSapProvider (LteEnbMac* mac);
 
   // inherited from LteEnbCmacSapProvider
@@ -79,7 +73,7 @@
   
 
 private:
-  LteEnbMac* m_mac; ///< the MAC
+  LteEnbMac* m_mac;
 };
 
 
@@ -143,22 +137,16 @@
 }
 
 
-/// EnbMacMemberFfMacSchedSapUser class
 class EnbMacMemberFfMacSchedSapUser : public FfMacSchedSapUser
 {
 public:
-  /**
-   * Constructor
-   * 
-   * \param mac the MAC
-   */
   EnbMacMemberFfMacSchedSapUser (LteEnbMac* mac);
 
 
   virtual void SchedDlConfigInd (const struct SchedDlConfigIndParameters& params);
   virtual void SchedUlConfigInd (const struct SchedUlConfigIndParameters& params);
 private:
-  LteEnbMac* m_mac; ///< the MAC
+  LteEnbMac* m_mac;
 };
 
 
@@ -183,15 +171,10 @@
 }
 
 
-/// EnbMacMemberFfMacCschedSapUser class
+
 class EnbMacMemberFfMacCschedSapUser : public FfMacCschedSapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the MAC
-   */
   EnbMacMemberFfMacCschedSapUser (LteEnbMac* mac);
 
   virtual void CschedCellConfigCnf (const struct CschedCellConfigCnfParameters& params);
@@ -203,7 +186,7 @@
   virtual void CschedCellConfigUpdateInd (const struct CschedCellConfigUpdateIndParameters& params);
 
 private:
-  LteEnbMac* m_mac; ///< the MAC
+  LteEnbMac* m_mac;
 };
 
 
@@ -256,15 +239,12 @@
 
 
 
-/// ---------- PHY-SAP
+// ---------- PHY-SAP
+
+
 class EnbMacMemberLteEnbPhySapUser : public LteEnbPhySapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the MAC
-   */
   EnbMacMemberLteEnbPhySapUser (LteEnbMac* mac);
 
   // inherited from LteEnbPhySapUser
@@ -277,7 +257,7 @@
   virtual void DlInfoListElementHarqFeeback (DlInfoListElement_s params);
 
 private:
-  LteEnbMac* m_mac; ///< the MAC
+  LteEnbMac* m_mac;
 };
 
 EnbMacMemberLteEnbPhySapUser::EnbMacMemberLteEnbPhySapUser (LteEnbMac* mac) : m_mac (mac)
@@ -363,19 +343,13 @@
                      "Information regarding UL scheduling.",
                      MakeTraceSourceAccessor (&LteEnbMac::m_ulScheduling),
                      "ns3::LteEnbMac::UlSchedulingTracedCallback")
-    .AddAttribute ("ComponentCarrierId",
-                   "ComponentCarrier Id, needed to reply on the appropriate sap.",
-                   UintegerValue (0),
-                   MakeUintegerAccessor (&LteEnbMac::m_componentCarrierId),
-                   MakeUintegerChecker<uint8_t> (0,4))
   ;
 
   return tid;
 }
 
 
-LteEnbMac::LteEnbMac ():
-m_ccmMacSapUser (0)
+LteEnbMac::LteEnbMac ()
 {
   NS_LOG_FUNCTION (this);
   m_macSapProvider = new EnbMacMemberLteMacSapProvider<LteEnbMac> (this);
@@ -383,7 +357,6 @@
   m_schedSapUser = new EnbMacMemberFfMacSchedSapUser (this);
   m_cschedSapUser = new EnbMacMemberFfMacCschedSapUser (this);
   m_enbPhySapUser = new EnbMacMemberLteEnbPhySapUser (this);
-  m_ccmMacSapProvider = new MemberLteCcmMacSapProvider<LteEnbMac> (this);
 }
 
 
@@ -407,14 +380,8 @@
   delete m_schedSapUser;
   delete m_cschedSapUser;
   delete m_enbPhySapUser;
-  delete m_ccmMacSapProvider;
 }
 
-void
-LteEnbMac::SetComponentCarrierId (uint8_t index)
-{
-  m_componentCarrierId = index;
-}
 
 void
 LteEnbMac::SetFfMacSchedSapProvider (FfMacSchedSapProvider* s)
@@ -479,18 +446,7 @@
   return m_enbPhySapUser;
 }
 
-void
-LteEnbMac::SetLteCcmMacSapUser (LteCcmMacSapUser* s)
-{
-  m_ccmMacSapUser = s;
-}
-
 
-LteCcmMacSapProvider*
-LteEnbMac::GetLteCcmMacSapProvider ()
-{
-  return m_ccmMacSapProvider;
-}
 
 void
 LteEnbMac::DoSubframeIndication (uint32_t frameNo, uint32_t subframeNo)
@@ -508,6 +464,12 @@
     {
       FfMacSchedSapProvider::SchedDlCqiInfoReqParameters dlcqiInfoReq;
       dlcqiInfoReq.m_sfnSf = ((0x3FF & frameNo) << 4) | (0xF & subframeNo);
+
+      int cqiNum = m_dlCqiReceived.size ();
+      if (cqiNum > MAX_CQI_LIST)
+        {
+          cqiNum = MAX_CQI_LIST;
+        }
       dlcqiInfoReq.m_cqiList.insert (dlcqiInfoReq.m_cqiList.begin (), m_dlCqiReceived.begin (), m_dlCqiReceived.end ());
       m_dlCqiReceived.erase (m_dlCqiReceived.begin (), m_dlCqiReceived.end ());
       m_schedSapProvider->SchedDlCqiInfoReq (dlcqiInfoReq);
@@ -537,8 +499,7 @@
               if (jt != m_allocatedNcRaPreambleMap.end ())
                 {
                   rnti = jt->second.rnti;
-                  NS_LOG_INFO ("preambleId previously allocated for NC based RA, RNTI =" << (uint32_t) rnti << ", sending RAR");
-                  
+                  NS_LOG_INFO ("preambleId previously allocated for NC based RA, RNTI =" << (uint32_t) rnti << ", sending RAR");                  
                 }
               else
                 {
@@ -705,17 +666,8 @@
 LteEnbMac::ReceiveBsrMessage  (MacCeListElement_s bsr)
 {
   NS_LOG_FUNCTION (this);
-  m_ccmMacSapUser->UlReceiveMacCe (bsr, m_componentCarrierId);
-}
 
-void
-LteEnbMac::DoReportMacCeToScheduler (MacCeListElement_s bsr)
-{
-  NS_LOG_FUNCTION (this);
-  NS_LOG_DEBUG (this << " bsr Size " << (uint16_t) m_ulCeReceived.size ());
-  //send to LteCcmMacSapUser
-  m_ulCeReceived.push_back (bsr); // this to called when LteUlCcmSapProvider::ReportMacCeToScheduler is called
-  NS_LOG_DEBUG (this << " bsr Size after push_back " << (uint16_t) m_ulCeReceived.size ());
+  m_ulCeReceived.push_back (bsr);
 }
 
 
@@ -769,7 +721,7 @@
   //Receive PDU only if LCID is found
   if (lcidIt != rntiIt->second.end ())
     {
-      (*lcidIt).second->ReceivePdu (p, rnti, lcid);
+      (*lcidIt).second->ReceivePdu (p);
     }
 }
 
@@ -844,7 +796,7 @@
 void
 LteEnbMac::DoAddLc (LteEnbCmacSapProvider::LcInfo lcinfo, LteMacSapUser* msu)
 {
-  NS_LOG_FUNCTION (this << lcinfo.rnti << (uint16_t) lcinfo.lcId);
+  NS_LOG_FUNCTION (this);
 
   std::map <LteFlowId_t, LteMacSapUser* >::iterator it;
   
@@ -983,11 +935,10 @@
   NS_LOG_FUNCTION (this);
   LteRadioBearerTag tag (params.rnti, params.lcid, params.layer);
   params.pdu->AddPacketTag (tag);
-  params.componentCarrierId = m_componentCarrierId;
   // Store pkt in HARQ buffer
   std::map <uint16_t, DlHarqProcessesBuffer_t>::iterator it =  m_miDlHarqProcessesPackets.find (params.rnti);
   NS_ASSERT (it != m_miDlHarqProcessesPackets.end ());
-  NS_LOG_DEBUG (this << " LAYER " << (uint16_t)tag.GetLayer () << " HARQ ID " << (uint16_t)params.harqProcessId);
+  NS_LOG_INFO(this << " LteEnbMac tx pdu LAYER " << (uint16_t)tag.GetLayer () << " HARQ ID " << (uint16_t)params.harqProcessId);
   
   //(*it).second.at (params.layer).at (params.harqProcessId) = params.pdu;//->Copy ();
   (*it).second.at (params.layer).at (params.harqProcessId)->AddPacket (params.pdu);
@@ -1053,9 +1004,9 @@
                   std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator rntiIt = m_rlcAttached.find (rnti);
                   NS_ASSERT_MSG (rntiIt != m_rlcAttached.end (), "could not find RNTI" << rnti);
                   std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = rntiIt->second.find (lcid);
-                  NS_ASSERT_MSG (lcidIt != rntiIt->second.end (), "could not find LCID" << (uint32_t)lcid<<" carrier id:"<<(uint16_t)m_componentCarrierId);
+                  NS_ASSERT_MSG (lcidIt != rntiIt->second.end (), "could not find LCID" << lcid);
                   NS_LOG_DEBUG (this << " rnti= " << rnti << " lcid= " << (uint32_t) lcid << " layer= " << k);
-                  (*lcidIt).second->NotifyTxOpportunity (ind.m_buildDataList.at (i).m_rlcPduList.at (j).at (k).m_size, k, ind.m_buildDataList.at (i).m_dci.m_harqProcess, m_componentCarrierId, rnti, lcid);
+                  (*lcidIt).second->NotifyTxOpportunity (ind.m_buildDataList.at (i).m_rlcPduList.at (j).at (k).m_size, k, ind.m_buildDataList.at (i).m_dci.m_harqProcess);
                 }
               else
                 {
@@ -1086,30 +1037,22 @@
       // Only one TB used
       if (ind.m_buildDataList.at (i).m_dci.m_tbsSize.size () == 1)
         {
-          DlSchedulingCallbackInfo dlSchedulingCallbackInfo;
-          dlSchedulingCallbackInfo.frameNo = m_frameNo;
-          dlSchedulingCallbackInfo.subframeNo = m_subframeNo;
-          dlSchedulingCallbackInfo.rnti = ind.m_buildDataList.at (i).m_dci.m_rnti;
-          dlSchedulingCallbackInfo.mcsTb1=ind.m_buildDataList.at (i).m_dci.m_mcs.at (0);
-          dlSchedulingCallbackInfo.sizeTb1 = ind.m_buildDataList.at (i).m_dci.m_tbsSize.at (0);
-          dlSchedulingCallbackInfo.mcsTb2 = 0;
-          dlSchedulingCallbackInfo.sizeTb2 = 0;
-          dlSchedulingCallbackInfo.componentCarrierId = m_componentCarrierId;
-          m_dlScheduling(dlSchedulingCallbackInfo);
+          m_dlScheduling (m_frameNo, m_subframeNo, ind.m_buildDataList.at (i).m_dci.m_rnti,
+                          ind.m_buildDataList.at (i).m_dci.m_mcs.at (0),
+                          ind.m_buildDataList.at (i).m_dci.m_tbsSize.at (0),
+                          0, 0
+                          );
+
         }
       // Two TBs used
       else if (ind.m_buildDataList.at (i).m_dci.m_tbsSize.size () == 2)
         {
-          DlSchedulingCallbackInfo dlSchedulingCallbackInfo;
-          dlSchedulingCallbackInfo.frameNo = m_frameNo;
-          dlSchedulingCallbackInfo.subframeNo = m_subframeNo;
-          dlSchedulingCallbackInfo.rnti = ind.m_buildDataList.at (i).m_dci.m_rnti;
-          dlSchedulingCallbackInfo.mcsTb1=ind.m_buildDataList.at (i).m_dci.m_mcs.at (0);
-          dlSchedulingCallbackInfo.sizeTb1 = ind.m_buildDataList.at (i).m_dci.m_tbsSize.at (0);
-          dlSchedulingCallbackInfo.mcsTb2 = ind.m_buildDataList.at (i).m_dci.m_mcs.at (1);
-          dlSchedulingCallbackInfo.sizeTb2 = ind.m_buildDataList.at (i).m_dci.m_tbsSize.at (1);
-          dlSchedulingCallbackInfo.componentCarrierId = m_componentCarrierId;
-          m_dlScheduling(dlSchedulingCallbackInfo);
+          m_dlScheduling (m_frameNo, m_subframeNo, ind.m_buildDataList.at (i).m_dci.m_rnti,
+                          ind.m_buildDataList.at (i).m_dci.m_mcs.at (0),
+                          ind.m_buildDataList.at (i).m_dci.m_tbsSize.at (0),
+                          ind.m_buildDataList.at (i).m_dci.m_mcs.at (1),
+                          ind.m_buildDataList.at (i).m_dci.m_tbsSize.at (1)
+                          );
         }
       else
         {
@@ -1169,7 +1112,7 @@
   for (  uint32_t i  = 0; i < ind.m_dciList.size (); i++ )
     {
       m_ulScheduling (m_frameNo, m_subframeNo, ind.m_dciList.at (i).m_rnti,
-                      ind.m_dciList.at (i).m_mcs, ind.m_dciList.at (i).m_tbSize, m_componentCarrierId);
+                      ind.m_dciList.at (i).m_mcs, ind.m_dciList.at (i).m_tbSize);
     }
 
 
diff -Naru a/model/lte-enb-mac.h b/model/lte-enb-mac.h
--- a/model/lte-enb-mac.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-mac.h	2017-10-05 11:47:22.310601768 +0200
@@ -17,9 +17,6 @@
  *
  * Author: Marco Miozzo  <marco.miozzo@cttc.es>
  *         Nicola Baldo  <nbaldo@cttc.es>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
  */
 
 #ifndef LTE_ENB_MAC_H
@@ -38,7 +35,6 @@
 #include "ns3/trace-source-accessor.h"
 #include <ns3/packet.h>
 #include <ns3/packet-burst.h>
-#include <ns3/lte-ccm-mac-sap.h>
 
 namespace ns3 {
 
@@ -46,7 +42,6 @@
 class UlCqiLteControlMessage;
 class PdcchMapLteControlMessage;
 
-/// DlHarqProcessesBuffer_t typedef
 typedef std::vector <std::vector < Ptr<PacketBurst> > > DlHarqProcessesBuffer_t;
 
 /**
@@ -54,35 +49,20 @@
  */
 class LteEnbMac :   public Object
 {
-  /// allow EnbMacMemberLteEnbCmacSapProvider class friend access
   friend class EnbMacMemberLteEnbCmacSapProvider;
-  /// allow EnbMacMemberLteMacSapProvider<LteEnbMac> class friend access
   friend class EnbMacMemberLteMacSapProvider<LteEnbMac>;
-  /// allow EnbMacMemberFfMacSchedSapUser class friend access
   friend class EnbMacMemberFfMacSchedSapUser;
-  /// allow EnbMacMemberFfMacCschedSapUser class friend access
   friend class EnbMacMemberFfMacCschedSapUser;
-  /// allow EnbMacMemberLteEnbPhySapUser class friend access
   friend class EnbMacMemberLteEnbPhySapUser;
-  /// allow MemberLteCcmMacSapProvider<LteEnbMac> class friend access
-  friend class MemberLteCcmMacSapProvider<LteEnbMac>;
 
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
   LteEnbMac (void);
   virtual ~LteEnbMac (void);
   virtual void DoDispose (void);
 
-  /**
-   * \brief Set the component carrier ID
-   * \param index the component carrier ID
-   */
-  void SetComponentCarrierId (uint8_t index);
+
   /**
    * \brief Set the scheduler SAP provider
    * \param s a pointer SAP provider of the FF packet scheduler
@@ -141,19 +121,6 @@
   void SetLteEnbPhySapProvider (LteEnbPhySapProvider* s);
 
   /**
-  * \brief Get the eNB-ComponentCarrierManager SAP User
-  * \return a pointer to the SAP User of the ComponentCarrierManager
-  */
-  LteCcmMacSapProvider* GetLteCcmMacSapProvider ();
-
-  /**
-  * \brief Set the ComponentCarrierManager SAP user
-  * \param s a pointer to the ComponentCarrierManager provider
-  */
-  void SetLteCcmMacSapUser (LteCcmMacSapUser* s);
-  
-
-  /**
    * TracedCallback signature for DL scheduling events.
    *
    * \param [in] frame Frame number.
@@ -163,12 +130,11 @@
    * \param [in] tbs0Size
    * \param [in] mcs1 The MCS for transport block.
    * \param [in] tbs1Size
-   * \param [in] component carrier id
    */
   typedef void (* DlSchedulingTracedCallback)
-    (const uint32_t frame, const uint32_t subframe, const uint16_t rnti,
-     const uint8_t mcs0, const uint16_t tbs0Size,
-     const uint8_t mcs1, const uint16_t tbs1Size, const uint8_t ccId);
+    (uint32_t frame, uint32_t subframe,  uint16_t rnti,
+     uint8_t mcs0, uint16_t tbs0Size,
+     uint8_t mcs1, uint16_t tbs1Size);
 
   /**
    *  TracedCallback signature for UL scheduling events.
@@ -180,8 +146,8 @@
    * \param [in] tbsSize
    */
   typedef void (* UlSchedulingTracedCallback)
-    (const uint32_t frame, const uint32_t subframe, const uint16_t rnti,
-     const uint8_t mcs, const uint16_t tbsSize);
+    (uint32_t frame, uint32_t subframe, uint16_t rnti,
+     uint8_t mcs, uint16_t tbsSize);
   
 private:
 
@@ -191,10 +157,6 @@
   */
   void ReceiveDlCqiLteControlMessage  (Ptr<DlCqiLteControlMessage> msg);
 
-  /**
-  * \brief Receive a DL CQI ideal control message
-  * \param msg the DL CQI message
-  */
   void DoReceiveLteControlMessage (Ptr<LteControlMessage> msg);
 
   /**
@@ -203,233 +165,110 @@
   */
   void ReceiveBsrMessage  (MacCeListElement_s bsr);
 
-  /**
-  * \brief UL CQI report
-  * \param ulcqi FfMacSchedSapProvider::SchedUlCqiInfoReqParameters
-  */
+ 
   void DoUlCqiReport (FfMacSchedSapProvider::SchedUlCqiInfoReqParameters ulcqi);
 
 
 
   // forwarded from LteEnbCmacSapProvider
-  /**
-  * \brief Configure MAC function
-  * \param ulBandwidth the UL bandwidth
-  * \param dlBandwidth the DL bandwidth
-  */
   void DoConfigureMac (uint8_t ulBandwidth, uint8_t dlBandwidth);
-  /**
-  * \brief Add UE function
-  * \param rnti the RNTI
-  */
   void DoAddUe (uint16_t rnti);
-  /**
-  * \brief Remove UE function
-  * \param rnti the RNTI
-  */
   void DoRemoveUe (uint16_t rnti);
-  /**
-  * \brief Add LC function
-  * \param lcinfo the LC info
-  * \param msu the LTE MAC SAP user
-  */
   void DoAddLc (LteEnbCmacSapProvider::LcInfo lcinfo, LteMacSapUser* msu);
-  /**
-  * \brief Reconfigure LC function
-  * \param lcinfo the LC info
-  */
   void DoReconfigureLc (LteEnbCmacSapProvider::LcInfo lcinfo);
-  /**
-  * \brief Release LC function
-  * \param rnti the RNTI
-  * \param lcid the LCID
-  */
   void DoReleaseLc (uint16_t  rnti, uint8_t lcid);
-  /**
-  * \brief UE Update configuration request function
-  * \param params LteEnbCmacSapProvider::UeConfig
-  */
   void DoUeUpdateConfigurationReq (LteEnbCmacSapProvider::UeConfig params);
-  /**
-  * \brief Get RACH configuration function
-  * \returns LteEnbCmacSapProvider::RachConfig
-  */
   LteEnbCmacSapProvider::RachConfig DoGetRachConfig ();
-  /**
-  * \brief Allocate NC RA preamble function
-  * \param rnti the RNTI
-  * \returns LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue
-  */
   LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue DoAllocateNcRaPreamble (uint16_t rnti);
 
   // forwarded from LteMacSapProvider
-  /**
-  * \brief Transmit PDU function
-  * \param params LteMacSapProvider::TransmitPduParameters
-  */
-  void DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params);
-  /**
-  * \brief Report Buffer Status function
-  * \param params LteMacSapProvider::ReportBufferStatusParameters
-  */
-  void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params);
+  void DoTransmitPdu (LteMacSapProvider::TransmitPduParameters);
+  void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters);
 
 
   // forwarded from FfMacCchedSapUser
-  /**
-  * \brief CSched Cell Config configure function
-  * \param params FfMacCschedSapUser::CschedCellConfigCnfParameters
-  */
   void DoCschedCellConfigCnf (FfMacCschedSapUser::CschedCellConfigCnfParameters params);
-  /**
-  * \brief CSched UE Config configure function
-  * \param params FfMacCschedSapUser::CschedUeConfigCnfParameters
-  */
   void DoCschedUeConfigCnf (FfMacCschedSapUser::CschedUeConfigCnfParameters params);
-  /**
-  * \brief CSched LC Config configure function
-  * \param params FfMacCschedSapUser::CschedLcConfigCnfParameters
-  */
   void DoCschedLcConfigCnf (FfMacCschedSapUser::CschedLcConfigCnfParameters params);
-  /**
-  * \brief CSched LC Release configure function
-  * \param params FfMacCschedSapUser::CschedLcReleaseCnfParameters
-  */
   void DoCschedLcReleaseCnf (FfMacCschedSapUser::CschedLcReleaseCnfParameters params);
-  /**
-  * \brief CSched UE Release configure function
-  * \param params FfMacCschedSapUser::CschedUeReleaseCnfParameters
-  */
   void DoCschedUeReleaseCnf (FfMacCschedSapUser::CschedUeReleaseCnfParameters params);
-  /**
-  * \brief CSched UE Config Update Indication function
-  * \param params FfMacCschedSapUser::CschedUeConfigUpdateIndParameters
-  */
   void DoCschedUeConfigUpdateInd (FfMacCschedSapUser::CschedUeConfigUpdateIndParameters params);
-  /**
-  * \brief CSched Cell Config Update Indication function
-  * \param params FfMacCschedSapUser::CschedCellConfigUpdateIndParameters
-  */
   void DoCschedCellConfigUpdateInd (FfMacCschedSapUser::CschedCellConfigUpdateIndParameters params);
 
   // forwarded from FfMacSchedSapUser
-  /**
-  * \brief Sched DL Config Indication function
-  * \param ind FfMacSchedSapUser::SchedDlConfigIndParameters
-  */
   void DoSchedDlConfigInd (FfMacSchedSapUser::SchedDlConfigIndParameters ind);
-  /**
-  * \brief Sched UL Config Indication function
-  * \param params FfMacSchedSapUser::SchedUlConfigIndParameters
-  */
   void DoSchedUlConfigInd (FfMacSchedSapUser::SchedUlConfigIndParameters params);
 
   // forwarded from LteEnbPhySapUser
-  /**
-  * \brief Subrame Indication function
-  * \param frameNo frame number
-  * \param subframeNo subframe number
-  */
   void DoSubframeIndication (uint32_t frameNo, uint32_t subframeNo);
-  /**
-  * \brief Receive RACH Preamble function
-  * \param prachId PRACH ID number
-  */
   void DoReceiveRachPreamble (uint8_t prachId);
 
-  // forwarded by LteCcmMacSapProvider
-  /**
-   * Report MAC CE to scheduler
-   * \param bsr the BSR
-   */
-  void DoReportMacCeToScheduler (MacCeListElement_s bsr);
-  
 public:
-  /**
-   * legacy public for use the Phy callback
-   * \param p packet
-   */
+  // legacy public for use the Phy callback
   void DoReceivePhyPdu (Ptr<Packet> p);
 
 private:
-  /**
-  * \brief UL Info List ELements HARQ Feedback function
-  * \param params UlInfoListElement_s
-  */
   void DoUlInfoListElementHarqFeeback (UlInfoListElement_s params);
-  /**
-  * \brief DL Info List ELements HARQ Feedback function
-  * \param params DlInfoListElement_s
-  */
   void DoDlInfoListElementHarqFeeback (DlInfoListElement_s params);
 
-  /// rnti, lcid, SAP of the RLC instance
+  //            rnti,             lcid, SAP of the RLC instance
   std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> > m_rlcAttached;
 
-  std::vector <CqiListElement_s> m_dlCqiReceived; ///< DL-CQI received
-  std::vector <FfMacSchedSapProvider::SchedUlCqiInfoReqParameters> m_ulCqiReceived; ///< UL-CQI received
-  std::vector <MacCeListElement_s> m_ulCeReceived; ///< CE received (BSR up to now)
+  std::vector <CqiListElement_s> m_dlCqiReceived; // DL-CQI received
+  std::vector <FfMacSchedSapProvider::SchedUlCqiInfoReqParameters> m_ulCqiReceived; // UL-CQI received
+  std::vector <MacCeListElement_s> m_ulCeReceived; // CE received (BSR up to now)
 
-  std::vector <DlInfoListElement_s> m_dlInfoListReceived; ///< DL HARQ feedback received
+  std::vector <DlInfoListElement_s> m_dlInfoListReceived; // DL HARQ feedback received
 
-  std::vector <UlInfoListElement_s> m_ulInfoListReceived; ///< UL HARQ feedback received
+  std::vector <UlInfoListElement_s> m_ulInfoListReceived; // UL HARQ feedback received
 
 
   /*
   * Map of UE's info element (see 4.3.12 of FF MAC Scheduler API)
   */
-  //std::map <uint16_t,UlInfoListElement_s> m_ulInfoListElements; 
+//   std::map <uint16_t,UlInfoListElement_s> m_ulInfoListElements; 
 
 
 
-  LteMacSapProvider* m_macSapProvider; ///< the MAC SAP provider
-  LteEnbCmacSapProvider* m_cmacSapProvider; ///< the CMAC SAP provider
-  LteMacSapUser* m_macSapUser; ///< the MAC SAP user
-  LteEnbCmacSapUser* m_cmacSapUser; ///< the CMAC SAP user
+  LteMacSapProvider* m_macSapProvider;
+  LteEnbCmacSapProvider* m_cmacSapProvider;
+  LteMacSapUser* m_macSapUser;
+  LteEnbCmacSapUser* m_cmacSapUser;
 
 
-  FfMacSchedSapProvider* m_schedSapProvider; ///< the Sched SAP provider
-  FfMacCschedSapProvider* m_cschedSapProvider; ///< the Csched SAP provider
-  FfMacSchedSapUser* m_schedSapUser; ///< the Sched SAP user
-  FfMacCschedSapUser* m_cschedSapUser; ///< the CSched SAP user
+  FfMacSchedSapProvider* m_schedSapProvider;
+  FfMacCschedSapProvider* m_cschedSapProvider;
+  FfMacSchedSapUser* m_schedSapUser;
+  FfMacCschedSapUser* m_cschedSapUser;
 
   // PHY-SAP
-  LteEnbPhySapProvider* m_enbPhySapProvider; ///< the ENB Phy SAP provider
-  LteEnbPhySapUser* m_enbPhySapUser; ///< the ENB Phy SAP user
+  LteEnbPhySapProvider* m_enbPhySapProvider;
+  LteEnbPhySapUser* m_enbPhySapUser;
 
-  // Sap For ComponentCarrierManager 'Uplink case'
-  LteCcmMacSapProvider* m_ccmMacSapProvider; ///< CCM MAC SAP provider
-  LteCcmMacSapUser* m_ccmMacSapUser; ///< CCM MAC SAP user
-  /**
-   * frame number of current subframe indication
-   */
   uint32_t m_frameNo;
-  /**
-   * subframe number of current subframe indication
-   */
   uint32_t m_subframeNo;
   /**
    * Trace information regarding DL scheduling
    * Frame number, Subframe number, RNTI, MCS of TB1, size of TB1,
    * MCS of TB2 (0 if not present), size of TB2 (0 if not present)
    */
-  TracedCallback<DlSchedulingCallbackInfo> m_dlScheduling;
-
+  TracedCallback<uint32_t, uint32_t, uint16_t,
+                 uint8_t, uint16_t, uint8_t, uint16_t> m_dlScheduling;
   /**
    * Trace information regarding UL scheduling
-   * Frame number, Subframe number, RNTI, MCS of TB, size of TB, component carrier id
+   * Frame number, Subframe number, RNTI, MCS of TB, size of TB
    */
   TracedCallback<uint32_t, uint32_t, uint16_t,
-                 uint8_t, uint16_t, uint8_t> m_ulScheduling;
+                 uint8_t, uint16_t> m_ulScheduling;
   
-  uint8_t m_macChTtiDelay; ///< delay of MAC, PHY and channel in terms of TTIs
+  uint8_t m_macChTtiDelay; // delay of MAC, PHY and channel in terms of TTIs
 
 
-  std::map <uint16_t, DlHarqProcessesBuffer_t> m_miDlHarqProcessesPackets; ///< Packet under transmission of the DL HARQ process
+  std::map <uint16_t, DlHarqProcessesBuffer_t> m_miDlHarqProcessesPackets; // Packet under trasmission of the DL HARQ process
   
-  uint8_t m_numberOfRaPreambles; ///< number of RA preambles
-  uint8_t m_preambleTransMax; ///< preamble transmit maximum
-  uint8_t m_raResponseWindowSize; ///< RA response window size
+  uint8_t m_numberOfRaPreambles;
+  uint8_t m_preambleTransMax;
+  uint8_t m_raResponseWindowSize;
 
   /**
    * info associated with a preamble allocated for non-contention based RA
@@ -442,19 +281,15 @@
   };
 
   /**
-   * map storing as key the random access preamble IDs allocated for
+   * map storing as key the random acccess preamble IDs allocated for
    * non-contention based access, and as value the associated info
    * 
    */
   std::map<uint8_t, NcRaPreambleInfo> m_allocatedNcRaPreambleMap;
  
-  std::map<uint8_t, uint32_t> m_receivedRachPreambleCount; ///< received RACH preamble count
+  std::map<uint8_t, uint32_t> m_receivedRachPreambleCount;
 
-  std::map<uint8_t, uint32_t> m_rapIdRntiMap; ///< RAPID RNTI map
-
-  /// component carrier Id used to address sap
-  uint8_t m_componentCarrierId;
- 
+  std::map<uint8_t, uint32_t> m_rapIdRntiMap;
 };
 
 } // end namespace ns3
diff -Naru a/model/lte-enb-net-device.cc b/model/lte-enb-net-device.cc
--- a/model/lte-enb-net-device.cc	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-net-device.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 TELEMATICS LAB, DEE - Politecnico di Bari
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,7 +19,9 @@
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  * Author: Marco Miozzo <mmiozzo@cttc.es> : Update to FF API Architecture
  * Author: Nicola Baldo <nbaldo@cttc.es>  : Integrated with new RRC and MAC architecture
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it> : Integrated with new architecture - GSoC 2015 - Carrier Aggregation
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/llc-snap-header.h>
@@ -45,9 +48,6 @@
 #include <ns3/ipv4-l3-protocol.h>
 #include <ns3/abort.h>
 #include <ns3/log.h>
-#include <ns3/lte-enb-component-carrier-manager.h>
-#include <ns3/object-map.h>
-#include <ns3/object-factory.h>
 
 namespace ns3 {
 
@@ -82,24 +82,30 @@
                    PointerValue (),
                    MakePointerAccessor (&LteEnbNetDevice::m_ffrAlgorithm),
                    MakePointerChecker <LteFfrAlgorithm> ())
-    .AddAttribute ("LteEnbComponentCarrierManager",
-                   "The RRC associated to this EnbNetDevice",
+    .AddAttribute ("LteEnbMac",
+                   "The MAC associated to this EnbNetDevice",
+                   PointerValue (),
+                   MakePointerAccessor (&LteEnbNetDevice::m_mac),
+                   MakePointerChecker <LteEnbMac> ())
+    .AddAttribute ("FfMacScheduler",
+                   "The scheduler associated to this EnbNetDevice",
                    PointerValue (),
-                   MakePointerAccessor (&LteEnbNetDevice::m_componentCarrierManager),
-                   MakePointerChecker <LteEnbComponentCarrierManager> ())
-    .AddAttribute ("ComponentCarrierMap", "List of component carriers.",
-                   ObjectMapValue (),
-                   MakeObjectMapAccessor (&LteEnbNetDevice::m_ccMap),
-                   MakeObjectMapChecker<ComponentCarrierEnb> ())
+                   MakePointerAccessor (&LteEnbNetDevice::m_scheduler),
+                   MakePointerChecker <FfMacScheduler> ())
+    .AddAttribute ("LteEnbPhy",
+                   "The PHY associated to this EnbNetDevice",
+                   PointerValue (),
+                   MakePointerAccessor (&LteEnbNetDevice::m_phy),
+                   MakePointerChecker <LteEnbPhy> ())
     .AddAttribute ("UlBandwidth",
                    "Uplink Transmission Bandwidth Configuration in number of Resource Blocks",
-                   UintegerValue (25),
+                   UintegerValue (100),
                    MakeUintegerAccessor (&LteEnbNetDevice::SetUlBandwidth, 
                                          &LteEnbNetDevice::GetUlBandwidth),
                    MakeUintegerChecker<uint8_t> ())
     .AddAttribute ("DlBandwidth",
                    "Downlink Transmission Bandwidth Configuration in number of Resource Blocks",
-                   UintegerValue (25),
+                   UintegerValue (100),
                    MakeUintegerAccessor (&LteEnbNetDevice::SetDlBandwidth, 
                                          &LteEnbNetDevice::GetDlBandwidth),
                    MakeUintegerChecker<uint8_t> ())
@@ -113,13 +119,13 @@
                    "as per 3GPP 36.101 Section 5.7.3. ",
                    UintegerValue (100),
                    MakeUintegerAccessor (&LteEnbNetDevice::m_dlEarfcn),
-                   MakeUintegerChecker<uint32_t> (0, 262143))
+                   MakeUintegerChecker<uint16_t> (0, 6599))
     .AddAttribute ("UlEarfcn",
                    "Uplink E-UTRA Absolute Radio Frequency Channel Number (EARFCN) "
                    "as per 3GPP 36.101 Section 5.7.3. ",
                    UintegerValue (18100),
                    MakeUintegerAccessor (&LteEnbNetDevice::m_ulEarfcn),
-                   MakeUintegerChecker<uint32_t> (0, 262143))
+                   MakeUintegerChecker<uint16_t> (18000, 24599))
     .AddAttribute ("CsgId",
                    "The Closed Subscriber Group (CSG) identity that this eNodeB belongs to",
                    UintegerValue (0),
@@ -141,8 +147,7 @@
 LteEnbNetDevice::LteEnbNetDevice ()
   : m_isConstructed (false),
     m_isConfigured (false),
-    m_anr (0),
-    m_componentCarrierManager(0)
+    m_anr (0)
 {
   NS_LOG_FUNCTION (this);
 }
@@ -157,6 +162,12 @@
 {
   NS_LOG_FUNCTION (this);
 
+  m_mac->Dispose ();
+  m_mac = 0;
+
+  m_scheduler->Dispose ();
+  m_scheduler = 0;
+
   m_rrc->Dispose ();
   m_rrc = 0;
 
@@ -168,16 +179,13 @@
       m_anr->Dispose ();
       m_anr = 0;
     }
-  m_componentCarrierManager->Dispose();
-  m_componentCarrierManager = 0;
-  // ComponentCarrierEnb::DoDispose() will call DoDispose
-  // of its PHY, MAC, FFR and scheduler instance
-  for (uint32_t i = 0; i < m_ccMap.size (); i++)
-    {
-      m_ccMap.at (i)->Dispose ();
-      m_ccMap.at (i) = 0;
-    }
-   
+
+  m_ffrAlgorithm->Dispose ();
+  m_ffrAlgorithm = 0;
+
+  m_phy->Dispose ();
+  m_phy = 0;
+
   LteNetDevice::DoDispose ();
 }
 
@@ -186,25 +194,13 @@
 Ptr<LteEnbMac>
 LteEnbNetDevice::GetMac () const
 {
-  return m_ccMap.at (0)->GetMac ();
+  return m_mac;
 }
 
 Ptr<LteEnbPhy>
 LteEnbNetDevice::GetPhy () const
 {
-  return m_ccMap.at (0)->GetPhy ();
-}
-
-Ptr<LteEnbMac>
-LteEnbNetDevice::GetMac (uint8_t index) 
-{
-  return m_ccMap.at (index)->GetMac ();
-}
-
-Ptr<LteEnbPhy>
-LteEnbNetDevice::GetPhy(uint8_t index)  
-{
-  return m_ccMap.at (index)->GetPhy ();
+  return m_phy;
 }
 
 Ptr<LteEnbRrc>
@@ -213,31 +209,12 @@
   return m_rrc;
 }
 
-Ptr<LteEnbComponentCarrierManager>
-LteEnbNetDevice::GetComponentCarrierManager () const
-{
-  return  m_componentCarrierManager;
-}
-
 uint16_t
 LteEnbNetDevice::GetCellId () const
 {
   return m_cellId;
 }
 
-bool
-LteEnbNetDevice::HasCellId (uint16_t cellId) const
-{
-  for (auto &it: m_ccMap)
-    {
-      if (it.second->GetCellId () == cellId)
-        {
-          return true;
-        }
-    }
-  return false;
-}
-
 uint8_t 
 LteEnbNetDevice::GetUlBandwidth () const
 {
@@ -292,27 +269,27 @@
     }
 }
 
-uint32_t 
+uint16_t 
 LteEnbNetDevice::GetDlEarfcn () const
 {
   return m_dlEarfcn;
 }
 
 void 
-LteEnbNetDevice::SetDlEarfcn (uint32_t earfcn)
+LteEnbNetDevice::SetDlEarfcn (uint16_t earfcn)
 { 
   NS_LOG_FUNCTION (this << earfcn);
   m_dlEarfcn = earfcn;
 }
 
-uint32_t 
+uint16_t 
 LteEnbNetDevice::GetUlEarfcn () const
 {
   return m_ulEarfcn;
 }
 
 void 
-LteEnbNetDevice::SetUlEarfcn (uint32_t earfcn)
+LteEnbNetDevice::SetUlEarfcn (uint16_t earfcn)
 { 
   NS_LOG_FUNCTION (this << earfcn);
   m_ulEarfcn = earfcn;
@@ -346,18 +323,6 @@
   UpdateConfig (); // propagate the change to RRC level
 }
 
-std::map < uint8_t, Ptr<ComponentCarrierEnb> >
-LteEnbNetDevice::GetCcMap ()
-{
-  return m_ccMap;
-}
-
-void
-LteEnbNetDevice::SetCcMap (std::map< uint8_t, Ptr<ComponentCarrierEnb> > ccm)
-{
-  NS_ASSERT_MSG (!m_isConfigured, "attempt to set CC map after configuration");
-  m_ccMap = ccm;
-}
 
 void 
 LteEnbNetDevice::DoInitialize (void)
@@ -365,13 +330,9 @@
   NS_LOG_FUNCTION (this);
   m_isConstructed = true;
   UpdateConfig ();
-  std::map< uint8_t, Ptr<ComponentCarrierEnb> >::iterator it;
-  for (it = m_ccMap.begin (); it != m_ccMap.end (); ++it)
-    {
-       it->second->Initialize ();
-    }
+  m_phy->Initialize ();
+  m_mac->Initialize ();
   m_rrc->Initialize ();
-  m_componentCarrierManager->Initialize();
   m_handoverAlgorithm->Initialize ();
 
   if (m_anr != 0)
@@ -403,8 +364,7 @@
         {
           NS_LOG_LOGIC (this << " Configure cell " << m_cellId);
           // we have to make sure that this function is called only once
-          NS_ASSERT (!m_ccMap.empty ());
-          m_rrc->ConfigureCell (m_ccMap);
+          m_rrc->ConfigureCell (m_ulBandwidth, m_dlBandwidth, m_ulEarfcn, m_dlEarfcn, m_cellId);
           m_isConfigured = true;
         }
 
diff -Naru a/model/lte-enb-net-device.h b/model/lte-enb-net-device.h
--- a/model/lte-enb-net-device.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-net-device.h	2017-10-05 11:47:22.310601768 +0200
@@ -17,7 +17,6 @@
  *
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  * Author: Marco Miozzo <marco.miozzo@cttc.es> : Update to FF API Architecture
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it> : Integrated with new architecture - GSoC 2015 - Carrier Aggregation
  */
 
 #ifndef LTE_ENB_NET_DEVICE_H
@@ -29,9 +28,7 @@
 #include "ns3/traced-callback.h"
 #include "ns3/nstime.h"
 #include "ns3/lte-phy.h"
-#include "ns3/component-carrier-enb.h"
 #include <vector>
-#include <map>
 
 namespace ns3 {
 
@@ -46,7 +43,6 @@
 class LteHandoverAlgorithm;
 class LteAnr;
 class LteFfrAlgorithm;
-class LteEnbComponentCarrierManager;
 
 /**
  * \ingroup lte
@@ -56,10 +52,6 @@
 class LteEnbNetDevice : public LteNetDevice
 {
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
   LteEnbNetDevice ();
@@ -71,48 +63,25 @@
   virtual bool Send (Ptr<Packet> packet, const Address& dest, uint16_t protocolNumber);
 
   /**
-   * \return a pointer to the MAC of the PCC.
+   * \return a pointer to the MAC 
    */
   Ptr<LteEnbMac> GetMac (void) const;
 
   /**
-   * \param index CC index
-   * \return a pointer to the MAC of the CC addressed by index.
-   */
-  Ptr<LteEnbMac> GetMac (uint8_t index);
-
-  /**
-   * \return a pointer to the physical layer of the PCC.
+   * \return a pointer to the physical layer.
    */
   Ptr<LteEnbPhy> GetPhy (void) const;
-  
-  /**
-   * \param index SCC index
-   * \return a pointer to the physical layer of the SCC addressed by index.
-   */
-  Ptr<LteEnbPhy> GetPhy (uint8_t index);
 
   /** 
    * \return a pointer to the Radio Resource Control instance of the eNB
    */
   Ptr<LteEnbRrc> GetRrc () const;
-  
-  /** 
-   * \return a pointer to the ComponentCarrierManager instance of the eNB
-   */
-  Ptr<LteEnbComponentCarrierManager> GetComponentCarrierManager () const;
 
   /** 
    * \return the Cell Identifier of this eNB
    */
   uint16_t GetCellId () const;
 
-  /**
-   * \param cellId cell ID
-   * \return true if cellId is served by this eNB
-   */
-  bool HasCellId (uint16_t cellId) const;
-
   /** 
    * \return the uplink bandwidth in RBs
    */
@@ -136,22 +105,22 @@
   /** 
    * \return the downlink carrier frequency (EARFCN)
    */
-  uint32_t GetDlEarfcn () const;
+  uint16_t GetDlEarfcn () const;
 
   /** 
    * \param earfcn the downlink carrier frequency (EARFCN)
    */
-  void SetDlEarfcn (uint32_t earfcn);
+  void SetDlEarfcn (uint16_t earfcn);
 
   /** 
    * \return the uplink carrier frequency (EARFCN)
    */
-  uint32_t GetUlEarfcn () const;
+  uint16_t GetUlEarfcn () const;
 
   /** 
    * \param earfcn the uplink carrier frequency (EARFCN)
    */
-  void SetUlEarfcn (uint32_t earfcn);
+  void SetUlEarfcn (uint16_t earfcn);
 
   /**
    * \brief Returns the CSG ID of the eNodeB.
@@ -198,29 +167,14 @@
    */
   void SetCsgIndication (bool csgIndication);
 
-  /**
-   * \brief Set the ComponentCarrier Map of the Enb
-   * \param ccm the map of ComponentCarrierEnb
-   *
-   */
-
-  void SetCcMap (std::map< uint8_t, Ptr<ComponentCarrierEnb> > ccm);
-
-  /**
-   * \returns  The Component Carrier Map of the Enb.
-   *
-   */
-
-  std::map< uint8_t, Ptr<ComponentCarrierEnb> >  GetCcMap (void);
-
 protected:
   // inherited from Object
   virtual void DoInitialize (void);
 
 
 private:
-  bool m_isConstructed; ///< is constructed?
-  bool m_isConfigured; ///< is configured?
+  bool m_isConstructed;
+  bool m_isConfigured;
 
   /**
    * \brief Propagate attributes and configuration to sub-modules.
@@ -234,28 +188,30 @@
    */
   void UpdateConfig ();
 
-  Ptr<LteEnbRrc> m_rrc; ///< the RRC
+  Ptr<LteEnbMac> m_mac;
 
-  Ptr<LteHandoverAlgorithm> m_handoverAlgorithm; ///< the handover algorithm
- 
-  Ptr<LteAnr> m_anr; ///< ANR
+  Ptr<LteEnbPhy> m_phy;
 
-  Ptr<LteFfrAlgorithm> m_ffrAlgorithm; /**< DEPRECATED - It is maintained for backward compatibility after adding CA feature*/
+  Ptr<LteEnbRrc> m_rrc;
 
-  uint16_t m_cellId; /**< Cell Identifer. Part of the CGI, see TS 29.274, section 8.21.1  */
+  Ptr<FfMacScheduler> m_scheduler;
+
+  Ptr<LteHandoverAlgorithm> m_handoverAlgorithm;
 
-  uint8_t m_dlBandwidth; /**<DEPRECATE - It is maintained for backward compatibility after adding CA feature- downlink bandwidth in RBs */
-  uint8_t m_ulBandwidth; /**<DEPRECATE - It is maintained for backward compatibility after adding CA feature- uplink bandwidth in RBs */
+  Ptr<LteAnr> m_anr;
+
+  Ptr<LteFfrAlgorithm> m_ffrAlgorithm;
+
+  uint16_t m_cellId; /**< Cell Identifer. Part of the CGI, see TS 29.274, section 8.21.1  */
 
-  uint32_t m_dlEarfcn;  /**<DEPRECATE - It is maintained for backward compatibility after adding CA feature- downlink carrier frequency */
-  uint32_t m_ulEarfcn;  /**<DEPRECATE - It is maintained for backward compatibility after adding CA feature- uplink carrier frequency */
+  uint8_t m_dlBandwidth; /**< downlink bandwidth in RBs */
+  uint8_t m_ulBandwidth; /**< uplink bandwidth in RBs */
 
-  uint16_t m_csgId; ///< CSG ID
-  bool m_csgIndication; ///< CSG indication
+  uint16_t m_dlEarfcn;  /**< downlink carrier frequency */
+  uint16_t m_ulEarfcn;  /**< uplink carrier frequency */
 
-  std::map < uint8_t, Ptr<ComponentCarrierEnb> > m_ccMap; /**< ComponentCarrier map */
-  
-  Ptr<LteEnbComponentCarrierManager> m_componentCarrierManager; ///< the component carrier manager of this eNb
+  uint16_t m_csgId;
+  bool m_csgIndication;
 
 }; // end of class LteEnbNetDevice
 
diff -Naru a/model/lte-enb-phy.cc b/model/lte-enb-phy.cc
--- a/model/lte-enb-phy.cc	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-phy.cc	2017-10-05 11:47:22.310601768 +0200
@@ -17,6 +17,9 @@
  *
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/object-factory.h>
@@ -74,34 +77,18 @@
 class EnbMemberLteEnbPhySapProvider : public LteEnbPhySapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param phy the ENB Phy
-   */
   EnbMemberLteEnbPhySapProvider (LteEnbPhy* phy);
 
   // inherited from LteEnbPhySapProvider
   virtual void SendMacPdu (Ptr<Packet> p);
-  virtual void SendLteControlMessage (Ptr<LteControlMessage> msg);
-  virtual uint8_t GetMacChTtiDelay ();
-  /**
-   * Set bandwidth function
-   *
-   * \param ulBandwidth the UL bandwidth
-   * \param dlBandwidth the DL bandwidth
-   */
   virtual void SetBandwidth (uint8_t ulBandwidth, uint8_t dlBandwidth);
-  /**
-   * Set Cell ID function
-   *
-   * \param cellId the cell ID
-   */
   virtual void SetCellId (uint16_t cellId);
+  virtual void SendLteControlMessage (Ptr<LteControlMessage> msg);
+  virtual uint8_t GetMacChTtiDelay ();
 
 
 private:
-  LteEnbPhy* m_phy; ///< the ENB Phy
+  LteEnbPhy* m_phy;
 };
 
 EnbMemberLteEnbPhySapProvider::EnbMemberLteEnbPhySapProvider (LteEnbPhy* phy) : m_phy (phy)
@@ -635,7 +622,7 @@
   if (m_srsPeriodicity>0)
     { 
       // might be 0 in case the eNB has no UEs attached
-      NS_ASSERT_MSG (m_nrFrames > 1, "the SRS index check code assumes that frameNo starts at 1");
+      NS_ASSERT_MSG (m_nrFrames >= 1, "the SRS index check code assumes that frameNo starts at 1");
       NS_ASSERT_MSG (m_nrSubFrames > 0 && m_nrSubFrames <= 10, "the SRS index check code assumes that subframeNo starts at 1");
       m_currentSrsOffset = (((m_nrFrames-1)*10 + (m_nrSubFrames-1)) % m_srsPeriodicity);
     }
@@ -720,7 +707,6 @@
                   params.m_size = dci->GetDci ().m_tbsSize.at (i);
                   params.m_rv = dci->GetDci ().m_rv.at (i);
                   params.m_ndi = dci->GetDci ().m_ndi.at (i);
-                  params.m_ccId = m_componentCarrierId;
                   m_dlPhyTransmission (params);
                 }
 
@@ -925,7 +911,7 @@
 }
 
 void 
-LteEnbPhy::DoSetEarfcn (uint32_t ulEarfcn, uint32_t dlEarfcn)
+LteEnbPhy::DoSetEarfcn (uint16_t ulEarfcn, uint16_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << ulEarfcn << dlEarfcn);
   m_ulEarfcn = ulEarfcn;
@@ -1029,7 +1015,8 @@
   (*it).second++;
   if ((*it).second == m_srsSamplePeriod)
     {
-      m_reportUeSinr (m_cellId, rnti, srs, (uint16_t) m_componentCarrierId);
+      uint8_t cc = 0;
+      m_reportUeSinr (m_cellId, rnti, srs, cc);
       (*it).second = 0;
     }
 }
diff -Naru a/model/lte-enb-phy.h b/model/lte-enb-phy.h
--- a/model/lte-enb-phy.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-phy.h	2017-10-05 11:47:22.310601768 +0200
@@ -46,9 +46,7 @@
  */
 class LteEnbPhy : public LtePhy
 {
-  /// allow EnbMemberLteEnbPhySapProvider class friend access
   friend class EnbMemberLteEnbPhySapProvider;
-  /// allow MemberLteEnbCphySapProvider<LteEnbPhy> class friend access
   friend class MemberLteEnbCphySapProvider<LteEnbPhy>;
 
 public:
@@ -66,12 +64,8 @@
 
   virtual ~LteEnbPhy ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
   // inherited from Object
+  static TypeId GetTypeId (void);
   virtual void DoInitialize (void);
   virtual void DoDispose (void);
 
@@ -187,13 +181,11 @@
 
   /**
    * \brief Create the PSD for TX
-   * \returns the PSD
    */
   virtual Ptr<SpectrumValue> CreateTxPowerSpectralDensity ();
 
   /**
    * \brief Create the PSD for TX with power allocation for each RB
-   * \return the PSD
    */
   virtual Ptr<SpectrumValue> CreateTxPowerSpectralDensityWithPowerAllocation ();
 
@@ -268,13 +260,12 @@
 
   /**
    * \brief PhySpectrum received a new PHY-PDU
-   * \param p the packet received
    */
   void PhyPduReceived (Ptr<Packet> p);
 
   /**
-   * \brief PhySpectrum received a new list of LteControlMessage
-   */
+  * \brief PhySpectrum received a new list of LteControlMessage
+  */
   virtual void ReceiveLteControlMessageList (std::list<Ptr<LteControlMessage> >);
 
   // inherited from LtePhy
@@ -286,16 +277,10 @@
 
 
   /**
-   * \brief PhySpectrum generated a new UL HARQ feedback
-   * \param mes UlInfoListElement_s
-   */
+  * \brief PhySpectrum generated a new UL HARQ feedback
+  */
   virtual void ReceiveLteUlHarqFeedback (UlInfoListElement_s mes);
 
-  /**
-   * \brief PhySpectrum generated a new UL HARQ feedback
-   *
-   * \param harq the HARQ Phy
-   */
   void SetHarqPhyModule (Ptr<LteHarqPhy> harq);
 
   /**
@@ -322,79 +307,19 @@
 private:
 
   // LteEnbCphySapProvider forwarded methods
-  /**
-   * Set bandwidth function
-   *
-   * \param ulBandwidth UL bandwidth
-   * \param dlBandwidth DL bandwidth
-   */
   void DoSetBandwidth (uint8_t ulBandwidth, uint8_t dlBandwidth);
-  /**
-   * Set EARFCN
-   *
-   * \param dlEarfcn DL EARFCN
-   * \param ulEarfcn UL EARFCN
-   */
-  void DoSetEarfcn (uint32_t dlEarfcn, uint32_t ulEarfcn);
-  /**
-   * Add UE
-   *
-   * \param rnti RNTI
-   */
+  void DoSetEarfcn (uint16_t dlEarfcn, uint16_t ulEarfcn);
   void DoAddUe (uint16_t rnti);
-  /**
-   * Remove UE
-   *
-   * \param rnti RNTI
-   */
   void DoRemoveUe (uint16_t rnti);
-  /**
-   * Set PA
-   *
-   * \param rnti RNTI
-   * \param pa PA
-   */
   void DoSetPa (uint16_t rnti, double pa);
-  /**
-   * Set transmission mode
-   *
-   * \param rnti RNTI
-   * \param txMode transmit mode
-   */
   void DoSetTransmissionMode (uint16_t  rnti, uint8_t txMode);
-  /**
-   * Set source configuration index
-   *
-   * \param rnti RNTI
-   * \param srcCi source configuration index
-   */
   void DoSetSrsConfigurationIndex (uint16_t  rnti, uint16_t srcCi);
-  /**
-   * Set master information block
-   *
-   * \param mib LteRrcSap::MasterInformationBlock
-   */
   void DoSetMasterInformationBlock (LteRrcSap::MasterInformationBlock mib);
-  /**
-   * Set system information block
-   *
-   * \param sib1 LteRrcSap::SystemInformationBlockType1
-   */
   void DoSetSystemInformationBlockType1 (LteRrcSap::SystemInformationBlockType1 sib1);
 
   // LteEnbPhySapProvider forwarded methods
   void DoSendMacPdu (Ptr<Packet> p);
-  /**
-   * Send LTE Control Message function
-   *
-   * \param msg LTE control message
-   */
   void DoSendLteControlMessage (Ptr<LteControlMessage> msg);
-  /**
-   * Get MAC ch TTI delay function
-   *
-   * \returns delay value
-   */
   uint8_t DoGetMacChTtiDelay ();
 
   /**
@@ -410,12 +335,6 @@
    */
   bool DeleteUePhy (uint16_t rnti);
 
-  /**
-   * Create SRS report function
-   *
-   * \param rnti the RNTI
-   * \param srs the SRS
-   */
   void CreateSrsReport (uint16_t rnti, double srs);
 
   /**
@@ -439,16 +358,16 @@
    */
   std::vector <int> m_listOfDownlinkSubchannel;
 
-  std::vector <int> m_dlDataRbMap; ///< DL data RB map
+  std::vector <int> m_dlDataRbMap;
 
   /// For storing info on future receptions.
   std::vector< std::list<UlDciLteControlMessage> > m_ulDciQueue;
 
-  LteEnbPhySapProvider* m_enbPhySapProvider; ///< ENB Phy SAP provider
-  LteEnbPhySapUser* m_enbPhySapUser; ///< ENB Phy SAP user
+  LteEnbPhySapProvider* m_enbPhySapProvider;
+  LteEnbPhySapUser* m_enbPhySapUser;
 
-  LteEnbCphySapProvider* m_enbCphySapProvider; ///< ENB CPhy SAP provider
-  LteEnbCphySapUser* m_enbCphySapUser; ///< ENB CPhy SAP user
+  LteEnbCphySapProvider* m_enbCphySapProvider;
+  LteEnbCphySapUser* m_enbCphySapUser;
 
   /**
    * The frame number currently served. In ns-3, frame number starts from 1.
@@ -462,11 +381,11 @@
    */
   uint32_t m_nrSubFrames;
 
-  uint16_t m_srsPeriodicity; ///< SRS periodicity
-  Time m_srsStartTime; ///< SRS start time
-  std::map <uint16_t,uint16_t> m_srsCounter; ///< SRS counter
-  std::vector <uint16_t> m_srsUeOffset; ///< SRS UE offset
-  uint16_t m_currentSrsOffset; ///< current SRS offset
+  uint16_t m_srsPeriodicity;
+  Time m_srsStartTime;
+  std::map <uint16_t,uint16_t> m_srsCounter;
+  std::vector <uint16_t> m_srsUeOffset;
+  uint16_t m_currentSrsOffset;
 
   /**
    * The Master Information Block message to be broadcasted every frame.
@@ -480,11 +399,11 @@
    */
   LteRrcSap::SystemInformationBlockType1 m_sib1;
 
-  Ptr<LteHarqPhy> m_harqPhyModule; ///< HARQ Phy module
+  Ptr<LteHarqPhy> m_harqPhyModule;
 
   /**
    * The `ReportUeSinr` trace source. Reporting the linear average of SRS SINR.
-   * Exporting cell ID, RNTI, SINR in linear unit and ComponentCarrierId
+   * Exporting cell ID, RNTI, and SINR in linear unit.
    */
   TracedCallback<uint16_t, uint16_t, double, uint8_t> m_reportUeSinr;
   /**
@@ -492,7 +411,7 @@
    * UEs' SINR stats.
    */
   uint16_t m_srsSamplePeriod;
-  std::map <uint16_t,uint16_t> m_srsSampleCounterMap; ///< SRS sample counter map
+  std::map <uint16_t,uint16_t> m_srsSampleCounterMap;
 
   /**
    * The `ReportInterference` trace source. Reporting the interference per PHY
@@ -508,7 +427,7 @@
    * \todo In what unit is this?
    */
   uint16_t m_interferenceSamplePeriod;
-  uint16_t m_interferenceSampleCounter; ///< interference sample counter
+  uint16_t m_interferenceSampleCounter;
 
   /**
    * The `DlPhyTransmission` trace source. Contains trace information regarding
diff -Naru a/model/lte-enb-phy-sap.h b/model/lte-enb-phy-sap.h
--- a/model/lte-enb-phy-sap.h	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-phy-sap.h	2017-10-05 11:47:22.310601768 +0200
@@ -57,7 +57,7 @@
   
   /**
   * \brief Get the delay from MAC to Channel expressed in TTIs
-  * \returns MAC channel TTI delay
+  *
   */
   virtual uint8_t GetMacChTtiDelay () = 0;
 
diff -Naru a/model/lte-enb-rrc.cc b/model/lte-enb-rrc.cc
--- a/model/lte-enb-rrc.cc	2017-10-05 11:46:52.206493945 +0200
+++ b/model/lte-enb-rrc.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,8 +19,8 @@
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Marco Miozzo <mmiozzo@cttc.es>
  *          Manuel Requena <manuel.requena@cttc.es>
- * Modified by:  Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015),
- *               Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ * Modified by Michele Polese <michele.polese@gmail.com> for DC functionalities
+ * Lossless HO code from https://github.com/binhqnguyen/lena
  */
 
 #include "lte-enb-rrc.h"
@@ -41,8 +42,14 @@
 #include <ns3/lte-rlc-tm.h>
 #include <ns3/lte-rlc-um.h>
 #include <ns3/lte-rlc-am.h>
+#include <ns3/lte-rlc-am-header.h>
+#include <ns3/lte-rlc-sdu-status-tag.h>
 #include <ns3/lte-pdcp.h>
-
+#include <ns3/lte-pdcp-header.h>
+#include <ns3/lte-rlc-um-lowlat.h>
+#include <ns3/mc-enb-pdcp.h>
+#include "ns3/lte-pdcp-tag.h"
+#include <ns3/lte-rlc-sap.h>
 
 
 
@@ -60,32 +67,25 @@
 class EnbRrcMemberLteEnbCmacSapUser : public LteEnbCmacSapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param rrc ENB RRC
-   */
-  EnbRrcMemberLteEnbCmacSapUser (LteEnbRrc* rrc, uint8_t componentCarrierId);
+  EnbRrcMemberLteEnbCmacSapUser (LteEnbRrc* rrc);
 
   virtual uint16_t AllocateTemporaryCellRnti ();
   virtual void NotifyLcConfigResult (uint16_t rnti, uint8_t lcid, bool success);
   virtual void RrcConfigurationUpdateInd (UeConfig params);
 
 private:
-  LteEnbRrc* m_rrc; ///< the RRC
-  uint8_t m_componentCarrierId; ///< Component carrier ID
+  LteEnbRrc* m_rrc;
 };
 
-EnbRrcMemberLteEnbCmacSapUser::EnbRrcMemberLteEnbCmacSapUser (LteEnbRrc* rrc, uint8_t componentCarrierId)
+EnbRrcMemberLteEnbCmacSapUser::EnbRrcMemberLteEnbCmacSapUser (LteEnbRrc* rrc)
   : m_rrc (rrc)
-  , m_componentCarrierId {componentCarrierId}
 {
 }
 
 uint16_t
 EnbRrcMemberLteEnbCmacSapUser::AllocateTemporaryCellRnti ()
 {
-  return m_rrc->DoAllocateTemporaryCellRnti (m_componentCarrierId);
+  return m_rrc->DoAllocateTemporaryCellRnti ();
 }
 
 void
@@ -120,6 +120,8 @@
   "HANDOVER_JOINING",
   "HANDOVER_PATH_SWITCH",
   "HANDOVER_LEAVING",
+  "PREPARE_MC_CONNECTION_RECONFIGURATION",
+  "MC_CONNECTION_RECONFIGURATION"
 };
 
 /**
@@ -137,15 +139,14 @@
 
 UeManager::UeManager ()
 {
-  NS_FATAL_ERROR ("this constructor is not expected to be used");
+  NS_FATAL_ERROR ("this constructor is not espected to be used");
 }
 
 
-UeManager::UeManager (Ptr<LteEnbRrc> rrc, uint16_t rnti, State s, uint8_t componentCarrierId)
+UeManager::UeManager (Ptr<LteEnbRrc> rrc, uint16_t rnti, State s)
   : m_lastAllocatedDrbid (0),
     m_rnti (rnti),
     m_imsi (0),
-    m_componentCarrierId (componentCarrierId),
     m_lastRrcTransactionIdentifier (0),
     m_rrc (rrc),
     m_state (s),
@@ -153,8 +154,9 @@
     m_sourceX2apId (0),
     m_sourceCellId (0),
     m_needPhyMacConfiguration (false),
-    m_caSupportConfigured (false),
-    m_pendingStartDataRadioBearers (false)
+    m_x2forwardingBufferSize (0),
+    m_maxx2forwardingBufferSize (2*1024),
+    m_allMmWaveInOutageAtInitialAccess (false)
 { 
   NS_LOG_FUNCTION (this);
 }
@@ -174,12 +176,10 @@
   m_physicalConfigDedicated.havePdschConfigDedicated = true;
   m_physicalConfigDedicated.pdschConfigDedicated.pa = LteRrcSap::PdschConfigDedicated::dB0;
 
-  
-  for (uint8_t i = 0; i < m_rrc->m_numberOfComponentCarriers; i++)
-    {
-      m_rrc->m_cmacSapProvider.at (i)->AddUe (m_rnti);
-      m_rrc->m_cphySapProvider.at (i)->AddUe (m_rnti);
-    }
+  m_rlcMap.clear();
+
+  m_rrc->m_cmacSapProvider->AddUe (m_rnti);
+  m_rrc->m_cphySapProvider->AddUe (m_rnti);
 
   // setup the eNB side of SRB0
   {
@@ -198,21 +198,9 @@
     LteEnbCmacSapProvider::LcInfo lcinfo;
     lcinfo.rnti = m_rnti;
     lcinfo.lcId = lcid;
-    // Initialise the rest of lcinfo structure even if CCCH (LCID 0) is pre-configured, and only m_rnti and lcid will be used from passed lcinfo structure.
-    // See FF LTE MAC Scheduler Iinterface Specification v1.11, 4.3.4 logicalChannelConfigListElement
-    lcinfo.lcGroup = 0;
-    lcinfo.qci = 0;
-    lcinfo.isGbr = false;
-    lcinfo.mbrUl = 0;
-    lcinfo.mbrDl = 0;
-    lcinfo.gbrUl = 0;
-    lcinfo.gbrDl = 0;
-
-    // MacSapUserForRlc in the ComponentCarrierManager MacSapUser
-    LteMacSapUser* lteMacSapUser = m_rrc->m_ccmRrcSapProvider->ConfigureSignalBearer(lcinfo, rlc->GetLteMacSapUser ()); 
-    // Signal Channel are only on Primary Carrier
-    m_rrc->m_cmacSapProvider.at (m_componentCarrierId)->AddLc (lcinfo, lteMacSapUser);
-    m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, lteMacSapUser);
+    // leave the rest of lcinfo empty as CCCH (LCID 0) is pre-configured
+    m_rrc->m_cmacSapProvider->AddLc (lcinfo, rlc->GetLteMacSapUser ());
+
   }
 
   // setup the eNB side of SRB1; the UE side will be set up upon RRC connection establishment
@@ -250,11 +238,7 @@
     lcinfo.mbrDl = 1e6;
     lcinfo.gbrUl = 1e4;
     lcinfo.gbrDl = 1e4;
-    // MacSapUserForRlc in the ComponentCarrierManager MacSapUser
-    LteMacSapUser* MacSapUserForRlc = m_rrc->m_ccmRrcSapProvider->ConfigureSignalBearer(lcinfo, rlc->GetLteMacSapUser ()); 
-    // Signal Channel are only on Primary Carrier
-    m_rrc->m_cmacSapProvider.at (m_componentCarrierId)->AddLc (lcinfo, MacSapUserForRlc);
-    m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, MacSapUserForRlc);
+    m_rrc->m_cmacSapProvider->AddLc (lcinfo, rlc->GetLteMacSapUser ());
   }
 
   LteEnbRrcSapUser::SetupUeParameters ueParams;
@@ -266,14 +250,12 @@
   LteEnbCmacSapProvider::UeConfig req;
   req.m_rnti = m_rnti;
   req.m_transmissionMode = m_physicalConfigDedicated.antennaInfo.transmissionMode;
+  m_rrc->m_cmacSapProvider->UeUpdateConfigurationReq (req);
 
   // configure PHY
-  for (uint16_t i = 0; i < m_rrc->m_numberOfComponentCarriers; i++)
-    {
-      m_rrc->m_cmacSapProvider.at (i)->UeUpdateConfigurationReq (req);
-      m_rrc->m_cphySapProvider.at (i)->SetTransmissionMode (m_rnti, m_physicalConfigDedicated.antennaInfo.transmissionMode);
-      m_rrc->m_cphySapProvider.at (i)->SetSrsConfigurationIndex (m_rnti, m_physicalConfigDedicated.soundingRsUlConfigDedicated.srsConfigIndex);
-    }
+  m_rrc->m_cphySapProvider->SetTransmissionMode (m_rnti, m_physicalConfigDedicated.antennaInfo.transmissionMode);
+  m_rrc->m_cphySapProvider->SetSrsConfigurationIndex (m_rnti, m_physicalConfigDedicated.soundingRsUlConfigDedicated.srsConfigIndex);
+
   // schedule this UeManager instance to be deleted if the UE does not give any sign of life within a reasonable time
   Time maxConnectionDelay;
   switch (m_state)
@@ -294,7 +276,12 @@
       NS_FATAL_ERROR ("unexpected state " << ToString (m_state));
       break;
     }
-  m_caSupportConfigured =  false;
+  m_firstConnection = false;
+  m_mmWaveCellId = 0;
+  m_mmWaveRnti = 0;
+  m_mmWaveCellAvailableForMcSetup = false;
+  m_receivedLteMmWaveHandoverCompleted = false;
+  m_queuedHandoverRequestCellId = 0;
 }
 
 
@@ -306,6 +293,7 @@
 UeManager::DoDispose ()
 {
   delete m_drbPdcpSapUser;
+  m_rlcMap.clear();
   // delete eventual X2-U TEIDs
   for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it = m_drbMap.begin ();
        it != m_drbMap.end ();
@@ -325,6 +313,10 @@
                    ObjectMapValue (),
                    MakeObjectMapAccessor (&UeManager::m_drbMap),
                    MakeObjectMapChecker<LteDataRadioBearerInfo> ())
+    .AddAttribute ("DataRadioRlcMap", "List of UE Secondary RLC by DRBID.",
+                   ObjectMapValue (),
+                   MakeObjectMapAccessor (&UeManager::m_rlcMap),
+                   MakeObjectMapChecker<RlcBearerInfo> ())
     .AddAttribute ("Srb0", "SignalingRadioBearerInfo for SRB0",
                    PointerValue (),
                    MakePointerAccessor (&UeManager::m_srb0),
@@ -344,6 +336,10 @@
                      "UeManager at the eNB RRC",
                      MakeTraceSourceAccessor (&UeManager::m_stateTransitionTrace),
                      "ns3::UeManager::StateTracedCallback")
+    .AddTraceSource ("SecondaryRlcCreated",
+                     "fired upon receiving RecvRlcSetupRequest",
+                     MakeTraceSourceAccessor (&UeManager::m_secondaryRlcCreatedTrace),
+                     "ns3::UeManager::ImsiCidRntiTracedCallback")
   ;
   return tid;
 }
@@ -355,6 +351,12 @@
   m_sourceCellId = sourceCellId;
 }
 
+std::pair<uint16_t, uint16_t>
+UeManager::GetSource (void)
+{
+  return std::pair<uint16_t, uint16_t> (m_sourceCellId, m_sourceX2apId);
+}
+
 void 
 UeManager::SetImsi (uint64_t imsi)
 {
@@ -362,7 +364,25 @@
 }
 
 void
-UeManager::SetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint32_t gtpTeid, Ipv4Address transportLayerAddress)
+UeManager::SetIsMc (bool isMc)
+{
+  m_isMc = isMc;
+}
+
+//void
+//UeManager::SetIsInterRatHoCapable (bool isInterRatHoCapable)
+//{
+//  m_isInterRatHoCapable = isInterRatHoCapable;
+//}
+
+bool
+UeManager::GetIsMc () const
+{
+  return m_isMc;
+}
+
+void
+UeManager::SetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint32_t gtpTeid, Ipv4Address transportLayerAddress) 
 {
   NS_LOG_FUNCTION (this << (uint32_t) m_rnti);
 
@@ -371,7 +391,6 @@
   uint8_t lcid = Drbid2Lcid (drbid); 
   uint8_t bid = Drbid2Bid (drbid);
   NS_ASSERT_MSG ( bearerId == 0 || bid == bearerId, "bearer ID mismatch (" << (uint32_t) bid << " != " << (uint32_t) bearerId << ", the assumption that ID are allocated in the same way by MME and RRC is not valid any more");
-  drbInfo->m_epsBearer = bearer;
   drbInfo->m_epsBearerIdentity = bid;
   drbInfo->m_drbIdentity = drbid;
   drbInfo->m_logicalChannelIdentity = lcid;
@@ -405,7 +424,8 @@
   // if we are using RLC/SM we don't care of anything above RLC
   if (rlcTypeId != LteRlcSm::GetTypeId ())
     {
-      Ptr<LtePdcp> pdcp = CreateObject<LtePdcp> ();
+      Ptr<McEnbPdcp> pdcp = CreateObject<McEnbPdcp> (); // Modified with McEnbPdcp to support MC
+                                                        // This will allow to add an X2 interface to pdcp
       pdcp->SetRnti (m_rnti);
       pdcp->SetLcId (lcid);
       pdcp->SetLtePdcpSapUser (m_drbPdcpSapUser);
@@ -414,30 +434,17 @@
       drbInfo->m_pdcp = pdcp;
     }
 
-  std::vector<LteCcmRrcSapProvider::LcsConfig> lcOnCcMapping = m_rrc->m_ccmRrcSapProvider->SetupDataRadioBearer (bearer, bearerId, m_rnti, lcid, m_rrc->GetLogicalChannelGroup (bearer), rlc->GetLteMacSapUser ());
-  // LteEnbCmacSapProvider::LcInfo lcinfo;
-  // lcinfo.rnti = m_rnti;
-  // lcinfo.lcId = lcid;
-  // lcinfo.lcGroup = m_rrc->GetLogicalChannelGroup (bearer);
-  // lcinfo.qci = bearer.qci;
-  // lcinfo.isGbr = bearer.IsGbr ();
-  // lcinfo.mbrUl = bearer.gbrQosInfo.mbrUl;
-  // lcinfo.mbrDl = bearer.gbrQosInfo.mbrDl;
-  // lcinfo.gbrUl = bearer.gbrQosInfo.gbrUl;
-  // lcinfo.gbrDl = bearer.gbrQosInfo.gbrDl;
-  // use a for cycle to send the AddLc to the appropriate Mac Sap
-  // if the sap is not initialized the appropriated method has to be called
-  std::vector<LteCcmRrcSapProvider::LcsConfig>::iterator itLcOnCcMapping = lcOnCcMapping.begin ();
-  NS_ASSERT_MSG (itLcOnCcMapping != lcOnCcMapping.end (), "Problem");
-  for (itLcOnCcMapping = lcOnCcMapping.begin (); itLcOnCcMapping != lcOnCcMapping.end (); ++itLcOnCcMapping)
-    {
-      NS_LOG_DEBUG (this << " RNTI " << itLcOnCcMapping->lc.rnti << "Lcid " << (uint16_t) itLcOnCcMapping->lc.lcId << " lcGroup " << (uint16_t) itLcOnCcMapping->lc.lcGroup << " ComponentCarrierId " << itLcOnCcMapping->componentCarrierId);
-      uint8_t index = itLcOnCcMapping->componentCarrierId;
-      LteEnbCmacSapProvider::LcInfo lcinfo = itLcOnCcMapping->lc;
-      LteMacSapUser *msu = itLcOnCcMapping->msu;
-      m_rrc->m_cmacSapProvider.at (index)->AddLc (lcinfo, msu);
-      m_rrc->m_ccmRrcSapProvider->AddLc (lcinfo, msu);
-    }
+  LteEnbCmacSapProvider::LcInfo lcinfo;
+  lcinfo.rnti = m_rnti;
+  lcinfo.lcId = lcid;
+  lcinfo.lcGroup = m_rrc->GetLogicalChannelGroup (bearer);
+  lcinfo.qci = bearer.qci;
+  lcinfo.isGbr = bearer.IsGbr ();
+  lcinfo.mbrUl = bearer.gbrQosInfo.mbrUl;
+  lcinfo.mbrDl = bearer.gbrQosInfo.mbrDl;
+  lcinfo.gbrUl = bearer.gbrQosInfo.gbrUl;
+  lcinfo.gbrDl = bearer.gbrQosInfo.gbrDl;
+  m_rrc->m_cmacSapProvider->AddLc (lcinfo, rlc->GetLteMacSapUser ());
 
   if (rlcTypeId == LteRlcAm::GetTypeId ())
     {
@@ -461,6 +468,22 @@
     }
   drbInfo->m_logicalChannelConfig.bucketSizeDurationMs = 1000;
 
+  EpcX2Sap::RlcSetupRequest req;
+  req.sourceCellId = m_rrc->GetCellId();
+  req.gtpTeid = drbInfo->m_gtpTeid;
+  req.lteRnti = m_rnti;
+  req.drbid = drbid;
+  req.lcinfo = lcinfo;
+  req.logicalChannelConfig = drbInfo->m_logicalChannelConfig;
+  req.rlcConfig = drbInfo->m_rlcConfig;
+  req.targetCellId = 0;
+  req.mmWaveRnti = 0;
+  // mmWaveRnti & targetCellId will be set before sending the request
+  drbInfo->m_rlcSetupRequest = req;
+
+  drbInfo->m_epsBearer = bearer;
+  drbInfo->m_isMc = false;
+
   ScheduleRrcConnectionReconfiguration ();
 }
 
@@ -508,13 +531,8 @@
   m_rrc->m_x2uTeidInfoMap.erase (it->second->m_gtpTeid);
 
   m_drbMap.erase (it);
-  std::vector<uint8_t> ccToRelease = m_rrc->m_ccmRrcSapProvider->ReleaseDataRadioBearer (m_rnti, lcid);
-  std::vector<uint8_t>::iterator itCcToRelease = ccToRelease.begin ();
-  NS_ASSERT_MSG (itCcToRelease != ccToRelease.end (), "request to remove radio bearer with unknown drbid (ComponentCarrierManager)");
-  for (itCcToRelease = ccToRelease.begin (); itCcToRelease != ccToRelease.end (); ++itCcToRelease)
-    {
-      m_rrc->m_cmacSapProvider.at (*itCcToRelease)->ReleaseLc (m_rnti, lcid);
-    }
+  m_rrc->m_cmacSapProvider->ReleaseLc (m_rnti, lcid);
+
   LteRrcSap::RadioResourceConfigDedicated rrcd;
   rrcd.havePhysicalConfigDedicated = false;
   rrcd.drbToReleaseList.push_back (drbid);
@@ -528,9 +546,6 @@
   msg.haveMobilityControlInfo = false;
   msg.radioResourceConfigDedicated = rrcd;
   msg.haveRadioResourceConfigDedicated = true;
-  // ToDo: Resend in eny case this configuration
-  // needs to be initialized
-  msg.haveNonCriticalExtension = false;
   //RRC Connection Reconfiguration towards UE
   m_rrc->m_rrcSapUser->SendRrcConnectionReconfiguration (m_rnti, msg);
 }
@@ -572,6 +587,22 @@
       }
       break;
 
+    case PREPARE_MC_CONNECTION_RECONFIGURATION:
+      {
+        m_pendingRrcConnectionReconfiguration = false;
+        LteRrcSap::RrcConnectionReconfiguration msg = BuildRrcConnectionReconfiguration ();
+        msg.haveMeasConfig = false;
+        msg.haveMobilityControlInfo = false;
+        msg.radioResourceConfigDedicated.srbToAddModList.clear();
+        msg.radioResourceConfigDedicated.physicalConfigDedicated.haveAntennaInfoDedicated = false;
+        msg.radioResourceConfigDedicated.physicalConfigDedicated.haveSoundingRsUlConfigDedicated = false;
+        msg.radioResourceConfigDedicated.physicalConfigDedicated.havePdschConfigDedicated = false;
+        m_rrc->m_rrcSapUser->SendRrcConnectionReconfiguration (m_rnti, msg);
+        RecordDataRadioBearersToBeStarted ();
+        SwitchToState (MC_CONNECTION_RECONFIGURATION);
+      }
+      break;
+
     default:
       NS_FATAL_ERROR ("method unexpected in state " << ToString (m_state));
       break;
@@ -590,12 +621,16 @@
         EpcX2SapProvider::HandoverRequestParams params;
         params.oldEnbUeX2apId = m_rnti;
         params.cause          = EpcX2SapProvider::HandoverDesirableForRadioReason;
-        params.sourceCellId   = m_rrc->ComponentCarrierToCellId (m_componentCarrierId);
+        params.sourceCellId   = m_rrc->m_cellId;
         params.targetCellId   = cellId;
         params.mmeUeS1apId    = m_imsi;
         params.ueAggregateMaxBitRateDownlink = 200 * 1000;
         params.ueAggregateMaxBitRateUplink = 100 * 1000;
         params.bearers = GetErabList ();
+        params.rlcRequests = m_rlcRequestVector;
+        // clear the vector to avoid keeping old information
+        // the target eNB will add the rlcRequests in its own vector
+        m_rlcRequestVector.clear();
 
         LteRrcSap::HandoverPreparationInfo hpi;
         hpi.asConfig.sourceUeIdentity = m_rnti;
@@ -604,11 +639,11 @@
         hpi.asConfig.sourceRadioResourceConfig = GetRadioResourceConfigForHandoverPreparationInfo ();
         hpi.asConfig.sourceMasterInformationBlock.dlBandwidth = m_rrc->m_dlBandwidth;
         hpi.asConfig.sourceMasterInformationBlock.systemFrameNumber = 0;
-        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity = m_rrc->m_sib1.at (m_componentCarrierId).cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity;
-        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.cellIdentity = m_rrc->ComponentCarrierToCellId (m_componentCarrierId);
-        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.csgIndication = m_rrc->m_sib1.at (m_componentCarrierId).cellAccessRelatedInfo.csgIndication;
-        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.csgIdentity = m_rrc->m_sib1.at (m_componentCarrierId).cellAccessRelatedInfo.csgIdentity;
-        LteEnbCmacSapProvider::RachConfig rc = m_rrc->m_cmacSapProvider.at (m_componentCarrierId)->GetRachConfig ();
+        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity = m_rrc->m_sib1.cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity;
+        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.cellIdentity = m_rrc->m_cellId;
+        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.csgIndication = m_rrc->m_sib1.cellAccessRelatedInfo.csgIndication;
+        hpi.asConfig.sourceSystemInformationBlockType1.cellAccessRelatedInfo.csgIdentity = m_rrc->m_sib1.cellAccessRelatedInfo.csgIdentity;
+        LteEnbCmacSapProvider::RachConfig rc = m_rrc->m_cmacSapProvider->GetRachConfig ();
         hpi.asConfig.sourceSystemInformationBlockType2.radioResourceConfigCommon.rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
         hpi.asConfig.sourceSystemInformationBlockType2.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
         hpi.asConfig.sourceSystemInformationBlockType2.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
@@ -616,6 +651,8 @@
         hpi.asConfig.sourceSystemInformationBlockType2.freqInfo.ulBandwidth = m_rrc->m_ulBandwidth;
         params.rrcContext = m_rrc->m_rrcSapUser->EncodeHandoverPreparationInformation (hpi);
 
+        params.isMc = m_isMc;
+
         NS_LOG_LOGIC ("oldEnbUeX2apId = " << params.oldEnbUeX2apId);
         NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
         NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
@@ -627,6 +664,14 @@
       }
       break;
 
+    case CONNECTION_RECONFIGURATION:
+    case HANDOVER_JOINING: // there may be some delays in the TX of RRC messages, thus an handover may be completed at UE side, but not at eNB side
+      {
+        m_queuedHandoverRequestCellId = cellId;
+        NS_LOG_INFO("UeManager is in CONNECTION_RECONFIGURATION, postpone the PrepareHandover command to cell " << m_queuedHandoverRequestCellId);
+      }
+      break;
+
     default:
       NS_FATAL_ERROR ("method unexpected in state " << ToString (m_state));
       break;
@@ -634,6 +679,70 @@
 
 }
 
+/*
+ * Merge 2 buffers of RlcAmPdus into 1 vector with increment order of Pdus
+ */
+std::vector < LteRlcAm::RetxPdu >
+UeManager::MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second)
+{
+  LteRlcAmHeader rlcamHeader_1, rlcamHeader_2;
+  std::vector < LteRlcAm::RetxPdu> result;
+  std::vector < LteRlcAm::RetxPdu>::iterator it_1 = first.begin();
+  std::vector < LteRlcAm::RetxPdu>::iterator it_2 = second.begin();
+  bool end_1_reached = false;
+  bool end_2_reached = false;
+  while (it_1 != first.end() && it_2 != second.end()){
+    while ((*it_1).m_pdu == 0){
+      ++it_1;
+      if(it_1 == first.end())
+      {
+        end_1_reached = true;
+        break;
+      }
+    }
+    while ((*it_2).m_pdu == 0){
+      ++it_2;
+      if(it_2 == second.end())
+      {
+        end_2_reached = true;
+        break;
+      }
+    }
+    if(!end_1_reached && !end_2_reached)
+    {
+      (*it_1).m_pdu->PeekHeader(rlcamHeader_1);
+      (*it_2).m_pdu->PeekHeader(rlcamHeader_2);
+      if (rlcamHeader_1.GetSequenceNumber() > rlcamHeader_2.GetSequenceNumber()){
+        result.push_back((*it_2));  
+        ++it_2;       
+      }
+      else if (rlcamHeader_2.GetSequenceNumber() > rlcamHeader_1.GetSequenceNumber()){
+        result.push_back((*it_1));
+        ++it_1;         
+      }
+      else {
+        result.push_back((*it_1));
+        ++it_1;
+        ++it_2;
+      }
+      NS_LOG_DEBUG ("first,second = " << rlcamHeader_1.GetSequenceNumber() << "," << rlcamHeader_2.GetSequenceNumber());
+    }
+    else
+    {
+      break;
+    }
+  }
+  while (it_1 != first.end()){
+    result.push_back((*it_1));
+    it_1++;
+  }
+  while (it_2 != second.end()){
+    result.push_back((*it_2));
+    it_2++;
+  }
+  return result;
+}
+
 void 
 UeManager::RecvHandoverRequestAck (EpcX2SapUser::HandoverRequestAckParams params)
 {
@@ -648,6 +757,8 @@
   // support both a real RRC protocol implementation and an ideal one
   // without actual RRC protocol encoding. 
 
+  // TODO for MC devices, when performing handover between mmWave cells, forward the Rlc buffers
+
   Ptr<Packet> encodedHandoverCommand = params.rrcContext;
   LteRrcSap::RrcConnectionReconfiguration handoverCommand = m_rrc->m_rrcSapUser->DecodeHandoverCommand (encodedHandoverCommand);
   m_rrc->m_rrcSapUser->SendRrcConnectionReconfiguration (m_rnti, handoverCommand);
@@ -655,8 +766,9 @@
   m_handoverLeavingTimeout = Simulator::Schedule (m_rrc->m_handoverLeavingTimeoutDuration, 
                                                   &LteEnbRrc::HandoverLeavingTimeout, 
                                                   m_rrc, m_rnti);
+  // TODO check the actions to be performed when timeout expires
   NS_ASSERT (handoverCommand.haveMobilityControlInfo);
-  m_rrc->m_handoverStartTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti, handoverCommand.mobilityControlInfo.targetPhysCellId);
+  m_rrc->m_handoverStartTrace (m_imsi, m_rrc->m_cellId, m_rnti, handoverCommand.mobilityControlInfo.targetPhysCellId);
 
   EpcX2SapProvider::SnStatusTransferParams sst;
   sst.oldEnbUeX2apId = params.oldEnbUeX2apId;
@@ -678,6 +790,284 @@
         }
     }
   m_rrc->m_x2SapProvider->SendSnStatusTransfer (sst);
+
+  // on a mmWave eNB, for a UeManager of an MC device, notify the EpcX2 class that it has to forward the incoming packets
+  if(m_rrc->m_ismmWave && m_isMc)
+  {
+    NS_LOG_INFO("Notify the X2 that packets with a certain TEID must be forwarded to the targetCell");
+    for(std::map <uint8_t, Ptr<RlcBearerInfo> >::iterator rlcIt = m_rlcMap.begin ();
+          rlcIt != m_rlcMap.end ();
+          ++rlcIt)
+    {
+      m_rrc->m_x2SapProvider->AddTeidToBeForwarded(rlcIt->second->gtpTeid, params.targetCellId);    
+    }
+  }
+
+  // LL HO
+  //Forward RlcTxBuffers to target eNodeb.
+  // TODO forwarding for secondary cell HO
+  NS_LOG_INFO("m_drbMap size " << m_drbMap.size() << " in cell " << m_rrc->m_cellId << " forward RLC buffers");
+  for ( std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbIt = m_drbMap.begin ();
+        drbIt != m_drbMap.end ();
+        ++drbIt)
+  {
+    ForwardRlcBuffers(drbIt->second->m_rlc, drbIt->second->m_pdcp, drbIt->second->m_gtpTeid, 0, 0, 0);
+  }
+
+  if(m_rrc->m_ismmWave && m_isMc) // for secondary cell HO
+  {
+    NS_LOG_INFO("m_rlcMap size " << m_rlcMap.size() << " in cell " << m_rrc->m_cellId << " forward RLC buffers");
+    for ( std::map <uint8_t, Ptr<RlcBearerInfo> >::iterator rlcIt = m_rlcMap.begin ();
+          rlcIt != m_rlcMap.end ();
+          ++rlcIt)
+    {
+      // the buffers are forwarded to m_targetCellId, which is set in PrepareHandover
+      // the target cell
+      ForwardRlcBuffers(rlcIt->second->m_rlc, 0, rlcIt->second->gtpTeid, 0, 1, 0);
+    }
+  }
+}
+
+// This code from the LL HO implementation is refactored in a function
+// in order to be used also when switching from LTE to MmWave and back
+void
+UeManager::ForwardRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint32_t gtpTeid, bool mcLteToMmWaveForwarding, bool mcMmToMmWaveForwarding, uint8_t bid)
+{
+  // RlcBuffers forwarding only for RlcAm bearers.
+  if (0 != rlc->GetObject<LteRlcAm> ())
+  {
+    //Copy lte-rlc-am.m_txOnBuffer to X2 forwarding buffer.
+    Ptr<LteRlcAm> rlcAm = rlc->GetObject<LteRlcAm>();
+    uint32_t txonBufferSize = rlcAm->GetTxBufferSize();
+    std::vector < Ptr<Packet> > txonBuffer = rlcAm->GetTxBuffer();
+    //m_x2forwardingBufferSize =  drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBufferSize();
+    //m_x2forwardingBuffer = drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBuffer();
+    uint32_t txedBufferSize = rlcAm->GetTxedBufferSize();
+    std::vector < LteRlcAm::RetxPdu > txedBuffer = rlcAm->GetTxedBuffer();
+    uint32_t retxBufferSize = rlcAm->GetRetxBufferSize();
+    std::vector < LteRlcAm::RetxPdu > retxBuffer = rlcAm->GetRetxBuffer();
+    
+    //Translate Pdus in Rlc txed/retx buffer into RLC Sdus
+    //and put these Sdus into rlcAm->m_transmittingRlcSdus.
+    NS_LOG_INFO("retxBuffer size = " << retxBufferSize);
+    NS_LOG_INFO("txedBuffer size = " << txedBufferSize);
+    //Merge txed and retx buffers into a single buffer before doing RlcPdusToRlc.
+    if ( retxBufferSize + txedBufferSize > 0 ){
+      std::vector< LteRlcAm::RetxPdu > sortedTxedRetxBuffer;
+      if (retxBufferSize == 0){
+        sortedTxedRetxBuffer = txedBuffer;
+      }
+      else if (txedBufferSize == 0){
+        sortedTxedRetxBuffer = retxBuffer;
+      }
+      else {
+        sortedTxedRetxBuffer = MergeBuffers(txedBuffer, retxBuffer);
+      }
+      rlcAm->RlcPdusToRlcSdus(sortedTxedRetxBuffer);  
+    }
+
+    //Construct the forwarding buffer
+    //Forwarding buffer = retxBuffer + txedBuffer + txonBuffer.
+    //if ( txonBufferSize > 0 )
+    //{
+      LtePdcpHeader pdcpHeader;
+      uint32_t pos = 0;
+      for (std::vector< Ptr<Packet> >::iterator it = txonBuffer.begin(); it != txonBuffer.end(); ++it)
+      {
+        pos++;
+        if((*it)->GetSize() > 3) 
+        {
+          (*it)->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG("txonBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+        }
+        else
+        {
+          NS_LOG_UNCOND("Fragment too small in txonBuffer, pos " << pos);
+        }
+          
+      }
+
+      // this cycle adds the SDUs given by the merge of txed and retxed buffers
+      if ( rlcAm->GetTransmittingRlcSduBufferSize() > 0 )
+      { //something inside the RLC AM's transmitting buffer 
+        NS_LOG_DEBUG ("ADDING TRANSMITTING SDUS OF RLC AM TO X2FORWARDINGBUFFER... Size = " << rlcAm->GetTransmittingRlcSduBufferSize() );
+        //copy the RlcSdu buffer (map) to forwardingBuffer.
+        std::map < uint32_t, Ptr<Packet> > rlcAmTransmittingBuffer = rlcAm->GetTransmittingRlcSduBuffer();
+        NS_LOG_DEBUG (" *** SIZE = " << rlcAmTransmittingBuffer.size());
+        for (std::map< uint32_t, Ptr<Packet> >::iterator it = rlcAmTransmittingBuffer.begin(); it != rlcAmTransmittingBuffer.end(); ++it)
+        {
+          if (it->second != 0)
+          {
+            NS_LOG_DEBUG ( this << " add to forwarding buffer SEQ = " << it->first << " Ptr<Packet> = " << it->second );
+            m_x2forwardingBuffer.push_back(it->second);
+          }
+        } 
+        NS_LOG_DEBUG(this << " ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+
+      
+        Ptr<Packet> segmentedRlcsdu = rlcAm->GetSegmentedRlcsdu();
+        if (segmentedRlcsdu != NULL){
+          segmentedRlcsdu->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG(this << "SegmentedRlcSdu = " << segmentedRlcsdu->GetSize() << " SEQ = " << pdcpHeader.GetSequenceNumber());
+          //insert the complete version of the fragmented SDU to the front of txonBuffer.
+          txonBuffer.insert(txonBuffer.begin(),segmentedRlcsdu);
+        }
+        m_x2forwardingBuffer.insert(m_x2forwardingBuffer.end(), txonBuffer.begin(), txonBuffer.end());
+        m_x2forwardingBufferSize += rlcAm->GetTransmittingRlcSduBufferSize() + txonBufferSize;
+
+        //Get the rlcAm
+        std::vector < Ptr <Packet> > rlcAmTxedSduBuffer = rlcAm->GetTxedRlcSduBuffer();
+        LtePdcpHeader pdcpHeader_1;
+        m_x2forwardingBuffer.at(0)->PeekHeader(pdcpHeader_1);
+        uint16_t i = 0;
+        for (std::vector< Ptr<Packet> >::iterator it = rlcAmTxedSduBuffer.begin(); it != rlcAmTxedSduBuffer.end(); ++it)
+        {
+          if ((*it) != NULL)
+          {
+            (*it)->PeekHeader(pdcpHeader);
+            NS_LOG_DEBUG("rlcAmTxedSduBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+          
+            //add the previous SDU of the forwarding buffer to the forwarding buffer.
+            if (pdcpHeader.GetSequenceNumber() >= (pdcpHeader_1.GetSequenceNumber() - 2) && pdcpHeader.GetSequenceNumber() <= (pdcpHeader_1.GetSequenceNumber()) )
+            {
+              NS_LOG_DEBUG("Added previous SDU to forwarding buffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+              m_x2forwardingBuffer.insert(m_x2forwardingBuffer.begin()+i, (*it)->Copy());
+              ++i;
+            }
+          }
+        }
+        
+      }
+      else 
+      { //TransmittingBuffer is empty. Only copy TxonBuffer.
+        NS_LOG_DEBUG(this << " ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+        m_x2forwardingBuffer = txonBuffer;
+        m_x2forwardingBufferSize += txonBufferSize;
+      }
+    //}
+  }
+  //For RlcUM, no forwarding available as the simulator itself (seamless HO).
+  //However, as the LTE-UMTS book, PDCP txbuffer should be forwarded for seamless 
+  //HO. Enable this code for txbuffer forwarding in seamless HO (which is believe to 
+  //be correct).
+  else if (0 != rlc->GetObject<LteRlcUm> ())
+  {
+    //Copy lte-rlc-um.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " Copying txonBuffer from RLC UM " << m_rnti);
+    m_x2forwardingBuffer = rlc->GetObject<LteRlcUm>()->GetTxBuffer();
+    m_x2forwardingBufferSize =  rlc->GetObject<LteRlcUm>()->GetTxBufferSize();
+  }
+  else if (0 != rlc->GetObject<LteRlcUmLowLat> ())
+  {
+    //Copy lte-rlc-um-low-lat.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " Copying txonBuffer from RLC UM " << m_rnti);
+    m_x2forwardingBuffer = rlc->GetObject<LteRlcUmLowLat>()->GetTxBuffer();
+    m_x2forwardingBufferSize =  rlc->GetObject<LteRlcUmLowLat>()->GetTxBufferSize();
+  }
+  //LteRlcAm m_txBuffer stores PDCP "PDU".
+  NS_LOG_DEBUG(this << " m_x2forw buffer size = " << m_x2forwardingBufferSize);
+    //Forwarding the packet inside m_x2forwardingBuffer to target eNB. 
+
+  // Prepare the variables for the LTE to MmWave DC forward
+  Ptr<McEnbPdcp> mcPdcp;
+  if(mcLteToMmWaveForwarding)
+  {
+    mcPdcp = DynamicCast<McEnbPdcp>(pdcp);
+    NS_ASSERT_MSG(mcPdcp != 0, "Invalid option for standard PDCP");
+    NS_ASSERT_MSG(bid > 0, "Bid can't be 0");
+    NS_ASSERT_MSG(mcPdcp->GetUseMmWaveConnection(), "The McEnbPdcp is not forwarding data to the mmWave eNB, check if the switch happened!");
+  }
+
+  while (!m_x2forwardingBuffer.empty())
+  {
+    NS_LOG_DEBUG(this << " Forwarding m_x2forwardingBuffer to target eNB, gtpTeid = " << gtpTeid );
+    EpcX2Sap::UeDataParams params;
+    params.sourceCellId = m_rrc->m_cellId;
+    params.targetCellId = m_targetCellId;
+    params.gtpTeid = gtpTeid;
+    //Remove tags to get PDCP SDU from PDCP PDU.
+    //Ptr<Packet> rlcSdu =  (*(m_x2forwardingBuffer.begin()))->Copy();
+    Ptr<Packet> rlcSdu =  m_x2forwardingBuffer.at(0);
+    //Tags to be removed from rlcSdu (from outer to inner)
+    //LteRlcSduStatusTag rlcSduStatusTag;
+    //RlcTag  rlcTag; //rlc layer timestamp
+    //PdcpTag pdcpTag;  //pdcp layer timestamp
+    LtePdcpHeader pdcpHeader;
+    
+    
+    NS_LOG_DEBUG ("RlcSdu size = " << rlcSdu->GetSize() );
+    //rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+    
+    //only forward data PDCP PDUs (1-DATA_PDU,0-CTR_PDU)
+    if(rlcSdu->GetSize() >= 3)
+    {
+      rlcSdu->PeekHeader(pdcpHeader);
+      if (pdcpHeader.GetDcBit() == 1 )
+      { //ignore control SDU.
+        NS_LOG_LOGIC ("SEQ = " << pdcpHeader.GetSequenceNumber());
+        NS_LOG_LOGIC ("removed pdcp header, size = " << rlcSdu->GetSize());
+
+        rlcSdu->RemoveAllPacketTags(); // this does not remove byte tags
+        NS_LOG_LOGIC ("removed tags, size = " << rlcSdu->GetSize() );
+        params.ueData = rlcSdu;
+        /*
+        rlcSdu->RemovePacketTag(rlcSduStatusTag); //remove Rlc status tag.
+        NS_LOG_DEBUG ("removed rlc status tag, size = " << rlcSdu->GetSize() );
+        rlcSdu->RemovePacketTag(rlcTag);  //remove Rlc timestamp
+        NS_LOG_DEBUG ("removed rlc timestamp, size = " << rlcSdu->GetSize() );
+        //rlcSdu->RemoveByteTag(pdcpTag); //remove pdcp timestamp
+        //NS_LOG_DEBUG ("removed pdcp timestamp, size = " << rlcSdu->GetSize());
+        */
+
+        if(!mcLteToMmWaveForwarding)
+        {
+          if(!mcMmToMmWaveForwarding)
+          {
+            rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+
+            NS_LOG_INFO("Forward to target cell in HO");
+            m_rrc->m_x2SapProvider->SendUeData (params);
+            NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+            NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+            NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+            NS_LOG_LOGIC ("ueData = " << params.ueData);
+            NS_LOG_LOGIC ("ueData size = " << params.ueData->GetSize ());
+          }
+          else
+          {
+            NS_LOG_INFO("Forward to target cell RLC in HO");
+            m_rrc->m_x2SapProvider->ForwardRlcPdu (params);
+            NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+            NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+            NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+            NS_LOG_LOGIC ("ueData = " << params.ueData);
+            NS_LOG_LOGIC ("ueData size = " << params.ueData->GetSize ());
+          }
+        }
+        else // the target eNB has no PDCP entity. Thus re-insert the packets in the 
+        // LTE eNB PDCP, which will forward them to the MmWave RLC entity. 
+        // Thus this method must be called after the switch to MmWave is done!
+        {
+          rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+          NS_LOG_INFO("Forward to mmWave cell in switch");
+          NS_ASSERT(mcPdcp != 0);
+          NS_ASSERT(mcPdcp->GetUseMmWaveConnection());
+          LtePdcpSapProvider::TransmitPdcpSduParameters pdcpParams;
+          pdcpParams.pdcpSdu = rlcSdu;
+          pdcpParams.rnti = m_rnti;
+          pdcpParams.lcid = Bid2Lcid (bid);
+          mcPdcp->GetLtePdcpSapProvider()->TransmitPdcpSdu(pdcpParams);
+        }
+      }
+    }
+    else
+    {
+      NS_LOG_UNCOND("Too small, not forwarded");
+    }
+    m_x2forwardingBufferSize -= (*(m_x2forwardingBuffer.begin()))->GetSize();
+    m_x2forwardingBuffer.erase (m_x2forwardingBuffer.begin());
+    NS_LOG_LOGIC(this << " After forwarding: buffer size = " << m_x2forwardingBufferSize );
+  }
 }
 
 
@@ -709,6 +1099,7 @@
 
     case CONNECTED_NORMALLY:
     case CONNECTION_RECONFIGURATION:
+    case MC_CONNECTION_RECONFIGURATION:
     case CONNECTION_REESTABLISHMENT:
     case HANDOVER_PREPARATION:
     case HANDOVER_JOINING:
@@ -728,7 +1119,7 @@
             if (bearerInfo != NULL)
               {
                 LtePdcpSapProvider* pdcpSapProvider = bearerInfo->m_pdcp->GetLtePdcpSapProvider ();
-                pdcpSapProvider->TransmitPdcpSdu (params);
+        pdcpSapProvider->TransmitPdcpSdu (params);
               }
           }
       }
@@ -736,14 +1127,32 @@
 
     case HANDOVER_LEAVING:
       {
-        NS_LOG_LOGIC ("forwarding data to target eNB over X2-U");
-        uint8_t drbid = Bid2Drbid (bid);
-        EpcX2Sap::UeDataParams params;
-        params.sourceCellId = m_rrc->ComponentCarrierToCellId (m_componentCarrierId);
-        params.targetCellId = m_targetCellId;
-        params.gtpTeid = GetDataRadioBearerInfo (drbid)->m_gtpTeid;
-        params.ueData = p;
-        m_rrc->m_x2SapProvider->SendUeData (params);
+        NS_LOG_LOGIC("SEQ SEQ HANDOVERLEAVING STATE LTE ENB RRC.");
+        //m_x2forwardingBuffer is empty, forward incomming pkts to target eNB.
+        if (m_x2forwardingBuffer.empty()){
+          NS_LOG_INFO ("forwarding incoming pkts to target eNB over X2-U");
+          NS_LOG_LOGIC ("forwarding data to target eNB over X2-U");
+          uint8_t drbid = Bid2Drbid (bid);        
+          EpcX2Sap::UeDataParams params;
+          params.sourceCellId = m_rrc->m_cellId;
+          params.targetCellId = m_targetCellId;
+          params.gtpTeid = GetDataRadioBearerInfo (drbid)->m_gtpTeid;
+          params.ueData = p;
+          NS_LOG_LOGIC("PDCP_FORWARDING_SEQ");
+          NS_LOG_LOGIC ("sourceCellId = " << params.sourceCellId);
+          NS_LOG_LOGIC ("targetCellId = " << params.targetCellId);
+          NS_LOG_LOGIC ("gtpTeid = " << params.gtpTeid);
+          NS_LOG_LOGIC ("ueData = " << params.ueData);
+          NS_LOG_LOGIC ("ueData size = " << params.ueData->GetSize ());
+          m_rrc->m_x2SapProvider->SendUeData (params);
+        }
+        //m_x2forwardingBuffer is not empty, append incomming pkts to m_x2forwardingBuffer.
+        //Forwarding of this m_x2forwardingBuffer is done in RecvHandoverRequestAck
+        else{
+          NS_LOG_INFO ("append incomming pkts to m_x2forwardingBuffer");
+          m_x2forwardingBuffer.push_back(p);
+          //NS_LOG_DEBUG("Forwarding but push_bach to buffer SEQ = " << pdcpHeader.GetSequenceNumber());
+        }
       }
       break;
 
@@ -785,10 +1194,9 @@
       ueCtxReleaseParams.oldEnbUeX2apId = m_sourceX2apId;
       ueCtxReleaseParams.newEnbUeX2apId = m_rnti;
       ueCtxReleaseParams.sourceCellId = m_sourceCellId;
-      ueCtxReleaseParams.targetCellId = m_targetCellId;
       m_rrc->m_x2SapProvider->SendUeContextRelease (ueCtxReleaseParams);
       SwitchToState (CONNECTED_NORMALLY);
-      m_rrc->m_handoverEndOkTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti);
+      m_rrc->m_handoverEndOkTrace (m_imsi, m_rrc->m_cellId, m_rnti);
       break;
 
     default:
@@ -809,6 +1217,11 @@
       SwitchToState (CONNECTED_NORMALLY);
       break;
 
+    case HANDOVER_LEAVING:
+      NS_ASSERT (cellId == m_targetCellId);
+      NS_LOG_INFO ("target eNB sent HO preparation failure, aborting HO because RrcConnectionReconfigurationCompleted was not received at target");
+      break;
+
     default:
       NS_FATAL_ERROR ("method unexpected in state " << ToString (m_state));
       break;
@@ -824,9 +1237,10 @@
        erabIt != params.erabsSubjectToStatusTransferList.end ();
        ++erabIt)
     {
-      // LtePdcp::Status status;
-      // status.txSn = erabIt->dlPdcpSn;
-      // status.rxSn = erabIt->ulPdcpSn;
+       LtePdcp::Status status;
+       status.txSn = erabIt->dlPdcpSn;
+       status.rxSn = erabIt->ulPdcpSn;
+        NS_LOG_DEBUG ("SN STATUS RECEIVED txSn, rxSn = " << status.txSn << "," << status.rxSn);
       // uint8_t drbId = Bid2Drbid (erabIt->erabId);
       // std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbIt = m_drbMap.find (drbId);
       // NS_ASSERT_MSG (drbIt != m_drbMap.end (), "could not find DRBID " << (uint32_t) drbId);
@@ -840,6 +1254,132 @@
   NS_LOG_FUNCTION (this);
   NS_ASSERT_MSG (m_state == HANDOVER_LEAVING, "method unexpected in state " << ToString (m_state));
   m_handoverLeavingTimeout.Cancel ();
+  NS_LOG_INFO("Remove UE " << m_rnti << " from eNB " << m_rrc->m_cellId);
+  if(m_rrc->m_ismmWave && m_isMc)
+  {
+    for (std::map<uint8_t, Ptr<RlcBearerInfo> >::iterator rlcIt = m_rlcMap.begin(); rlcIt != m_rlcMap.end(); ++rlcIt)
+    {
+      NS_LOG_INFO("Remove the X2 forward for TEID " << rlcIt->second->gtpTeid);
+      m_rrc->m_x2SapProvider->RemoveTeidToBeForwarded(rlcIt->second->gtpTeid);
+    }
+  }
+}
+
+void
+UeManager::RecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params) // TODO only on MC
+{
+  if(m_isMc)
+  {
+    NS_LOG_INFO("Setup remote RLC in cell " << m_rrc->GetCellId());
+    NS_ASSERT_MSG(m_state==HANDOVER_JOINING || params.mmWaveRnti == m_rnti, "Rnti not correct " << params.mmWaveRnti << " " << m_rnti);
+    // store the params, so that on handover the eNB sends the RLC request
+    // to the othe MmWaveEnb
+    m_rlcRequestVector.push_back(params);
+
+    // setup TEIDs to receive data eventually forwarded over X2-U 
+    LteEnbRrc::X2uTeidInfo x2uTeidInfo;
+    x2uTeidInfo.rnti = m_rnti;
+    x2uTeidInfo.drbid = params.drbid;
+    std::pair<std::map<uint32_t, LteEnbRrc::X2uTeidInfo>::iterator, bool> ret;
+    ret = m_rrc->m_x2uMcTeidInfoMap.insert (std::pair<uint32_t, LteEnbRrc::X2uTeidInfo> (params.gtpTeid, x2uTeidInfo));
+    // TODO overwrite may be legit, as in EpcX2::SetMcEpcX2PdcpUser
+    //NS_ASSERT_MSG (ret.second == true, "overwriting a pre-existing entry in m_x2uTeidInfoMap");
+    NS_LOG_INFO("Added entry in m_x2uMcTeidInfoMap");
+    
+    // create new Rlc
+    // define a new struct similar to LteDataRadioBearerInfo with only rlc
+    Ptr<RlcBearerInfo> rlcInfo = CreateObject<RlcBearerInfo> ();
+    rlcInfo->targetCellId = params.sourceCellId; // i.e. the LTE cell
+    rlcInfo->gtpTeid = params.gtpTeid;
+    rlcInfo->mmWaveRnti = m_rnti;
+    rlcInfo->lteRnti = params.lteRnti;
+    rlcInfo->drbid = params.drbid;
+    rlcInfo->rlcConfig = params.rlcConfig;
+    rlcInfo->logicalChannelConfig = params.logicalChannelConfig;
+
+    uint8_t lcid = Drbid2Lcid(params.drbid);
+
+    EpsBearer bearer;
+    TypeId rlcTypeId = m_rrc->GetRlcType (bearer); // actually, this doesn't depend on bearer
+
+    ObjectFactory rlcObjectFactory;
+    rlcObjectFactory.SetTypeId (rlcTypeId);
+    Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+    NS_LOG_INFO("Created rlc " << rlc);
+    rlc->SetLteMacSapProvider (m_rrc->m_macSapProvider);
+    rlc->SetRnti (m_rnti);
+
+    rlcInfo->m_rlc = rlc;
+
+    rlc->SetLcId (lcid);
+
+    if (rlcTypeId != LteRlcSm::GetTypeId ())
+    {
+      // connect with remote PDCP
+      rlc->SetEpcX2RlcProvider (m_rrc->GetEpcX2RlcProvider());
+      EpcX2Sap::UeDataParams ueParams;
+      ueParams.sourceCellId = m_rrc->GetCellId();
+      ueParams.targetCellId = rlcInfo->targetCellId; // the LTE cell
+      ueParams.gtpTeid = rlcInfo->gtpTeid;
+      rlc->SetUeDataParams(ueParams);
+      m_rrc->m_x2SapProvider->SetEpcX2RlcUser (params.gtpTeid, rlc->GetEpcX2RlcUser());
+    }
+
+    LteEnbCmacSapProvider::LcInfo lcinfo;
+    lcinfo.rnti = m_rnti;
+    lcinfo.lcId = lcid;
+    lcinfo.lcGroup = m_rrc->GetLogicalChannelGroup (params.lcinfo.isGbr);
+    lcinfo.qci = params.lcinfo.qci;
+    lcinfo.isGbr = params.lcinfo.isGbr;
+    lcinfo.mbrUl = params.lcinfo.mbrUl;
+    lcinfo.mbrDl = params.lcinfo.mbrDl;
+    lcinfo.gbrUl = params.lcinfo.gbrUl;
+    lcinfo.gbrDl = params.lcinfo.gbrDl;
+    m_rrc->m_cmacSapProvider->AddLc (lcinfo, rlc->GetLteMacSapUser ());
+    rlcInfo->lcinfo = lcinfo;
+
+    rlcInfo->logicalChannelIdentity = lcid;
+    rlcInfo->logicalChannelConfig.priority = params.logicalChannelConfig.priority;
+    rlcInfo->logicalChannelConfig.logicalChannelGroup = lcinfo.lcGroup;
+    if (params.lcinfo.isGbr)
+      {
+        rlcInfo->logicalChannelConfig.prioritizedBitRateKbps = params.logicalChannelConfig.prioritizedBitRateKbps;
+      }
+    else
+      {
+        rlcInfo->logicalChannelConfig.prioritizedBitRateKbps = 0;
+      }
+    rlcInfo->logicalChannelConfig.bucketSizeDurationMs = params.logicalChannelConfig.bucketSizeDurationMs;
+
+    m_rlcMap[params.drbid] = rlcInfo; //TODO add assert 
+
+    // callback to notify the BearerConnector that new rlcs are available
+    m_secondaryRlcCreatedTrace(m_imsi, m_rrc->m_cellId, m_rnti);
+
+    if(m_state != HANDOVER_JOINING) // when performing a secondary cell HO do not ack the LTE eNB
+    {
+      // Ack the LTE BS, that will trigger the setup in the UE
+      EpcX2Sap::UeDataParams ackParams;
+      ackParams.sourceCellId = params.targetCellId;
+      ackParams.targetCellId = params.sourceCellId;
+      ackParams.gtpTeid = params.gtpTeid;  
+      m_rrc->m_x2SapProvider->SendRlcSetupCompleted(ackParams);
+    } 
+  }
+  else
+  {
+    NS_FATAL_ERROR("This is not a MC device");
+  }
+}
+
+void
+UeManager::RecvRlcSetupCompleted(uint8_t drbid)
+{
+  NS_ASSERT_MSG(m_drbMap.find(drbid) != m_drbMap.end(), "The drbid does not match");
+  NS_LOG_INFO("Setup completed for split DataRadioBearer " << drbid);
+  m_drbMap.find(drbid)->second->m_isMc = true;
+  SwitchToState(PREPARE_MC_CONNECTION_RECONFIGURATION);
+  ScheduleRrcConnectionReconfiguration();
 }
 
 
@@ -854,7 +1394,7 @@
 }
 
 void
-UeManager::RecvRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg)
+UeManager::RecvRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg) 
 {
   NS_LOG_FUNCTION (this);
   switch (m_state)
@@ -862,11 +1402,15 @@
     case INITIAL_RANDOM_ACCESS:
       {
         m_connectionRequestTimeout.Cancel ();
+        m_isMc = msg.isMc;
 
         if (m_rrc->m_admitRrcConnectionRequest == true)
           {
             m_imsi = msg.ueIdentity;
-            if (m_rrc->m_s1SapProvider != 0)
+            m_rrc->RegisterImsiToRnti(m_imsi, m_rnti);
+            m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = false;
+            NS_LOG_DEBUG("For imsi " << m_imsi << " m_rrc->m_mmWaveCellSetupCompleted[m_imsi] " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi]);
+            if (!m_isMc && m_rrc->m_s1SapProvider != 0)
               {
                 m_rrc->m_s1SapProvider->InitialUeMessage (m_imsi, m_rnti);
               }
@@ -914,18 +1458,45 @@
     {
     case CONNECTION_SETUP:
       m_connectionSetupTimeout.Cancel ();
-      if ( m_caSupportConfigured == false && m_rrc->m_numberOfComponentCarriers > 1)
+      StartDataRadioBearers ();
+      NS_LOG_INFO("m_firstConnection " << m_firstConnection);
+      if(m_firstConnection && m_rrc->m_ismmWave)
+      {
+        m_firstConnection = false;
+        EpcX2Sap::SecondaryHandoverParams params;
+        params.oldCellId = m_rrc->m_lteCellId;
+        params.targetCellId = m_rrc->m_cellId;
+        params.imsi = m_imsi;
+        m_rrc->m_x2SapProvider->NotifyLteMmWaveHandoverCompleted(params);
+      }
+      else if(m_firstConnection && !m_rrc->m_ismmWave)
+      {
+        m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = false;
+        m_rrc->m_lastMmWaveCell[m_imsi] = m_rrc->m_cellId;
+        m_rrc->m_imsiUsingLte[m_imsi] = true; // the inital connection happened on a LTE eNB
+      }
+      SwitchToState (CONNECTED_NORMALLY);
+      // reply to the UE with a command to connect to the best MmWave eNB
+      if(m_rrc->m_bestMmWaveCellForImsiMap[m_imsi] != m_rrc->GetCellId() && !m_rrc->m_ismmWave)
+      { 
+        uint16_t maxSinrCellId = m_rrc->m_bestMmWaveCellForImsiMap[m_imsi];
+        // get the SINR
+        double maxSinrDb = 10*std::log10(m_rrc->m_imsiCellSinrMap.find(m_imsi)->second.find(maxSinrCellId)->second);
+        if(maxSinrDb > m_rrc->m_outageThreshold)
         {
-          m_pendingRrcConnectionReconfiguration = true; // Force Reconfiguration
-          m_pendingStartDataRadioBearers = true;
+          // there is a MmWave cell to which the UE can connect
+          // send the connection message, then, if capable, the UE will connect 
+          NS_LOG_INFO("Send connect to " << m_rrc->m_bestMmWaveCellForImsiMap.find(m_imsi)->second << " at least one mmWave eNB is not in outage");
+          m_rrc->m_rrcSapUser->SendRrcConnectToMmWave (m_rnti, m_rrc->m_bestMmWaveCellForImsiMap.find(m_imsi)->second);   
         }
-      else
+        else
         {
-          m_pendingStartDataRadioBearers = false;
-          StartDataRadioBearers ();
-        }
-      SwitchToState (CONNECTED_NORMALLY);
-      m_rrc->m_connectionEstablishedTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti);
+          //TODO
+          m_allMmWaveInOutageAtInitialAccess = true;
+          m_rrc->m_imsiUsingLte[m_imsi] = true;
+        } 
+      }
+      m_rrc->m_connectionEstablishedTrace (m_imsi, m_rrc->m_cellId, m_rnti);
       break;
 
     default:
@@ -934,34 +1505,100 @@
     }
 }
 
+bool
+UeManager::GetAllMmWaveInOutageAtInitialAccess()
+{
+  return m_allMmWaveInOutageAtInitialAccess;
+}
+
+void
+UeManager::SetAllMmWaveInOutageAtInitialAccess(bool param)
+{
+  m_allMmWaveInOutageAtInitialAccess = param;
+}
+
 void
 UeManager::RecvRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg)
 {
   NS_LOG_FUNCTION (this);
   switch (m_state)
     {
+    
+    case MC_CONNECTION_RECONFIGURATION:
+          // cycle on the MC bearers and perform switch to MmWave connection
+      for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
+           it != m_drbMap.end ();
+           ++it)
+        {
+          if(it->second->m_isMc)
+          {
+            bool useMmWaveConnection = true;
+            Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp>(it->second->m_pdcp);
+            if(pdcp != 0)
+            {
+              pdcp->SwitchConnection(useMmWaveConnection);
+              m_rrc->m_lastMmWaveCell[m_imsi] = m_mmWaveCellId;
+              m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = true;
+              NS_LOG_INFO("Imsi " << m_imsi << " m_mmWaveCellSetupCompleted set to " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi] << 
+                " for cell " <<  m_rrc->m_lastMmWaveCell[m_imsi]);
+              m_rrc->m_imsiUsingLte[m_imsi] = false;
+              ForwardRlcBuffers(it->second->m_rlc, pdcp, it->second->m_gtpTeid, 1, 0, it->first);
+            }     
+            else
+            {
+              NS_FATAL_ERROR("A device defined as MC has not a McEnbPdcp");
+            }
+          }
+        }
+    // no break so that also the CONNECTION_RECONFIGURATION code is executed
     case CONNECTION_RECONFIGURATION:
       StartDataRadioBearers ();
       if (m_needPhyMacConfiguration)
-        {
-          // configure MAC (and scheduler)
-          LteEnbCmacSapProvider::UeConfig req;
-          req.m_rnti = m_rnti;
-          req.m_transmissionMode = m_physicalConfigDedicated.antennaInfo.transmissionMode;
-          for (uint8_t i = 0; i < m_rrc->m_numberOfComponentCarriers; i++)
-            {
-              m_rrc->m_cmacSapProvider.at (i)->UeUpdateConfigurationReq (req);
+      {
+        // configure MAC (and scheduler)
+        LteEnbCmacSapProvider::UeConfig req;
+        req.m_rnti = m_rnti;
+        req.m_transmissionMode = m_physicalConfigDedicated.antennaInfo.transmissionMode;
+        m_rrc->m_cmacSapProvider->UeUpdateConfigurationReq (req);
 
-              // configure PHY
-              m_rrc->m_cphySapProvider.at (i)->SetTransmissionMode (req.m_rnti, req.m_transmissionMode);
-              double paDouble = LteRrcSap::ConvertPdschConfigDedicated2Double (m_physicalConfigDedicated.pdschConfigDedicated);
-              m_rrc->m_cphySapProvider.at (i)->SetPa (m_rnti, paDouble);
-            }
+        // configure PHY
+        m_rrc->m_cphySapProvider->SetTransmissionMode (req.m_rnti, req.m_transmissionMode);
+
+        double paDouble = LteRrcSap::ConvertPdschConfigDedicated2Double (m_physicalConfigDedicated.pdschConfigDedicated);
+        m_rrc->m_cphySapProvider->SetPa (m_rnti, paDouble);
+
+        m_needPhyMacConfiguration = false;
+      }
+      if(m_mmWaveCellAvailableForMcSetup)
+      {
+        NS_LOG_INFO("Notify the secondary cell that some bearers' RLC can be setup");
+        NS_ASSERT_MSG((m_mmWaveCellId!=0) && (m_mmWaveRnti!=0), "Unkonwn secondary MmWave cell");
+        RecvRrcSecondaryCellInitialAccessSuccessful(m_mmWaveRnti, m_mmWaveCellId); 
+      }
+      if(m_receivedLteMmWaveHandoverCompleted)
+      {
+        NS_LOG_INFO("Notify LteEnbRrc that LTE cell received a NotifyLteMmWaveHandoverCompleted and has completed CONNECTION_RECONFIGURATION");
+        m_rrc->m_mmWaveCellSetupCompleted.find(m_imsi)->second = true;
+        m_rrc->m_imsiUsingLte.find(m_imsi)->second = true;
+      }
+
+      // for IA on LTE eNB, need to wait for CONNECTION_RECONF to be completed and a bearer to be setup
+      if(m_rrc->m_interRatHoMode && m_firstConnection && !m_rrc->m_ismmWave)
+      {
+        m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = true;
+        m_rrc->m_lastMmWaveCell[m_imsi] = m_rrc->m_cellId;
+        m_rrc->m_imsiUsingLte[m_imsi] = true; // the inital connection happened on a LTE eNB
+        m_firstConnection = false;
+      }
 
-          m_needPhyMacConfiguration = false;
-        }
       SwitchToState (CONNECTED_NORMALLY);
-      m_rrc->m_connectionReconfigurationTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti);
+      NS_LOG_INFO("m_queuedHandoverRequestCellId " << m_queuedHandoverRequestCellId);
+      if(m_queuedHandoverRequestCellId > 0)
+      {
+        NS_LOG_INFO("Call the postponed PrepareHandover to cell " << m_queuedHandoverRequestCellId);
+        PrepareHandover(m_queuedHandoverRequestCellId);
+      }
+      m_rrc->m_connectionReconfigurationTrace (m_imsi, m_rrc->m_cellId, m_rnti);
       break;
 
     // This case is added to NS-3 in order to handle bearer de-activation scenario for CONNECTED state UE
@@ -976,13 +1613,15 @@
     case HANDOVER_JOINING:
       {
         m_handoverJoiningTimeout.Cancel ();
-        NS_LOG_INFO ("Send PATH SWITCH REQUEST to the MME");
-        EpcEnbS1SapProvider::PathSwitchRequestParameters params;
-        params.rnti = m_rnti;
-        params.cellId = m_rrc->ComponentCarrierToCellId (m_componentCarrierId);
-        params.mmeUeS1Id = m_imsi;
-        SwitchToState (HANDOVER_PATH_SWITCH);
-        for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
+        if(!m_isMc)
+        {
+          NS_LOG_INFO ("Send PATH SWITCH REQUEST to the MME");
+          EpcEnbS1SapProvider::PathSwitchRequestParameters params;
+          params.rnti = m_rnti;
+          params.cellId = m_rrc->m_cellId;
+          params.mmeUeS1Id = m_imsi;
+          SwitchToState (HANDOVER_PATH_SWITCH);
+          for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
              it != m_drbMap.end ();
              ++it)
           {
@@ -991,7 +1630,30 @@
             b.teid =  it->second->m_gtpTeid;
             params.bearersToBeSwitched.push_back (b);
           }
-        m_rrc->m_s1SapProvider->PathSwitchRequest (params);
+        
+          m_rrc->m_s1SapProvider->PathSwitchRequest (params);
+        }
+        else
+        {
+          // Send "path switch to the LTE eNB"
+          // The context release will be sent by the LTE eNB
+          NS_LOG_INFO("RRC Reconfiguration completed after secondary cell HO: send path switch to LTE coordinator");
+          EpcX2Sap::SecondaryHandoverCompletedParams params;
+          params.mmWaveRnti = m_rnti;
+          params.oldEnbUeX2apId = m_sourceX2apId;
+          params.imsi = m_imsi;
+          params.cellId = m_rrc->m_lteCellId; // just a placeholder to find the correct X2 socket in EpcX2
+          // Notify the LTE eNB
+          m_rrc->m_handoverEndOkTrace (m_imsi, m_rrc->m_cellId, m_rnti);
+          m_rrc->m_x2SapProvider->SendSecondaryCellHandoverCompleted(params);
+          SwitchToState(CONNECTED_NORMALLY);
+          NS_LOG_INFO("m_queuedHandoverRequestCellId " << m_queuedHandoverRequestCellId);
+          if(m_queuedHandoverRequestCellId > 0)
+          {
+            NS_LOG_INFO("Call the postponed PrepareHandover to cell " << m_queuedHandoverRequestCellId);
+            PrepareHandover(m_queuedHandoverRequestCellId);
+          }
+        }
       }
       break;
 
@@ -1040,10 +1702,8 @@
   NS_LOG_FUNCTION (this << (uint16_t) measId);
   NS_LOG_LOGIC ("measId " << (uint16_t) measId
                           << " haveMeasResultNeighCells " << msg.measResults.haveMeasResultNeighCells
-                          << " measResultListEutra " << msg.measResults.measResultListEutra.size ()
-                          << " haveScellsMeas " << msg.measResults.haveScellsMeas
-                          << " measScellResultList " << msg.measResults.measScellResultList.measResultScell.size ());
-  NS_LOG_LOGIC ("serving cellId " << m_rrc->ComponentCarrierToCellId (m_componentCarrierId)
+                          << " measResultListEutra " << msg.measResults.measResultListEutra.size ());
+  NS_LOG_LOGIC ("serving cellId " << m_rrc->m_cellId
                                   << " RSRP " << (uint16_t) msg.measResults.rsrpResult
                                   << " RSRQ " << (uint16_t) msg.measResults.rsrqResult);
 
@@ -1064,14 +1724,6 @@
                                                             msg.measResults);
     }
 
-  if ((m_rrc->m_ccmRrcSapProvider != 0)
-      && (m_rrc->m_componentCarrierMeasIds.find (measId) != m_rrc->m_componentCarrierMeasIds.end ()))
-    {
-      // this measurement was requested by the handover algorithm
-      m_rrc->m_ccmRrcSapProvider->ReportUeMeas (m_rnti,
-                                                msg.measResults);
-    }
-
   if ((m_rrc->m_anrSapProvider != 0)
       && (m_rrc->m_anrMeasIds.find (measId) != m_rrc->m_anrMeasIds.end ()))
     {
@@ -1079,32 +1731,286 @@
       m_rrc->m_anrSapProvider->ReportUeMeas (msg.measResults);
     }
 
-  if ((m_rrc->m_ffrRrcSapProvider.at (0) != 0)
+  if ((m_rrc->m_ffrRrcSapProvider != 0)
       && (m_rrc->m_ffrMeasIds.find (measId) != m_rrc->m_ffrMeasIds.end ()))
     {
       // this measurement was requested by the FFR function
-      m_rrc->m_ffrRrcSapProvider.at (0)->ReportUeMeas (m_rnti, msg.measResults);
-    }
-  if (msg.measResults.haveScellsMeas == true)
-    {
-      for (std::list <LteRrcSap::MeasResultScell>::iterator it = msg.measResults.measScellResultList.measResultScell.begin ();
-           it != msg.measResults.measScellResultList.measResultScell.end ();
-           ++it)
-        {
-          m_rrc->m_ffrRrcSapProvider.at (it->servFreqId)->ReportUeMeas (m_rnti, msg.measResults);
-          /// ToDo: implement on Ffr algorithm the code to properly parsing the new measResults message format
-          /// alternatevely it is needed to 'repack' properly the measResults message before sending to Ffr 
-        }
+      m_rrc->m_ffrRrcSapProvider->ReportUeMeas (m_rnti, msg.measResults);
     }
 
-  ///Report any measurements to ComponentCarrierManager, so it can react to any change or activate the SCC
-  m_rrc->m_ccmRrcSapProvider->ReportUeMeas (m_rnti, msg.measResults);
   // fire a trace source
-  m_rrc->m_recvMeasurementReportTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti, msg);
+  m_rrc->m_recvMeasurementReportTrace (m_imsi, m_rrc->m_cellId, m_rnti, msg);
 
 } // end of UeManager::RecvMeasurementReport
 
-
+void
+UeManager::RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_mmWaveCellId = mmWaveCellId;
+  m_mmWaveRnti = mmWaveRnti;
+
+  NS_LOG_INFO("Map size " << m_drbMap.size());
+
+  // If the Map size is > 0 (Bearers already setup in the LTE cell) perform this action
+  // immediately, otherwise wait for the InitialContextSetupResponse in EpcEnbApplication
+  // that calls DataRadioBearerSetupRequest
+  if(m_drbMap.size() == 0)
+  {
+    m_mmWaveCellAvailableForMcSetup = true;
+    NS_LOG_INFO("Postpone RLC setup in the secondary cell since no bearers are yet available");
+    return;
+  }
+  else
+  {
+    for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it = m_drbMap.begin ();
+       it != m_drbMap.end ();
+       ++it)
+    {
+      if(!(it->second->m_isMc) || (it->second->m_isMc && m_rrc->m_lastMmWaveCell.find(m_imsi)->second != m_mmWaveCellId))
+      {
+        Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp> (it->second->m_pdcp); 
+        if (pdcp != 0)
+        {
+          // Get the EPC X2 and set it in the PDCP
+          pdcp->SetEpcX2PdcpProvider(m_rrc->GetEpcX2PdcpProvider());
+          // Set UeDataParams
+          EpcX2Sap::UeDataParams params;
+          params.sourceCellId = m_rrc->GetCellId();
+          params.targetCellId = m_mmWaveCellId;
+          params.gtpTeid = it->second->m_gtpTeid;
+          pdcp->SetUeDataParams(params);
+          pdcp->SetMmWaveRnti(mmWaveRnti);
+          // Setup TEIDs for receiving data eventually forwarded over X2-U 
+          LteEnbRrc::X2uTeidInfo x2uTeidInfo;
+          x2uTeidInfo.rnti = m_rnti;
+          x2uTeidInfo.drbid = it->first;
+          std::pair<std::map<uint32_t, LteEnbRrc::X2uTeidInfo>::iterator, bool> ret;
+          ret = m_rrc->m_x2uMcTeidInfoMap.insert (std::pair<uint32_t, LteEnbRrc::X2uTeidInfo> (it->second->m_gtpTeid, x2uTeidInfo));
+          // NS_ASSERT_MSG (ret.second == true, "overwriting a pre-existing entry in m_x2uMcTeidInfoMap");
+          // Setup McEpcX2PdcpUser
+          m_rrc->m_x2SapProvider->SetEpcX2PdcpUser(it->second->m_gtpTeid, pdcp->GetEpcX2PdcpUser());
+
+          // Create a remote RLC, pass along the UeDataParams + mmWaveRnti
+          EpcX2SapProvider::RlcSetupRequest rlcParams = it->second->m_rlcSetupRequest;
+          rlcParams.targetCellId = m_mmWaveCellId;
+          rlcParams.mmWaveRnti = mmWaveRnti;
+
+          m_rrc->m_x2SapProvider->SendRlcSetupRequest(rlcParams);
+        }
+        else
+        {
+          NS_FATAL_ERROR("Trying to setup a MC device with a non MC capable PDCP");
+        }  
+      }
+      else
+      {
+        NS_LOG_INFO("MC Bearer already setup"); // TODO consider bearer modifications
+      }  
+    }
+  }
+}
+
+void
+UeManager::RecvSecondaryCellHandoverCompleted(EpcX2Sap::SecondaryHandoverCompletedParams params)
+{
+  uint16_t oldMmWaveCellId = m_mmWaveCellId;
+  m_mmWaveCellId = params.cellId;
+  m_mmWaveRnti = params.mmWaveRnti;
+
+  for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it = m_drbMap.begin ();
+     it != m_drbMap.end ();
+     ++it)
+  {
+    if(!(it->second->m_isMc) || (it->second->m_isMc && m_rrc->m_lastMmWaveCell.find(m_imsi)->second != m_mmWaveCellId))
+    {
+      Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp> (it->second->m_pdcp); 
+      if (pdcp != 0)
+      {
+        // Updated UeDataParams in the PDCP instance
+        EpcX2Sap::UeDataParams params;
+        params.sourceCellId = m_rrc->GetCellId();
+        params.targetCellId = m_mmWaveCellId;
+        params.gtpTeid = it->second->m_gtpTeid;
+        pdcp->SetUeDataParams(params);
+        pdcp->SetMmWaveRnti(m_mmWaveRnti);
+        // Update TEIDs for receiving data eventually forwarded over X2-U 
+        LteEnbRrc::X2uTeidInfo x2uTeidInfo;
+        x2uTeidInfo.rnti = m_rnti;
+        x2uTeidInfo.drbid = it->first;
+        std::pair<std::map<uint32_t, LteEnbRrc::X2uTeidInfo>::iterator, bool> ret;
+        ret = m_rrc->m_x2uMcTeidInfoMap.insert (std::pair<uint32_t, LteEnbRrc::X2uTeidInfo> (it->second->m_gtpTeid, x2uTeidInfo));
+        // NS_ASSERT_MSG (ret.second == true, "overwriting a pre-existing entry in m_x2uMcTeidInfoMap");
+        // Setup McEpcX2PdcpUser
+        m_rrc->m_x2SapProvider->SetEpcX2PdcpUser(it->second->m_gtpTeid, pdcp->GetEpcX2PdcpUser());
+        // Remote RLC already setup
+
+        m_rrc->m_lastMmWaveCell[m_imsi] = m_mmWaveCellId;
+        m_rrc->m_mmWaveCellSetupCompleted[m_imsi] = true;
+        NS_LOG_INFO("Imsi " << m_imsi << " m_mmWaveCellSetupCompleted set to " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi] << 
+                " for cell " <<  m_rrc->m_lastMmWaveCell[m_imsi]);
+        m_rrc->m_imsiUsingLte[m_imsi] = false;
+
+        pdcp->SwitchConnection(true); // this is needed when an handover happens after coming back from outage
+      }
+      else
+      {
+        NS_FATAL_ERROR("Trying to update a MC device with a non MC capable PDCP");
+      }  
+    }
+    else
+    {
+      NS_LOG_INFO("No difference with the MC Bearer already defined"); // TODO consider bearer modifications
+    }  
+  }
+
+  // send ContextRelease to the old mmWave eNB
+  NS_LOG_INFO ("Send UE CONTEXT RELEASE from target eNB to source eNB");
+  EpcX2SapProvider::UeContextReleaseParams ueCtxReleaseParams;
+  ueCtxReleaseParams.oldEnbUeX2apId = params.oldEnbUeX2apId;
+  ueCtxReleaseParams.newEnbUeX2apId = m_mmWaveRnti;
+  ueCtxReleaseParams.sourceCellId = oldMmWaveCellId;
+  m_rrc->m_x2SapProvider->SendUeContextRelease (ueCtxReleaseParams); 
+}
+
+
+void
+UeManager::SendRrcConnectionSwitch(bool useMmWaveConnection)
+{
+  LteRrcSap::RrcConnectionSwitch msg;
+  msg.rrcTransactionIdentifier = GetNewRrcTransactionIdentifier();
+  std::vector<uint8_t> drbidVector;
+  for (std::map <uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it =  m_drbMap.begin ();
+     it != m_drbMap.end ();
+     ++it)
+  {
+    if(it->second->m_isMc)
+    {
+      drbidVector.push_back(it->first); 
+      Ptr<McEnbPdcp> pdcp = DynamicCast<McEnbPdcp>(it->second->m_pdcp);
+      if(pdcp != 0)
+      {
+        //m_rrc->m_x2SapProvider->
+        pdcp->SwitchConnection(useMmWaveConnection);
+        // forward packets in RLC buffers! 
+        // when a switch happens, the swicth target RETX and TXED buffers of RLC AM are emptied, and 
+        // the different windows are resetted.
+        // then the switch message is sent and the RLC buffers are fed back to the pdpc
+        if(!m_rrc->m_ismmWave && useMmWaveConnection) // 
+        {
+          NS_LOG_INFO("UeManager: forward LTE RLC buffers to mmWave");
+          ForwardRlcBuffers(it->second->m_rlc, it->second->m_pdcp, it->second->m_gtpTeid, 1, 0, it->first);
+          // create a new rlc instance!
+
+          // reset RLC and LC
+          it->second->m_rlc = 0;
+          uint8_t lcid = it->second->m_logicalChannelIdentity;
+          m_rrc->m_cmacSapProvider->ReleaseLc(m_rnti, lcid);
+
+          TypeId rlcTypeId = m_rrc->GetRlcType (it->second->m_epsBearer);
+
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_rrc->m_macSapProvider);
+          rlc->SetRnti (m_rnti);
+
+          it->second->m_rlc = rlc;
+
+          NS_LOG_INFO("Reset RLC in LTE eNB after switch, new rlc " << rlc);
+
+          rlc->SetLcId (lcid);
+
+          // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
+          // if we are using RLC/SM we don't care of anything above RLC
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+          {
+            DynamicCast<McEnbPdcp>(it->second->m_pdcp)->SetLteRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            rlc->SetLteRlcSapUser (DynamicCast<McEnbPdcp>(it->second->m_pdcp)->GetLteRlcSapUser ());
+          }
+
+          LteEnbCmacSapProvider::LcInfo lcinfo;
+          lcinfo.rnti = m_rnti;
+          lcinfo.lcId = lcid;
+          lcinfo.lcGroup = m_rrc->GetLogicalChannelGroup (it->second->m_epsBearer);
+          lcinfo.qci =   it->second->m_epsBearer.qci;
+          lcinfo.isGbr = it->second->m_epsBearer.IsGbr ();
+          lcinfo.mbrUl = it->second->m_epsBearer.gbrQosInfo.mbrUl;
+          lcinfo.mbrDl = it->second->m_epsBearer.gbrQosInfo.mbrDl;
+          lcinfo.gbrUl = it->second->m_epsBearer.gbrQosInfo.gbrUl;
+          lcinfo.gbrDl = it->second->m_epsBearer.gbrQosInfo.gbrDl;
+          m_rrc->m_cmacSapProvider->AddLc (lcinfo, rlc->GetLteMacSapUser ());
+        }
+        else if(!m_rrc->m_ismmWave && !useMmWaveConnection)
+        {
+          // switch from mmWave to LTE: it will be the mmWave cell that forwards the data back to LTE
+          EpcX2SapProvider::SwitchConnectionParams params;
+          params.mmWaveRnti = m_mmWaveRnti;
+          params.mmWaveCellId = m_mmWaveCellId;
+          params.useMmWaveConnection = useMmWaveConnection;
+          params.drbid = it->first;
+          m_rrc->m_x2SapProvider->SendSwitchConnectionToMmWave(params);
+        }
+
+      }     
+      else
+      {
+        NS_FATAL_ERROR("A device defined as MC has not a McEnbPdcp");
+      }
+    }
+  }
+  msg.drbidList = drbidVector;
+  msg.useMmWaveConnection = useMmWaveConnection;
+  NS_LOG_INFO("SendRrcConnectionSwitch to " << m_rnti << " with useMmWaveConnection " << msg.useMmWaveConnection << " at time " << Simulator::Now().GetSeconds());
+  m_rrc->m_rrcSapUser->SendRrcConnectionSwitch(m_rnti, msg);  
+}
+
+
+void 
+UeManager::RecvConnectionSwitchToMmWave (bool useMmWaveConnection, uint8_t drbid)
+{
+  NS_ASSERT_MSG(m_rlcMap.find(drbid) != m_rlcMap.end(), "drbid not found in m_rlcMap");
+  NS_LOG_INFO("RecvConnectionSwitchToMmWave on cell " << m_rrc->m_cellId << " switch " << useMmWaveConnection << " for drbid " << (uint32_t)drbid);
+  if(!useMmWaveConnection)
+  {
+    //Ptr<RlcBearerInfo> rlcInfo = m_rlcMap.find(drbid)->second;
+    m_targetCellId = m_rrc->m_lteCellId;
+    ForwardRlcBuffers(m_rlcMap.find(drbid)->second->m_rlc, 0, m_rlcMap.find(drbid)->second->gtpTeid, 0, 0, 0);
+    // create a new rlc!
+
+    m_rlcMap.find(drbid)->second->m_rlc = 0;
+
+    uint8_t lcid = m_rlcMap.find(drbid)->second->logicalChannelIdentity;
+    m_rrc->m_cmacSapProvider->ReleaseLc(m_rnti, lcid);
+
+    EpsBearer bearer;
+    TypeId rlcTypeId = m_rrc->GetRlcType (bearer); // actually, this doesn't depend on bearer
+
+    ObjectFactory rlcObjectFactory;
+    rlcObjectFactory.SetTypeId (rlcTypeId);
+    Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+    NS_LOG_INFO("Reset rlc in mmWave after switch to LTE " << rlc);
+    rlc->SetLteMacSapProvider (m_rrc->m_macSapProvider);
+    rlc->SetRnti (m_rnti);
+
+    m_rlcMap.find(drbid)->second->m_rlc = rlc;
+    rlc->SetLcId (lcid);
+
+    if (rlcTypeId != LteRlcSm::GetTypeId ())
+    {
+      // connect with remote PDCP
+      rlc->SetEpcX2RlcProvider (m_rrc->GetEpcX2RlcProvider());
+      EpcX2Sap::UeDataParams ueParams;
+      ueParams.sourceCellId = m_rrc->GetCellId();
+      ueParams.targetCellId = m_rlcMap.find(drbid)->second->targetCellId; // the LTE cell
+      ueParams.gtpTeid = m_rlcMap.find(drbid)->second->gtpTeid;
+      rlc->SetUeDataParams(ueParams);
+      m_rrc->m_x2SapProvider->SetEpcX2RlcUser (m_rlcMap.find(drbid)->second->gtpTeid, rlc->GetEpcX2RlcUser());
+    }
+
+    m_rrc->m_cmacSapProvider->AddLc (m_rlcMap.find(drbid)->second->lcinfo, rlc->GetLteMacSapUser ());
+  }
+}
+
 // methods forwarded from CMAC SAP
 
 void
@@ -1152,12 +2058,6 @@
   return m_imsi;
 }
 
-uint8_t
-UeManager::GetComponentCarrierId () const
-{
-  return m_componentCarrierId;
-}
-
 uint16_t
 UeManager::GetSrsConfigurationIndex (void) const
 {
@@ -1169,10 +2069,7 @@
 {
   NS_LOG_FUNCTION (this);
   m_physicalConfigDedicated.soundingRsUlConfigDedicated.srsConfigIndex = srsConfIndex;
-  for (uint16_t i = 0; i < m_rrc->m_numberOfComponentCarriers; i++)
-    {
-      m_rrc->m_cphySapProvider.at (i)->SetSrsConfigurationIndex (m_rnti, srsConfIndex);
-    }
+  m_rrc->m_cphySapProvider->SetSrsConfigurationIndex (m_rnti, srsConfIndex);
   switch (m_state)
     {
     case INITIAL_RANDOM_ACCESS:
@@ -1252,7 +2149,6 @@
 LteRrcSap::RrcConnectionReconfiguration
 UeManager::BuildRrcConnectionReconfiguration ()
 {
-  NS_LOG_FUNCTION (this);
   LteRrcSap::RrcConnectionReconfiguration msg;
   msg.rrcTransactionIdentifier = GetNewRrcTransactionIdentifier ();
   msg.haveRadioResourceConfigDedicated = true;
@@ -1260,18 +2156,6 @@
   msg.haveMobilityControlInfo = false;
   msg.haveMeasConfig = true;
   msg.measConfig = m_rrc->m_ueMeasConfig;
-  if ( m_caSupportConfigured == false && m_rrc->m_numberOfComponentCarriers > 1)
-    {
-      m_caSupportConfigured = true;
-      NS_LOG_FUNCTION ( this << "CA not configured. Configure now!" );
-      msg.haveNonCriticalExtension = true;
-      msg.nonCriticalExtension = BuildNonCriticalExtentionConfigurationCa ();
-      NS_LOG_FUNCTION ( this << " haveNonCriticalExtension " << msg.haveNonCriticalExtension );
-    }
-  else
-    {
-      msg.haveNonCriticalExtension = false;
-    }
 
   return msg;
 }
@@ -1299,8 +2183,26 @@
       dtam.rlcConfig = it->second->m_rlcConfig;
       dtam.logicalChannelIdentity = it->second->m_logicalChannelIdentity;
       dtam.logicalChannelConfig = it->second->m_logicalChannelConfig;
+      dtam.is_mc = it->second->m_isMc;
+      rrcd.drbToAddModList.push_back (dtam);
+    }
+
+  if(m_drbMap.size() == 0 && m_isMc && m_rrc->m_ismmWave) // UeManager on a secondary cell for a MC device
+  {
+    for (std::map <uint8_t, Ptr<RlcBearerInfo> >::iterator it = m_rlcMap.begin ();
+       it != m_rlcMap.end ();
+       ++it)
+    {
+      LteRrcSap::DrbToAddMod dtam;
+      dtam.epsBearerIdentity = Drbid2Bid(it->second->drbid);
+      dtam.drbIdentity = it->second->drbid;
+      dtam.rlcConfig = it->second->rlcConfig;
+      dtam.logicalChannelIdentity = it->second->logicalChannelIdentity;
+      dtam.logicalChannelConfig = it->second->logicalChannelConfig;
+      dtam.is_mc = true;
       rrcd.drbToAddModList.push_back (dtam);
     }
+  }
 
   rrcd.havePhysicalConfigDedicated = true;
   rrcd.physicalConfigDedicated = m_physicalConfigDedicated;
@@ -1357,9 +2259,9 @@
   NS_LOG_FUNCTION (this << ToString (newState));
   State oldState = m_state;
   m_state = newState;
-  NS_LOG_INFO (this << " IMSI " << m_imsi << " RNTI " << m_rnti << " UeManager "
+  NS_LOG_INFO (this << " IMSI " << m_imsi << " RNTI " << m_rnti << " CellId " << m_rrc->m_cellId << " UeManager "
                     << ToString (oldState) << " --> " << ToString (newState));
-  m_stateTransitionTrace (m_imsi, m_rrc->ComponentCarrierToCellId (m_componentCarrierId), m_rnti, oldState, newState);
+  m_stateTransitionTrace (m_imsi, m_rrc->m_cellId, m_rnti, oldState, newState);
 
   switch (newState)
     {
@@ -1377,10 +2279,6 @@
           {
             ScheduleRrcConnectionReconfiguration ();
           }
-        if (m_pendingStartDataRadioBearers == true && m_caSupportConfigured == true)
-          {
-            StartDataRadioBearers ();
-          }
       }
       break;
 
@@ -1398,79 +2296,28 @@
     }
 }
 
-LteRrcSap::NonCriticalExtensionConfiguration
-UeManager::BuildNonCriticalExtentionConfigurationCa ()
+void
+UeManager::SetFirstConnection()
 {
-  NS_LOG_FUNCTION ( this );
-  LteRrcSap::NonCriticalExtensionConfiguration ncec;
-  
-  //  LteRrcSap::SCellToAddMod scell;
-  std::list<LteRrcSap::SCellToAddMod> SccCon;
-
-  // sCellToReleaseList is always empty since no Scc is released
-
-  for (auto &it: m_rrc->m_componentCarrierPhyConf)
-    {
-      uint8_t ccId = it.first;
+  m_firstConnection = true;
+}
 
-      if (ccId == m_componentCarrierId)
-        {
-          // Skip primary CC.
-          continue;
-        }
-      else if (ccId < m_componentCarrierId)
-        {
-          // Shift all IDs below PCC forward so PCC can use CC ID 1.
-          ccId++;
-        }
-
-      Ptr<ComponentCarrierEnb> eNbCcm = it.second;
-      LteRrcSap::SCellToAddMod component;
-      component.sCellIndex = ccId;
-      component.cellIdentification.physCellId = eNbCcm->GetCellId ();
-      component.cellIdentification.dlCarrierFreq = eNbCcm->GetDlEarfcn ();
-      component.radioResourceConfigCommonSCell.haveNonUlConfiguration = true;
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.dlBandwidth = eNbCcm->GetDlBandwidth ();
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.antennaInfoCommon.antennaPortsCount = 0;
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.referenceSignalPower = m_rrc->m_cphySapProvider.at (0)->GetReferenceSignalPower ();
-      component.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.pb = 0;
-      component.radioResourceConfigCommonSCell.haveUlConfiguration = true;
-      component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulCarrierFreq = eNbCcm->GetUlEarfcn ();
-      component.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulBandwidth = eNbCcm->GetUlBandwidth ();
-      component.radioResourceConfigCommonSCell.ulConfiguration.ulPowerControlCommonSCell.alpha = 0;
-      //component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
-      component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsBandwidthConfig = 0;
-      component.radioResourceConfigCommonSCell.ulConfiguration.soundingRsUlConfigCommon.srsSubframeConfig = 0;
-      component.radioResourceConfigCommonSCell.ulConfiguration.prachConfigSCell.index = 0;
-    
-      if (true)
-        {
-          component.haveRadioResourceConfigDedicatedSCell = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveNonUlConfiguration = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfo.transmissionMode = m_rrc->m_defaultTransmissionMode;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.crossCarrierSchedulingConfig = false;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.havePdschConfigDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pdschConfigDedicated.pa = LteRrcSap::PdschConfigDedicated::dB0;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveUlConfiguration = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveAntennaInfoUlDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfoUl.transmissionMode = m_rrc->m_defaultTransmissionMode;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pushConfigDedicatedSCell.nPuschIdentity = 0;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.ulPowerControlDedicatedSCell.pSrsOffset = 0;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.haveSoundingRsUlConfigDedicated = true;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsConfigIndex = GetSrsConfigurationIndex();
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
-          component.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsBandwidth = 0;
-        }
-      else 
-        {
-          component.haveRadioResourceConfigDedicatedSCell = false;
-        }
-      SccCon.push_back (component);
-    }
-  ncec.sCellsToAddModList = SccCon;
+void
+UeManager::RecvNotifyLteMmWaveHandoverCompleted()
+{
+  NS_LOG_FUNCTION(this << m_state);
 
-  return ncec;
+  switch(m_state)
+  {
+    case CONNECTED_NORMALLY:
+      m_rrc->m_mmWaveCellSetupCompleted.find(m_imsi)->second = true;
+      NS_LOG_DEBUG("RecvNotifyLteMmWaveHandoverCompleted imsi " << m_imsi << " m_rrc->m_mmWaveCellSetupCompleted[m_imsi] " << m_rrc->m_mmWaveCellSetupCompleted[m_imsi]);
+      m_rrc->m_imsiUsingLte.find(m_imsi)->second = true;
+      break;
+    default:
+      m_receivedLteMmWaveHandoverCompleted = true;
+      break;
+  }
 }
 
 
@@ -1478,13 +2325,13 @@
 // eNB RRC methods
 ///////////////////////////////////////////
 
+
 NS_OBJECT_ENSURE_REGISTERED (LteEnbRrc);
 
 LteEnbRrc::LteEnbRrc ()
   : m_x2SapProvider (0),
     m_cmacSapProvider (0),
     m_handoverManagementSapProvider (0),
-    m_ccmRrcSapProvider (0),
     m_anrSapProvider (0),
     m_ffrRrcSapProvider (0),
     m_rrcSapUser (0),
@@ -1496,45 +2343,24 @@
     m_srsCurrentPeriodicityId (0),
     m_lastAllocatedConfigurationIndex (0),
     m_reconfigureUes (false),
-    m_numberOfComponentCarriers (0),
-    m_carriersConfigured (false)
+    m_firstSibTime (16),
+    m_numNewSinrReports (0)
 {
   NS_LOG_FUNCTION (this);
-  m_cmacSapUser.push_back (new EnbRrcMemberLteEnbCmacSapUser (this, 0));
+  m_cmacSapUser = new EnbRrcMemberLteEnbCmacSapUser (this);
   m_handoverManagementSapUser = new MemberLteHandoverManagementSapUser<LteEnbRrc> (this);
   m_anrSapUser = new MemberLteAnrSapUser<LteEnbRrc> (this);
-  m_ffrRrcSapUser.push_back (new MemberLteFfrRrcSapUser<LteEnbRrc> (this));
+  m_ffrRrcSapUser = new MemberLteFfrRrcSapUser<LteEnbRrc> (this);
   m_rrcSapProvider = new MemberLteEnbRrcSapProvider<LteEnbRrc> (this);
   m_x2SapUser = new EpcX2SpecificEpcX2SapUser<LteEnbRrc> (this);
   m_s1SapUser = new MemberEpcEnbS1SapUser<LteEnbRrc> (this);
-  m_cphySapUser.push_back (new MemberLteEnbCphySapUser<LteEnbRrc> (this));
-  m_ccmRrcSapUser = new MemberLteCcmRrcSapUser <LteEnbRrc>(this);
-  m_cphySapProvider.push_back (0);
-  m_cmacSapProvider.push_back (0);
-  m_ffrRrcSapProvider.push_back (0);
+  m_cphySapUser = new MemberLteEnbCphySapUser<LteEnbRrc> (this);
+  m_imsiCellSinrMap.clear();
+  m_x2_received_cnt = 0;
+  m_switchEnabled = true;
+  m_lteCellId = 0;
 }
 
-void
-LteEnbRrc::ConfigureCarriers (std::map<uint8_t, Ptr<ComponentCarrierEnb>> ccPhyConf)
-{
-  NS_ASSERT_MSG (!m_carriersConfigured, "Secondary carriers can be configured only once.");
-  m_componentCarrierPhyConf = ccPhyConf;
-  m_numberOfComponentCarriers = ccPhyConf.size ();
-
-  NS_ASSERT (m_numberOfComponentCarriers >= MIN_NO_CC && m_numberOfComponentCarriers <= MAX_NO_CC);
-
-  for (uint8_t i = 1; i < m_numberOfComponentCarriers; i++)
-    {
-      m_cphySapUser.push_back (new MemberLteEnbCphySapUser<LteEnbRrc> (this));
-      m_cmacSapUser.push_back (new EnbRrcMemberLteEnbCmacSapUser (this, i));
-      m_ffrRrcSapUser.push_back (new MemberLteFfrRrcSapUser<LteEnbRrc> (this));
-      m_cphySapProvider.push_back (0);
-      m_cmacSapProvider.push_back (0);
-      m_ffrRrcSapProvider.push_back (0);
-    }
-  m_carriersConfigured = true;
-  Object::DoInitialize ();
-}
 
 LteEnbRrc::~LteEnbRrc ()
 {
@@ -1546,29 +2372,15 @@
 LteEnbRrc::DoDispose ()
 {
   NS_LOG_FUNCTION (this);
-  for ( uint8_t i = 0; i < m_numberOfComponentCarriers ; i++)
-    {
-      delete m_cphySapUser[i];
-      delete m_cmacSapUser[i];
-      delete m_ffrRrcSapUser[i];
-    }
-  //delete m_cphySapUser;        
-  m_cphySapUser.erase (m_cphySapUser.begin (),m_cphySapUser.end ());
-  m_cphySapUser.clear ();  
-  //delete m_cmacSapUser;
-  m_cmacSapUser.erase (m_cmacSapUser.begin (),m_cmacSapUser.end ());
-  m_cmacSapUser.clear ();  
-  //delete m_ffrRrcSapUser;
-  m_ffrRrcSapUser.erase (m_ffrRrcSapUser.begin (),m_ffrRrcSapUser.end ());
-  m_ffrRrcSapUser.clear ();
-  m_ueMap.clear ();  
+  m_ueMap.clear ();
+  delete m_cmacSapUser;
   delete m_handoverManagementSapUser;
-  delete m_ccmRrcSapUser;
   delete m_anrSapUser;
+  delete m_ffrRrcSapUser;
   delete m_rrcSapProvider;
   delete m_x2SapUser;
   delete m_s1SapUser;
-
+  delete m_cphySapUser;
 }
 
 TypeId
@@ -1595,10 +2407,11 @@
                    MakeEnumChecker (RLC_SM_ALWAYS, "RlcSmAlways",
                                     RLC_UM_ALWAYS, "RlcUmAlways",
                                     RLC_AM_ALWAYS, "RlcAmAlways",
-                                    PER_BASED,     "PacketErrorRateBased"))
+                                    PER_BASED,     "PacketErrorRateBased",
+                                    RLC_UM_LOWLAT_ALWAYS, "MmwRlcUmAlways"))
     .AddAttribute ("SystemInformationPeriodicity",
                    "The interval for sending system information (Time value)",
-                   TimeValue (MilliSeconds (80)),
+                   TimeValue (MilliSeconds (5)),
                    MakeTimeAccessor (&LteEnbRrc::m_systemInformationPeriodicity),
                    MakeTimeChecker ())
 
@@ -1641,16 +2454,21 @@
                    "X2 HO REQ ACK by source eNB, transmission of the Handover "
                    "Command, non-contention-based random access and reception "
                    "of the RRC CONNECTION RECONFIGURATION COMPLETE message.",
-                   TimeValue (MilliSeconds (200)),
+                   TimeValue (Seconds (45)),
                    MakeTimeAccessor (&LteEnbRrc::m_handoverJoiningTimeoutDuration),
                    MakeTimeChecker ())
     .AddAttribute ("HandoverLeavingTimeoutDuration",
                    "After issuing a Handover Command, if neither RRC "
                    "CONNECTION RE-ESTABLISHMENT nor X2 UE Context Release has "
                    "been previously received, the UE context is destroyed.",
-                   TimeValue (MilliSeconds (500)),
+                   TimeValue (Seconds (45)),
                    MakeTimeAccessor (&LteEnbRrc::m_handoverLeavingTimeoutDuration),
                    MakeTimeChecker ())
+    .AddAttribute ("OutageThreshold",
+                   "SNR threshold for outage events [dB]",
+                   DoubleValue (-5.0),
+                   MakeDoubleAccessor (&LteEnbRrc::m_outageThreshold),
+                   MakeDoubleChecker<long double> (-10000.0, 10.0))
 
     // Cell selection related attribute
     .AddAttribute ("QRxLevMin",
@@ -1665,12 +2483,6 @@
                    IntegerValue (-70),
                    MakeIntegerAccessor (&LteEnbRrc::m_qRxLevMin),
                    MakeIntegerChecker<int8_t> (-70, -22))
-    .AddAttribute ("NumberOfComponentCarriers",
-                   "Number of Component Carriers ",
-                   UintegerValue (1),
-                   MakeIntegerAccessor (&LteEnbRrc::m_numberOfComponentCarriers),
-                   MakeIntegerChecker<int16_t> (MIN_NO_CC, MAX_NO_CC))
-
     // Handover related attributes
     .AddAttribute ("AdmitHandoverRequest",
                    "Whether to admit an X2 handover request from another eNB",
@@ -1700,7 +2512,64 @@
                    UintegerValue (4),
                    MakeUintegerAccessor (&LteEnbRrc::m_rsrqFilterCoefficient),
                    MakeUintegerChecker<uint8_t> (0))
-
+    .AddAttribute ("mmWaveDevice",
+             "Indicates whether RRC is for mmWave base station",
+             BooleanValue (false),
+             MakeBooleanAccessor (&LteEnbRrc::m_ismmWave),
+             MakeBooleanChecker ())
+    .AddAttribute ("FirstSibTime",
+                   "Time in ms of initial SIB message",
+                   // i.e. the variable k in 3GPP TS 36.331 section 5.5.3.2
+                   UintegerValue (2),
+                   MakeUintegerAccessor (&LteEnbRrc::m_firstSibTime),
+                   MakeUintegerChecker<uint32_t> (0)) 
+    .AddAttribute ("InterRatHoMode",
+             "Indicates whether RRC is for LTE base station that coordinates InterRatHo among eNBs",
+             BooleanValue (false),
+             MakeBooleanAccessor (&LteEnbRrc::m_interRatHoMode),
+             MakeBooleanChecker ())
+    .AddAttribute ("HoSinrDifference",
+             "The value for which an handover between MmWave eNB is triggered",
+             DoubleValue (3),
+             MakeDoubleAccessor (&LteEnbRrc::m_sinrThresholdDifference),
+             MakeDoubleChecker<double> ())
+    .AddAttribute ("SecondaryCellHandoverMode",
+        "Select the secondary cell handover mode",
+         EnumValue (DYNAMIC_TTT),
+         MakeEnumAccessor (&LteEnbRrc::m_handoverMode),
+         MakeEnumChecker (FIXED_TTT, "FixedTtt",
+                  DYNAMIC_TTT, "DynamicTtt",
+                  THRESHOLD, "Threshold"))
+    .AddAttribute ("FixedTttValue",
+        "The value of TTT in case of fixed TTT handover (in ms)",
+        UintegerValue(110),
+        MakeUintegerAccessor(&LteEnbRrc::m_fixedTttValue),
+        MakeUintegerChecker<uint8_t>()) // TODO consider using a TimeValue
+    .AddAttribute ("MinDynTttValue",
+        "The minimum value of TTT in case of dynamic TTT handover (in ms)",
+        UintegerValue(25),
+        MakeUintegerAccessor(&LteEnbRrc::m_minDynTttValue),
+        MakeUintegerChecker<uint8_t>()) // TODO consider using a TimeValue
+    .AddAttribute ("MaxDynTttValue",
+        "The maximum value of TTT in case of dynamic TTT handover (in ms)",
+        UintegerValue(150),
+        MakeUintegerAccessor(&LteEnbRrc::m_maxDynTttValue),
+        MakeUintegerChecker<uint8_t>()) // TODO consider using a TimeValue    
+    .AddAttribute ("MinDiffValue",
+        "The minimum value of the difference in case of dynamic TTT handover [dB]",
+        DoubleValue(3),
+        MakeDoubleAccessor(&LteEnbRrc::m_minDiffTttValue),
+        MakeDoubleChecker<double>()) // TODO set the proper value    
+    .AddAttribute ("MaxDiffValue",
+        "The maximum value of the difference in case of dynamic TTT handover [dB]",
+        DoubleValue(20),
+        MakeDoubleAccessor(&LteEnbRrc::m_maxDiffTttValue),
+        MakeDoubleChecker<double>()) // TODO set the proper value
+    .AddAttribute ("CrtPeriod",
+        "The periodicity of a CRT (us)",
+        IntegerValue(1600),
+        MakeIntegerAccessor(&LteEnbRrc::m_crtPeriod),
+        MakeIntegerChecker<int>()) // TODO consider using a TimeValue  
     // Trace sources
     .AddTraceSource ("NewUeContext",
                      "Fired upon creation of a new UE context.",
@@ -1726,6 +2595,10 @@
                      "trace fired when measurement report is received",
                      MakeTraceSourceAccessor (&LteEnbRrc::m_recvMeasurementReportTrace),
                      "ns3::LteEnbRrc::ReceiveReportTracedCallback")
+    .AddTraceSource ("NotifyMmWaveSinr",
+                 "trace fired when measurement report is received from mmWave cells, for each cell, for each UE",
+                 MakeTraceSourceAccessor (&LteEnbRrc::m_notifyMmWaveSinrTrace),
+                 "ns3::LteEnbRrc::NotifyMmWaveSinrTracedCallback")
   ;
   return tid;
 }
@@ -1744,60 +2617,58 @@
   return m_x2SapUser;
 }
 
-void
-LteEnbRrc::SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s)
+void 
+LteEnbRrc::SetEpcX2PdcpProvider (EpcX2PdcpProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_cmacSapProvider.at (0) = s;
+  m_x2PdcpProvider = s;
 }
 
-void
-LteEnbRrc::SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s, uint8_t pos)
+void 
+LteEnbRrc::SetEpcX2RlcProvider (EpcX2RlcProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_cmacSapProvider.at (pos) = s;
+  m_x2RlcProvider = s;
 }
 
-LteEnbCmacSapUser*
-LteEnbRrc::GetLteEnbCmacSapUser ()
+EpcX2PdcpProvider*
+LteEnbRrc::GetEpcX2PdcpProvider () const
 {
-  NS_LOG_FUNCTION (this);
-  return m_cmacSapUser.at (0);
+  return m_x2PdcpProvider;
 }
 
-LteEnbCmacSapUser*
-LteEnbRrc::GetLteEnbCmacSapUser (uint8_t pos)
+EpcX2RlcProvider*
+LteEnbRrc::GetEpcX2RlcProvider () const
 {
-  NS_LOG_FUNCTION (this);
-  return m_cmacSapUser.at (pos);
+  return m_x2RlcProvider;
 }
 
 void
-LteEnbRrc::SetLteHandoverManagementSapProvider (LteHandoverManagementSapProvider * s)
+LteEnbRrc::SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_handoverManagementSapProvider = s;
+  m_cmacSapProvider = s;
 }
 
-LteHandoverManagementSapUser*
-LteEnbRrc::GetLteHandoverManagementSapUser ()
+LteEnbCmacSapUser*
+LteEnbRrc::GetLteEnbCmacSapUser ()
 {
   NS_LOG_FUNCTION (this);
-  return m_handoverManagementSapUser;
+  return m_cmacSapUser;
 }
 
 void
-LteEnbRrc::SetLteCcmRrcSapProvider (LteCcmRrcSapProvider * s)
+LteEnbRrc::SetLteHandoverManagementSapProvider (LteHandoverManagementSapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_ccmRrcSapProvider = s;
+  m_handoverManagementSapProvider = s;
 }
 
-LteCcmRrcSapUser*
-LteEnbRrc::GetLteCcmRrcSapUser ()
+LteHandoverManagementSapUser*
+LteEnbRrc::GetLteHandoverManagementSapUser ()
 {
   NS_LOG_FUNCTION (this);
-  return m_ccmRrcSapUser;
+  return m_handoverManagementSapUser;
 }
 
 void
@@ -1818,29 +2689,14 @@
 LteEnbRrc::SetLteFfrRrcSapProvider (LteFfrRrcSapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_ffrRrcSapProvider.at (0) = s;
-}
-
-void
-LteEnbRrc::SetLteFfrRrcSapProvider (LteFfrRrcSapProvider * s, uint8_t index)
-{
-  NS_LOG_FUNCTION (this << s);
-  m_ffrRrcSapProvider.at (index) = s;
+  m_ffrRrcSapProvider = s;
 }
 
 LteFfrRrcSapUser*
 LteEnbRrc::GetLteFfrRrcSapUser ()
 {
   NS_LOG_FUNCTION (this);
-  return m_ffrRrcSapUser.at (0);
-}
-
-LteFfrRrcSapUser*
-LteEnbRrc::GetLteFfrRrcSapUser (uint8_t index)
-{
-  NS_LOG_FUNCTION (this);
-  NS_ASSERT_MSG (index < m_numberOfComponentCarriers, "Invalid component carrier index:"<<index<<" provided in order to obtain FfrRrcSapUser.");
-  return m_ffrRrcSapUser.at (index);
+  return m_ffrRrcSapUser;
 }
 
 void
@@ -1881,28 +2737,14 @@
 LteEnbRrc::SetLteEnbCphySapProvider (LteEnbCphySapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_cphySapProvider.at(0) = s;
+  m_cphySapProvider = s;
 }
 
 LteEnbCphySapUser*
 LteEnbRrc::GetLteEnbCphySapUser ()
 {
   NS_LOG_FUNCTION (this);
-  return m_cphySapUser.at(0);
-}
-
-void
-LteEnbRrc::SetLteEnbCphySapProvider (LteEnbCphySapProvider * s, uint8_t pos)
-{
-  NS_LOG_FUNCTION (this << s);
-  m_cphySapProvider.at(pos) = s;
-}
-
-LteEnbCphySapUser*
-LteEnbRrc::GetLteEnbCphySapUser (uint8_t pos)
-{
-  NS_LOG_FUNCTION (this);
-  return m_cphySapUser.at(pos);
+  return m_cphySapUser;
 }
 
 bool
@@ -1919,10 +2761,64 @@
   NS_LOG_FUNCTION (this << (uint32_t) rnti);
   NS_ASSERT (0 != rnti);
   std::map<uint16_t, Ptr<UeManager> >::iterator it = m_ueMap.find (rnti);
-  NS_ASSERT_MSG (it != m_ueMap.end (), "UE manager for RNTI " << rnti << " not found");
+  NS_ASSERT_MSG (it != m_ueMap.end (), "RNTI " << rnti << " not found in eNB with cellId " << m_cellId);
   return it->second;
 }
 
+void 
+LteEnbRrc::RegisterImsiToRnti(uint64_t imsi, uint16_t rnti)
+{
+  if(m_imsiRntiMap.find(imsi) == m_imsiRntiMap.end())
+  {
+    m_imsiRntiMap.insert(std::pair<uint64_t, uint16_t> (imsi, rnti));
+    NS_LOG_INFO("New entry in m_imsiRntiMap, for rnti " << rnti << " m_interRatHoMode " << m_interRatHoMode << " m_ismmWave " << m_ismmWave);
+    if(m_interRatHoMode) // warn the UeManager that this is the first time a UE with a certain imsi
+      // connects to this MmWave eNB. This will trigger a notification to the LTE RRC once RecvRrcReconfCompleted is called
+    {
+      GetUeManager(rnti)->SetFirstConnection();
+    }
+  }
+  else
+  {
+    m_imsiRntiMap.find(imsi)->second = rnti;
+  }
+
+  if(m_rntiImsiMap.find(rnti) == m_rntiImsiMap.end())
+  {
+    m_rntiImsiMap.insert(std::pair<uint16_t, uint64_t> (rnti, imsi));
+  }
+  else
+  {
+    m_rntiImsiMap.find(rnti)->second = imsi;
+  }
+}
+
+uint16_t 
+LteEnbRrc::GetRntiFromImsi(uint64_t imsi)
+{
+  if(m_imsiRntiMap.find(imsi) != m_imsiRntiMap.end())
+  {
+    return m_imsiRntiMap.find(imsi)->second;
+  }
+  else
+  {
+    return 0;
+  }
+}
+
+uint64_t
+LteEnbRrc::GetImsiFromRnti(uint16_t rnti)
+{
+  if(m_rntiImsiMap.find(rnti) != m_rntiImsiMap.end())
+  {
+    return m_rntiImsiMap.find(rnti)->second;
+  }
+  else
+  {
+    return 0;
+  }
+}
+
 uint8_t
 LteEnbRrc::AddUeMeasReportConfig (LteRrcSap::ReportConfigEutra config)
 {
@@ -2012,32 +2908,27 @@
 }
 
 void
-LteEnbRrc::ConfigureCell (std::map<uint8_t, Ptr<ComponentCarrierEnb>> ccPhyConf)
+LteEnbRrc::ConfigureCell (uint8_t ulBandwidth, uint8_t dlBandwidth,
+                          uint16_t ulEarfcn, uint16_t dlEarfcn, uint16_t cellId)
 {
-  auto it = ccPhyConf.begin ();
-  NS_ASSERT (it != ccPhyConf.end ());
-  uint8_t ulBandwidth = it->second->GetUlBandwidth ();
-  uint8_t dlBandwidth = it->second->GetDlBandwidth ();
-  uint32_t ulEarfcn = it->second->GetUlEarfcn ();
-  uint32_t dlEarfcn = it->second->GetDlEarfcn ();
   NS_LOG_FUNCTION (this << (uint16_t) ulBandwidth << (uint16_t) dlBandwidth
-                        << ulEarfcn << dlEarfcn);
+                        << ulEarfcn << dlEarfcn << cellId);
   NS_ASSERT (!m_configured);
-
-  for (const auto &it: ccPhyConf)
-    {
-      m_cphySapProvider.at (it.first)->SetBandwidth (it.second->GetUlBandwidth (), it.second->GetDlBandwidth ());
-      m_cphySapProvider.at (it.first)->SetEarfcn (it.second->GetUlEarfcn (), it.second->GetDlEarfcn ());
-      m_cphySapProvider.at (it.first)->SetCellId (it.second->GetCellId ());
-      m_cmacSapProvider.at (it.first)->ConfigureMac (it.second->GetUlBandwidth (), it.second->GetDlBandwidth ());
-      m_ffrRrcSapProvider.at (it.first)->SetCellId (it.second->GetCellId ());
-      m_ffrRrcSapProvider.at (it.first)->SetBandwidth (it.second->GetUlBandwidth (), it.second->GetDlBandwidth ());
-    }
-
+  m_cmacSapProvider->ConfigureMac (ulBandwidth, dlBandwidth);
+  m_cphySapProvider->SetBandwidth (ulBandwidth, dlBandwidth);
+  m_cphySapProvider->SetEarfcn (ulEarfcn, dlEarfcn);
   m_dlEarfcn = dlEarfcn;
   m_ulEarfcn = ulEarfcn;
   m_dlBandwidth = dlBandwidth;
   m_ulBandwidth = ulBandwidth;
+  m_cellId = cellId;
+  m_cphySapProvider->SetCellId (cellId);
+
+  if (!m_ismmWave)
+  {
+    m_ffrRrcSapProvider->SetCellId (cellId);
+    m_ffrRrcSapProvider->SetBandwidth(ulBandwidth, dlBandwidth);
+  }
 
   /*
    * Initializing the list of UE measurement configuration (m_ueMeasConfig).
@@ -2062,90 +2953,875 @@
   m_ueMeasConfig.haveSmeasure = false;
   m_ueMeasConfig.haveSpeedStatePars = false;
 
-  m_sib1.clear ();
-  m_sib1.reserve (ccPhyConf.size ());
-  for (const auto &it: ccPhyConf)
-    {
-      // Enabling MIB transmission
-      LteRrcSap::MasterInformationBlock mib;
-      mib.dlBandwidth = it.second->GetDlBandwidth ();
-      mib.systemFrameNumber = 0;
-      m_cphySapProvider.at (it.first)->SetMasterInformationBlock (mib);
-
-      // Enabling SIB1 transmission with default values
-      LteRrcSap::SystemInformationBlockType1 sib1;
-      sib1.cellAccessRelatedInfo.cellIdentity = it.second->GetCellId ();
-      sib1.cellAccessRelatedInfo.csgIndication = false;
-      sib1.cellAccessRelatedInfo.csgIdentity = 0;
-      sib1.cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity = 0; // not used
-      sib1.cellSelectionInfo.qQualMin = -34; // not used, set as minimum value
-      sib1.cellSelectionInfo.qRxLevMin = m_qRxLevMin; // set as minimum value
-      m_sib1.push_back (sib1);
-      m_cphySapProvider.at (it.first)->SetSystemInformationBlockType1 (sib1);
-    }
+  // Enabling MIB transmission
+  LteRrcSap::MasterInformationBlock mib;
+  mib.dlBandwidth = m_dlBandwidth;
+  m_cphySapProvider->SetMasterInformationBlock (mib);
+
+  // Enabling SIB1 transmission with default values
+  m_sib1.cellAccessRelatedInfo.cellIdentity = cellId;
+  m_sib1.cellAccessRelatedInfo.csgIndication = false;
+  m_sib1.cellAccessRelatedInfo.csgIdentity = 0;
+  m_sib1.cellAccessRelatedInfo.plmnIdentityInfo.plmnIdentity = 0; // not used
+  m_sib1.cellSelectionInfo.qQualMin = -34; // not used, set as minimum value
+  m_sib1.cellSelectionInfo.qRxLevMin = m_qRxLevMin; // set as minimum value
+  m_cphySapProvider->SetSystemInformationBlockType1 (m_sib1);
+
   /*
    * Enabling transmission of other SIB. The first time System Information is
    * transmitted is arbitrarily assumed to be at +0.016s, and then it will be
    * regularly transmitted every 80 ms by default (set the
    * SystemInformationPeriodicity attribute to configure this).
    */
-  Simulator::Schedule (MilliSeconds (16), &LteEnbRrc::SendSystemInformation, this);
-
+  // mmWave module: Changed scheduling of initial system information to +2ms
+  Simulator::Schedule (MilliSeconds (m_firstSibTime), &LteEnbRrc::SendSystemInformation, this);
+  m_imsiCellSinrMap.clear();
+  m_firstReport = true;
   m_configured = true;
-
 }
 
-
 void
-LteEnbRrc::SetCellId (uint16_t cellId)
+LteEnbRrc::SetInterRatHoMode(void)
 {
-  // update SIB1
-  m_sib1.at (0).cellAccessRelatedInfo.cellIdentity = cellId;
-  m_cphySapProvider.at (0)->SetSystemInformationBlockType1 (m_sib1.at (0));
+  m_interRatHoMode = true;
 }
 
+
 void
-LteEnbRrc::SetCellId (uint16_t cellId, uint8_t ccIndex)
+LteEnbRrc::SetCellId (uint16_t cellId)
 {
-  // update SIB1
-  m_sib1.at (ccIndex).cellAccessRelatedInfo.cellIdentity = cellId;
-  m_cphySapProvider.at (ccIndex)->SetSystemInformationBlockType1 (m_sib1.at (ccIndex));
+  m_cellId = cellId;
+  NS_LOG_LOGIC("CellId set to " << m_cellId);
+  // update SIB1 too
+  m_sib1.cellAccessRelatedInfo.cellIdentity = cellId;
+  m_cphySapProvider->SetSystemInformationBlockType1 (m_sib1);
 }
 
-uint8_t
-LteEnbRrc::CellToComponentCarrierId (uint16_t cellId)
+void
+LteEnbRrc::SetClosestLteCellId (uint16_t cellId)
 {
-  NS_LOG_FUNCTION (this << cellId);
-  for (auto &it: m_componentCarrierPhyConf)
-    {
-      if (it.second->GetCellId () == cellId)
-        {
-          return it.first;
-        }
-    }
-  NS_FATAL_ERROR ("Cell " << cellId << " not found in CC map");
+  m_lteCellId = cellId;
+  NS_LOG_LOGIC("Closest Lte CellId set to " << m_lteCellId);
 }
 
 uint16_t
-LteEnbRrc::ComponentCarrierToCellId (uint8_t componentCarrierId)
+LteEnbRrc::GetCellId () const
 {
-  NS_LOG_FUNCTION (this << +componentCarrierId);
-  return m_componentCarrierPhyConf.at (componentCarrierId)->GetCellId ();
+  return m_cellId;
 }
 
-bool
-LteEnbRrc::SendData (Ptr<Packet> packet)
+void 
+LteEnbRrc::DoUpdateUeSinrEstimate(LteEnbCphySapUser::UeAssociatedSinrInfo info)
 {
-  NS_LOG_FUNCTION (this << packet);
+  NS_LOG_FUNCTION(this);
 
-  EpsBearerTag tag;
-  bool found = packet->RemovePacketTag (tag);
-  NS_ASSERT_MSG (found, "no EpsBearerTag found in packet to be sent");
-  Ptr<UeManager> ueManager = GetUeManager (tag.GetRnti ());
-  ueManager->SendData (tag.GetBid (), packet);
+  m_ueImsiSinrMap.clear();
+  m_ueImsiSinrMap.insert(info.ueImsiSinrMap.begin(), info.ueImsiSinrMap.end());
+  NS_LOG_LOGIC("number of SINR reported " << m_ueImsiSinrMap.size());
+  // TODO report immediately or with some filtering 
+  if(m_lteCellId > 0) // i.e., only if a LTE eNB was actually registered in the scenario 
+                      // (this is done when an X2 interface among mmWave eNBs and LTE eNB is added)
+  {
+    EpcX2SapProvider::UeImsiSinrParams params;
+    params.targetCellId = m_lteCellId;
+    params.sourceCellId = m_cellId;
+    params.ueImsiSinrMap = m_ueImsiSinrMap;
+    m_x2SapProvider->SendUeSinrUpdate (params); 
+  }
 
-  return true;
-}
+  }
+
+void 
+LteEnbRrc::DoRecvUeSinrUpdate(EpcX2SapUser::UeImsiSinrParams params)
+{
+  NS_LOG_FUNCTION(this);
+  NS_LOG_LOGIC("Recv Ue SINR Update from cell " << params.sourceCellId);
+  uint16_t mmWaveCellId = params.sourceCellId;
+  if(m_cellSinrMap.find(mmWaveCellId) != m_cellSinrMap.end())
+  {     // update the entry
+    m_cellSinrMap[mmWaveCellId] = params.ueImsiSinrMap;
+    m_numNewSinrReports++;
+  }
+  else  // add the entry
+  {
+    m_cellSinrMap.insert(std::pair<uint16_t, ImsiSinrMap> (mmWaveCellId, params.ueImsiSinrMap));
+    m_numNewSinrReports++;
+  }
+  // cycle on all the Imsi whose SINR is known in cell mmWaveCellId
+  for(std::map<uint64_t, double>::iterator imsiIter = params.ueImsiSinrMap.begin(); imsiIter != params.ueImsiSinrMap.end(); ++imsiIter)
+  {
+    uint64_t imsi = imsiIter->first;
+    double sinr = imsiIter->second;
+
+    m_notifyMmWaveSinrTrace(imsi, mmWaveCellId, sinr);
+    
+    NS_LOG_LOGIC("Imsi " << imsi << " sinr " << sinr);
+
+    if(m_imsiCellSinrMap.find(imsi) != m_imsiCellSinrMap.end())
+    {
+      if(m_imsiCellSinrMap[imsi].find(mmWaveCellId) != m_imsiCellSinrMap[imsi].end())
+      {
+        // update the SINR measure
+        m_imsiCellSinrMap[imsi].find(mmWaveCellId)->second = sinr;
+      }
+      else // new cell for this Imsi
+      {
+        // insert a new SINR measure
+        m_imsiCellSinrMap[imsi].insert(std::pair<uint16_t, double>(mmWaveCellId, sinr));
+      }
+    }
+    else // new imsi
+    {
+      CellSinrMap map;
+      map.insert(std::pair<uint16_t, double>(mmWaveCellId, sinr));
+      m_imsiCellSinrMap.insert(std::pair<uint64_t, CellSinrMap> (imsi, map));
+    }
+  }
+  
+  for(std::map<uint64_t, CellSinrMap>::iterator imsiIter = m_imsiCellSinrMap.begin(); imsiIter != m_imsiCellSinrMap.end(); ++imsiIter)
+  {
+    NS_LOG_LOGIC("Imsi " << imsiIter->first);
+    for(CellSinrMap::iterator cellIter = imsiIter->second.begin(); cellIter != imsiIter->second.end(); ++cellIter)
+    {
+      NS_LOG_LOGIC("mmWaveCell " << cellIter->first << " sinr " <<  cellIter->second);
+    }
+  }
+
+  if(!m_ismmWave && !m_interRatHoMode && m_firstReport) 
+  {
+    m_firstReport = false;
+    switch(m_handoverMode)
+    {
+      case FIXED_TTT : NS_LOG_INFO("Handover Mode: Fixed TTT"); break;
+      case DYNAMIC_TTT : NS_LOG_INFO("Handover Mode: Dynamic TTT"); break;
+      case THRESHOLD : NS_LOG_INFO("Handover Mode: Threshold"); break;
+    }
+    Simulator::Schedule(MilliSeconds(0), &LteEnbRrc::TriggerUeAssociationUpdate, this);
+  }
+  else if(!m_ismmWave && m_interRatHoMode && m_firstReport)
+  {
+    m_firstReport = false;
+    Simulator::Schedule(MilliSeconds(0), &LteEnbRrc::UpdateUeHandoverAssociation, this);
+  }
+
+}
+
+void 
+LteEnbRrc::TttBasedHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb)
+{
+  uint64_t imsi = imsiIter->first;
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("TttBasedHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  bool handoverNeeded = false;
+
+  double currentSinrDb = 0;
+  if(alreadyAssociatedImsi && m_lastMmWaveCell.find(imsi) != m_lastMmWaveCell.end())
+  {
+    currentSinrDb = 10*std::log10(m_imsiCellSinrMap.find(imsi)->second[m_lastMmWaveCell[imsi]]);
+    NS_LOG_DEBUG("Current SINR " << currentSinrDb);
+  }
+
+  // the UE was in outage, now a mmWave eNB is available. It may be the one to which the UE is already attached or
+  // another one
+  if(alreadyAssociatedImsi && m_imsiUsingLte[imsi])
+  {
+    if(!m_interRatHoMode)
+    {
+      if(GetUeManager(GetRntiFromImsi(imsi))->GetAllMmWaveInOutageAtInitialAccess())
+      {
+        NS_LOG_INFO("Send connect to " << maxSinrCellId << ", for the first time at least one mmWave eNB is not in outage");
+        m_rrcSapUser->SendRrcConnectToMmWave (GetRntiFromImsi(imsi), maxSinrCellId);
+        GetUeManager(GetRntiFromImsi(imsi))->SetAllMmWaveInOutageAtInitialAccess(false);
+      }
+      else if(m_lastMmWaveCell[imsi] == maxSinrCellId && !onHandoverImsi) 
+      // it is on LTE, but now the last used MmWave cell is not in outage
+      {
+        // switch back to MmWave
+        NS_LOG_INFO("----- on LTE, switch to lastMmWaveCell " << m_lastMmWaveCell[imsi] << " at time " << Simulator::Now().GetSeconds());
+        Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+        bool useMmWaveConnection = true;
+        m_imsiUsingLte[imsi] = !useMmWaveConnection;
+        ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+      }
+      else if (m_lastMmWaveCell[imsi] != maxSinrCellId && !onHandoverImsi)
+      // it is on LTE, but now a MmWave cell different from the last used is not in outage, so we need to handover
+      {
+        // already using LTE connection
+        NS_LOG_INFO("----- on LTE, switch to new MmWaveCell " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+        // trigger ho via X2
+        EpcX2SapProvider::SecondaryHandoverParams params;
+        params.imsi = imsi;
+        params.targetCellId = maxSinrCellId;
+        params.oldCellId = m_lastMmWaveCell[imsi];
+        m_x2SapProvider->SendMcHandoverRequest(params);
+
+        m_mmWaveCellSetupCompleted[imsi] = false;
+      }  
+    }
+    else
+    {
+      if(!onHandoverImsi)
+      {
+        // trigger an handover to mmWave
+        m_mmWaveCellSetupCompleted[imsi] = false;
+        m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+        NS_LOG_INFO("---- on LTE, handover to MmWave " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+        SendHandoverRequest(GetRntiFromImsi(imsi), maxSinrCellId);
+      }
+    }
+     
+  }
+  else if(alreadyAssociatedImsi && !onHandoverImsi)
+  {
+    // the UE is connected to a mmWave eNB which was not in outage
+    // check if there are HO events pending
+    HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi); 
+    if(handoverEvent != m_imsiHandoverEventsMap.end())
+    {
+      // an handover event is already scheduled
+      // check if the cell to which the handover should happen is maxSinrCellId
+      if(handoverEvent->second.targetCellId == maxSinrCellId)
+      {
+        if(currentSinrDb < m_outageThreshold) // we need to handover right now!
+        {
+          handoverEvent->second.scheduledHandoverEvent.Cancel();
+          handoverNeeded = true;
+          NS_LOG_INFO("------ Handover was already scheduled, but the current cell is in outage, thus HO to " << maxSinrCellId);
+        }
+        else
+        {
+          // TODO consider if TTT must be updated or if it can remain as computed before
+          // we should compute the new TTT: if Now() + TTT < scheduledTime then update!
+          uint8_t newTtt = ComputeTtt(sinrDifference);
+          uint64_t handoverHappensAtTime = handoverEvent->second.scheduledHandoverEvent.GetTs(); // in nanoseconds
+          NS_LOG_INFO("Scheduled for " << handoverHappensAtTime << " while now the scheduler would give " << Simulator::Now().GetMilliSeconds() + newTtt);
+          if(Simulator::Now().GetMilliSeconds() + newTtt < (double)handoverHappensAtTime/1e6)
+          {
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            NS_LOG_INFO("------ Handover remains scheduled for " << maxSinrCellId << " but a new shorter TTT is computed");
+            handoverNeeded = true;
+          }  
+        }
+      }
+      else
+      {
+        uint16_t targetCellId = handoverEvent->second.targetCellId;
+        NS_LOG_INFO("------ Handover was scheduled for " << handoverEvent->second.targetCellId << " but now maxSinrCellId is " << maxSinrCellId);
+        //  get the SINR for the scheduled targetCellId: if the diff is smaller than 3 dB handover anyway
+        double originalTargetSinrDb = 10*std::log10(m_imsiCellSinrMap.find(imsi)->second[targetCellId]);
+        if(maxSinrDb - originalTargetSinrDb > m_sinrThresholdDifference) // this parameter is the same as the one for ThresholdBasedSecondaryCellHandover
+        {
+          // delete this event
+          handoverEvent->second.scheduledHandoverEvent.Cancel();
+          // we need to re-compute the TTT and schedule a new event
+          if(maxSinrCellId != m_lastMmWaveCell[imsi])
+          {
+            handoverNeeded = true;
+          }
+          else
+          {
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+        }
+        else
+        {
+          if(maxSinrCellId == m_lastMmWaveCell[imsi])
+          {
+            // delete this event
+            NS_LOG_INFO("-------------- The difference between the two mmWave SINR is smaller than " 
+                  << m_sinrThresholdDifference << " dB, but the new max is the current cell, thus cancel the handover");
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+          else
+          {
+            NS_LOG_INFO("-------------- The difference between the two mmWave SINR is smaller than " 
+                  << m_sinrThresholdDifference << " dB, do not cancel the handover");
+          }
+        } 
+      }
+    }
+    else
+    {
+      // check if the maxSinrCellId is different from the current cell
+      if(maxSinrCellId != m_lastMmWaveCell[imsi])
+      {
+        NS_LOG_INFO("----- Handover needed from cell " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId);
+        handoverNeeded = true;
+      }
+    }
+  }
+
+  if(handoverNeeded)
+  {
+    NS_LOG_DEBUG("handoverNeeded");
+    // compute the TTT
+    uint8_t millisecondsToHandover = ComputeTtt(sinrDifference);
+    NS_LOG_INFO("The sinrDifference is " << sinrDifference << " and the TTT computed is " << (uint32_t)millisecondsToHandover 
+      << " ms, thus the event will happen at time " << Simulator::Now().GetMilliSeconds() + millisecondsToHandover);
+    if(currentSinrDb < m_outageThreshold)
+    {
+      millisecondsToHandover = 0;
+      NS_LOG_INFO("Current Cell is in outage, handover immediately");
+    }
+    // schedule the event
+    EventId scheduledHandoverEvent = Simulator::Schedule(MilliSeconds(millisecondsToHandover), &LteEnbRrc::PerformHandover, this, imsi);
+    LteEnbRrc::HandoverEventInfo handoverInfo;
+    handoverInfo.sourceCellId = m_lastMmWaveCell[imsi];
+    handoverInfo.targetCellId = maxSinrCellId;
+    handoverInfo.scheduledHandoverEvent = scheduledHandoverEvent;
+    HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi); 
+    if(handoverEvent != m_imsiHandoverEventsMap.end()) // another event was scheduled, but it was already deleted. Replace the entry
+    {
+      handoverEvent->second = handoverInfo;
+    }
+    else
+    {
+      m_imsiHandoverEventsMap.insert(std::pair<uint64_t, HandoverEventInfo> (imsi, handoverInfo));
+    }
+    // when the handover event happens, we need to check that no other procedures are ongoing and in case
+    // postpone it!
+  }
+}
+
+uint8_t
+LteEnbRrc::ComputeTtt(double sinrDifference)
+{
+  if(m_handoverMode == FIXED_TTT)
+  {
+    return m_fixedTttValue;
+  }
+  else if(m_handoverMode == DYNAMIC_TTT)
+  {
+    if(sinrDifference < m_minDiffTttValue)
+    {
+      return m_maxDynTttValue;
+    }
+    else if(sinrDifference > m_maxDiffTttValue)
+    {
+      return m_minDynTttValue;
+    }
+    else // in between
+    {
+      double ttt = m_maxDynTttValue - (m_maxDynTttValue - m_minDynTttValue)*(sinrDifference - m_minDiffTttValue)/(m_maxDiffTttValue - m_minDiffTttValue);
+      NS_ASSERT_MSG(ttt >= 0, "Negative TTT!");
+      uint8_t truncated_ttt = ttt;
+      return truncated_ttt;
+    }
+  }
+  else
+  {
+    NS_FATAL_ERROR("Unsupported HO mode");
+  }
+}
+
+void
+LteEnbRrc::PerformHandover(uint64_t imsi)
+{
+  NS_ASSERT_MSG(m_imsiHandoverEventsMap.find(imsi) != m_imsiHandoverEventsMap.end(), "No handover event for this imsi!");
+  LteEnbRrc::HandoverEventInfo handoverInfo = m_imsiHandoverEventsMap.find(imsi)->second;
+  NS_ASSERT_MSG(handoverInfo.sourceCellId == m_lastMmWaveCell[imsi], "The secondary cell to which the UE is attached has changed handoverInfo.sourceCellId "
+    << handoverInfo.sourceCellId << " m_lastMmWaveCell[imsi] " << m_lastMmWaveCell[imsi] << " imsi " << imsi);
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("PerformHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  if(alreadyAssociatedImsi)
+  {
+    if(!onHandoverImsi)
+    {
+      // The new secondary cell HO procedure does not require to switch to LTE
+      NS_LOG_INFO("PerformHandover ----- handover from " << m_lastMmWaveCell[imsi] << " to " << handoverInfo.targetCellId << " at time " << Simulator::Now().GetSeconds());
+
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = handoverInfo.targetCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;    
+    }
+    else
+    {
+      //TODO Do nothing or what?
+      NS_LOG_UNCOND("## Warn: handover not triggered because the UE is already performing HO!");
+    }  
+  }
+  else
+  {
+    NS_LOG_UNCOND("## Warn: handover not triggered because the UE is not associated yet!");    
+  }
+
+  // remove the HandoverEvent from the map
+  m_imsiHandoverEventsMap.erase(m_imsiHandoverEventsMap.find(imsi));
+}
+
+void 
+LteEnbRrc::ThresholdBasedSecondaryCellHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb)
+{
+  uint64_t imsi = imsiIter->first;
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("ThresholdBasedSecondaryCellHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  if(maxSinrCellId == m_bestMmWaveCellForImsiMap[imsi] && !m_imsiUsingLte[imsi])
+  {
+    if (alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference) // not on LTE, handover between MmWave cells
+    // this may happen when channel changes while there is an handover
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " channel changed previously at time " << Simulator::Now().GetSeconds());
+
+      // The new secondary cell HO procedure does not require to switch to LTE
+      //Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+      //bool useMmWaveConnection = false;
+      //m_imsiUsingLte[imsi] = !useMmWaveConnection;
+      //ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false; // TODO check this bool
+      m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+      NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+    } 
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference << " at time " << Simulator::Now().GetSeconds());
+    }
+  }
+  else
+  {
+    if(alreadyAssociatedImsi && !onHandoverImsi && m_imsiUsingLte[imsi] && GetUeManager(GetRntiFromImsi(imsi))->GetAllMmWaveInOutageAtInitialAccess())
+    {
+      // perform initial access to mmWave eNB, since for the first time one mmWave eNB is not in outage!
+      NS_LOG_INFO("Send connect to " << maxSinrCellId << ", for the first time at least one mmWave eNB is not in outage");
+      m_rrcSapUser->SendRrcConnectToMmWave (GetRntiFromImsi(imsi), maxSinrCellId);   
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_imsiUsingLte[imsi] && m_lastMmWaveCell[imsi] == maxSinrCellId) 
+    // it is on LTE, but now the last used MmWave cell is not in outage
+    {
+      // switch back to MmWave
+      NS_LOG_INFO("----- on LTE, switch to lastMmWaveCell " << m_lastMmWaveCell[imsi] << " at time " << Simulator::Now().GetSeconds());
+      Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+      bool useMmWaveConnection = true;
+      m_imsiUsingLte[imsi] = !useMmWaveConnection;
+      ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+    }
+    else if (alreadyAssociatedImsi && !onHandoverImsi && m_imsiUsingLte[imsi] && m_lastMmWaveCell[imsi] != maxSinrCellId)
+    // it is on LTE, but now a MmWave cell different from the last used is not in outage, so we need to handover
+    {
+      // already using LTE connection
+      NS_LOG_INFO("----- on LTE, switch to new MmWaveCell " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+    }
+    else if (alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference) 
+    // not on LTE, handover between MmWave cells
+    {
+      // The new secondary cell HO procedure does not require to switch to LTE
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " at time " << Simulator::Now().GetSeconds());
+      //Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(imsi));
+      //bool useMmWaveConnection = false;
+      //m_imsiUsingLte[imsi] = !useMmWaveConnection;
+      //ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference << " at time " << Simulator::Now().GetSeconds());
+    }
+    m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+    NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+  }
+}
+
+void 
+LteEnbRrc::TriggerUeAssociationUpdate()
+{
+  if(m_imsiCellSinrMap.size() > 0) // there are some entries
+  {
+    for(std::map<uint64_t, CellSinrMap>::iterator imsiIter = m_imsiCellSinrMap.begin(); imsiIter != m_imsiCellSinrMap.end(); ++imsiIter)
+    {
+      uint64_t imsi = imsiIter->first;
+      long double maxSinr = 0;
+      long double currentSinr = 0;
+      uint16_t maxSinrCellId = 0;
+      bool alreadyAssociatedImsi = false;
+      bool onHandoverImsi = true;
+      Ptr<UeManager> ueMan;
+      // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+      // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+      // After the first connection to a MmWave eNB, the entry becomes true.
+      // When an handover between MmWave cells is triggered, it is set to false.
+      if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+      {
+        alreadyAssociatedImsi = true;
+        //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+        onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+
+      }
+      else
+      {
+        alreadyAssociatedImsi = false;
+        onHandoverImsi = true;
+      }
+      NS_LOG_INFO("alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+      for(CellSinrMap::iterator cellIter = imsiIter->second.begin(); cellIter != imsiIter->second.end(); ++cellIter)
+      {
+        NS_LOG_INFO("Cell " << cellIter->first << " reports " << 10*std::log10(cellIter->second));
+        if(cellIter->second > maxSinr)
+        {
+          maxSinr = cellIter->second;
+          maxSinrCellId = cellIter->first;
+        }
+        if(m_lastMmWaveCell[imsi] == cellIter->first)
+        {
+          currentSinr = cellIter->second;
+        }
+      }
+      long double sinrDifference = std::abs(10*(std::log10((long double)maxSinr) - std::log10((long double)currentSinr)));
+      long double maxSinrDb = 10*std::log10((long double)maxSinr);
+      long double currentSinrDb = 10*std::log10((long double)currentSinr);
+      NS_LOG_INFO("MaxSinr " << maxSinrDb << " in cell " << maxSinrCellId << 
+          " current cell " << m_lastMmWaveCell[imsi] << " currentSinr " << currentSinrDb << " sinrDifference " << sinrDifference);
+      if ((maxSinrDb < m_outageThreshold || (m_imsiUsingLte[imsi] && maxSinrDb < m_outageThreshold + 2)) && alreadyAssociatedImsi) // no MmWaveCell can serve this UE
+      {
+        // outage, perform fast switching if MC device or hard handover
+        NS_LOG_INFO("----- Warn: outage detected ------ at time " << Simulator::Now().GetSeconds());
+        if(m_imsiUsingLte[imsi] == false) 
+        {
+          ueMan = GetUeManager(GetRntiFromImsi(imsi));
+          NS_LOG_INFO("Switch to LTE stack");
+          bool useMmWaveConnection = false; 
+          m_imsiUsingLte[imsi] = !useMmWaveConnection;
+          ueMan->SendRrcConnectionSwitch(useMmWaveConnection);
+          //m_switchEnabled = false;
+          //Simulator::Schedule(MilliSeconds(50), &LteEnbRrc::EnableSwitching, this, imsi);
+
+          // delete the handover event which was scheduled for this UE (if any)
+          HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi); 
+          if(handoverEvent != m_imsiHandoverEventsMap.end())
+          {
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+        }
+        else
+        {
+          NS_LOG_INFO("Already on LTE");
+          ueMan = GetUeManager(GetRntiFromImsi(imsi));
+          if(ueMan->GetAllMmWaveInOutageAtInitialAccess())
+          {
+            NS_LOG_INFO("The UE never connected to a mmWave eNB");
+          }
+        }
+      } 
+      else
+      {
+        if(m_handoverMode == THRESHOLD)
+        {
+          ThresholdBasedSecondaryCellHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);  
+        }
+        else if(m_handoverMode == FIXED_TTT || m_handoverMode == DYNAMIC_TTT)
+        {
+          m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+          TttBasedHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);
+        }
+        else
+        {
+          NS_FATAL_ERROR("Unsupported HO mode");
+        }
+      }
+    }
+  }
+  
+  Simulator::Schedule(MicroSeconds(m_crtPeriod), &LteEnbRrc::TriggerUeAssociationUpdate, this);
+}
+
+
+void 
+LteEnbRrc::ThresholdBasedInterRatHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb)
+{
+  uint64_t imsi = imsiIter->first;
+  bool alreadyAssociatedImsi = false;
+  bool onHandoverImsi = true;
+  // On RecvRrcConnectionRequest for a new RNTI, the Lte Enb RRC stores the imsi
+  // of the UE and insert a new false entry in m_mmWaveCellSetupCompleted.
+  // After the first connection to a MmWave eNB, the entry becomes true.
+  // When an handover between MmWave cells is triggered, it is set to false.
+  if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+  {
+    alreadyAssociatedImsi = true;
+    //onHandoverImsi = (!m_switchEnabled) ? true : !m_mmWaveCellSetupCompleted.find(imsi)->second;
+    onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+  }
+  else
+  {
+    alreadyAssociatedImsi = false;
+    onHandoverImsi = true;
+  }
+  NS_LOG_INFO("ThresholdBasedSecondaryCellHandover: alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+  if(maxSinrCellId == m_bestMmWaveCellForImsiMap[imsi] && !m_imsiUsingLte[imsi])
+  {
+    if (alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference) // not on LTE, handover between MmWave cells
+    // this may happen when channel changes while there is an handover
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " channel changed previously");
+      // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+      m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+      NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+    } 
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference);
+    }
+  }
+  else
+  {
+    if(m_imsiUsingLte[imsi] && alreadyAssociatedImsi && !onHandoverImsi) 
+    // it is on LTE, but now the a MmWave cell is not in outage
+    {
+      // switch back to MmWave
+      m_mmWaveCellSetupCompleted[imsi] = false;
+      m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+      NS_LOG_INFO("Handover to MmWave " << m_bestMmWaveCellForImsiMap[imsi]);
+      SendHandoverRequest(GetRntiFromImsi(imsi), m_bestMmWaveCellForImsiMap[imsi]);
+    }
+    else if (!m_imsiUsingLte[imsi] && alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference > m_sinrThresholdDifference) // not on LTE, handover between MmWave cells
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId);
+                  // trigger ho via X2
+      EpcX2SapProvider::SecondaryHandoverParams params;
+      params.imsi = imsi;
+      params.targetCellId = maxSinrCellId;
+      params.oldCellId = m_lastMmWaveCell[imsi];
+      m_x2SapProvider->SendMcHandoverRequest(params);
+
+      m_mmWaveCellSetupCompleted[imsi] = false;
+    }
+    else if(alreadyAssociatedImsi && !onHandoverImsi && m_lastMmWaveCell[imsi] != maxSinrCellId && sinrDifference < m_sinrThresholdDifference)
+    {
+      NS_LOG_INFO("----- handover from " << m_lastMmWaveCell[imsi] << " to " << maxSinrCellId << " not triggered due to small diff " << sinrDifference);
+    }
+    m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+    NS_LOG_INFO("For imsi " << imsi << " the best cell is " << m_bestMmWaveCellForImsiMap[imsi] << " with SINR " << maxSinrDb);
+  }
+}
+
+void
+LteEnbRrc::EnableSwitching(uint64_t imsi)
+{
+  m_switchEnabled = true;
+}
+
+void
+LteEnbRrc::UpdateUeHandoverAssociation()
+{
+  // TODO rules for possible ho of each UE
+  if(m_imsiCellSinrMap.size() > 0) // there are some entries
+  {
+    for(std::map<uint64_t, CellSinrMap>::iterator imsiIter = m_imsiCellSinrMap.begin(); imsiIter != m_imsiCellSinrMap.end(); ++imsiIter)
+    {
+      uint64_t imsi = imsiIter->first;
+      long double maxSinr = 0;
+      long double currentSinr = 0;
+      uint16_t maxSinrCellId = 0;
+      bool alreadyAssociatedImsi = false;
+      bool onHandoverImsi = true;
+      
+      // If the LteEnbRrc is InterRatHo mode, the MmWave eNB notifies the 
+      // LTE eNB of the first access of a certain imsi. This is stored in a map
+      // and m_mmWaveCellSetupCompleted for that imsi is set to true.
+      // When an handover between MmWave cells is triggered, it is set to false.
+      if(m_mmWaveCellSetupCompleted.find(imsi) != m_mmWaveCellSetupCompleted.end())
+      {
+        alreadyAssociatedImsi = true;
+        onHandoverImsi = !m_mmWaveCellSetupCompleted.find(imsi)->second;
+      }
+      else
+      {
+        alreadyAssociatedImsi = false;
+        onHandoverImsi = true;
+      }
+      NS_LOG_INFO("alreadyAssociatedImsi " << alreadyAssociatedImsi << " onHandoverImsi " << onHandoverImsi);
+
+      for(CellSinrMap::iterator cellIter = imsiIter->second.begin(); cellIter != imsiIter->second.end(); ++cellIter)
+      {
+        NS_LOG_INFO("Cell " << cellIter->first << " reports " << 10*std::log10(cellIter->second));
+        if(cellIter->second > maxSinr)
+        {
+          maxSinr = cellIter->second;
+          maxSinrCellId = cellIter->first;
+        }
+        if(m_lastMmWaveCell[imsi] == cellIter->first)
+        {
+          currentSinr = cellIter->second;
+        }
+      }
+
+      long double sinrDifference = std::abs(10*(std::log10((long double)maxSinr) - std::log10((long double)currentSinr)));
+      long double maxSinrDb = 10*std::log10((long double)maxSinr);
+      long double currentSinrDb = 10*std::log10((long double)currentSinr);
+      NS_LOG_INFO("MaxSinr " << maxSinrDb << " in cell " << maxSinrCellId << 
+          " current cell " << m_lastMmWaveCell[imsi] << " currentSinr " << currentSinrDb << " sinrDifference " << sinrDifference);
+      // check if MmWave cells are in outage. In this case the UE should handover to LTE cell
+      if (maxSinrDb < m_outageThreshold || (m_imsiUsingLte[imsi] && maxSinrDb < m_outageThreshold + 2)) // no MmWaveCell can serve this UE
+      {
+        // outage, perform handover to LTE
+        NS_LOG_INFO("----- Warn: outage detected ------");
+        if(m_imsiUsingLte[imsi] == false) 
+        {
+          NS_LOG_INFO("Handover to LTE");
+          if(!onHandoverImsi)
+          {
+            bool useMmWaveConnection = false; 
+            m_imsiUsingLte[imsi] = !useMmWaveConnection;
+            // trigger ho via X2
+            EpcX2SapProvider::SecondaryHandoverParams params;
+            params.imsi = imsi;
+            params.targetCellId = m_cellId;
+            params.oldCellId = m_lastMmWaveCell[imsi];
+            m_mmWaveCellSetupCompleted.find(imsi)->second = false;
+            m_x2SapProvider->SendMcHandoverRequest(params);
+          }
+          else
+          {
+            NS_LOG_INFO("Already performing another HO");
+          }
+
+          // delete the handover event which was scheduled for this UE (if any)
+          HandoverEventMap::iterator handoverEvent = m_imsiHandoverEventsMap.find(imsi); 
+          if(handoverEvent != m_imsiHandoverEventsMap.end())
+          {
+            handoverEvent->second.scheduledHandoverEvent.Cancel();
+            m_imsiHandoverEventsMap.erase(handoverEvent);
+          }
+          
+        }
+        else
+        {
+          NS_LOG_INFO("Already on LTE");
+        }
+      }
+      else // there is at least a MmWave eNB that can serve this UE
+      {
+        if(m_handoverMode == THRESHOLD)
+        {
+          ThresholdBasedInterRatHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);  
+        }
+        else if(m_handoverMode == FIXED_TTT || m_handoverMode == DYNAMIC_TTT)
+        {
+          m_bestMmWaveCellForImsiMap[imsi] = maxSinrCellId;
+          TttBasedHandover(imsiIter, sinrDifference, maxSinrCellId, maxSinrDb);
+        }
+        else
+        {
+          NS_FATAL_ERROR("Unsupported HO mode");
+        }
+      }
+    }
+  }
+  Simulator::Schedule(MicroSeconds(m_crtPeriod), &LteEnbRrc::UpdateUeHandoverAssociation, this);
+}
+
+void
+LteEnbRrc::DoRecvMcHandoverRequest(EpcX2SapUser::SecondaryHandoverParams params)
+{
+  NS_ASSERT_MSG(m_ismmWave == true, "Trying to perform HO for a secondary cell on a non secondary cell");
+  // retrieve RNTI
+  uint16_t rnti = GetRntiFromImsi(params.imsi);
+  NS_LOG_LOGIC("Rnti " << rnti);
+  SendHandoverRequest(rnti, params.targetCellId);
+}
+
+bool
+LteEnbRrc::SendData (Ptr<Packet> packet)
+{
+  NS_LOG_FUNCTION (this << packet);
+
+  EpsBearerTag tag;
+  bool found = packet->RemovePacketTag (tag);
+  NS_ASSERT_MSG (found, "no EpsBearerTag found in packet to be sent");
+  Ptr<UeManager> ueManager = GetUeManager (tag.GetRnti ());
+  ueManager->SendData (tag.GetBid (), packet);
+
+  return true;
+}
 
 void 
 LteEnbRrc::SetForwardUpCallback (Callback <void, Ptr<Packet> > cb)
@@ -2184,9 +3860,25 @@
 LteEnbRrc::HandoverJoiningTimeout (uint16_t rnti)
 {
   NS_LOG_FUNCTION (this << rnti);
+  NS_LOG_INFO("Handover joining Timeout on cell " << m_cellId);
   NS_ASSERT_MSG (GetUeManager (rnti)->GetState () == UeManager::HANDOVER_JOINING,
                  "HandoverJoiningTimeout in unexpected state " << ToString (GetUeManager (rnti)->GetState ()));
-  RemoveUe (rnti);
+  
+  // notify the LTE eNB (coordinator) of the failure
+  if(m_ismmWave)
+  {
+    uint16_t sourceCellId = (GetUeManager (rnti)->GetSource()).first;
+
+    NS_LOG_INFO ("rejecting handover request from cellId " << sourceCellId);
+    EpcX2SapProvider::HandoverFailedParams res;
+    res.sourceCellId = sourceCellId;
+    res.targetCellId = m_cellId;
+    res.coordinatorId = m_lteCellId;
+    res.imsi = GetImsiFromRnti(rnti);
+    m_x2SapProvider->NotifyCoordinatorHandoverFailed(res);
+  }
+  // schedule the removal of the UE
+  Simulator::Schedule(MilliSeconds(300), &LteEnbRrc::RemoveUe, this, rnti);
 }
 
 void
@@ -2205,6 +3897,8 @@
   NS_LOG_LOGIC ("Request to send HANDOVER REQUEST");
   NS_ASSERT (m_configured);
 
+  NS_LOG_INFO("LteEnbRrc on cell " << m_cellId << " for rnti " << rnti << " SendHandoverRequest at time " << Simulator::Now().GetSeconds() << " to cellId " << cellId);
+
   Ptr<UeManager> ueManager = GetUeManager (rnti);
   ueManager->PrepareHandover (cellId);
  
@@ -2235,6 +3929,7 @@
 LteEnbRrc::DoRecvRrcConnectionReconfigurationCompleted (uint16_t rnti, LteRrcSap::RrcConnectionReconfigurationCompleted msg)
 {
   NS_LOG_FUNCTION (this << rnti);
+  NS_LOG_INFO("Received RRC connection reconf completed on cell " << m_cellId);
   GetUeManager (rnti)->RecvRrcConnectionReconfigurationCompleted (msg);
 }
 
@@ -2260,6 +3955,13 @@
 }
 
 void 
+LteEnbRrc::DoRecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  NS_LOG_FUNCTION (this << rnti);
+  GetUeManager (rnti)->RecvRrcSecondaryCellInitialAccessSuccessful (mmWaveRnti, mmWaveCellId);
+}
+
+void 
 LteEnbRrc::DoDataRadioBearerSetupRequest (EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters request)
 {
   Ptr<UeManager> ueManager = GetUeManager (request.rnti);
@@ -2278,12 +3980,15 @@
 {
   NS_LOG_FUNCTION (this);
 
-  NS_LOG_LOGIC ("Recv X2 message: HANDOVER REQUEST");
+  NS_LOG_INFO ("Recv X2 message: HANDOVER REQUEST");
 
   NS_LOG_LOGIC ("oldEnbUeX2apId = " << req.oldEnbUeX2apId);
   NS_LOG_LOGIC ("sourceCellId = " << req.sourceCellId);
   NS_LOG_LOGIC ("targetCellId = " << req.targetCellId);
   NS_LOG_LOGIC ("mmeUeS1apId = " << req.mmeUeS1apId);
+  NS_LOG_INFO ("isMc = " << req.isMc);
+
+  NS_ASSERT (req.targetCellId == m_cellId);
 
   if (m_admitHandoverRequest == false)
     {
@@ -2298,8 +4003,8 @@
       return;
     }
 
-  uint16_t rnti = AddUe (UeManager::HANDOVER_JOINING, CellToComponentCarrierId (req.targetCellId));
-  LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue anrcrv = m_cmacSapProvider.at (0)->AllocateNcRaPreamble (rnti);
+  uint16_t rnti = AddUe (UeManager::HANDOVER_JOINING);
+  LteEnbCmacSapProvider::AllocateNcRaPreambleReturnValue anrcrv = m_cmacSapProvider->AllocateNcRaPreamble (rnti);
   if (anrcrv.valid == false)
     {
       NS_LOG_INFO (this << " failed to allocate a preamble for non-contention based RA => cannot accept HO");
@@ -2311,6 +4016,8 @@
   Ptr<UeManager> ueManager = GetUeManager (rnti);
   ueManager->SetSource (req.sourceCellId, req.oldEnbUeX2apId);
   ueManager->SetImsi (req.mmeUeS1apId);
+  ueManager->SetIsMc (req.isMc);
+  RegisterImsiToRnti(req.mmeUeS1apId, rnti);
 
   EpcX2SapProvider::HandoverRequestAckParams ackParams;
   ackParams.oldEnbUeX2apId = req.oldEnbUeX2apId;
@@ -2328,9 +4035,17 @@
       ackParams.admittedBearers.push_back (i);
     }
 
+  // For secondary cell HO for MC devices, setup RLC instances
+  for (std::vector <EpcX2Sap::RlcSetupRequest>::iterator it = req.rlcRequests.begin();
+     it != req.rlcRequests.end ();
+       ++it)
+  {
+    ueManager->RecvRlcSetupRequest(*it);
+  }
+
   LteRrcSap::RrcConnectionReconfiguration handoverCommand = ueManager->GetRrcConnectionReconfigurationForHandover ();
   handoverCommand.haveMobilityControlInfo = true;
-  handoverCommand.mobilityControlInfo.targetPhysCellId = req.targetCellId;
+  handoverCommand.mobilityControlInfo.targetPhysCellId = m_cellId;
   handoverCommand.mobilityControlInfo.haveCarrierFreq = true;
   handoverCommand.mobilityControlInfo.carrierFreq.dlCarrierFreq = m_dlEarfcn;
   handoverCommand.mobilityControlInfo.carrierFreq.ulCarrierFreq = m_ulEarfcn;
@@ -2342,11 +4057,10 @@
   handoverCommand.mobilityControlInfo.rachConfigDedicated.raPreambleIndex = anrcrv.raPreambleId;
   handoverCommand.mobilityControlInfo.rachConfigDedicated.raPrachMaskIndex = anrcrv.raPrachMaskIndex;
 
-  LteEnbCmacSapProvider::RachConfig rc = m_cmacSapProvider.at (0)->GetRachConfig ();
+  LteEnbCmacSapProvider::RachConfig rc = m_cmacSapProvider->GetRachConfig ();
   handoverCommand.mobilityControlInfo.radioResourceConfigCommon.rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
   handoverCommand.mobilityControlInfo.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
   handoverCommand.mobilityControlInfo.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
-  handoverCommand.haveNonCriticalExtension = false;
 
   Ptr<Packet> encodedHandoverCommand = m_rrcSapUser->EncodeHandoverCommand (handoverCommand);
 
@@ -2380,6 +4094,19 @@
 }
 
 void
+LteEnbRrc::DoRecvSecondaryCellHandoverCompleted (EpcX2SapUser::SecondaryHandoverCompletedParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_ASSERT_MSG(!m_ismmWave, "Only the LTE cell (coordinator) can receive a SecondaryCellHandoverCompleted message");
+  NS_LOG_LOGIC ("Recv X2 message: SECONDARY CELL HANDOVER COMPLETED");
+
+  // get the RNTI from IMSI
+  Ptr<UeManager> ueMan = GetUeManager(GetRntiFromImsi(params.imsi));
+  ueMan->RecvSecondaryCellHandoverCompleted(params);
+}
+
+void
 LteEnbRrc::DoRecvHandoverPreparationFailure (EpcX2SapUser::HandoverPreparationFailureParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -2424,11 +4151,68 @@
   NS_LOG_LOGIC ("newEnbUeX2apId = " << params.newEnbUeX2apId);
 
   uint16_t rnti = params.oldEnbUeX2apId;
+
+  if(m_interRatHoMode && m_ismmWave)
+  {
+    NS_LOG_INFO("Notify LTE eNB that the handover is completed from cell " << m_cellId << " to " << params.sourceCellId);
+    EpcX2Sap::SecondaryHandoverParams sendParams;
+    sendParams.imsi = GetImsiFromRnti(rnti);
+    sendParams.oldCellId = m_lteCellId;
+    sendParams.targetCellId = params.sourceCellId;
+    m_x2SapProvider->NotifyLteMmWaveHandoverCompleted(sendParams);
+  }
+  else if(m_interRatHoMode && !m_ismmWave)
+  {
+    NS_LOG_INFO("LTE eNB received UE context release from cell " << params.sourceCellId);
+    m_lastMmWaveCell[GetImsiFromRnti(rnti)] = params.sourceCellId;
+    m_mmWaveCellSetupCompleted[GetImsiFromRnti(rnti)] = true;
+    m_imsiUsingLte[GetImsiFromRnti(rnti)] = false;
+  }
+
   GetUeManager (rnti)->RecvUeContextRelease (params);
   RemoveUe (rnti);
 }
 
 void
+LteEnbRrc::DoRecvLteMmWaveHandoverCompleted (EpcX2SapUser::SecondaryHandoverParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_INFO ("Recv X2 message: NOTIFY MMWAVE HANDOVER COMPLETED " << m_interRatHoMode << " m_ismmWave " << m_ismmWave);
+
+  if(m_interRatHoMode && !m_ismmWave)
+  {
+    uint64_t imsi = params.imsi;
+    NS_LOG_INFO("LTE eNB received notification that MmWave handover is completed to cell " << params.targetCellId);
+    m_lastMmWaveCell[imsi] = params.targetCellId;
+    if(params.targetCellId != m_cellId)
+    {
+      m_imsiUsingLte[imsi] = false;
+      m_mmWaveCellSetupCompleted[imsi] = true;
+    }
+    else
+    {
+      // m_imsiUsingLte[imsi] = true;
+      // if the LTE cell is the target of the Handover, it may still 
+      // be in the RRC RECONFIGURATION phase
+      GetUeManager(GetRntiFromImsi(imsi))->RecvNotifyLteMmWaveHandoverCompleted();
+      // m_mmWaveCellSetupCompleted[imsi] = true;
+    }
+  }
+}
+
+void
+LteEnbRrc::DoRecvConnectionSwitchToMmWave (EpcX2SapUser::SwitchConnectionParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("Recv X2 message: SWITCH CONNECTION");
+
+  GetUeManager(params.mmWaveRnti)->RecvConnectionSwitchToMmWave(params.useMmWaveConnection, params.drbid);
+}
+
+
+void
 LteEnbRrc::DoRecvLoadInformation (EpcX2SapUser::LoadInformationParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -2437,7 +4221,7 @@
 
   NS_LOG_LOGIC ("Number of cellInformationItems = " << params.cellInformationList.size ());
 
-  m_ffrRrcSapProvider.at (0)->RecvLoadInformation (params);
+  m_ffrRrcSapProvider->RecvLoadInformation(params);
 }
 
 void
@@ -2453,6 +4237,35 @@
 }
 
 void
+LteEnbRrc::DoRecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("Recv X2 message: RLC SETUP REQUEST");
+
+  GetUeManager(params.mmWaveRnti)->RecvRlcSetupRequest(params);
+}
+
+void
+LteEnbRrc::DoRecvRlcSetupCompleted (EpcX2SapUser::UeDataParams params)
+{
+  NS_LOG_FUNCTION (this);
+
+  NS_LOG_LOGIC ("Recv X2 message: RLC SETUP COMPLETED");
+
+  std::map<uint32_t, X2uTeidInfo>::iterator 
+    teidInfoIt = m_x2uMcTeidInfoMap.find (params.gtpTeid);
+  if (teidInfoIt != m_x2uMcTeidInfoMap.end ())
+    {
+      GetUeManager (teidInfoIt->second.rnti)->RecvRlcSetupCompleted (teidInfoIt->second.drbid);
+    }
+  else
+    {
+      NS_FATAL_ERROR ("No X2uMcTeidInfo found");
+    }
+}
+
+void
 LteEnbRrc::DoRecvUeData (EpcX2SapUser::UeDataParams params)
 {
   NS_LOG_FUNCTION (this);
@@ -2472,16 +4285,23 @@
     }
   else
     {
-      NS_FATAL_ERROR ("X2-U data received but no X2uTeidInfo found");
+      teidInfoIt = m_x2uMcTeidInfoMap.find(params.gtpTeid);
+      if(teidInfoIt != m_x2uMcTeidInfoMap.end ())
+      {
+        GetUeManager (teidInfoIt->second.rnti)->SendData (teidInfoIt->second.drbid, params.ueData);
+      }
+      else
+      {
+        NS_FATAL_ERROR ("X2-U data received but no X2uTeidInfo found");
+      }
     }
 }
 
-
 uint16_t 
-LteEnbRrc::DoAllocateTemporaryCellRnti (uint8_t componentCarrierId)
+LteEnbRrc::DoAllocateTemporaryCellRnti ()
 {
-  NS_LOG_FUNCTION (this << +componentCarrierId);
-  return AddUe (UeManager::INITIAL_RANDOM_ACCESS, componentCarrierId);
+  NS_LOG_FUNCTION (this);
+  return AddUe (UeManager::INITIAL_RANDOM_ACCESS);
 }
 
 void
@@ -2508,15 +4328,6 @@
   return measId;
 }
 
-uint8_t
-LteEnbRrc::DoAddUeMeasReportConfigForComponentCarrier (LteRrcSap::ReportConfigEutra reportConfig)
-{
-  NS_LOG_FUNCTION (this);
-  uint8_t measId = AddUeMeasReportConfig (reportConfig);
-  m_componentCarrierMeasIds.insert (measId);
-  return measId;
-}
-
 void
 LteEnbRrc::DoTriggerHandover (uint16_t rnti, uint16_t targetCellId)
 {
@@ -2524,15 +4335,12 @@
 
   bool isHandoverAllowed = true;
 
-  Ptr<UeManager> ueManager = GetUeManager (rnti);
-  NS_ASSERT_MSG (ueManager != 0, "Cannot find UE context with RNTI " << rnti);
-
   if (m_anrSapProvider != 0)
     {
       // ensure that proper neighbour relationship exists between source and target cells
       bool noHo = m_anrSapProvider->GetNoHo (targetCellId);
       bool noX2 = m_anrSapProvider->GetNoX2 (targetCellId);
-      NS_LOG_DEBUG (this << " cellId=" << ComponentCarrierToCellId (ueManager->GetComponentCarrierId ())
+      NS_LOG_DEBUG (this << " cellId=" << m_cellId
                          << " targetCellId=" << targetCellId
                          << " NRT.NoHo=" << noHo << " NRT.NoX2=" << noX2);
 
@@ -2544,6 +4352,9 @@
         }
     }
 
+  Ptr<UeManager> ueManager = GetUeManager (rnti);
+  NS_ASSERT_MSG (ueManager != 0, "Cannot find UE context with RNTI " << rnti);
+
   if (ueManager->GetState () != UeManager::CONNECTED_NORMALLY)
     {
       isHandoverAllowed = false;
@@ -2594,7 +4405,7 @@
 }
 
 uint16_t
-LteEnbRrc::AddUe (UeManager::State state, uint8_t componentCarrierId)
+LteEnbRrc::AddUe (UeManager::State state)
 {
   NS_LOG_FUNCTION (this);
   bool found = false;
@@ -2612,13 +4423,11 @@
 
   NS_ASSERT_MSG (found, "no more RNTIs available (do you have more than 65535 UEs in a cell?)");
   m_lastAllocatedRnti = rnti;
-  Ptr<UeManager> ueManager = CreateObject<UeManager> (this, rnti, state, componentCarrierId);
-  m_ccmRrcSapProvider-> AddUe (rnti, (uint8_t)state);
+  Ptr<UeManager> ueManager = CreateObject<UeManager> (this, rnti, state); 
   m_ueMap.insert (std::pair<uint16_t, Ptr<UeManager> > (rnti, ueManager));
   ueManager->Initialize ();
-  const uint16_t cellId = ComponentCarrierToCellId (componentCarrierId);
-  NS_LOG_DEBUG (this << " New UE RNTI " << rnti << " cellId " << cellId << " srs CI " << ueManager->GetSrsConfigurationIndex ());
-  m_newUeContextTrace (cellId, rnti);
+  NS_LOG_DEBUG (this << " New UE RNTI " << rnti << " cellId " << m_cellId << " srs CI " << ueManager->GetSrsConfigurationIndex ());
+  m_newUeContextTrace (m_cellId, rnti);
   return rnti;
 }
 
@@ -2629,17 +4438,14 @@
   std::map <uint16_t, Ptr<UeManager> >::iterator it = m_ueMap.find (rnti);
   NS_ASSERT_MSG (it != m_ueMap.end (), "request to remove UE info with unknown rnti " << rnti);
   uint16_t srsCi = (*it).second->GetSrsConfigurationIndex ();
+  bool isMc = it->second->GetIsMc();
   m_ueMap.erase (it);
-  for (uint8_t i = 0; i < m_numberOfComponentCarriers; i++)
-    {
-      m_cmacSapProvider.at (i)->RemoveUe (rnti);
-      m_cphySapProvider.at (i)->RemoveUe (rnti);
-    }
-  if (m_s1SapProvider != 0)
+  m_cmacSapProvider->RemoveUe (rnti);
+  m_cphySapProvider->RemoveUe (rnti);
+  if (m_s1SapProvider != 0 && !isMc)
     {
       m_s1SapProvider->UeContextRelease (rnti);
     }
-  m_ccmRrcSapProvider-> RemoveUe (rnti);
   // need to do this after UeManager has been deleted
   RemoveSrsConfigurationIndex (srsCi); 
 }
@@ -2672,6 +4478,10 @@
         }
       break;
 
+    case RLC_UM_LOWLAT_ALWAYS:
+      return LteRlcUmLowLat::GetTypeId ();
+      break;
+
     default:
       return LteRlcSm::GetTypeId ();
       break;
@@ -2694,19 +4504,11 @@
 LteEnbRrc::SetCsgId (uint32_t csgId, bool csgIndication)
 {
   NS_LOG_FUNCTION (this << csgId << csgIndication);
-  for (uint8_t componentCarrierId = 0; componentCarrierId < m_sib1.size (); componentCarrierId++)
-    {
-      m_sib1.at (componentCarrierId).cellAccessRelatedInfo.csgIdentity = csgId;
-      m_sib1.at (componentCarrierId).cellAccessRelatedInfo.csgIndication = csgIndication;
-      m_cphySapProvider.at (componentCarrierId)->SetSystemInformationBlockType1 (m_sib1.at (componentCarrierId));
-    }
+  m_sib1.cellAccessRelatedInfo.csgIdentity = csgId;
+  m_sib1.cellAccessRelatedInfo.csgIndication = csgIndication;
+  m_cphySapProvider->SetSystemInformationBlockType1 (m_sib1);
 }
 
-void
-LteEnbRrc::SetNumberOfComponentCarriers(uint16_t numberOfComponentCarriers)
-{
-  m_numberOfComponentCarriers = numberOfComponentCarriers;
-}
 
 /// Number of distinct SRS periodicity plus one.
 static const uint8_t SRS_ENTRIES = 9;
@@ -2836,6 +4638,19 @@
 }
 
 uint8_t 
+LteEnbRrc::GetLogicalChannelGroup (bool isGbr)
+{
+  if (isGbr)
+    {
+      return 1;
+    }
+  else
+    {
+      return 2;
+    }
+}
+
+uint8_t 
 LteEnbRrc::GetLogicalChannelPriority (EpsBearer bearer)
 {
   return bearer.qci;
@@ -2846,31 +4661,25 @@
 {
   // NS_LOG_FUNCTION (this);
 
-  for (auto &it: m_componentCarrierPhyConf)
-    {
-      uint8_t ccId = it.first;
-
-      LteRrcSap::SystemInformation si;
-      si.haveSib2 = true;
-      si.sib2.freqInfo.ulCarrierFreq = it.second->GetUlEarfcn ();
-      si.sib2.freqInfo.ulBandwidth = it.second->GetUlBandwidth ();
-      si.sib2.radioResourceConfigCommon.pdschConfigCommon.referenceSignalPower = m_cphySapProvider.at (ccId)->GetReferenceSignalPower ();
-      si.sib2.radioResourceConfigCommon.pdschConfigCommon.pb = 0;
-
-      LteEnbCmacSapProvider::RachConfig rc = m_cmacSapProvider.at (ccId)->GetRachConfig ();
-      LteRrcSap::RachConfigCommon rachConfigCommon;
-      rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
-      rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
-      rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
-      si.sib2.radioResourceConfigCommon.rachConfigCommon = rachConfigCommon;
-
-      m_rrcSapUser->SendSystemInformation (it.second->GetCellId (), si);
-    }
-
   /*
    * For simplicity, we use the same periodicity for all SIBs. Note that in real
    * systems the periodicy of each SIBs could be different.
    */
+  LteRrcSap::SystemInformation si;
+  si.haveSib2 = true;
+  si.sib2.freqInfo.ulCarrierFreq = m_ulEarfcn;
+  si.sib2.freqInfo.ulBandwidth = m_ulBandwidth;
+  si.sib2.radioResourceConfigCommon.pdschConfigCommon.referenceSignalPower = m_cphySapProvider->GetReferenceSignalPower();
+  si.sib2.radioResourceConfigCommon.pdschConfigCommon.pb = 0;
+
+  LteEnbCmacSapProvider::RachConfig rc = m_cmacSapProvider->GetRachConfig ();
+  LteRrcSap::RachConfigCommon rachConfigCommon;
+  rachConfigCommon.preambleInfo.numberOfRaPreambles = rc.numberOfRaPreambles;
+  rachConfigCommon.raSupervisionInfo.preambleTransMax = rc.preambleTransMax;
+  rachConfigCommon.raSupervisionInfo.raResponseWindowSize = rc.raResponseWindowSize;
+  si.sib2.radioResourceConfigCommon.rachConfigCommon = rachConfigCommon;
+
+  m_rrcSapUser->SendSystemInformation (si);
   Simulator::Schedule (m_systemInformationPeriodicity, &LteEnbRrc::SendSystemInformation, this);
 }
 
diff -Naru a/model/lte-enb-rrc.h b/model/lte-enb-rrc.h
--- a/model/lte-enb-rrc.h	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-enb-rrc.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,9 +19,9 @@
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Marco Miozzo <mmiozzo@cttc.es>
  *          Manuel Requena <manuel.requena@cttc.es> 
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_ENB_RRC_H
@@ -39,30 +40,28 @@
 #include <ns3/epc-x2-sap.h>
 #include <ns3/epc-enb-s1-sap.h>
 #include <ns3/lte-handover-management-sap.h>
-#include <ns3/lte-ccm-rrc-sap.h>
 #include <ns3/lte-enb-cphy-sap.h>
 #include <ns3/lte-rrc-sap.h>
 #include <ns3/lte-anr-sap.h>
 #include <ns3/lte-ffr-rrc-sap.h>
 #include <ns3/lte-rlc.h>
+#include <ns3/lte-pdcp.h>
+#include <ns3/lte-rlc-am.h>
 
 #include <map>
 #include <set>
-#include <ns3/component-carrier-enb.h>
-#include <vector>
-
-#define MIN_NO_CC 1
-#define MAX_NO_CC 5 // this is the maximum number of carrier components allowed by 3GPP up to R13
 
 namespace ns3 {
 
 class LteRadioBearerInfo;
 class LteSignalingRadioBearerInfo;
 class LteDataRadioBearerInfo;
+class RlcBearerInfo;
 class LteEnbRrc;
 class Packet;
 
-
+typedef std::map<uint64_t, double> ImsiSinrMap;
+typedef std::map<uint16_t, double> CellSinrMap;
 
 /**
  * \ingroup lte
@@ -71,7 +70,6 @@
  */
 class UeManager : public Object
 {
-  /// allow LtePdcpSpecificLtePdcpSapUser<UeManager> class friend access
   friend class LtePdcpSpecificLtePdcpSapUser<UeManager>;
 
 public:
@@ -93,6 +91,8 @@
     HANDOVER_JOINING,
     HANDOVER_PATH_SWITCH,
     HANDOVER_LEAVING,
+    PREPARE_MC_CONNECTION_RECONFIGURATION,
+    MC_CONNECTION_RECONFIGURATION,
     NUM_STATES
   };
 
@@ -104,11 +104,10 @@
    * \param rrc pointer to the LteEnbRrc holding this UeManager
    * \param rnti RNTI of the UE
    * \param s initial state of the UeManager
-   * \param componentCarrierId primary component carrier ID
    * 
    * \return 
    */
-  UeManager (Ptr<LteEnbRrc> rrc, uint16_t rnti, State s, uint8_t componentCarrierId);
+  UeManager (Ptr<LteEnbRrc> rrc, uint16_t rnti, State s);
 
   virtual ~UeManager (void);
 
@@ -117,10 +116,6 @@
   virtual void DoInitialize ();
   virtual void DoDispose ();
 public: 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
   /** 
@@ -131,6 +126,7 @@
    * \param sourceX2apId 
    */
   void SetSource (uint16_t sourceCellId, uint16_t sourceX2apId);
+  std::pair<uint16_t, uint16_t> GetSource (void);
 
   /** 
    * Set the IMSI
@@ -139,6 +135,13 @@
    */
   void SetImsi (uint64_t imsi);
 
+  // set if this is a MC device
+  void SetIsMc (bool isMc);
+  // know if this is a MC device
+  bool GetIsMc (void) const;
+
+  //void SetIsInterRatHoCapable (bool isInterRatHoCapable);
+
   /** 
    * Setup a new data radio bearer, including both the configuration
    * within the eNB and the necessary RRC signaling with the UE
@@ -232,6 +235,8 @@
    */
   void SendUeContextRelease ();
 
+  void SendRrcConnectionSwitch(bool useMmWaveConnection);
+
   /** 
    * Take the necessary actions in response to the reception of an X2 HO preparation failure message
    * 
@@ -253,60 +258,43 @@
    */
   void RecvUeContextRelease (EpcX2SapUser::UeContextReleaseParams params); 
 
-
-  // METHODS FORWARDED FROM ENB RRC SAP ///////////////////////////////////////
-
   /**
-   * Implement the LteEnbRrcSapProvider::CompleteSetupUe interface.
-   * \param params CompleteSetupUeParameters
+   * Setup a new RLC entity and the X2 related connection
    */
-  void CompleteSetupUe (LteEnbRrcSapProvider::CompleteSetupUeParameters params);
+  void RecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params);
+
   /**
-   * Implement the LteEnbRrcSapProvider::RecvRrcConnectionRequest interface.
-   * \param msg the RRC connection request message
+   * Ack the setup of the RLC remote entity, start the re-configuration on the UE
    */
+  void RecvRlcSetupCompleted (uint8_t drbid);
+
+
+  // METHODS FORWARDED FROM ENB RRC SAP ///////////////////////////////////////
+
+  /// Part of the RRC protocol. Implement the LteEnbRrcSapProvider::CompleteSetupUe interface.
+  void CompleteSetupUe (LteEnbRrcSapProvider::CompleteSetupUeParameters params);
+  /// Part of the RRC protocol. Implement the LteEnbRrcSapProvider::RecvRrcConnectionRequest interface.
   void RecvRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg);
-  /**
-   * Implement the LteEnbRrcSapProvider::RecvRrcConnectionSetupCompleted interface.
-   * \param msg RRC connection setup completed message
-   */
+  /// Part of the RRC protocol. Implement the LteEnbRrcSapProvider::RecvRrcConnectionSetupCompleted interface.
   void RecvRrcConnectionSetupCompleted (LteRrcSap::RrcConnectionSetupCompleted msg);
-  /**
-   * Implement the LteEnbRrcSapProvider::RecvRrcConnectionReconfigurationCompleted interface.
-   * \param msg RRC connection reconfiguration completed message
-   */
+  /// Part of the RRC protocol. Implement the LteEnbRrcSapProvider::RecvRrcConnectionReconfigurationCompleted interface.
   void RecvRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg);
-  /**
-   * Implement the LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentRequest interface.
-   * \param msg the RRC connection reestablishment request message
-   */
+  /// Part of the RRC protocol. Implement the LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentRequest interface.
   void RecvRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg);
-  /**
-   * Implement the LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentComplete interface.
-   * \param msg the RRC connection reestablsihment complete message
-   */
+  /// Part of the RRC protocol. Implement the LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentComplete interface.
   void RecvRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg);
-  /**
-   * Implement the LteEnbRrcSapProvider::RecvMeasurementReport interface.
-   * \param msg the measrurement report
-   */
+  /// Part of the RRC protocol. Implement the LteEnbRrcSapProvider::RecvMeasurementReport interface.
   void RecvMeasurementReport (LteRrcSap::MeasurementReport msg);
+  ///
+  void RecvRrcSecondaryCellInitialAccessSuccessful(uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
 
   // METHODS FORWARDED FROM ENB CMAC SAP //////////////////////////////////////
 
-  /**
-   * CMAC UE config update indication function
-   * \param cmacParams the UE config parameters
-   */
   void CmacUeConfigUpdateInd (LteEnbCmacSapUser::UeConfig cmacParams);
 
   // METHODS FORWARDED FROM ENB PDCP SAP //////////////////////////////////////
 
-  /**
-   * Receive PDCP SDU function
-   * \param params the receive PDCP SDU parameters
-   */
   void DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params);
 
   /** 
@@ -322,12 +310,6 @@
    */
   uint64_t GetImsi (void) const;
 
-  /**
-   *
-   * \return the primary component carrier ID
-   */
-  uint8_t GetComponentCarrierId () const;
-
   /** 
    * 
    * \return the SRS Configuration Index
@@ -364,12 +346,73 @@
    * \param [in] oldState
    * \param [in] newState
    */
-  typedef void (*StateTracedCallback)
-    (const uint64_t imsi, const uint16_t cellId, const uint16_t rnti,
-    const State oldState, const State newState);
+  typedef void (* StateTracedCallback)
+    (uint64_t imsi, uint16_t cellId, uint16_t rnti,
+     State oldState, State newState);
+
+  /**
+   * TracedCallback signature for imsi, cellId and rnti events.
+   *
+   * \param [in] imsi
+   * \param [in] cellId
+   * \param [in] rnti
+   */
+  typedef void (* ImsiCidRntiTracedCallback)
+    (uint64_t imsi, uint16_t cellId, uint16_t rnti);
+
+  // for interRatHandover mode
+  void SetFirstConnection();
+
+  // for mc devices, get the m_allMmWaveInOutageAtInitialAccess variable
+  bool GetAllMmWaveInOutageAtInitialAccess();
+  void SetAllMmWaveInOutageAtInitialAccess(bool param);
+
+  /**
+   * This method is called by the eNB RRC to notify the 
+   * UeManager that the handover from a MmWave cell to LTE
+   * was completed. Then, according to the state of 
+   * the UeManager, it will modify the m_mmWaveCellSetupCompleted map
+   * of RRC.
+   * Used only with InterRat HO mode
+   */
+  void RecvNotifyLteMmWaveHandoverCompleted();
+
+  /**
+   * Notify a mmWave remote UeManager that a switch is expected. 
+   * If the switch is to LTE, forward RLC buffers to LTE eNB
+   */
+  void RecvConnectionSwitchToMmWave (bool useMmWaveConnection, uint8_t drbid);
+
+  /**
+   * A SecondaryCellHandoverCompleted is received by the LTE eNB when the
+   * handover between 2 mmWave eNBs is completed. The LTE eNB has to update 
+   * the information on the secondary cell and send the connection release to the
+   * source mmWave eNB.
+   */
+  void RecvSecondaryCellHandoverCompleted (EpcX2SapUser::SecondaryHandoverCompletedParams params);
 
 private:
+  //Lossless HO: merge 2 buffers into 1 with increment order.
+  std::vector < LteRlcAm::RetxPdu > MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second);
+  /**
+   * Forward the content of RLC buffers. For RLC UM and UM LowLat, forward txBuffer.
+   * For RLC AM, forward the merge of retx and txed buffers, and txBuffer
+   * @param the RLC entity
+   * @param the PDCP entity, if the mcLteToMmWaveForwarding is false it can be 0
+   * @param the gtpTeid that identifies the X2 connection to be used
+   * @param a bool that specifies if this operation involves a classic forwarding (to PDCP of the target eNB)
+   * or a LTE to MmWave Dual Connectivity forwarding, which needs the packets to be inserted back in the LTE PDCP
+   * (there is no PDCP in the MmWave eNB in DC setup)
+   * @param a bool that specifies if this operation involves the forwarding of packets from a secondary mmWave cell
+   * to another secondary mmWave cell during a secondary cell HO 
+   * @param the bearer id, used only if mcLteToMmWaveForwarding is true
+   */
+  void ForwardRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint32_t gtpTeid, bool mcLteToMmWaveForwarding, bool mcMmToMmWaveForwarding, uint8_t bid);
 
+  
+  bool m_firstConnection;
+  bool m_receivedLteMmWaveHandoverCompleted;
+  uint16_t m_queuedHandoverRequestCellId;
   /** 
    * Add a new LteDataRadioBearerInfo structure to the UeManager
    * 
@@ -402,13 +445,6 @@
 
   /** 
    * 
-   * \return an NonCriticalExtensionConfiguration struct built based on the
-   * current configuration
-   */
-  LteRrcSap::NonCriticalExtensionConfiguration BuildNonCriticalExtentionConfigurationCa ();
-
-  /** 
-   * 
    * \return a RadioResourceConfigDedicated struct built based on the
    * current configuration
    */
@@ -469,13 +505,22 @@
    */
   void SwitchToState (State s);
 
-  uint8_t m_lastAllocatedDrbid; ///< last allocated Data Radio Bearer ID
+  uint8_t m_lastAllocatedDrbid;
 
   /**
    * The `DataRadioBearerMap` attribute. List of UE DataRadioBearerInfo by
    * DRBID.
    */
   std::map <uint8_t, Ptr<LteDataRadioBearerInfo> > m_drbMap;
+  
+  /**
+   * Map the drb into a RLC (used for remote independent RLC in an MC setup)
+   */
+  std::map <uint8_t, Ptr<RlcBearerInfo> > m_rlcMap;
+  /**
+   * Map the drb into a RLCSetupRequest (used to handover remote independent RLC in an MC setup)
+   */
+  std::vector <EpcX2SapUser::RlcSetupRequest> m_rlcRequestVector;
 
   /**
    * The `Srb0` attribute. SignalingRadioBearerInfo for SRB0.
@@ -495,22 +540,18 @@
    * unique UE identifier.
    */
   uint64_t m_imsi;
-  /**
-   * ID of the primary CC for this UE
-   */
-  uint8_t m_componentCarrierId;
-  
-  uint8_t m_lastRrcTransactionIdentifier; ///< last RRC transaction identifier
-
-  LteRrcSap::PhysicalConfigDedicated m_physicalConfigDedicated; ///< physical config dedicated
+  ///
+  uint8_t m_lastRrcTransactionIdentifier;
+  ///
+  LteRrcSap::PhysicalConfigDedicated m_physicalConfigDedicated;
   /// Pointer to the parent eNodeB RRC.
   Ptr<LteEnbRrc> m_rrc;
   /// The current UeManager state.
   State m_state;
-  
-  LtePdcpSapUser* m_drbPdcpSapUser; ///< DRB PDCP SAP user
-
-  bool m_pendingRrcConnectionReconfiguration; ///< pending RRC connection reconfiguration
+  ///
+  LtePdcpSapUser* m_drbPdcpSapUser;
+  ///
+  bool m_pendingRrcConnectionReconfiguration;
 
   /**
    * The `StateTransition` trace source. Fired upon every UE state transition
@@ -519,11 +560,23 @@
    */
   TracedCallback<uint64_t, uint16_t, uint16_t, State, State> m_stateTransitionTrace;
 
-  uint16_t m_sourceX2apId; ///< source X2 ap ID
-  uint16_t m_sourceCellId; ///< source cell ID
-  uint16_t m_targetCellId; ///< target cell ID
-  std::list<uint8_t> m_drbsToBeStarted; ///< DRBS to be started
-  bool m_needPhyMacConfiguration; ///< need Phy MAC configuration
+  /**
+   * The `SwitchToMmWaveEnb` trace source. Fired upon receiving an ACK to a command to 
+   * switch to MmWave RAT. Exporting IMSI, cellId, RNTI.
+   */
+  TracedCallback<uint64_t, uint16_t, uint16_t> m_secondaryRlcCreatedTrace;
+
+  uint16_t m_sourceX2apId;
+  uint16_t m_sourceCellId;
+  uint16_t m_targetCellId;
+  std::list<uint8_t> m_drbsToBeStarted;
+  bool m_needPhyMacConfiguration;
+
+  uint16_t m_mmWaveCellId;
+  uint16_t m_mmWaveRnti;
+  bool m_mmWaveCellAvailableForMcSetup;
+  bool m_isMc;
+  //bool m_isInterRatHoCapable;
 
   /**
    * Time limit before a _connection request timeout_ occurs. Set after a new
@@ -559,11 +612,12 @@
    */
   EventId m_handoverLeavingTimeout;
 
-  /// Define if the Carrier Aggregation was already configure for the current UE on not
-  bool m_caSupportConfigured;
+  std::vector < Ptr<Packet> > m_x2forwardingBuffer;
+  uint32_t m_x2forwardingBufferSize;
+  uint32_t m_maxx2forwardingBufferSize;
 
-  /// Pending start data radio bearers
-  bool m_pendingStartDataRadioBearers;
+  // this variable is set to true if on initial access, for mc devices, all the mmWave eNBs are in outage
+  bool m_allMmWaveInOutageAtInitialAccess;
 
 }; // end of `class UeManager`
 
@@ -577,24 +631,15 @@
 class LteEnbRrc : public Object
 {
 
-  /// allow EnbRrcMemberLteEnbCmacSapUser class friend access
   friend class EnbRrcMemberLteEnbCmacSapUser;
-  /// allow MemberLteHandoverManagementSapUser<LteEnbRrc> class friend access
   friend class MemberLteHandoverManagementSapUser<LteEnbRrc>;
-  /// allow MemberLteAnrSapUser<LteEnbRrc> class friend access
   friend class MemberLteAnrSapUser<LteEnbRrc>;
-  /// allow MemberLteFfrRrcSapUser<LteEnbRrc> class friend access
   friend class MemberLteFfrRrcSapUser<LteEnbRrc>;
-  /// allow MemberLteEnbRrcSapProvider<LteEnbRrc> class friend access
   friend class MemberLteEnbRrcSapProvider<LteEnbRrc>;
-  /// allow MemberLteEnbRrcSapProvider<LteEnbRrc> class friend access
   friend class MemberEpcEnbS1SapUser<LteEnbRrc>;
-  /// allow MemberEpcEnbS1SapUser<LteEnbRrc> class friend access
   friend class EpcX2SpecificEpcX2SapUser<LteEnbRrc>;
-  /// allow UeManager class friend access
   friend class UeManager;
-  /// allow  MemberLteCcmRrcSapUser<LteEnbRrc> class friend access
-  friend class MemberLteCcmRrcSapUser<LteEnbRrc>;
+  friend class MemberLteEnbCphySapUser<LteEnbRrc>;
 
 public:
   /**
@@ -613,12 +658,9 @@
 protected:
   virtual void DoDispose (void);
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
+
   /**
    * Set the X2 SAP this RRC should interact with
    * \param s the X2 SAP Provider to be used by this RRC entity
@@ -631,34 +673,33 @@
    */
   EpcX2SapUser* GetEpcX2SapUser ();
 
+  /**
+   * Set the X2 PDCP Provider this RRC should pass to PDCP layers
+   * \param s the X2 PDCP Provider to be stored in this RRC entity
+   */
+  void SetEpcX2PdcpProvider (EpcX2PdcpProvider* s);
+  EpcX2PdcpProvider* GetEpcX2PdcpProvider () const;
 
   /**
-   * set the CMAC SAP this RRC should interact with
-   *
-   * \param s the CMAC SAP Provider to be used by this RRC
+   * Set the X2 RLC Provider this RRC should pass to RLC layers
+   * \param s the X2 RLC Provider to be stored in this RRC entity
    */
-  void SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s);
+  void SetEpcX2RlcProvider (EpcX2RlcProvider* s);
+  EpcX2RlcProvider* GetEpcX2RlcProvider() const;
 
   /**
    * set the CMAC SAP this RRC should interact with
    *
    * \param s the CMAC SAP Provider to be used by this RRC
-   * \param pos the position
    */
-  void SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s, uint8_t pos);
+  void SetLteEnbCmacSapProvider (LteEnbCmacSapProvider * s);
 
   /** 
    * Get the CMAC SAP offered by this RRC
-   * \returns the CMAC SAP User interface offered to the MAC by this RRC
+   * \return s the CMAC SAP User interface offered to the MAC by this RRC
    */
   LteEnbCmacSapUser* GetLteEnbCmacSapUser ();
 
-  /** 
-   * Get the CMAC SAP offered by this RRC
-   * \param pos the position
-   * \returns the CMAC SAP User interface offered to the MAC by this RRC
-   */
-  LteEnbCmacSapUser* GetLteEnbCmacSapUser (uint8_t pos);
 
   /**
    * set the Handover Management SAP this RRC should interact with
@@ -669,28 +710,13 @@
 
   /**
    * Get the Handover Management SAP offered by this RRC
-   * \returns the Handover Management SAP User interface offered to the
+   * \return s the Handover Management SAP User interface offered to the
    *           handover algorithm by this RRC
    */
   LteHandoverManagementSapUser* GetLteHandoverManagementSapUser ();
 
 
   /**
-   * set the Component Carrier Management SAP this RRC should interact with
-   *
-   * \param s the Component Carrier Management SAP Provider to be used by this RRC
-   */
-  void SetLteCcmRrcSapProvider (LteCcmRrcSapProvider * s);
-
-  /**
-   * Get the Component Carrier Management SAP offered by this RRC
-   * \return s the Component Carrier Management SAP User interface offered to the
-   *           carrier component selection algorithm by this RRC
-   */
-  LteCcmRrcSapUser* GetLteCcmRrcSapUser ();
-
-
-  /**
    * set the ANR SAP this RRC should interact with
    *
    * \param s the ANR SAP Provider to be used by this RRC
@@ -712,13 +738,6 @@
    * \param s the FFR SAP Provider to be used by this RRC
    */
   void SetLteFfrRrcSapProvider (LteFfrRrcSapProvider * s);
-  /**
-   * set the FFR SAP this RRC should interact with
-   *
-   * \param s the FFR SAP Provider to be used by this RRC
-   * \param index the index
-   */
-  void SetLteFfrRrcSapProvider (LteFfrRrcSapProvider * s, uint8_t index);
 
   /**
    * Get the FFR SAP offered by this RRC
@@ -726,13 +745,6 @@
    *           RRC
    */
   LteFfrRrcSapUser* GetLteFfrRrcSapUser ();
-  /**
-   * Get the FFR SAP offered by this RRC
-   * \param index the index
-   * \return s the FFR SAP User interface offered to the ANR instance by this
-   *           RRC
-   */
-  LteFfrRrcSapUser* GetLteFfrRrcSapUser (uint8_t index);
 
   /**
    * set the RRC SAP this RRC should interact with
@@ -780,28 +792,12 @@
   void SetLteEnbCphySapProvider (LteEnbCphySapProvider * s);
 
   /**
-   * set the CPHY SAP this RRC should use to interact with the PHY
-   *
-   * \param s the CPHY SAP Provider
-   * \param pos the position
-   */
-  void SetLteEnbCphySapProvider (LteEnbCphySapProvider * s, uint8_t pos);
-
-  /**
    *
    *
    * \return s the CPHY SAP User interface offered to the PHY by this RRC
    */
   LteEnbCphySapUser* GetLteEnbCphySapUser ();
 
-  /**
-   * Get the ENB CPhy SAP user
-   *
-   * \param pos the position
-   * \return s the CPHY SAP User interface offered to the PHY by this RRC
-   */
-  LteEnbCphySapUser* GetLteEnbCphySapUser (uint8_t pos);
-
   /** 
    * 
    * 
@@ -836,6 +832,10 @@
 
   /**
    * \brief Configure cell-specific parameters.
+   * \param ulBandwidth the uplink bandwidth in number of RB
+   * \param dlBandwidth the downlink bandwidth in number of RB
+   * \param ulEarfcn the UL EARFCN
+   * \param dlEarfcn the DL EARFCN
    * \param cellId the ID of the cell
    *
    * Configure cell-specific parameters and propagate them to lower layers.
@@ -854,16 +854,12 @@
    * `LteHelper::InstallEnbDevice` (i.e. before the simulation starts).
    *
    * \warning Raises an error when executed more than once.
-   *
-   * \param ccPhyConf the component carrier configuration
-   */
-  void ConfigureCell (std::map<uint8_t, Ptr<ComponentCarrierEnb>> ccPhyConf);
-
-  /**
-   * \brief Configure carriers.
-   * \param ccPhyConf the component carrier configuration
    */
-  void ConfigureCarriers (std::map<uint8_t, Ptr<ComponentCarrierEnb>> ccPhyConf);
+  void ConfigureCell (uint8_t ulBandwidth,
+                      uint8_t dlBandwidth,
+                      uint16_t ulEarfcn, 
+                      uint16_t dlEarfcn,
+                      uint16_t cellId);
 
   /** 
    * set the cell id of this eNB
@@ -873,30 +869,18 @@
   void SetCellId (uint16_t m_cellId);
 
   /** 
-   * set the cell id of this eNB
+   * If this is a MmWave eNB RRC, set the cell id of the closest LTE cell
    * 
-   * \param m_cellId 
-   * \param ccIndex 
-   */
-  void SetCellId (uint16_t m_cellId, uint8_t ccIndex);
-
-  /**
-   * convert the cell id to component carrier id
-   *
-   * \param cellId Cell ID
-   *
-   * \return corresponding component carrier id
+   * \param cellId 
    */
-  uint8_t CellToComponentCarrierId (uint16_t cellId);
+  void SetClosestLteCellId (uint16_t cellId);
 
-  /**
-   * convert the component carrier id to cell id
-   *
-   * \param componentCarrierId component carrier ID
-   *
-   * \return corresponding cell ID
+  /** 
+   * get the cell id of this eNB
+   * 
+   * \param m_cellId 
    */
-  uint16_t ComponentCarrierToCellId (uint8_t componentCarrierId);
+  uint16_t GetCellId () const;
 
   /** 
    * Enqueue an IP data packet on the proper bearer for downlink
@@ -984,7 +968,8 @@
   enum LteEpsBearerToRlcMapping_t {RLC_SM_ALWAYS = 1,
                                    RLC_UM_ALWAYS = 2,
                                    RLC_AM_ALWAYS = 3,
-                                   PER_BASED = 4};
+                                   PER_BASED = 4,
+																	 RLC_UM_LOWLAT_ALWAYS = 5};
 
   /**
    * TracedCallback signature for new Ue Context events.
@@ -992,8 +977,8 @@
    * \param [in] cellId
    * \param [in] rnti
    */
-  typedef void (*NewUeContextTracedCallback)
-    (const uint16_t cellId, const uint16_t rnti);
+  typedef void (* NewUeContextTracedCallback)
+    (uint16_t cellId, uint16_t rnti);
 
   /**
    * TracedCallback signature for connection and handover end events.
@@ -1002,9 +987,9 @@
    * \param [in] cellId
    * \param [in] rnti
    */
-  typedef void (*ConnectionHandoverTracedCallback)
-    (const uint64_t imsi, const uint16_t cellId, const uint16_t rnti);
-
+  typedef void (* ConnectionHandoverTracedCallback)
+    (uint64_t imsi, uint16_t cellId, uint16_t rnti);
+  
   /**
    * TracedCallback signature for handover start events.
    *
@@ -1013,9 +998,8 @@
    * \param [in] rnti
    * \param [in] targetCid
    */
-  typedef void (*HandoverStartTracedCallback)
-    (const uint64_t imsi, const uint16_t cellId, const uint16_t rnti,
-     const uint16_t targetCid);
+  typedef void (* HandoverStartTracedCallback)
+    (uint64_t imsi, uint16_t cellId, uint16_t rnti, uint16_t targetCid);
 
   /**
    * TracedCallback signature for receive measurement report events.
@@ -1027,224 +1011,129 @@
    * \todo The \c LteRrcSap::MeasurementReport argument should be
    * changed to a const reference since the argument is large.
    */
-  typedef void (*ReceiveReportTracedCallback)
-    (const uint64_t imsi, const uint16_t cellId, const uint16_t rnti,
-     const LteRrcSap::MeasurementReport report);
-
-private:
+  typedef void (* ReceiveReportTracedCallback)
+    (uint64_t imsi, uint16_t cellId, uint16_t rnti,
+     LteRrcSap::MeasurementReport report);
 
-
-  // RRC SAP methods
+  typedef void (* NotifyMmWaveSinrTracedCallback)
+    (uint64_t imsi, uint16_t cellId, long double sinr);
 
   /**
-   * Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::CompleteSetupUe interface to UeManager::CompleteSetupUe
-   * \param rnti the RNTI
-   * \param params the LteEnbRrcSapProvider::CompleteSetupUeParameters
+   * Different secondary cell handover modes
    */
-  void DoCompleteSetupUe (uint16_t rnti, LteEnbRrcSapProvider::CompleteSetupUeParameters params);
+  enum HandoverMode
+  {
+    FIXED_TTT = 1,
+    DYNAMIC_TTT = 2,
+    THRESHOLD = 3
+  };
+
+  struct HandoverEventInfo
+  {
+    uint16_t sourceCellId;
+    uint16_t targetCellId;
+    EventId scheduledHandoverEvent;
+  };
+  
   /**
-   * Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionRequest interface to UeManager::RecvRrcConnectionRequest
-   *
-   * \param rnti the RNTI
-   * \param msg the LteRrcSap::RrcConnectionRequest
+   * Map with info on handover events, per imsi
    */
-  void DoRecvRrcConnectionRequest (uint16_t rnti, LteRrcSap::RrcConnectionRequest msg);
+  typedef std::map<uint64_t, HandoverEventInfo> HandoverEventMap;
+
   /**
-   * Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionSetupCompleted interface to UeManager::RecvRrcConnectionSetupCompleted
-   *
-   * \param rnti the RNTI
-   * \param msg the LteRrcSap::RrcConnectionSetupCompleted
+   * This method maps Imsi to Rnti, so that the UeManager of a certain UE
+   * can be retrieved also with the Imsi
    */
+  void RegisterImsiToRnti(uint64_t imsi, uint16_t rnti);
+
+  uint16_t GetRntiFromImsi(uint64_t imsi);
+
+  uint64_t GetImsiFromRnti(uint16_t rnti);
+
+  void SetInterRatHoMode ();
+  
+private:
+
+
+  // RRC SAP methods
+
+  /// Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::CompleteSetupUe interface to UeManager::CompleteSetupUe
+  void DoCompleteSetupUe (uint16_t rnti, LteEnbRrcSapProvider::CompleteSetupUeParameters params);
+  /// Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionRequest interface to UeManager::RecvRrcConnectionRequest
+  void DoRecvRrcConnectionRequest (uint16_t rnti, LteRrcSap::RrcConnectionRequest msg);
+  /// Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionSetupCompleted interface to UeManager::RecvRrcConnectionSetupCompleted
   void DoRecvRrcConnectionSetupCompleted (uint16_t rnti, LteRrcSap::RrcConnectionSetupCompleted msg);
-  /**
-   * Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionReconfigurationCompleted interface to UeManager::RecvRrcConnectionReconfigurationCompleted
-   *
-   * \param rnti the RNTI
-   * \param msg the LteRrcSap::RrcConnectionReconfigurationCompleted
-   */
+  /// Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionReconfigurationCompleted interface to UeManager::RecvRrcConnectionReconfigurationCompleted
   void DoRecvRrcConnectionReconfigurationCompleted (uint16_t rnti, LteRrcSap::RrcConnectionReconfigurationCompleted msg);
-  /**
-   * Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentRequest interface to UeManager::RecvRrcConnectionReestablishmentRequest
-   *
-   * \param rnti the RNTI
-   * \param msg the LteRrcSap::RrcConnectionReestablishmentRequest
-   */
+  /// Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentRequest interface to UeManager::RecvRrcConnectionReestablishmentRequest
   void DoRecvRrcConnectionReestablishmentRequest (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentRequest msg);
-  /**
-   * Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentComplete interface to UeManager::RecvRrcConnectionReestablishmentComplete
-   *
-   * \param rnti the RNTI
-   * \param msg the LteRrcSap::RrcConnectionReestablishmentComplete
-   */
+  /// Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvRrcConnectionReestablishmentComplete interface to UeManager::RecvRrcConnectionReestablishmentComplete
   void DoRecvRrcConnectionReestablishmentComplete (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentComplete msg);
-  /**
-   * Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvMeasurementReport interface to UeManager::RecvMeasurementReport
-   *
-   * \param rnti the RNTI
-   * \param msg the LteRrcSap::MeasurementReport
-   */
+  /// Part of the RRC protocol. Forwarding LteEnbRrcSapProvider::RecvMeasurementReport interface to UeManager::RecvMeasurementReport
   void DoRecvMeasurementReport (uint16_t rnti, LteRrcSap::MeasurementReport msg);
-
+  ///
+  void DoRecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId);
   // S1 SAP methods
 
-  /**
-   * Data radio beaerer setup request function
-   *
-   * \param params EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters
-   */
   void DoDataRadioBearerSetupRequest (EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters params);
-  /**
-   * Path switch request acknowledge function
-   *
-   * \param params EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters
-   */
   void DoPathSwitchRequestAcknowledge (EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters params);
 
   // X2 SAP methods
 
-  /**
-   * Receive handover request function
-   *
-   * \param params EpcX2SapUser::HandoverRequestParams
-   */
   void DoRecvHandoverRequest (EpcX2SapUser::HandoverRequestParams params);
-  /**
-   * Receive handover request acknowledge function
-   *
-   * \param params EpcX2SapUser::HandoverRequestAckParams
-   */
   void DoRecvHandoverRequestAck (EpcX2SapUser::HandoverRequestAckParams params);
-  /**
-   * Receive handover preparation failure function
-   *
-   * \param params EpcX2SapUser::HandoverPreparationFailureParams
-   */
   void DoRecvHandoverPreparationFailure (EpcX2SapUser::HandoverPreparationFailureParams params);
-  /**
-   * Receive SN status transfer function
-   *
-   * \param params EpcX2SapUser::SnStatusTransferParams
-   */
   void DoRecvSnStatusTransfer (EpcX2SapUser::SnStatusTransferParams params);
-  /**
-   * Receive UE context release function
-   *
-   * \param params EpcX2SapUser::UeContextReleaseParams
-   */
   void DoRecvUeContextRelease (EpcX2SapUser::UeContextReleaseParams params);
-  /**
-   * Receive load information function
-   *
-   * \param params EpcX2SapUser::LoadInformationParams
-   */
   void DoRecvLoadInformation (EpcX2SapUser::LoadInformationParams params);
-  /**
-   * Receive resource status update function
-   *
-   * \param params EpcX2SapUser::ResourceStatusUpdateParams
-   */
   void DoRecvResourceStatusUpdate (EpcX2SapUser::ResourceStatusUpdateParams params);
-  /**
-   * Receive UE data function
-   *
-   * \param params EpcX2SapUser::UeDataParams
-   */
+  void DoRecvRlcSetupRequest (EpcX2SapUser::RlcSetupRequest params);
+  void DoRecvRlcSetupCompleted (EpcX2SapUser::UeDataParams params);
   void DoRecvUeData (EpcX2SapUser::UeDataParams params);
+  void DoRecvUeSinrUpdate(EpcX2SapUser::UeImsiSinrParams params);
+  void DoRecvMcHandoverRequest(EpcX2SapUser::SecondaryHandoverParams params);
+  void DoRecvLteMmWaveHandoverCompleted (EpcX2SapUser::SecondaryHandoverParams params);
+  void DoRecvConnectionSwitchToMmWave (EpcX2SapUser::SwitchConnectionParams params);
+  void DoRecvSecondaryCellHandoverCompleted (EpcX2SapUser::SecondaryHandoverCompletedParams params);
 
   // CMAC SAP methods
 
-  /**
-   * Allocate temporary cell RNTI function
-   *
-   * \param componentCarrierId ID of the primary component carrier
-   * \return temporary RNTI
-   */
-  uint16_t DoAllocateTemporaryCellRnti (uint8_t componentCarrierId);
-  /**
-   * Notify LC config result function
-   *
-   * \param rnti RNTI
-   * \param lcid LCID
-   * \param success the success indicator
-   */
+  uint16_t DoAllocateTemporaryCellRnti ();
   void DoNotifyLcConfigResult (uint16_t rnti, uint8_t lcid, bool success);
-  /**
-   * RRC configuration update indication function
-   *
-   * \param params LteEnbCmacSapUser::UeConfig
-   */
   void DoRrcConfigurationUpdateInd (LteEnbCmacSapUser::UeConfig params);
 
   // Handover Management SAP methods
 
-  /**
-   * Add UE measure report config for handover function
-   *
-   * \param reportConfig LteRrcSap::ReportConfigEutra
-   * \returns measure ID
-   */
   uint8_t DoAddUeMeasReportConfigForHandover (LteRrcSap::ReportConfigEutra reportConfig);
-  /**
-   * Add UE measure report config for component carrier function
-   *
-   * \param reportConfig LteRrcSap::ReportConfigEutra
-   * \returns measure ID
-   */
-  uint8_t DoAddUeMeasReportConfigForComponentCarrier (LteRrcSap::ReportConfigEutra reportConfig);
-
-  /**
-   * Trigger handover function
-   *
-   * \param rnti RNTI
-   * \param targetCellId target cell ID
-   */
   void DoTriggerHandover (uint16_t rnti, uint16_t targetCellId);
 
   // ANR SAP methods
 
-  /**
-   * Add UE measure report config for ANR function
-   *
-   * \param reportConfig LteRrcSap::ReportConfigEutra
-   * \returns measure ID
-   */
   uint8_t DoAddUeMeasReportConfigForAnr (LteRrcSap::ReportConfigEutra reportConfig);
 
   // FFR RRC SAP methods
-  /**
-   * Add UE measure report config for FFR function
-   *
-   * \param reportConfig LteRrcSap::ReportConfigEutra
-   * \returns measure ID
-   */
   uint8_t DoAddUeMeasReportConfigForFfr (LteRrcSap::ReportConfigEutra reportConfig);
-  /**
-   * Set PDSCH config dedicated function
-   *
-   * \param rnti the RNTI
-   * \param pa LteRrcSap::PdschConfigDedicated
-   */
   void DoSetPdschConfigDedicated (uint16_t rnti, LteRrcSap::PdschConfigDedicated pa);
-  /**
-   * Send load information function
-   *
-   * \param params EpcX2Sap::LoadInformationParams
-   */
   void DoSendLoadInformation (EpcX2Sap::LoadInformationParams params);
 
+  // CPHY SAP methods
+  void DoUpdateUeSinrEstimate(LteEnbCphySapUser::UeAssociatedSinrInfo info);
+
   // Internal methods
 
+  void EnableSwitching(uint64_t imsi);
+  bool m_switchEnabled;
+
   /**
    * Allocate a new RNTI for a new UE. This is done in the following cases:
    *   * T-C-RNTI allocation upon contention-based MAC Random Access procedure
    *   * target cell RNTI allocation upon handover
    *
    * \param state the initial state of the UeManager
-   * \param componentCarrierId primary component carrier ID of the UeManager
    *
    * \return the newly allocated RNTI
    */
-  uint16_t AddUe (UeManager::State state, uint8_t componentCarrierId);
+  uint16_t AddUe (UeManager::State state);
 
   /**
    * remove a UE from the cell
@@ -1306,12 +1195,6 @@
    */
   void SetCsgId (uint32_t csgId, bool csgIndication);
 
-  /**
-   * \brief Set number of component carriers
-   * \param numberOfComponentCarriers the number of component carriers
-   */
-  void SetNumberOfComponentCarriers (uint16_t numberOfComponentCarriers);
-
 private:
 
   /** 
@@ -1344,6 +1227,7 @@
    * characteristics is put. Used for MAC Buffer Status Reporting purposes. 
    */
   uint8_t GetLogicalChannelGroup (EpsBearer bearer);
+  uint8_t GetLogicalChannelGroup (bool isGbr);
 
   /** 
    * 
@@ -1362,37 +1246,86 @@
    */
   void SendSystemInformation ();
 
-  Callback <void, Ptr<Packet> > m_forwardUpCallback;  ///< forward up callback function
+  /** 
+   * method used to periodically check if switching of MC devices or handover of MmWave dev is needed
+   * 
+   */
+  void TriggerUeAssociationUpdate();
+
+  /**
+   * Trigger an handover according to certain conditions on the SINR
+   * @params the iterator on m_imsiCellSinrMap
+   * @params the sinrDifference between the current and the maxSinr cell
+   * @params the CellId of the maximum SINR cell
+   * @params the value of the SINR for this cell
+   */
+  void ThresholdBasedSecondaryCellHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb);
+
+    /**
+   * Trigger an handover according to certain conditions on the SINR and the TTT
+   * @params the iterator on m_imsiCellSinrMap
+   * @params the sinrDifference between the current and the maxSinr cell
+   * @params the CellId of the maximum SINR cell
+   * @params the value of the SINR for this cell
+   */
+  void TttBasedHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb);
+
+  /**
+   * Compute the TTT according to the sinrDifference and the dynamic handover algorithm
+   */
+  uint8_t ComputeTtt(double sinrDifference);
+
+  /**
+   * Method that can be scheduled to perform an handover
+   * @params imsi 
+   */
+  void PerformHandover(uint64_t imsi);
+
+  /** 
+   * method used to periodically check if HO between MmWave and LTE is needed
+   * 
+   */
+  void UpdateUeHandoverAssociation();
+
+  /**
+   * Trigger an handover according to certain conditions on the SINR (for single-connectivity devices)
+   * @params the iterator on m_imsiCellSinrMap
+   * @params the sinrDifference between the current and the maxSinr cell
+   * @params the CellId of the maximum SINR cell
+   * @params the value of the SINR for this cell
+   */  
+  void ThresholdBasedInterRatHandover(std::map<uint64_t, CellSinrMap>::iterator imsiIter, double sinrDifference, uint16_t maxSinrCellId, double maxSinrDb);
+  
+  Callback <void, Ptr<Packet> > m_forwardUpCallback;
 
   /// Interface to receive messages from neighbour eNodeB over the X2 interface.
   EpcX2SapUser* m_x2SapUser;
   /// Interface to send messages to neighbour eNodeB over the X2 interface.
   EpcX2SapProvider* m_x2SapProvider;
+  /// Interface to be provided to PDCP
+  EpcX2PdcpProvider* m_x2PdcpProvider;
+  /// Interface to be provided to RLC
+  EpcX2RlcProvider* m_x2RlcProvider;
 
   /// Receive API calls from the eNodeB MAC instance.
-  std::vector<LteEnbCmacSapUser*> m_cmacSapUser;
+  LteEnbCmacSapUser* m_cmacSapUser;
   /// Interface to the eNodeB MAC instance.
-  std::vector<LteEnbCmacSapProvider*> m_cmacSapProvider;
+  LteEnbCmacSapProvider* m_cmacSapProvider;
 
   /// Receive API calls from the handover algorithm instance.
   LteHandoverManagementSapUser* m_handoverManagementSapUser;
   /// Interface to the handover algorithm instance.
   LteHandoverManagementSapProvider* m_handoverManagementSapProvider;
 
-  /// Receive API calls from the LteEnbComponentCarrierManager instance.
-  LteCcmRrcSapUser* m_ccmRrcSapUser;
-  /// Interface to the LteEnbComponentCarrierManager instance.
-  LteCcmRrcSapProvider* m_ccmRrcSapProvider;
-
   /// Receive API calls from the ANR instance.
   LteAnrSapUser* m_anrSapUser;
   /// Interface to the ANR instance.
   LteAnrSapProvider* m_anrSapProvider;
 
   /// Receive API calls from the FFR algorithm instance.
-  std::vector<LteFfrRrcSapUser*> m_ffrRrcSapUser;
+  LteFfrRrcSapUser* m_ffrRrcSapUser;
   /// Interface to the FFR algorithm instance.
-  std::vector<LteFfrRrcSapProvider*> m_ffrRrcSapProvider;
+  LteFfrRrcSapProvider* m_ffrRrcSapProvider;
 
   /// Interface to send messages to UE over the RRC protocol.
   LteEnbRrcSapUser* m_rrcSapUser;
@@ -1407,32 +1340,37 @@
   /// Interface to receive messages from core network over the S1 protocol.
   EpcEnbS1SapUser* m_s1SapUser;
 
-  /// Receive API calls from the eNodeB PHY instances.
-  std::vector<LteEnbCphySapUser*> m_cphySapUser;
-  /// Interface to the eNodeB PHY instances.
-  std::vector<LteEnbCphySapProvider*> m_cphySapProvider;
+  /// Receive API calls from the eNodeB PHY instance.
+  LteEnbCphySapUser* m_cphySapUser;
+  /// Interface to the eNodeB PHY instance.
+  LteEnbCphySapProvider* m_cphySapProvider;
 
   /// True if ConfigureCell() has been completed.
   bool m_configured;
+  /// Cell identifier. Must be unique across the simulation.
+  uint16_t m_cellId;
+  /// Closest LTE Cell identifier (for MmWave cells only).
+  uint16_t m_lteCellId;
   /// Downlink E-UTRA Absolute Radio Frequency Channel Number.
-  uint32_t m_dlEarfcn;
+  uint16_t m_dlEarfcn;
   /// Uplink E-UTRA Absolute Radio Frequency Channel Number.
-  uint32_t m_ulEarfcn;
+  uint16_t m_ulEarfcn;
   /// Downlink transmission bandwidth configuration in number of Resource Blocks.
   uint16_t m_dlBandwidth;
   /// Uplink transmission bandwidth configuration in number of Resource Blocks.
   uint16_t m_ulBandwidth;
-  /// Last allocated RNTI
+  ///
   uint16_t m_lastAllocatedRnti;
 
   /// The System Information Block Type 1 that is currently broadcasted over BCH.
-  std::vector<LteRrcSap::SystemInformationBlockType1> m_sib1;
+  LteRrcSap::SystemInformationBlockType1 m_sib1;
 
   /**
    * The `UeMap` attribute. List of UeManager by C-RNTI.
    */
   std::map<uint16_t, Ptr<UeManager> > m_ueMap;
 
+  //std::map<uint16_t, EpcX2SapUser::HandoverRequestParams> m_requestMap;
   /**
    * List of measurement configuration which are active in every UE attached to
    * this eNodeB instance.
@@ -1445,18 +1383,16 @@
   std::set<uint8_t> m_anrMeasIds;
   /// List of measurement identities which are intended for FFR purpose.
   std::set<uint8_t> m_ffrMeasIds;
-  /// List of measurement identities which are intended for component carrier management purposes.
-  std::set<uint8_t> m_componentCarrierMeasIds;
 
-  /// X2uTeidInfo structure
   struct X2uTeidInfo
   {
-    uint16_t rnti; ///< RNTI
-    uint8_t drbid; ///< DRBID
+    uint16_t rnti;
+    uint8_t drbid;
   };
 
-  /// TEID, RNTI, DRBID
-  std::map<uint32_t, X2uTeidInfo> m_x2uTeidInfoMap;
+  //       TEID      RNTI, DRBID
+  std::map<uint32_t, X2uTeidInfo> m_x2uTeidInfoMap; // for the handovers
+  std::map<uint32_t, X2uTeidInfo> m_x2uMcTeidInfoMap; // for the MC devices
 
   /**
    * The `DefaultTransmissionMode` attribute. The default UEs' transmission
@@ -1476,10 +1412,10 @@
   /**
    * The `SrsPeriodicity` attribute. The SRS periodicity in milliseconds.
    */
-  uint16_t m_srsCurrentPeriodicityId; ///< SRS current periodicity ID
-  std::set<uint16_t> m_ueSrsConfigurationIndexSet; ///< UE SRS configuration index set
-  uint16_t m_lastAllocatedConfigurationIndex; ///< last allocated configuration index
-  bool m_reconfigureUes; ///< reconfigure UEs?
+  uint16_t m_srsCurrentPeriodicityId;
+  std::set<uint16_t> m_ueSrsConfigurationIndexSet;
+  uint16_t m_lastAllocatedConfigurationIndex;
+  bool m_reconfigureUes;
 
   /**
    * The `QRxLevMin` attribute. One of information transmitted within the SIB1
@@ -1575,11 +1511,46 @@
    */
   TracedCallback<uint64_t, uint16_t, uint16_t, LteRrcSap::MeasurementReport> m_recvMeasurementReportTrace;
 
-  uint16_t m_numberOfComponentCarriers; ///< number of component carriers
+  TracedCallback<uint64_t, uint16_t, long double> m_notifyMmWaveSinrTrace;
+
+  bool m_ismmWave;
+  bool m_interRatHoMode;
+  bool m_firstReport;
+
+  uint32_t m_firstSibTime;		// time in ms of initial SIB
+
+  // for MmWave eNBs
+  ImsiSinrMap m_ueImsiSinrMap;
+
+  // for LTE eNBs
+  std::map<uint16_t, ImsiSinrMap> m_cellSinrMap;
+  uint16_t m_numNewSinrReports;
+  std::map<uint64_t, uint16_t> m_bestMmWaveCellForImsiMap;
+  std::map<uint64_t, uint16_t> m_lastMmWaveCell;
+  std::map<uint64_t, bool> m_mmWaveCellSetupCompleted;
+  std::map<uint64_t, bool> m_imsiUsingLte;
+  std::map<uint64_t, CellSinrMap> m_imsiCellSinrMap;
+  std::map<uint64_t, uint16_t> m_imsiRntiMap;
+  std::map<uint16_t, uint64_t> m_rntiImsiMap;
+
+  HandoverMode m_handoverMode;
+
+  // TTT based handover management
+  HandoverEventMap m_imsiHandoverEventsMap;
+
+  long double m_sinrThresholdDifference;
+
+  long double m_outageThreshold;
+
+  uint8_t m_fixedTttValue;
+  uint8_t m_minDynTttValue;
+  uint8_t m_maxDynTttValue;
+  double m_minDiffTttValue;
+  double m_maxDiffTttValue;
 
-  bool m_carriersConfigured; ///< are carriers configured
+  int m_crtPeriod;
 
-  std::map<uint8_t, Ptr<ComponentCarrierEnb>> m_componentCarrierPhyConf; ///< component carrier phy configuration
+  uint32_t m_x2_received_cnt;
 
 }; // end of `class LteEnbRrc`
 
diff -Naru a/model/lte-mac-sap.cc b/model/lte-mac-sap.cc
--- a/model/lte-mac-sap.cc	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-mac-sap.cc	2017-10-05 11:47:22.310601768 +0200
@@ -33,7 +33,15 @@
 {
 }
 
+void
+LteMacSapUser::NotifyDlHarqDeliveryFailure (uint8_t harqId)
+{
+}
 
+void
+LteMacSapUser::NotifyUlHarqDeliveryFailure (uint8_t harqId)
+{
+}
 
 
 } // namespace ns3
diff -Naru a/model/lte-mac-sap.h b/model/lte-mac-sap.h
--- a/model/lte-mac-sap.h	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-mac-sap.h	2017-10-05 11:47:22.310601768 +0200
@@ -49,20 +49,19 @@
     uint8_t     lcid; /**< the logical channel id corresponding to the sending RLC instance */
     uint8_t     layer; /**< the layer value that was passed by the MAC in the call to NotifyTxOpportunity that generated this PDU */
     uint8_t     harqProcessId; /**< the HARQ process id that was passed by the MAC in the call to NotifyTxOpportunity that generated this PDU */
-    uint8_t componentCarrierId; /**< the component carrier id corresponding to the sending Mac istance */
   };
 
   /**
    * send an RLC PDU to the MAC for transmission. This method is to be
    * called as a response to LteMacSapUser::NotifyTxOpportunity
-   *
-   * \param params TransmitPduParameters
    */
   virtual void TransmitPdu (TransmitPduParameters params) = 0;
 
 
   /**
    * Parameters for LteMacSapProvider::ReportBufferStatus
+   *
+   * \param params
    */
   struct ReportBufferStatusParameters
   {
@@ -73,12 +72,19 @@
     uint32_t retxQueueSize;  /**<  the current size of the RLC retransmission queue in bytes */
     uint16_t retxQueueHolDelay;  /**<  the Head Of Line delay of the retransmission queue */
     uint16_t statusPduSize;  /**< the current size of the pending STATUS RLC  PDU message in bytes */
+
+    // RDF: Added for MmWave low-latency schedulers
+		std::list<uint32_t>	txPacketSizes;
+		std::list<uint32_t>	retxPacketSizes;
+		std::list<double>	txPacketDelays;
+		std::list<double>	retxPacketDelays;
+		double arrivalRate;		// average bits per s
   };
 
   /**
    * Report the RLC buffer status to the MAC
    *
-   * \param params ReportBufferStatusParameters
+   * \param params
    */
   virtual void ReportBufferStatus (ReportBufferStatusParameters params) = 0;
 
@@ -102,12 +108,8 @@
    *
    * \param bytes the number of bytes to transmit
    * \param layer the layer of transmission (MIMO)
-   * \param harqId the HARQ ID
-   * \param componentCarrierId component carrier ID
-   * \param rnti the RNTI
-   * \param lcid the LCID
    */
-  virtual void NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) = 0;
+  virtual void NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId) = 0;
 
   /**
    * Called by the MAC to notify the RLC that an HARQ process related
@@ -117,28 +119,25 @@
    */
   virtual void NotifyHarqDeliveryFailure () = 0;
 
+  virtual void NotifyDlHarqDeliveryFailure (uint8_t harqId);
+
+  virtual void NotifyUlHarqDeliveryFailure (uint8_t harqId);
 
   /**
    * Called by the MAC to notify the RLC of the reception of a new PDU
    *
-   * \param p the packet
-   * \param rnti the RNTI
-   * \param lcid the LCID
+   * \param p
    */
-  virtual void ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid) = 0;
+  virtual void ReceivePdu (Ptr<Packet> p) = 0;
 
 };
 
-/// EnbMacMemberLteMacSapProvider class
+///////////////////////////////////////
+
 template <class C>
 class EnbMacMemberLteMacSapProvider : public LteMacSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the MAC class
-   */
   EnbMacMemberLteMacSapProvider (C* mac);
 
   // inherited from LteMacSapProvider
@@ -146,7 +145,7 @@
   virtual void ReportBufferStatus (ReportBufferStatusParameters params);
 
 private:
-  C* m_mac; ///< the MAC class
+  C* m_mac;
 };
 
 
diff -Naru a/model/lte-pdcp.cc b/model/lte-pdcp.cc
--- a/model/lte-pdcp.cc	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-pdcp.cc	2017-10-05 11:47:22.310601768 +0200
@@ -30,15 +30,9 @@
 
 NS_LOG_COMPONENT_DEFINE ("LtePdcp");
 
-/// LtePdcpSpecificLteRlcSapUser class
 class LtePdcpSpecificLteRlcSapUser : public LteRlcSapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param pdcp PDCP
-   */
   LtePdcpSpecificLteRlcSapUser (LtePdcp* pdcp);
 
   // Interface provided to lower RLC entity (implemented from LteRlcSapUser)
@@ -46,7 +40,7 @@
 
 private:
   LtePdcpSpecificLteRlcSapUser ();
-  LtePdcp* m_pdcp; ///< the PDCP
+  LtePdcp* m_pdcp;
 };
 
 LtePdcpSpecificLteRlcSapUser::LtePdcpSpecificLteRlcSapUser (LtePdcp* pdcp)
@@ -194,7 +188,7 @@
 
   // Sender timestamp
   PdcpTag pdcpTag (Simulator::Now ());
-  p->AddPacketTag (pdcpTag);
+  p->AddByteTag (pdcpTag);
   m_txPdu (m_rnti, m_lcid, p->GetSize ());
 
   LteRlcSapProvider::TransmitPdcpPduParameters params;
@@ -213,9 +207,10 @@
   // Receiver timestamp
   PdcpTag pdcpTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (pdcpTag), "PdcpTag is missing");
-  p->RemovePacketTag (pdcpTag);
-  delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag (pdcpTag))
+    {
+      delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+    }
   m_rxPdu(m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
 
   LtePdcpHeader pdcpHeader;
diff -Naru a/model/lte-pdcp-header.cc b/model/lte-pdcp-header.cc
--- a/model/lte-pdcp-header.cc	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-pdcp-header.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -98,7 +102,7 @@
   Buffer::Iterator i = start;
 
   i.WriteU8 ( (m_dcBit << 7) | (m_sequenceNumber & 0x0F00) >> 8 );
-  i.WriteU8 ( (m_sequenceNumber & 0x00FF) );
+  i.WriteU8 ( (uint8_t)(m_sequenceNumber & 0x00FF) );
 }
 
 uint32_t LtePdcpHeader::Deserialize (Buffer::Iterator start)
@@ -110,8 +114,10 @@
   byte_1 = i.ReadU8 ();
   byte_2 = i.ReadU8 ();
   m_dcBit = (byte_1 & 0x80) > 7;
-  // For now, we just support DATA PDUs
-  NS_ASSERT (m_dcBit == DATA_PDU);
+  
+  // HACKED. ENABLE THIS TO DISTINGUISH DATA_PDU and CONTROL_PDU in lte-enb-rrc.cc, lossless HO func
+  //NS_ASSERT (m_dcBit == DATA_PDU);
+
   m_sequenceNumber = ((byte_1 & 0x0F) << 8) | byte_2;
 
   return GetSerializedSize ();
diff -Naru a/model/lte-phy.cc b/model/lte-phy.cc
--- a/model/lte-phy.cc	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-phy.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 TELEMATICS LAB, DEE - Politecnico di Bari
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/waveform-generator.h>
@@ -49,8 +53,7 @@
     m_dlBandwidth (0),
     m_rbgSize (0),
     m_macChTtiDelay (0),
-    m_cellId (0),
-    m_componentCarrierId(0)
+    m_cellId (0)
 {
   NS_LOG_FUNCTION (this);
 }
@@ -87,14 +90,14 @@
 }
 
 void
-LtePhy::SetDevice (Ptr<LteNetDevice> d)
+LtePhy::SetDevice (Ptr<NetDevice> d)
 {
   NS_LOG_FUNCTION (this << d);
   m_netDevice = d;
 }
 
 
-Ptr<LteNetDevice>
+Ptr<NetDevice>
 LtePhy::GetDevice () const
 {
   NS_LOG_FUNCTION (this);
@@ -250,18 +253,5 @@
   m_uplinkSpectrumPhy->SetCellId (cellId);
 }
 
-void
-LtePhy::SetComponentCarrierId (uint8_t index)
-{
-  m_componentCarrierId = index;
-  m_downlinkSpectrumPhy->SetComponentCarrierId (index);
-  m_uplinkSpectrumPhy->SetComponentCarrierId (index);
-}
-
-uint8_t
-LtePhy::GetComponentCarrierId ()
-{
-  return m_componentCarrierId;
-}
 
 } // namespace ns3
diff -Naru a/model/lte-phy.h b/model/lte-phy.h
--- a/model/lte-phy.h	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-phy.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 TELEMATICS LAB, DEE - Politecnico di Bari
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <mmiozzo@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_PHY_H
@@ -67,22 +71,18 @@
 
   virtual ~LtePhy ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
   /**
    * \brief Set the device where the phy layer is attached
    * \param d the device
    */
-  void SetDevice (Ptr<LteNetDevice> d);
+  void SetDevice (Ptr<NetDevice> d);
   /**
    * \brief Get the device where the phy layer is attached
    * \return the pointer to the device
    */
-  Ptr<LteNetDevice> GetDevice () const;
+  Ptr<NetDevice> GetDevice () const;
 
   /** 
    * 
@@ -213,23 +213,11 @@
   */
   virtual void ReportRsReceivedPower (const SpectrumValue& power) = 0;
 
-  /**
-  * Set the component carrier ID 
-  *
-  * \param index the component carrier ID index
-  */
-  void SetComponentCarrierId (uint8_t index);
 
-  /**
-  * Get the component carrier ID 
-  *
-  * \returns the component carrier ID index
-  */
-  uint8_t GetComponentCarrierId ();
 
 protected:
   /// Pointer to the NetDevice where this PHY layer is attached.
-  Ptr<LteNetDevice> m_netDevice;
+  Ptr<NetDevice> m_netDevice;
 
   /**
    * The downlink LteSpectrumPhy associated to this LtePhy. Also available as
@@ -278,12 +266,12 @@
    * The downlink carrier frequency.
    * Specified by the upper layer through CPHY SAP.
    */
-  uint32_t m_dlEarfcn;
+  uint16_t m_dlEarfcn;
   /**
    * The uplink carrier frequency.
    * Specified by the upper layer through CPHY SAP.
    */
-  uint32_t m_ulEarfcn;
+  uint16_t m_ulEarfcn;
 
   /// A queue of packet bursts to be sent.
   std::vector< Ptr<PacketBurst> > m_packetBurstQueue;
@@ -307,9 +295,6 @@
    */
   uint16_t m_cellId;
 
-  /// component carrier Id used to address sap
-  uint8_t m_componentCarrierId;
-
 }; // end of `class LtePhy`
 
 
diff -Naru a/model/lte-radio-bearer-info.cc b/model/lte-radio-bearer-info.cc
--- a/model/lte-radio-bearer-info.cc	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-radio-bearer-info.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "lte-radio-bearer-info.h"
@@ -113,6 +117,31 @@
   return tid;
 }
 
+RlcBearerInfo::RlcBearerInfo (void)
+{
+}
+
+RlcBearerInfo::~RlcBearerInfo (void)
+{
+}
+  
+TypeId 
+RlcBearerInfo::GetTypeId (void)
+{
+  static TypeId
+    tid =
+    TypeId ("ns3::RlcBearerInfo")
+    .SetParent<Object> ()
+    .AddConstructor<RlcBearerInfo> ()
+    .AddAttribute ("LteRlc", "RLC instance of the secondary connection.",
+                   PointerValue (),
+                   MakePointerAccessor (&RlcBearerInfo::m_rlc),
+                   MakePointerChecker<LteRlc> ())
+    ;
+  return tid;
+}
+
+
 
 
 } // namespace ns3
diff -Naru a/model/lte-radio-bearer-info.h b/model/lte-radio-bearer-info.h
--- a/model/lte-radio-bearer-info.h	2017-10-05 11:46:52.210493959 +0200
+++ b/model/lte-radio-bearer-info.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RADIO_BEARER_INFO_H
@@ -26,6 +30,7 @@
 #include <ns3/eps-bearer.h>
 #include <ns3/lte-rrc-sap.h>
 #include <ns3/ipv4-address.h>
+#include <ns3/epc-x2-sap.h>
 
 namespace ns3 {
 
@@ -42,14 +47,10 @@
 public:
   LteRadioBearerInfo (void);
   virtual ~LteRadioBearerInfo (void);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  Ptr<LteRlc> m_rlc; ///< RLC
-  Ptr<LtePdcp> m_pdcp; ///< PDCP
+  Ptr<LteRlc> m_rlc;
+  Ptr<LtePdcp> m_pdcp;  
 };
 
 
@@ -61,14 +62,10 @@
 {
 
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  uint8_t m_srbIdentity; ///< SRB indentity
-  LteRrcSap::LogicalChannelConfig m_logicalChannelConfig; ///< logical channel config  
+  uint8_t m_srbIdentity;   
+  LteRrcSap::LogicalChannelConfig m_logicalChannelConfig;  
 };
 
 
@@ -80,22 +77,39 @@
 {
 
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  EpsBearer m_epsBearer; ///< EPS bearer
-  uint8_t m_epsBearerIdentity; ///< EPS bearer identity
-  uint8_t m_drbIdentity; ///< DRB identity
-  LteRrcSap::RlcConfig m_rlcConfig; ///< RLC config
-  uint8_t m_logicalChannelIdentity; ///< logical channel identity
-  LteRrcSap::LogicalChannelConfig m_logicalChannelConfig; ///< logical channel config
+  EpsBearer m_epsBearer;
+  uint8_t m_epsBearerIdentity;
+  uint8_t m_drbIdentity;
+  LteRrcSap::RlcConfig m_rlcConfig;
+  uint8_t m_logicalChannelIdentity;
+  LteRrcSap::LogicalChannelConfig m_logicalChannelConfig;
   uint32_t m_gtpTeid; /**< S1-bearer GTP tunnel endpoint identifier, see 36.423 9.2.1 */
   Ipv4Address m_transportLayerAddress; /**< IP Address of the SGW, see 36.423 9.2.1 */
+  EpcX2Sap::RlcSetupRequest m_rlcSetupRequest; // complete bearer with related info, for MC functionalities
+  bool m_isMc; // true if a bearer is split
 };
 
+class RlcBearerInfo : public Object
+{
+public:
+  RlcBearerInfo (void);
+  virtual ~RlcBearerInfo (void);
+  static TypeId GetTypeId (void);
+    
+    uint16_t    sourceCellId;
+    uint16_t    targetCellId;
+    uint32_t    gtpTeid;
+    uint16_t    mmWaveRnti;
+    uint16_t    lteRnti;
+    uint8_t     drbid;
+    uint8_t     logicalChannelIdentity;
+    LteRrcSap::RlcConfig rlcConfig;
+    LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+    LteEnbCmacSapProvider::LcInfo lcinfo;
+    Ptr<LteRlc> m_rlc;
+};
 
 
 
diff -Naru a/model/lte-rlc-am.cc b/model/lte-rlc-am.cc
--- a/model/lte-rlc-am.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc-am.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,16 +18,21 @@
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/simulator.h"
 #include "ns3/log.h"
+#include "ns3/string.h"
 
 #include "ns3/lte-rlc-am-header.h"
 #include "ns3/lte-rlc-am.h"
 #include "ns3/lte-rlc-sdu-status-tag.h"
 #include "ns3/lte-rlc-tag.h"
-
+#include "ns3/ipv4-queue-disc-item.h"
+#include "ns3/ipv4-packet-filter.h"
 
 namespace ns3 {
 
@@ -41,11 +47,19 @@
 
   // Buffers
   m_txonBufferSize = 0;
+  m_retxSegBuffer.resize (1024);
   m_retxBuffer.resize (1024);
   m_retxBufferSize = 0;
   m_txedBuffer.resize (1024);
   m_txedBufferSize = 0;
 
+  // LL HO
+  m_transmittingRlcSduBufferSize = 0;
+  m_txedRlcSduBuffer.resize (0);
+  m_txedRlcSduBufferSize = 0;
+  is_fragmented = 0;
+  //
+
   m_statusPduRequested = false;
   m_statusPduBufferSize = 0;
 
@@ -70,13 +84,52 @@
   // Configurable parameters
   m_maxRetxThreshold = 5;
   m_pollPdu = 1;
-  m_pollByte = 50;
+  m_pollByte = 50; // 1500000
 
   // SDU reassembling process
   m_reassemblingState = WAITING_S0_FULL;
   m_expectedSeqNumber = 0;
 
+  //LL HO: Reassemble
+  m_reassembleExpectedSeqNumber = 0;
+  m_assemblingState = WAITING_SI_SF;
+
   m_pollRetransmitTimerJustExpired = false;
+
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlcAm> (this);
+  m_epcX2RlcProvider = 0;
+
+  m_txonQueue = CreateObject<CoDelQueueDisc> ();
+  m_txonQueue->Initialize ();
+
+  m_traceBufferSizeEvent = Simulator::Schedule(MilliSeconds(2), &LteRlcAm::BufferSizeTrace, this);
+}
+
+void
+LteRlcAm::BufferSizeTrace()
+{
+  NS_LOG_LOGIC("BufferSizeTrace " << Simulator::Now().GetSeconds() << " " << m_rnti << " " << m_lcid << " " << m_txonBufferSize);
+  // write to file
+  if(!m_bufferSizeFile.is_open())
+  {
+    m_bufferSizeFile.open(GetBufferSizeFilename().c_str(), std::ofstream::app);
+    NS_LOG_LOGIC("File opened");
+  }
+  m_bufferSizeFile << Simulator::Now().GetSeconds() << " " << m_rnti << " " << (uint16_t) m_lcid << " " << m_txonBufferSize << std::endl;
+
+  m_traceBufferSizeEvent = Simulator::Schedule(MilliSeconds(10), &LteRlcAm::BufferSizeTrace, this);
+}
+
+std::string
+LteRlcAm::GetBufferSizeFilename()
+{
+  return m_bufferSizeFilename;
+}
+
+void
+LteRlcAm::SetBufferSizeFilename(std::string filename)
+{
+  m_bufferSizeFilename = filename;
 }
 
 LteRlcAm::~LteRlcAm ()
@@ -119,7 +172,21 @@
                    BooleanValue (false),
                    MakeBooleanAccessor (&LteRlcAm::m_txOpportunityForRetxAlwaysBigEnough),
                    MakeBooleanChecker ())
-
+   .AddAttribute ("MaxTxBufferSize",
+                  "Maximum Size of the Transmission Buffer (in Bytes)",
+                  UintegerValue (1024 * 1024),
+                  MakeUintegerAccessor (&LteRlcAm::m_maxTxBufferSize),
+                  MakeUintegerChecker<uint32_t> ())
+    .AddAttribute ("EnableAQM",
+                  "Enable active queue management (CoDel)",
+                   BooleanValue (false),
+                   MakeBooleanAccessor (&LteRlcAm::m_enableAqm),
+                   MakeBooleanChecker ())
+   .AddAttribute ("BufferSizeFilename",
+                   "Name of the file where the buffer size will be periodically written.",
+                   StringValue ("RlcAmBufferSize.txt"),
+                   MakeStringAccessor (&LteRlcAm::SetBufferSizeFilename),
+                   MakeStringChecker ())
     ;
   return tid;
 }
@@ -142,8 +209,22 @@
   m_rxonBuffer.clear ();
   m_sdusBuffer.clear ();
   m_keepS0 = 0;
+  m_keepS0Reassemble = 0;
   m_controlPduBuffer = 0;
 
+  // LL HO
+  m_sdusAssembleBuffer.clear ();
+  m_reassembleExpectedSeqNumber = 0;
+  m_expectedSeqNumber = 0;
+  m_transmittingRlcSduBufferSize = 0;
+  m_transmittingRlcSduBuffer.clear();
+  is_fragmented = 0;
+  m_txedRlcSduBuffer.clear ();
+  m_txedRlcSduBufferSize = 0;
+
+  m_traceBufferSizeEvent.Cancel();
+  m_bufferSizeFile.close();
+
   LteRlc::DoDispose ();
 }
 
@@ -157,22 +238,57 @@
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
 
-  /** Store arrival time */
-  Time now = Simulator::Now ();
-  RlcTag timeTag (now);
-  p->AddPacketTag (timeTag);
-
-  /** Store PDCP PDU */
-
-  LteRlcSduStatusTag tag;
-  tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
-  p->AddPacketTag (tag);
-
-  NS_LOG_LOGIC ("Txon Buffer: New packet added");
-  m_txonBuffer.push_back (p);
-  m_txonBufferSize += p->GetSize ();
-  NS_LOG_LOGIC ("NumOfBuffers = " << m_txonBuffer.size() );
-  NS_LOG_LOGIC ("txonBufferSize = " << m_txonBufferSize);
+  if(m_enableAqm == false)
+  {
+    if (m_txonBufferSize + p->GetSize () <= m_maxTxBufferSize)
+    {
+      /** Store arrival time */
+      Time now = Simulator::Now ();
+      RlcTag timeTag (now);
+      p->AddPacketTag (timeTag);
+
+      /** Store PDCP PDU */
+
+      LteRlcSduStatusTag tag;
+      tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+      p->AddPacketTag (tag);
+
+      NS_LOG_INFO ("Txon Buffer: New packet added");
+      m_txonBuffer.push_back (p);
+      m_txonBufferSize += p->GetSize ();
+      NS_LOG_LOGIC ("NumOfBuffers = " << m_txonBuffer.size() );
+      NS_LOG_LOGIC ("txonBufferSize = " << m_txonBufferSize);
+    }
+    else
+    {
+      // Discard full RLC SDU
+      NS_LOG_LOGIC ("TxBuffer is full. RLC SDU discarded");
+      NS_LOG_LOGIC ("MaxTxBufferSize = " << m_maxTxBufferSize);
+      NS_LOG_LOGIC ("txonBufferSize    = " << m_txonBufferSize);
+      NS_LOG_LOGIC ("packet size     = " << p->GetSize ());
+    }  
+  }
+  else // Use CoDel queue
+  {
+    //Store arrival time
+    Time now = Simulator::Now ();
+    RlcTag timeTag (now);
+    p->AddPacketTag (timeTag);
+
+    //Store PDCP PDU
+
+    LteRlcSduStatusTag tag;
+    tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+    p->AddPacketTag (tag);
+
+    NS_LOG_LOGIC ("Txon Buffer: New packet added");
+    Ptr<Ipv4QueueDiscItem> item;
+    Ipv4Header ipv4Header;
+    Address dest;
+    item = Create<Ipv4QueueDiscItem> (p, dest, 0, ipv4Header);
+    m_txonQueue->Enqueue (item);
+  }
+  
 
   /** Report Buffer Status */
   DoReportBufferStatus ();
@@ -180,13 +296,21 @@
   m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcAm::ExpireRbsTimer, this);
 }
 
+void 
+LteRlcAm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  NS_LOG_INFO("Send MC PDU received from " << params.sourceCellId << " in cell " << params.targetCellId);
+  DoTransmitPdcpPdu(params.ueData);
+}
+
 
 /**
  * MAC SAP
  */
 
 void
-LteRlcAm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
+LteRlcAm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId)
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << bytes);
 
@@ -252,16 +376,17 @@
       NS_ASSERT_MSG (sn <= m_vrMs, "first SN not reported as missing = " << sn << ", VR(MS) = " << m_vrMs);      
       rlcAmHeader.SetAckSn (sn); 
 
+      // map SN to HARQ ID
+      std::map <uint8_t, uint16_t>::iterator itHarqIdMap = m_harqIdToSnMap.find (harqId);
+      if (itHarqIdMap != m_harqIdToSnMap.end ())
+      {
+        m_harqIdToSnMap.erase (itHarqIdMap);
+      }
+      m_harqIdToSnMap.insert (std::pair <uint8_t, uint16_t> (harqId, sn.GetValue ()));
 
       NS_LOG_LOGIC ("RLC header: " << rlcAmHeader);
       packet->AddHeader (rlcAmHeader);
 
-      // Sender timestamp
-      RlcTag rlcTag (Simulator::Now ());
-      NS_ASSERT_MSG (!packet->PeekPacketTag (rlcTag), "RlcTag is already present");
-      packet->AddPacketTag (rlcTag);
-      m_txPdu (m_rnti, m_lcid, packet->GetSize ());
-
       // Send RLC PDU to MAC layer
       LteMacSapProvider::TransmitPduParameters params;
       params.pdu = packet;
@@ -269,7 +394,6 @@
       params.lcid = m_lcid;
       params.layer = layer;
       params.harqProcessId = harqId;
-      params.componentCarrierId = componentCarrierId;
 
       m_macSapProvider->TransmitPdu (params);
 
@@ -286,16 +410,32 @@
       NS_ASSERT (m_vtA < m_vtS);
       SequenceNumber10 sn;
       sn.SetModulusBase (m_vtA);
+      bool found = false;
       for (sn = m_vtA; sn < m_vtS; sn++) 
         {
           uint16_t seqNumberValue = sn.GetValue ();
           NS_LOG_LOGIC ("SN = " << seqNumberValue << " m_pdu " << m_retxBuffer.at (seqNumberValue).m_pdu);
 
-          if (m_retxBuffer.at (seqNumberValue).m_pdu != 0)
-            {            
-
-              Ptr<Packet> packet = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
-              
+          if (m_retxSegBuffer.at (seqNumberValue).m_lastSegSent)
+          {
+            return; // all segments sent, need to wait for ACK or reorder timer to expire
+          }
+
+          Ptr<Packet> packet;
+          bool segment = false;
+          if (m_retxSegBuffer.at (seqNumberValue).m_pdu != 0)
+          {
+            packet = m_retxSegBuffer.at (seqNumberValue).m_pdu->Copy ();
+            found = true;
+            segment = true;
+          }
+          else if (m_retxBuffer.at (seqNumberValue).m_pdu != 0)
+          {
+            packet = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
+            found = true;
+          }
+          if (found == true)
+          {
               if (( packet->GetSize () <= bytes )
                   || m_txOpportunityForRetxAlwaysBigEnough)
                 {
@@ -304,13 +444,23 @@
                   packet->RemoveHeader (rlcAmHeader);
                   NS_LOG_LOGIC ("old AM RLC header: " << rlcAmHeader);
 
+                  if (segment)
+                  {
+                    NS_LOG_INFO ("Sending last RLC PDU segment, sn= " << seqNumberValue << " offset= " << rlcAmHeader.GetSegmentOffset()
+                                                     << " size= " << rlcAmHeader.GetLastOffset()-rlcAmHeader.GetSegmentOffset());
+                    // opportunity is large enough to transmit remaining segment, so clear segment buffer
+                    m_retxSegBuffer.at(seqNumberValue).m_pdu = 0;
+                    m_retxSegBuffer.at(seqNumberValue).m_lastSegSent = true;
+                    rlcAmHeader.SetLastSegmentFlag (LteRlcAmHeader::LAST_PDU_SEGMENT);
+                  }
+
                   // Calculate the Polling Bit (5.2.2.1)
                   rlcAmHeader.SetPollingBit (LteRlcAmHeader::STATUS_REPORT_NOT_REQUESTED);
 
                   NS_LOG_LOGIC ("polling conditions: m_txonBuffer.empty=" << m_txonBuffer.empty () 
                                 << " retxBufferSize="  << m_retxBufferSize
                                 << " packet->GetSize ()=" << packet->GetSize ());
-                  if (((m_txonBuffer.empty ()) && (m_retxBufferSize == packet->GetSize () + rlcAmHeader.GetSerializedSize ())) 
+                  if (((m_txonBuffer.empty ()) && (m_txonQueue->GetNPackets ()==0) && (m_retxBufferSize == packet->GetSize () + rlcAmHeader.GetSerializedSize ()))
                       || (m_vtS >= m_vtMs)
                       || m_pollRetransmitTimerJustExpired)
                     {
@@ -339,15 +489,10 @@
                         }
                     }
 
+
                   packet->AddHeader (rlcAmHeader);
                   NS_LOG_LOGIC ("new AM RLC header: " << rlcAmHeader);
-
-                  // Sender timestamp
-                  RlcTag rlcTag (Simulator::Now ());
-                  NS_ASSERT_MSG (packet->PeekPacketTag (rlcTag), "RlcTag is missing");
-                  packet->ReplacePacketTag (rlcTag);
-                  m_txPdu (m_rnti, m_lcid, packet->GetSize ());
-
+                  
                   // Send RLC PDU to MAC layer
                   LteMacSapProvider::TransmitPduParameters params;
                   params.pdu = packet;
@@ -355,7 +500,6 @@
                   params.lcid = m_lcid;
                   params.layer = layer;
                   params.harqProcessId = harqId;
-                  params.componentCarrierId = componentCarrierId;
                   
                   m_macSapProvider->TransmitPdu (params);
 
@@ -369,27 +513,156 @@
                   NS_LOG_INFO ("Move SN = " << seqNumberValue << " back to txedBuffer");
                   m_txedBuffer.at (seqNumberValue).m_pdu = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
                   m_txedBuffer.at (seqNumberValue).m_retxCount = m_retxBuffer.at (seqNumberValue).m_retxCount;
+                  NS_ASSERT_MSG(m_txedBuffer.at (seqNumberValue).m_pdu != 0, "Just inserted an invalid pointer");
                   m_txedBufferSize += m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
 
                   m_retxBufferSize -= m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
                   m_retxBuffer.at (seqNumberValue).m_pdu = 0;
                   m_retxBuffer.at (seqNumberValue).m_retxCount = 0;
                   
+                  // reset segment buffer
+                  m_retxSegBuffer.at (seqNumberValue).m_pdu = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_retxCount = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_lastSegSent = 0;
+
                   NS_LOG_LOGIC ("retxBufferSize = " << m_retxBufferSize);
 
                   return;
                 }
               else
                 {
-                  NS_LOG_LOGIC ("TxOpportunity (size = " << bytes << ") too small for retransmission of the packet (size = " << packet->GetSize () << ")");
-                  NS_LOG_LOGIC ("Waiting for bigger TxOpportunity");
+//                  NS_LOG_LOGIC ("TxOpportunity (size = " << bytes << ") too small for retransmission of the packet (size = " << packet->GetSize () << ")");
+//                  NS_LOG_LOGIC ("Waiting for bigger TxOpportunity");
+//                  return;
+                  // According to 5.2.1, the data field is left as is, but we rebuild the header
+                  LteRlcAmHeader firstSegHdr;
+
+                  // if(bytes < firstSegHdr.GetSerializedSize() )
+                  // {
+                  //   return;
+                  // }
+
+                  packet->RemoveHeader (firstSegHdr);
+                  NS_LOG_LOGIC ("old AM RLC header: " << firstSegHdr);
+
+                  // Calculate the Polling Bit (5.2.2.1)
+                  firstSegHdr.SetPollingBit (LteRlcAmHeader::STATUS_REPORT_NOT_REQUESTED);
+
+                  NS_LOG_LOGIC ("polling conditions: m_txonBuffer.empty=" << m_txonBuffer.empty ()
+                                << " retxBufferSize="  << m_retxBufferSize
+                                << " packet->GetSize ()=" << packet->GetSize ());
+                  if (((m_txonBuffer.empty ()) && (m_txonQueue->GetNPackets () == 0) && (m_retxBufferSize == packet->GetSize () + firstSegHdr.GetSerializedSize ()))
+                      || (m_vtS >= m_vtMs)
+                      || m_pollRetransmitTimerJustExpired)
+                  {
+                    m_pollRetransmitTimerJustExpired = false;
+                    firstSegHdr.SetPollingBit (LteRlcAmHeader::STATUS_REPORT_IS_REQUESTED);
+                    m_pduWithoutPoll = 0;
+                    m_byteWithoutPoll = 0;
+
+                    m_pollSn = m_vtS - 1;
+                    NS_LOG_LOGIC ("New POLL_SN = " << m_pollSn);
+
+                    if (! m_pollRetransmitTimer.IsRunning () )
+                    {
+                      NS_LOG_LOGIC ("Start PollRetransmit timer");
+
+                      m_pollRetransmitTimer = Simulator::Schedule (m_pollRetransmitTimerValue,
+                                                                   &LteRlcAm::ExpirePollRetransmitTimer, this);
+                    }
+                    else
+                    {
+                      NS_LOG_LOGIC ("Restart PollRetransmit timer");
+
+                      m_pollRetransmitTimer.Cancel ();
+                      m_pollRetransmitTimer = Simulator::Schedule (m_pollRetransmitTimerValue,
+                                                                   &LteRlcAm::ExpirePollRetransmitTimer, this);
+                    }
+                  }
+
+                  // set flags
+                  firstSegHdr.SetResegmentationFlag (LteRlcAmHeader::SEGMENT);
+                  firstSegHdr.SetLastSegmentFlag (LteRlcAmHeader::NO_LAST_PDU_SEGMENT);
+                  //firstSegHdr.PushLengthIndicator (firstPduSegSize);
+
+                  // build header for second segment
+                  LteRlcAmHeader nextSegHdr = firstSegHdr;
+                  //nextSegHdr.PushLengthIndicator (nextPduSegSize);
+                  // get size of last segment
+                  //unsigned segSize = rlcAmHeader.PopLengthIndicator ();
+                  // set offset to last offset + last size
+
+                  if (!segment)
+                  {
+                    firstSegHdr.SetSegmentOffset (0);
+                  }
+
+                  if (bytes < firstSegHdr.GetSerializedSize ())
+                  {
+                    return;
+                  }
+
+                   // segment packet
+                  uint16_t firstPduSegSize = bytes - firstSegHdr.GetSerializedSize ();
+                  uint16_t nextPduSegSize = packet->GetSize ()-firstPduSegSize;
+                  Ptr<Packet> firstSeg = packet->CreateFragment (0, firstPduSegSize);
+                  Ptr<Packet> nextSeg = packet->CreateFragment (firstPduSegSize, nextPduSegSize);
+
+                  nextSegHdr.SetSegmentOffset (firstSegHdr.GetSegmentOffset () + firstPduSegSize);
+
+                  firstSeg->AddHeader (firstSegHdr);
+                  nextSeg->AddHeader (nextSegHdr);
+
+                  // add next segment to reTX segment buffer
+                  m_retxSegBuffer.at (seqNumberValue).m_pdu = nextSeg;
+
+                  NS_LOG_LOGIC ("new AM RLC header: " << firstSegHdr);
+
+                  // Send RLC PDU to MAC layer
+                  LteMacSapProvider::TransmitPduParameters params;
+                  params.pdu = firstSeg;
+                  params.rnti = m_rnti;
+                  params.lcid = m_lcid;
+                  params.layer = layer;
+                  params.harqProcessId = harqId;
+
+                  NS_LOG_INFO ("Sending RLC PDU segment, sn= " << seqNumberValue << " offset= " << firstSegHdr.GetSegmentOffset()
+                                                   << " size= " << firstPduSegSize);
+
+                  if (firstSeg->GetSize () > bytes)
+                  {
+                    NS_FATAL_ERROR ("PDU header too large " << firstSegHdr);
+                  }
+
+                  m_macSapProvider->TransmitPdu (params);
+
+                  //m_retxSegBuffer.at (seqNumberValue).m_pdu
+
+//                  m_retxBuffer.at (seqNumberValue).m_retxCount++;
+//                  NS_LOG_INFO ("Incr RETX_COUNT for SN = " << seqNumberValue);
+//                  if (m_retxBuffer.at (seqNumberValue).m_retxCount >= m_maxRetxThreshold)
+//                  {
+//                    NS_LOG_INFO ("Max RETX_COUNT for SN = " << seqNumberValue);
+//                  }
+//
+//                  NS_LOG_INFO ("Move SN = " << seqNumberValue << " back to txedBuffer");
+//                  m_txedBuffer.at (seqNumberValue).m_pdu = m_retxBuffer.at (seqNumberValue).m_pdu->Copy ();
+//                  m_txedBuffer.at (seqNumberValue).m_retxCount = m_retxBuffer.at (seqNumberValue).m_retxCount;
+//                  m_txedBufferSize += m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
+//
+//                  m_retxBufferSize -= m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
+//                  m_retxBuffer.at (seqNumberValue).m_pdu = 0;
+//                  m_retxBuffer.at (seqNumberValue).m_retxCount = 0;
+
+                  NS_LOG_LOGIC ("retxBufferSize = " << m_retxBufferSize);
+
                   return;
                 }
             }
         }
-      NS_ASSERT_MSG (false, "m_retxBufferSize > 0, but no PDU considered for retx found");
+      NS_ASSERT_MSG (found, "m_retxBufferSize > 0, but no PDU considered for retx found");
     }
-  else if ( m_txonBufferSize > 0 )
+  else if ( m_txonBufferSize + m_txonQueue->GetNBytes() > 0 )
     {
       if (bytes < 7)
       {
@@ -421,6 +694,16 @@
   //
   //
 
+  // LL HO
+  // if m_vtS is not inside the transmitting window: simply return
+  //      otherwise continue constructing sending RLC PDU with m_vtS is 
+  //      the sequence number and deliver it to the lower layer.
+  if (!IsInsideTransmittingWindow()){
+    NS_LOG_LOGIC ("SEQ = " << m_vtS << " is NOT inside transmitting window [ " << m_vtA << " , " << m_vtMs << " ). Discard TxOppotunity");
+    return;
+  } 
+ 
+
   Ptr<Packet> packet = Create<Packet> ();
   LteRlcAmHeader rlcAmHeader;
   rlcAmHeader.SetDataPdu ();
@@ -434,7 +717,7 @@
 
   // Remove the first packet from the transmission buffer.
   // If only a segment of the packet is taken, then the remaining is given back later
-  if ( m_txonBuffer.size () == 0 )
+  if ( m_txonBuffer.size () + m_txonQueue->GetNBytes() == 0 )
     {
       NS_LOG_LOGIC ("No data pending");
       return;
@@ -445,7 +728,27 @@
   NS_LOG_LOGIC ("First SDU size    = " << (*(m_txonBuffer.begin()))->GetSize ());
   NS_LOG_LOGIC ("Next segment size = " << nextSegmentSize);
   NS_LOG_LOGIC ("Remove SDU from TxBuffer");
+
+  if (m_txonBuffer.empty())
+  {
+    Ptr<Packet> tempP = m_txonQueue->Dequeue()->GetPacket();
+    m_txonBuffer.push_back (tempP);
+    m_txonBufferSize += tempP->GetSize ();
+  }
+
   Ptr<Packet> firstSegment = (*(m_txonBuffer.begin ()))->Copy ();
+  
+  // LL HO
+  // tricky: store the incomplete Rlc SDU for forwarding to 
+  // target eNB in lossless HO. This will reduce the work of 
+  // reassemling the incomplete SDU later.
+  Ptr<Packet> entireSdu ;
+  // store complete the last complete SDU of the txonBuffer.
+  if (!is_fragmented){
+    NS_LOG_DEBUG ("Last complete SDU in txonBuffer size = " << firstSegment->GetSize() << " SEQ = " << m_vtS );
+    entireSdu = (*(m_txonBuffer.begin ()))->Copy ();
+  }
+
   m_txonBufferSize -= (*(m_txonBuffer.begin()))->GetSize ();
   NS_LOG_LOGIC ("txBufferSize      = " << m_txonBufferSize );
   m_txonBuffer.erase (m_txonBuffer.begin ());
@@ -470,6 +773,9 @@
           // Segment txBuffer.FirstBuffer and
           // Give back the remaining segment to the transmission buffer
           Ptr<Packet> newSegment = firstSegment->CreateFragment (0, currSegmentSize);
+          // LL HO: This firstSegment is fragmented. Update the status variable.
+          is_fragmented = 1;        
+
           NS_LOG_LOGIC ("    newSegment size   = " << newSegment->GetSize ());
 
           // Status tag of the new and remaining segments
@@ -496,7 +802,20 @@
             {
               firstSegment->AddPacketTag (oldTag);
 
-              m_txonBuffer.insert (m_txonBuffer.begin (), firstSegment);
+              //LL HO Mark the first SDU is txonBuffer is fragmented. This maybe not needed.
+              is_fragmented = 1;
+
+              // m_txonBuffer.insert (m_txonBuffer.begin (), firstSegment);
+              
+              if(m_txonBuffer.empty())
+              {
+                m_txonBuffer.push_back(firstSegment);
+              }
+              else
+              {
+                m_txonBuffer.insert (m_txonBuffer.begin (), firstSegment);
+              }
+
               m_txonBufferSize += (*(m_txonBuffer.begin()))->GetSize ();
 
               NS_LOG_LOGIC ("    Txon buffer: Give back the remaining segment");
@@ -542,7 +861,8 @@
           // (NO more segments) ? exit
           // break;
         }
-      else if ( (nextSegmentSize - firstSegment->GetSize () <= 2) || (m_txonBuffer.size () == 0) )
+      else if ( (nextSegmentSize - firstSegment->GetSize () <= 2) 
+        || (m_txonBuffer.size () + m_txonQueue->GetNPackets() == 0) )
         {
           NS_LOG_LOGIC ("    IF nextSegmentSize - firstSegment->GetSize () <= 2 || txonBuffer.size == 0");
 
@@ -561,7 +881,7 @@
           nextSegmentId++;
 
           NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txonBuffer.size ());
-          if (m_txonBuffer.size () > 0)
+          if (m_txonBuffer.size () + m_txonQueue->GetNPackets() > 0)
             {
               NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txonBuffer.begin()));
               NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txonBuffer.begin()))->GetSize ());
@@ -591,7 +911,7 @@
           nextSegmentId++;
 
           NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txonBuffer.size ());
-          if (m_txonBuffer.size () > 0)
+          if (m_txonBuffer.size () + m_txonQueue->GetNPackets() > 0)
             {
               NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txonBuffer.begin()));
               NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txonBuffer.begin()))->GetSize ());
@@ -600,14 +920,45 @@
           NS_LOG_LOGIC ("        Remove SDU from TxBuffer");
 
           // (more segments)
+
+          if(m_txonBuffer.empty())
+          {
+            Ptr<Packet> tempP = m_txonQueue->Dequeue()->GetPacket();
+            m_txonBuffer.push_back (tempP);
+            m_txonBufferSize += tempP->GetSize ();
+          }
+
           firstSegment = (*(m_txonBuffer.begin ()))->Copy ();
+          
+          // LL HO
+          // New complete SDU is taken from txonBuffer so reset the 
+          // status is_fragmented.
+          is_fragmented = 0;
+          m_txedRlcSduBuffer.push_back((*(m_txonBuffer.begin()))->Copy());
+          NS_LOG_DEBUG ("m_txedRlcSduBuffer.size() = " << m_txedRlcSduBuffer.size());
+          if (m_txedRlcSduBuffer.size() > 1024){
+            NS_LOG_DEBUG ("m_txedRlcSduBuffer.size() = " << m_txedRlcSduBuffer.size() << " clear and resize");
+            m_txedRlcSduBuffer.clear();
+            m_txedRlcSduBuffer.resize(0);
+            NS_LOG_DEBUG ("m_txedRlcSduBuffer.size() = " << m_txedRlcSduBuffer.size() << " after clear and resize");
+          }
+          // Store the last complete SDU before segmentation in txonBuffer.
+          entireSdu = (*(m_txonBuffer.begin ()))->Copy ();
+
           m_txonBufferSize -= (*(m_txonBuffer.begin()))->GetSize ();
           m_txonBuffer.erase (m_txonBuffer.begin ());
           NS_LOG_LOGIC ("        txBufferSize = " << m_txonBufferSize );
         }
-
     }
 
+  // LL HO tricky: store the complete version of the LAST incomplete Rlc SDU for forwarding to 
+  // target eNB in lossless HO. This will reduce the work of 
+  // reassemling the incomplete SDU later.
+  if (entireSdu != NULL){
+    m_segmented_rlcsdu = entireSdu;
+    NS_LOG_DEBUG ("entireSdu = " << m_segmented_rlcsdu->GetSize() << " SEQ = " << m_vtS );
+  }
+
   //
   // Build RLC header
   //
@@ -617,6 +968,8 @@
   rlcAmHeader.SetLastSegmentFlag (LteRlcAmHeader::LAST_PDU_SEGMENT);
   rlcAmHeader.SetSegmentOffset (0);
 
+  NS_LOG_INFO("Send m_vtS " << m_vtS << " m_vtMs " << m_vtMs << " m_vtA " << m_vtA << " time " << Simulator::Now().GetSeconds());
+
   NS_ASSERT_MSG(rlcAmHeader.GetSequenceNumber () < m_vtMs, "SN above TX window");
   NS_ASSERT_MSG(rlcAmHeader.GetSequenceNumber () >= m_vtA, "SN below TX window");
 
@@ -627,8 +980,7 @@
 
   // FIRST SEGMENT
   LteRlcSduStatusTag tag;
-  NS_ASSERT_MSG ((*it)->PeekPacketTag (tag), "LteRlcSduStatusTag is missing");
-  (*it)->PeekPacketTag (tag);
+  (*it)->RemovePacketTag (tag);
   if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
        (tag.GetStatus () == LteRlcSduStatusTag::FIRST_SEGMENT)
      )
@@ -639,27 +991,20 @@
     {
       framingInfo |= LteRlcAmHeader::NO_FIRST_BYTE;
     }
+  (*it)->AddPacketTag (tag);
 
   // Add all SDUs (in DataField) to the Packet
   while (it < dataField.end ())
     {
       NS_LOG_LOGIC ("Adding SDU/segment to packet, length = " << (*it)->GetSize ());
 
-      NS_ASSERT_MSG ((*it)->PeekPacketTag (tag), "LteRlcSduStatusTag is missing");
-      (*it)->RemovePacketTag (tag);
-      if (packet->GetSize () > 0)
-        {
-          packet->AddAtEnd (*it);
-        }
-      else
-        {
-          packet = (*it);
-        }
+      packet->AddAtEnd (*it);
       it++;
     }
 
   // LAST SEGMENT (Note: There could be only one and be the first one)
   it--;
+  (*it)->RemovePacketTag (tag);
   if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
         (tag.GetStatus () == LteRlcSduStatusTag::LAST_SEGMENT) )
     {
@@ -669,6 +1014,7 @@
     {
       framingInfo |= LteRlcAmHeader::NO_LAST_BYTE;
     }
+  (*it)->AddPacketTag (tag);
 
   // Set the FramingInfo flag after the calculation
   rlcAmHeader.SetFramingInfo (framingInfo);
@@ -682,11 +1028,16 @@
   m_byteWithoutPoll += packet->GetSize ();
   NS_LOG_LOGIC ("BYTE_WITHOUT_POLL = " << m_byteWithoutPoll);
 
+  // if ( (m_pduWithoutPoll >= m_pollPdu) || (m_byteWithoutPoll >= m_pollByte) ||
+  //      ( (m_txonBuffer.empty ()) && (m_retxBufferSize == 0) ) ||
+  //      (m_vtS >= m_vtMs)
+  //      || m_pollRetransmitTimerJustExpired
+  //    )
   if ( (m_pduWithoutPoll >= m_pollPdu) || (m_byteWithoutPoll >= m_pollByte) ||
-       ( (m_txonBuffer.empty ()) && (m_retxBufferSize == 0) ) ||
+       ( (m_txonBuffer.empty ()) && (m_txonQueue->GetNPackets () == 0) && (m_retxBufferSize == 0) ) ||
        (m_vtS >= m_vtMs)
        || m_pollRetransmitTimerJustExpired
-     )
+     )  
     {
       m_pollRetransmitTimerJustExpired = false;
       rlcAmHeader.SetPollingBit (LteRlcAmHeader::STATUS_REPORT_IS_REQUESTED);
@@ -723,10 +1074,11 @@
   m_txedBufferSize += packet->GetSize ();
   m_txedBuffer.at ( rlcAmHeader.GetSequenceNumber ().GetValue () ).m_pdu = packet->Copy ();
   m_txedBuffer.at ( rlcAmHeader.GetSequenceNumber ().GetValue () ).m_retxCount = 0;
+  NS_ASSERT_MSG(m_txedBuffer.at (rlcAmHeader.GetSequenceNumber ().GetValue ()).m_pdu != 0, "Just inserted an invalid pointer");
 
   // Sender timestamp
   RlcTag rlcTag (Simulator::Now ());
-  packet->ReplacePacketTag (rlcTag);
+  packet->AddByteTag (rlcTag);
   m_txPdu (m_rnti, m_lcid, packet->GetSize ());
 
   // Send RLC PDU to MAC layer
@@ -736,29 +1088,694 @@
   params.lcid = m_lcid;
   params.layer = layer;
   params.harqProcessId = harqId;
-  params.componentCarrierId = componentCarrierId;
 
   m_macSapProvider->TransmitPdu (params);
 }
 
+std::vector < Ptr<Packet> > 
+LteRlcAm::GetTxBuffer()
+{
+  std::vector < Ptr<Packet> > toBeReturned;
+  if(!m_enableAqm)
+  {
+    toBeReturned.insert(toBeReturned.begin(), m_txonBuffer.begin(), m_txonBuffer.end());
+    m_txonBuffer.clear();
+    m_txonBufferSize = 0;
+  }
+  else
+  {
+    while(m_txonQueue->GetNBytes() > 0)
+    {
+      toBeReturned.push_back(m_txonQueue->Dequeue()->GetPacket());
+    }
+  }
+  return toBeReturned;
+}
+uint32_t LteRlcAm::GetTxBufferSize()
+{
+  return m_txonBufferSize + m_txonQueue->GetNBytes();
+}
+
+std::vector < LteRlcAm::RetxPdu > 
+LteRlcAm::GetTxedBuffer()
+{
+  //std::vector < LteRlcAm::RetxPdu > toBeReturned;
+  //toBeReturned.insert(toBeReturned.begin(), m_txedBuffer.begin(), m_txedBuffer.end());
+  return m_txedBuffer;
+}
+uint32_t 
+LteRlcAm::GetTxedBufferSize()
+{
+  return m_txedBufferSize;
+}
+
+std::vector < LteRlcAm::RetxPdu > 
+LteRlcAm::GetRetxBuffer()
+{
+  std::vector < LteRlcAm::RetxPdu > toBeReturned;
+  toBeReturned.insert(toBeReturned.begin(), m_retxBuffer.begin(), m_retxBuffer.end());
+  return toBeReturned;
+}
+
+uint32_t 
+LteRlcAm::GetRetxBufferSize()
+{
+  return m_retxBufferSize;
+}
+
+std::map < uint32_t, Ptr<Packet> > 
+LteRlcAm::GetTransmittingRlcSduBuffer()
+{
+  return m_transmittingRlcSduBuffer;
+  // TODO check if it must be emptied
+}
+uint32_t 
+LteRlcAm::GetTransmittingRlcSduBufferSize()
+{
+  return m_transmittingRlcSduBufferSize;
+}
+
+Ptr<Packet> 
+LteRlcAm::GetSegmentedRlcsdu()
+{
+  return m_segmented_rlcsdu;
+}
+
+/* LL HO
+ * Check if the current m_vtS (sending SEQ) is 
+ * inside the transmitting window.
+ */
+bool 
+LteRlcAm::IsInsideTransmittingWindow(){
+  //36.322 Section 5.1.3.1.1: window is m_vtA <= SN < m_vtMs, here: m_vtA <= SN <= m_vtMs.
+  if (m_vtS < m_vtMs && m_vtS >= m_vtA){
+    return true;
+  }
+  else
+    return false;
+}
+
 void
 LteRlcAm::DoNotifyHarqDeliveryFailure ()
 {
   NS_LOG_FUNCTION (this);
 }
 
+void
+LteRlcAm::DoNotifyDlHarqDeliveryFailure (uint8_t harqId)
+{
+  NS_LOG_FUNCTION (this);
+
+/*
+  std::map <uint8_t, uint16_t>::const_iterator it = m_harqIdToSnMap.find (harqId);
+  NS_ASSERT (it != m_harqIdToSnMap.end ());
+
+  uint16_t seqNumberValue = it->second;
+  if (m_txedBuffer.at (seqNumberValue).m_pdu != 0)
+  {
+    NS_LOG_INFO ("Move SN = " << seqNumberValue << " to retxBuffer");
+    m_retxBuffer.at (seqNumberValue).m_pdu = m_txedBuffer.at (seqNumberValue).m_pdu->Copy ();
+    m_retxBuffer.at (seqNumberValue).m_retxCount = m_txedBuffer.at (seqNumberValue).m_retxCount;
+    m_retxBufferSize += m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
+
+    m_txedBufferSize -= m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
+    m_txedBuffer.at (seqNumberValue).m_pdu = 0;
+    m_txedBuffer.at (seqNumberValue).m_retxCount = 0;
+  }
+  NS_ASSERT (m_retxBuffer.at (seqNumberValue).m_pdu != 0);
+*/
+}
+
+void
+LteRlcAm::DoNotifyUlHarqDeliveryFailure (uint8_t harqId)
+{
+  // send NACK
+}
 
+// LL HO 
+// Packet: RlcPdu
+// Assemble RlcPdus in txed/retxBuffer to RlcSdu.
+// Note: if handover happens when RlcPdu is smaller than RlcSdu,
+// the switch condition often ends up with: NO LOSS S1 11 case 
+// and multiple RlcPdus is combined to create a RlcSdu (1500B).
 void
-LteRlcAm::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
+LteRlcAm::Reassemble (Ptr<Packet> packet)
+{
+  LteRlcAmHeader rlcAmHeader;
+  packet->RemoveHeader (rlcAmHeader);
+  uint8_t framingInfo = rlcAmHeader.GetFramingInfo ();
+  SequenceNumber10 currSeqNumber = rlcAmHeader.GetSequenceNumber ();
+  bool expectedSnLost;
+  NS_LOG_DEBUG("currSeqNumber = " << currSeqNumber << "expected = " << m_reassembleExpectedSeqNumber);
+  //Starting state: WITH LOSS.
+  if ( currSeqNumber != m_reassembleExpectedSeqNumber )
+    {
+      expectedSnLost = true;
+      NS_LOG_LOGIC ("There are losses. Expected SN = " << m_reassembleExpectedSeqNumber  << ". Current SN = " << currSeqNumber);
+      m_reassembleExpectedSeqNumber = currSeqNumber + 1;
+    }
+  else
+    {
+      expectedSnLost = false;
+      NS_LOG_LOGIC ("No losses. Expected SN = " << m_reassembleExpectedSeqNumber  << ". Current SN = " << currSeqNumber);
+      m_reassembleExpectedSeqNumber = m_reassembleExpectedSeqNumber + 1;
+    }
+
+  // Build list of SDUs
+  uint8_t extensionBit;
+  uint16_t lengthIndicator;
+  do
+    {
+      extensionBit = rlcAmHeader.PopExtensionBit ();
+      NS_LOG_DEBUG ("E = " << (uint16_t)extensionBit);
+
+      if ( extensionBit == 0 )
+        {
+          m_sdusAssembleBuffer.push_back (packet);
+        }
+      else // extensionBit == 1
+        {
+          lengthIndicator = rlcAmHeader.PopLengthIndicator ();
+          NS_LOG_DEBUG ("LI = " << lengthIndicator);
+
+          // Check if there is enough data in the packet
+          if ( lengthIndicator >= packet->GetSize () )
+            {
+              NS_LOG_DEBUG ("INTERNAL ERROR: Not enough data in the packet (" << packet->GetSize () << "). Needed LI=" << lengthIndicator);
+              /// \todo What to do in this case? Discard packet and continue? Or Assert?
+            }
+
+          // Split packet in two fragments
+          Ptr<Packet> data_field = packet->CreateFragment (0, lengthIndicator);
+          packet->RemoveAtStart (lengthIndicator);
+
+          m_sdusAssembleBuffer.push_back (data_field);
+        }
+    }
+  while ( extensionBit == 1 );
+
+  std::list < Ptr<Packet> >::iterator it;
+  
+  //m_assemblingState = WAITING_SI_SF;
+  // Current reassembling state
+  if      (m_assemblingState == WAITING_S0_FULL)  NS_LOG_DEBUG ("Reassembling State = 'WAITING_S0_FULL'");
+  else if (m_assemblingState == WAITING_SI_SF)    NS_LOG_DEBUG ("Reassembling State = 'WAITING_SI_SF'");
+  else                                              NS_LOG_DEBUG ("Reassembling State = Unknown state");
+
+  // Received framing Info
+  NS_LOG_DEBUG ("Framing Info = " << (uint16_t)framingInfo);
+  NS_LOG_DEBUG ("m_sdusAssembleBuffer = " << m_sdusAssembleBuffer.size ());
+ // Reassemble the list of SDUs (when there is no losses)
+  if (!expectedSnLost)
+    {
+      NS_LOG_DEBUG ("Reassembling NO LOSS ");
+      switch (m_assemblingState)
+        {
+          case WAITING_S0_FULL: //Not waiting to complete a SDU.
+                  switch (framingInfo)
+                    {
+                      //RlcPdu = RlcSdu, without loss -> m_sdusAssembleBuffer contains all RLC SDUs.
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+
+                              NS_LOG_DEBUG (" S0 00 ");
+                              /**
+                              * Deliver one or multiple PDUs
+                              */
+                              for ( it = m_sdusAssembleBuffer.begin () ; it != m_sdusAssembleBuffer.end () ; it++ )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << (*it)->GetSize());
+                                  m_transmittingRlcSdus.push_back (*it);
+                                  m_transmittingRlcSduBufferSize += (*it)->GetSize ();
+                                }
+                              m_sdusAssembleBuffer.clear ();
+                      break;
+                      
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              //Received a PDU with the last part is a portion of a SDU.
+                              //Switch to waiting for complete SDU state.
+                              m_assemblingState = WAITING_SI_SF;
+                              NS_LOG_DEBUG (" S0 01 ");
+
+                              /**
+                              * Deliver full PDUs
+                              */
+                              //Previous recorded SDUs must be complete SDUs. The last PDU could 
+                              //be: (1) a part of the SDU, (2) several SDUs and a part of the last SDU.
+                              while ( m_sdusAssembleBuffer.size () > 1 )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+
+                              /**
+                              * Keep S0. Keep the last incomplete SDU in the sduBuffer
+                              * to wait for its ending portion.
+                              */
+                              m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+
+                              m_sdusAssembleBuffer.pop_front ();
+                      break;
+                      //This could not happen because in this state, PDU should presents complete 
+                      //SDU or the last part of PDU is a portion of RLC.
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                      default:
+                              /**
+                              * ERROR: Transition not possible
+                              */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE): //finish the previous S0.
+                              m_assemblingState = WAITING_S0_FULL;  //switch state to not waiting for S0 full.
+
+                              NS_LOG_DEBUG (" SI 10 ");
+                              /**
+                              * Deliver (Kept)S0 + SN
+                              */
+                              //Received an ending flag, if the state is waiting for the ending, 
+                              //then switch to complete (S0_full)
+                              m_keepS0Reassemble->AddAtEnd (m_sdusAssembleBuffer.front ());
+                              m_sdusAssembleBuffer.pop_front ();
+                              NS_LOG_DEBUG ("Received Pdu Size = " << m_keepS0Reassemble->GetSize ());
+                              m_transmittingRlcSdus.push_back (m_keepS0Reassemble);
+                              m_transmittingRlcSduBufferSize += m_keepS0Reassemble->GetSize ();
+
+                              /**
+                                * Deliver zero, one or multiple PDUs
+                                */
+                              //Deliver the complete SDUs after the first portion of SDU that completes
+                              //the above S0.
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              m_assemblingState = WAITING_SI_SF;
+                              NS_LOG_DEBUG (" SI 11 ");
+                      
+                              /**
+                              * Keep SI
+                              */
+                              if ( m_sdusAssembleBuffer.size () == 1 )
+                                {
+                                  m_keepS0Reassemble->AddAtEnd (m_sdusAssembleBuffer.front ());
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                              else // m_sdusAssembleBuffer.size () > 1
+                                {
+                                  /**
+                                  * Deliver (Kept)S0 + SN
+                                  */
+                                  m_keepS0Reassemble->AddAtEnd (m_sdusAssembleBuffer.front ());
+                                  m_sdusAssembleBuffer.pop_front ();
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_keepS0Reassemble->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_keepS0Reassemble);
+                                  m_transmittingRlcSduBufferSize += m_keepS0Reassemble->GetSize ();
+
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusAssembleBuffer.size () > 1 )
+                                    {
+                                      NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                      m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                      m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                      m_sdusAssembleBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_assemblingState);
+          break;
+        }
+    }
+  else // Reassemble the list of SDUs (when there are losses, i.e. the received SN is not the expected one)
+    {
+    NS_LOG_DEBUG ("Reassembling WITH LOSS");
+    switch (m_assemblingState)
+        {
+          case WAITING_S0_FULL:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+                              NS_LOG_DEBUG (" S0 00");
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              for ( it = m_sdusAssembleBuffer.begin () ; it != m_sdusAssembleBuffer.end () ; it++ )
+                                { 
+                                  m_transmittingRlcSdus.push_back (*it);
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << (*it)->GetSize ());
+                                  m_transmittingRlcSduBufferSize += (*it)->GetSize ();
+                                }
+                              m_sdusAssembleBuffer.clear ();
+                      break;
+
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              m_assemblingState = WAITING_SI_SF;
+
+                              NS_LOG_DEBUG (" S0 01 ");
+                              /**
+                               * Deliver full PDUs
+                               */
+                              while ( m_sdusAssembleBuffer.size () > 1 )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                              m_sdusAssembleBuffer.pop_front ();
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+                              NS_LOG_DEBUG (" S0 10");
+                              /**
+                               * Discard the first junk portion of SDU.
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              NS_LOG_DEBUG(" S0 11");
+                              
+                              if ( m_sdusAssembleBuffer.size () == 1 )
+                                {
+                                  m_assemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_assemblingState = WAITING_SI_SF;
+                                }
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              if ( m_sdusAssembleBuffer.size () > 0 )
+                                {
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusAssembleBuffer.size () > 1 )
+                                    {
+                                      NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                      m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                      m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                      m_sdusAssembleBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                               * ERROR: Transition not possible
+                               */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              m_assemblingState = WAITING_S0_FULL;
+
+                              NS_LOG_DEBUG (" SI 00");
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+                              m_assemblingState = WAITING_SI_SF;
+
+                              NS_LOG_DEBUG (" SI 01");
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( m_sdusAssembleBuffer.size () > 1 )
+                                {
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                              m_sdusAssembleBuffer.pop_front ();
+
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::LAST_BYTE):
+                              NS_LOG_DEBUG (" SI 10");
+                              m_assemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusAssembleBuffer.empty () )
+                                {
+                                  m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                  NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                  m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcAmHeader::NO_FIRST_BYTE | LteRlcAmHeader::NO_LAST_BYTE):
+
+                              NS_LOG_DEBUG(" SI 11");
+                              if ( m_sdusAssembleBuffer.size () == 1 )
+                                {
+                                  m_assemblingState = WAITING_SI_SF;
+                                  m_reassembleExpectedSeqNumber = currSeqNumber - 1; //With loss + SI_SF: Jump here until sdusBuffer is larger than 1, meaning a new SDU begins.
+                                }
+                              else
+                                {
+                                  m_assemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0Reassemble = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusAssembleBuffer.pop_front ();
+
+                              if ( m_sdusAssembleBuffer.size () > 0 )
+                                {
+                                  /**
+                                   * Deliver zero, one or multiple PDUs
+                                   */
+                                  while ( m_sdusAssembleBuffer.size () > 1 )
+                                    {
+                                      NS_LOG_DEBUG ("Received Pdu Size = " << m_sdusAssembleBuffer.front()->GetSize ());
+                                      m_transmittingRlcSdus.push_back (m_sdusAssembleBuffer.front ());
+                                      m_transmittingRlcSduBufferSize += m_sdusAssembleBuffer.front()->GetSize ();
+                                      m_sdusAssembleBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                   * Keep S0
+                                   */
+                                  m_keepS0Reassemble = m_sdusAssembleBuffer.front ();
+                                  m_sdusAssembleBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                              NS_LOG_DEBUG ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_assemblingState);
+                NS_LOG_DEBUG ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_assemblingState);
+          break;
+        }
+  }
+  NS_LOG_DEBUG ("End RlcPdutoRlcSdu... transmittingRlcSduBufferSize= " << m_transmittingRlcSdus.size() << " Bytes= " << m_transmittingRlcSduBufferSize);
+}
+
+// LL HO
+void 
+LteRlcAm::CreateRlcSduBuffer(){
+  NS_LOG_DEBUG (this);
+  LtePdcpHeader pdcpHeader;
+  for (std::vector < Ptr<Packet> >::iterator it = m_transmittingRlcSdus.begin(); it != m_transmittingRlcSdus.end(); ++it){
+    (*it)->PeekHeader(pdcpHeader);
+    NS_LOG_DEBUG ("RLCSDU_SEQ = " << pdcpHeader.GetSequenceNumber());
+    m_transmittingRlcSduBuffer[pdcpHeader.GetSequenceNumber()] = (*it)->Copy();
+  }
+}
+
+// LL HO
+void 
+LteRlcAm::RlcPdusToRlcSdus (std::vector < LteRlcAm::RetxPdu > RlcPdus){
+
+  NS_LOG_DEBUG (this << "in RlcPdusTo..." );
+  uint16_t isGotExpectedSeqNumber = 0;
+  for ( std::vector <LteRlcAm::RetxPdu>::iterator it = RlcPdus.begin(); it != RlcPdus.end (); it++)
+        {
+          if (it->m_pdu == 0){
+            continue;
+          }
+          NS_LOG_DEBUG (this << "Pdu = " << it->m_pdu );
+          Ptr<Packet> p = it->m_pdu->Copy();
+
+          // Get RLC header parameters
+          LteRlcAmHeader rlcAmHeader;
+          p->PeekHeader (rlcAmHeader);
+          NS_LOG_DEBUG("RLC header: " << rlcAmHeader);
+          
+          //Always enter the Reassemble function with LOSS mode.
+          if (isGotExpectedSeqNumber  == 0){ 
+              isGotExpectedSeqNumber = 1;
+              m_reassembleExpectedSeqNumber = rlcAmHeader.GetSequenceNumber()+1; //To make the condition WITH LOSS true.
+          }
+          if ( rlcAmHeader.IsDataPdu () )
+            {
+              SequenceNumber10 seqNumber = rlcAmHeader.GetSequenceNumber ();
+
+              if ( rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::SEGMENT )
+                {
+                  NS_LOG_DEBUG ("PDU segment in Txed/Retx buffer ( *absolute* SN = " << seqNumber << " )");
+                }
+              else if ( rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::PDU )
+                {
+                  NS_LOG_DEBUG ("PDU in Txed/Retx buffer ( *absolute* SN = " << seqNumber << " )");
+                }
+              else
+                {
+                  NS_ASSERT_MSG (false, "Neither a PDU segment nor a PDU Txed/Retx buffer");
+                  return ;
+                }
+              Reassemble(p);
+            }
+          else if ( rlcAmHeader.IsControlPdu () )
+            {
+              NS_LOG_DEBUG ("Control AM RLC PDU in Txed/Retx buffer. Discard");
+            }
+          else
+            {
+              NS_LOG_DEBUG ("Wrong AM RLC PDU type in Txed/Retx buffer");
+              return;
+            }
+    }
+    CreateRlcSduBuffer();
+}
+
+void
+LteRlcAm::DoReceivePdu (Ptr<Packet> p)
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
 
   // Receiver timestamp
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
-  p->RemovePacketTag (rlcTag);
-  delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag (rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
   m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
 
   // Get RLC header parameters
@@ -768,6 +1785,7 @@
 
   if ( rlcAmHeader.IsDataPdu () )
     {
+      NS_LOG_INFO (this << " RLC DoReceivePdu " << m_rnti << (uint32_t) m_lcid << p->GetSize () << " time " << Simulator::Now().GetSeconds());
 
       // 5.1.3.1   Transmit operations
 
@@ -883,17 +1901,79 @@
           if (it != m_rxonBuffer.end () )
             {
               NS_ASSERT (it->second.m_byteSegments.size () > 0);
-              NS_ASSERT_MSG (it->second.m_byteSegments.size () == 1, "re-segmentation not supported");
-              NS_LOG_LOGIC ("PDU segment already received, discarded");
+              //NS_ASSERT_MSG (it->second.m_byteSegments.size () == 1, "re-segmentation not supported");
+              NS_LOG_LOGIC ("Received duplicate SN");
+
+              if (rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::SEGMENT)
+              {
+                NS_LOG_LOGIC ("Received PDU segment");
+                //unsigned totalBytes = 0;
+                std::list < Ptr<Packet> >::iterator itSeg;
+//                for (itSeg = it->second.m_byteSegments.begin ();
+//                    itSeg != it->second.m_byteSegments.end (); itSeg++)
+//                {
+//                  totalBytes += (*itSeg)->GetSize ();
+//                }
+                // get header of last segment received
+                NS_LOG_INFO ("RLC AM PDU segment received, offset= " << rlcAmHeader.GetSegmentOffset() <<
+                               " size= " << rlcAmHeader.GetLastOffset()-rlcAmHeader.GetSegmentOffset());
+                LteRlcAmHeader lastSegHdr;
+                it->second.m_byteSegments.back ()->PeekHeader (lastSegHdr);
+                if(rlcAmHeader.GetSegmentOffset() == lastSegHdr.GetLastOffset () || rlcAmHeader.GetSegmentOffset() + 32768 == lastSegHdr.GetLastOffset ()) 
+                {
+                  // segment is next in sequence
+                  it->second.m_byteSegments.push_back (p);
+                  if (rlcAmHeader.GetLastSegmentFlag () == LteRlcAmHeader::LAST_PDU_SEGMENT)
+                  {
+                    // got last segment, reassemble segments
+                    it->second.m_pduComplete = true;
+                    NS_ASSERT (it->second.m_byteSegments.size () > 1);
+                    itSeg = it->second.m_byteSegments.begin ();
+                    itSeg++;
+                    for (; itSeg != it->second.m_byteSegments.end (); itSeg++)
+                    {
+                      LteRlcAmHeader segHdr;
+                      (*itSeg)->RemoveHeader (segHdr);
+                      //totalBytes = segHdr.PopLengthIndicator ();
+                      it->second.m_byteSegments.front ()->AddAtEnd (*itSeg);
+                    }
+                    // now delete all fragments after the first whole data field
+                    itSeg = it->second.m_byteSegments.begin ();
+                    itSeg++;
+                    it->second.m_byteSegments.erase (itSeg, it->second.m_byteSegments.end ());
+                  }
+                }
+                else
+                {
+                  // out of order segment, discard both received packet and buffered
+                  //it->second.m_byteSegments.clear ();
+                  if(it->second.m_pduComplete == false)
+                  {
+                      m_rxonBuffer.erase (it);
+                      NS_LOG_LOGIC ("PDU segment received out of order, discarding");
+                  }
+                }
+              }
             }
           else
             {
-              NS_LOG_LOGIC ("Place PDU in the reception buffer ( SN = " << seqNumber << " )");
-              m_rxonBuffer[ seqNumber.GetValue () ].m_byteSegments.push_back (p);
-              m_rxonBuffer[ seqNumber.GetValue () ].m_pduComplete = true;
+              if(rlcAmHeader.GetSegmentOffset() == 0)
+              {
+                NS_LOG_LOGIC ("Place PDU in the reception buffer ( SN = " << seqNumber << " )");
+                m_rxonBuffer[ seqNumber.GetValue () ].m_byteSegments.push_back (p);
+                if(rlcAmHeader.GetResegmentationFlag () == LteRlcAmHeader::SEGMENT)
+                {
+                  NS_LOG_INFO ("RLC AM PDU segment received, offset= " << rlcAmHeader.GetSegmentOffset() <<
+                                                 " size= " << rlcAmHeader.GetLastOffset()-rlcAmHeader.GetSegmentOffset());
+                  // received segment
+                  m_rxonBuffer[ seqNumber.GetValue () ].m_pduComplete = false;
+                }
+                else
+                {
+                  m_rxonBuffer[ seqNumber.GetValue () ].m_pduComplete = true;
+                }
+              }
             }
-
-
         }
 
       // 5.1.3.2.3 Actions when a RLC data PDU is placed in the reception buffer
@@ -949,7 +2029,7 @@
                 {
                   NS_LOG_LOGIC ("Reassemble and Deliver ( SN = " << m_vrR << " )");
                   NS_ASSERT_MSG (it->second.m_byteSegments.size () == 1,
-                                "Too many segments. PDU Reassembly process didn't work");
+                                 "Too many segments. PDU Reassembly process didn't work");
                   ReassembleAndDeliver (it->second.m_byteSegments.front ());
                   m_rxonBuffer.erase (m_vrR.GetValue ());
 
@@ -1068,6 +2148,9 @@
                 {
                   NS_LOG_INFO ("ACKed SN = " << seqNumberValue << " from txedBuffer");
                   //               NS_LOG_INFO ("m_txedBuffer( " << m_vtA << " )->GetSize = " << m_txedBuffer.at (m_vtA.GetValue ())->GetSize ());
+                  NS_LOG_LOGIC("m_txCompletedCallback " << m_rnti);
+                  m_txCompletedCallback(m_rnti, m_lcid, m_txedBuffer.at (seqNumberValue).m_pdu->GetSize (), 0); // 0 retransmissions at the RLC layer
+
                   m_txedBufferSize -= m_txedBuffer.at (seqNumberValue).m_pdu->GetSize ();
                   m_txedBuffer.at (seqNumberValue).m_pdu = 0;
                   NS_ASSERT (m_retxBuffer.at (seqNumberValue).m_pdu == 0);
@@ -1077,8 +2160,16 @@
                 {
                   NS_LOG_INFO ("ACKed SN = " << seqNumberValue << " from retxBuffer");
                   m_retxBufferSize -= m_retxBuffer.at (seqNumberValue).m_pdu->GetSize ();
+                  NS_LOG_LOGIC("m_txCompletedCallback " << m_rnti);
+
+                  m_txCompletedCallback(m_rnti, m_lcid, m_retxBuffer.at (seqNumberValue).m_pdu->GetSize (), m_retxBuffer.at (seqNumberValue).m_retxCount);
+
                   m_retxBuffer.at (seqNumberValue).m_pdu = 0;
                   m_retxBuffer.at (seqNumberValue).m_retxCount = 0;
+                  // reset segment buffer
+                  m_retxSegBuffer.at (seqNumberValue).m_pdu = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_retxCount = 0;
+                  m_retxSegBuffer.at (seqNumberValue).m_lastSegSent = 0;
                 }
 
             }
@@ -1111,7 +2202,6 @@
 
 }
 
-
 bool
 LteRlcAm::IsInsideReceivingWindow (SequenceNumber10 seqNumber)
 {
@@ -1218,7 +2308,7 @@
                               */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -1231,7 +2321,7 @@
                               */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -1264,14 +2354,14 @@
                               */
                               m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                               m_sdusBuffer.pop_front ();
-                              m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                              TriggerReceivePdcpPdu (m_keepS0);
 
                               /**
                                 * Deliver zero, one or multiple PDUs
                                 */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1294,14 +2384,14 @@
                                   */
                                   m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
-                                  m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                                  TriggerReceivePdcpPdu (m_keepS0);
 
                                   /**
                                   * Deliver zero, one or multiple PDUs
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1344,7 +2434,7 @@
                                */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -1357,7 +2447,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -1381,7 +2471,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1408,7 +2498,7 @@
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1445,7 +2535,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1463,7 +2553,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -1493,7 +2583,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1525,7 +2615,7 @@
                                    */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1555,6 +2645,21 @@
 }
 
 void
+LteRlcAm::TriggerReceivePdcpPdu(Ptr<Packet> p)
+{
+  if(!isMc) 
+  {
+    m_rlcSapUser->ReceivePdcpPdu(p);
+  }
+  else
+  {
+    m_ueDataParams.ueData = p;
+    m_epcX2RlcProvider->ReceiveMcPdcpSdu(m_ueDataParams);
+  }
+}
+
+
+void
 LteRlcAm::DoReportBufferStatus (void)
 {
   NS_LOG_FUNCTION (this);
@@ -1599,10 +2704,24 @@
   LteMacSapProvider::ReportBufferStatusParameters r;
   r.rnti = m_rnti;
   r.lcid = m_lcid;
-  r.txQueueSize = m_txonBufferSize;
+  r.txQueueSize = m_txonBufferSize + m_txonQueue->GetNBytes();
   r.txQueueHolDelay = txonQueueHolDelay.GetMilliSeconds ();
-  r.retxQueueSize = m_retxBufferSize + m_txedBufferSize;
+  r.retxQueueSize = m_retxBufferSize;// + m_txedBufferSize;
   r.retxQueueHolDelay = retxQueueHolDelay.GetMilliSeconds ();
+  
+  // from UM low lat TODO check
+  for (unsigned i = 0; i < m_txonBuffer.size(); i++)
+  {
+    if (i == 20)  // only include up to the first 20 packets
+    {
+      break;
+    }
+    r.txPacketSizes.push_back (m_txonBuffer[i]->GetSize ());
+    RlcTag holTimeTag;
+    m_txonBuffer[i]->PeekPacketTag (holTimeTag);
+    Time holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+    r.txPacketDelays.push_back (holDelay.GetMicroSeconds ());
+  }
 
   if ( m_statusPduRequested && ! m_statusProhibitTimer.IsRunning () )
     {
@@ -1617,7 +2736,7 @@
     {
       NS_LOG_INFO ("Send ReportBufferStatus: " << r.txQueueSize << ", " << r.txQueueHolDelay << ", " 
                                                << r.retxQueueSize << ", " << r.retxQueueHolDelay << ", " 
-                                               << r.statusPduSize);
+                                               << r.statusPduSize << ", " << r.txPacketSizes.size());
       m_macSapProvider->ReportBufferStatus (r);
     }
   else
@@ -1633,6 +2752,13 @@
   NS_LOG_FUNCTION (this);
   NS_LOG_LOGIC ("Reordering Timer has expired");
 
+  // clear the RLC segment buffer
+  // for (unsigned i = 0; i < m_retxSegBuffer.size(); i++)
+  // {
+  //  m_retxSegBuffer.at (i).m_pdu = 0;
+  //  m_retxSegBuffer.at (i).m_lastSegSent = false;
+  // }
+
   // 5.1.3.2.4 Actions when t-Reordering expires
   // When t-Reordering expires, the receiving side of an AM RLC entity shall:
   // - update VR(MS) to the SN of the first AMD PDU with SN >= VR(X) for which not all byte segments
@@ -1685,30 +2811,72 @@
   // see section 5.2.2.3
   // note the difference between Rel 8 and Rel 11 specs; we follow Rel 11 here
   NS_ASSERT (m_vtS <= m_vtMs);
-  if ((m_txonBufferSize == 0 && m_retxBufferSize == 0)
+  //if ((m_txonBufferSize == 0 && m_retxBufferSize == 0)
+  if ((m_txonBufferSize + m_txonQueue->GetNBytes() == 0 && m_retxBufferSize == 0)
       || (m_vtS == m_vtMs))
     {
       NS_LOG_INFO ("txonBuffer and retxBuffer empty. Move PDUs up to = " << m_vtS.GetValue () - 1 << " to retxBuffer");
-      for (SequenceNumber10 sn = m_vtA; sn < m_vtS; sn++)
+      uint16_t sn = 0;
+      uint16_t acked =  m_vtA.GetValue();
+      uint16_t sent = m_vtS.GetValue ();
+      if(acked <= sent) //If no overflow, no change.
         {
-          bool pduAvailable = m_txedBuffer.at (sn.GetValue ()).m_pdu != 0;
+      for ( sn = m_vtA.GetValue(); sn < m_vtS.GetValue (); sn++ )
+      {
+        bool pduAvailable = m_txedBuffer.at (sn).m_pdu != 0;
+
+         if ( pduAvailable )
+         {
+           NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
+           m_retxBuffer.at (sn).m_pdu = m_txedBuffer.at (sn).m_pdu->Copy ();
+           m_retxBuffer.at (sn).m_retxCount = m_txedBuffer.at (sn).m_retxCount;
+           m_retxBufferSize += m_retxBuffer.at (sn).m_pdu->GetSize ();
+
+           m_txedBufferSize -= m_txedBuffer.at (sn).m_pdu->GetSize ();
+           m_txedBuffer.at (sn).m_pdu = 0;
+           m_txedBuffer.at (sn).m_retxCount = 0;
+         }
+       }
+         }
+       else//If overflow happened, we retransmit from acked sequence to 1023, then from 0 to sent sequence.
+         {
+       for ( sn = m_vtA.GetValue(); sn < 1024; sn++ )
+         {
+         bool pduAvailable = m_txedBuffer.at (sn).m_pdu != 0;
+
+         if ( pduAvailable )
+         {
+           NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
+           m_retxBuffer.at (sn).m_pdu = m_txedBuffer.at (sn).m_pdu->Copy ();
+           m_retxBuffer.at (sn).m_retxCount = m_txedBuffer.at (sn).m_retxCount;
+           m_retxBufferSize += m_retxBuffer.at (sn).m_pdu->GetSize ();
+
+           m_txedBufferSize -= m_txedBuffer.at (sn).m_pdu->GetSize ();
+           m_txedBuffer.at (sn).m_pdu = 0;
+           m_txedBuffer.at (sn).m_retxCount = 0;
+         }
+      }
 
-           if ( pduAvailable )
-             {
-               uint16_t snValue = sn.GetValue ();
-               NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
-               m_retxBuffer.at (snValue).m_pdu = m_txedBuffer.at (snValue).m_pdu->Copy ();
-               m_retxBuffer.at (snValue).m_retxCount = m_txedBuffer.at (snValue).m_retxCount;
-               m_retxBufferSize += m_retxBuffer.at (snValue).m_pdu->GetSize ();
-
-               m_txedBufferSize -= m_txedBuffer.at (snValue).m_pdu->GetSize ();
-               m_txedBuffer.at (snValue).m_pdu = 0;
-               m_txedBuffer.at (snValue).m_retxCount = 0;
-             }
+      for ( sn = 0; sn < m_vtS.GetValue (); sn++ )
+      {
+        bool pduAvailable = m_txedBuffer.at (sn).m_pdu != 0;
+
+         if ( pduAvailable )
+         {
+           NS_LOG_INFO ("Move PDU " << sn << " from txedBuffer to retxBuffer");
+           m_retxBuffer.at (sn).m_pdu = m_txedBuffer.at (sn).m_pdu->Copy ();
+           m_retxBuffer.at (sn).m_retxCount = m_txedBuffer.at (sn).m_retxCount;
+           m_retxBufferSize += m_retxBuffer.at (sn).m_pdu->GetSize ();
+
+           m_txedBufferSize -= m_txedBuffer.at (sn).m_pdu->GetSize ();
+           m_txedBuffer.at (sn).m_pdu = 0;
+           m_txedBuffer.at (sn).m_retxCount = 0;
+         }
+      }
         }
     }
 
-  DoReportBufferStatus ();
+  DoReportBufferStatus ();  
 }
 
 
@@ -1723,7 +2891,7 @@
 {
   NS_LOG_LOGIC ("RBS Timer expires");
 
-  if (m_txonBufferSize + m_txedBufferSize + m_retxBufferSize > 0)
+  if (m_txonBufferSize + m_txonQueue->GetNBytes() + m_txedBufferSize + m_retxBufferSize > 0)
     {
       DoReportBufferStatus ();
       m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcAm::ExpireRbsTimer, this);
diff -Naru a/model/lte-rlc-am.h b/model/lte-rlc-am.h
--- a/model/lte-rlc-am.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc-am.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by Michele Polese <michele.polese@gmail.com> to add DC functionalities
  */
 
 #ifndef LTE_RLC_AM_H
@@ -24,9 +27,15 @@
 #include <ns3/event-id.h>
 #include <ns3/lte-rlc-sequence-number.h>
 #include <ns3/lte-rlc.h>
+#include <ns3/epc-x2-sap.h>
+#include <ns3/lte-pdcp-header.h>
 
 #include <vector>
 #include <map>
+#include <fstream>
+#include <string>
+
+#include "ns3/codel-queue-disc.h" 
 
 namespace ns3 {
 
@@ -38,36 +47,64 @@
 public:
   LteRlcAm ();
   virtual ~LteRlcAm ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
+  struct RetxPdu
+  {
+    Ptr<Packet> m_pdu;
+    uint16_t    m_retxCount;
+  };
+
   /**
    * RLC SAP
-   *
-   * \param p packet
    */
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
 
   /**
+   * RLC EPC X2 SAP
+   */
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
+
+  // LL HO
+  std::vector < Ptr<Packet> > GetTxBuffer();
+  uint32_t GetTxBufferSize();
+  
+  std::vector < RetxPdu > GetTxedBuffer();
+  uint32_t GetTxedBufferSize();
+
+  std::vector < RetxPdu > GetRetxBuffer();
+  uint32_t GetRetxBufferSize();
+
+  std::map < uint32_t, Ptr<Packet> > GetTransmittingRlcSduBuffer();
+  uint32_t GetTransmittingRlcSduBufferSize();
+
+  Ptr<Packet> GetSegmentedRlcsdu();
+  ///< translate a vector of Rlc PDUs to Rlc SDUs 
+  ///< and put the Rlc SDUs into m_transmittingRlcSdus.
+  void  RlcPdusToRlcSdus (std::vector < RetxPdu >  Pdus);
+  
+  std::vector < Ptr<Packet> > GetTxedRlcSduBuffer (){
+    return m_txedRlcSduBuffer;
+  }
+
+private:
+  //whether the last SDU in the txonBuffer is a complete SDU.
+  bool is_fragmented;
+
+  //
+  std::vector < Ptr <Packet> > m_txedRlcSduBuffer;
+  uint32_t m_txedRlcSduBufferSize;
+  
+public:
+  /**
    * MAC SAP
-   *
-   * \param bytes number of bytes
-   * \param layer 
-   * \param harqId HARQ ID
-   * \param componentCarrierId component carrier ID
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */
-  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
-    /**
-   * Notify HARQ delivery failure
    */
+  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId);
   virtual void DoNotifyHarqDeliveryFailure ();
-  virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
+  virtual void DoNotifyDlHarqDeliveryFailure (uint8_t harqId);
+  virtual void DoNotifyUlHarqDeliveryFailure (uint8_t harqId);
+  virtual void DoReceivePdu (Ptr<Packet> p);
 
 private:
   /**
@@ -76,9 +113,7 @@
    * in which case this method does nothing.
    */
   void ExpireReorderingTimer (void);
-  /// Expire poll retransmitter 
   void ExpirePollRetransmitTimer (void);
-  /// Expire RBS timer
   void ExpireRbsTimer (void);
 
   /** 
@@ -87,91 +122,107 @@
    */
   void ExpireStatusProhibitTimer (void);
 
-  /** 
-   * method called when the T_status_prohibit timer expires
-   * 
-   * \param seqNumber SequenceNumber10
-   * \returns true is inside receivign window
-   */
   bool IsInsideReceivingWindow (SequenceNumber10 seqNumber);
+
+  // LL HO
+  bool IsInsideTransmittingWindow ();
+  //Create RlcSduBuffer <seqNumber, RlcSDU> based on m_transmittingRlcSdus.
+  //The buffer is ascending ordered on sequence number.
+  void CreateRlcSduBuffer ();
+
 // 
 //   void ReassembleOutsideWindow (void);
 //   void ReassembleSnLessThan (uint16_t seqNumber);
 // 
-
-  /** 
-   * Reassemble and deliver
-   * 
-   * \param packet the packet
-   */
   void ReassembleAndDeliver (Ptr<Packet> packet);
+  void TriggerReceivePdcpPdu(Ptr<Packet> p);
+
+  void Reassemble (Ptr<Packet> Packet);
 
-  /** 
-   * Report buffer status
-   */
   void DoReportBufferStatus ();
 
+  std::string GetBufferSizeFilename();
+  void SetBufferSizeFilename(std::string filename);
+  void BufferSizeTrace();
+
 private:
-    std::vector < Ptr<Packet> > m_txonBuffer; ///< Transmission buffer
+    std::vector < Ptr<Packet> > m_txonBuffer;       // Transmission buffer
 
-    /// RetxPdu structure
-    struct RetxPdu
+    struct RetxSegPdu
     {
-      Ptr<Packet> m_pdu; ///< PDU
-      uint16_t    m_retxCount; ///< retransmit count
+      Ptr<Packet> m_pdu;
+      uint16_t    m_retxCount;
+      bool      m_lastSegSent;    // all segments sent, waiting for ACK
     };
 
+  // LL HO: store a complete version of the incomplete RLC SDU at the 
+  // edge of the m_txonBuffer during the segmentation process.
+  // This SDU will be forwarded to target eNB in lossless HO
+  // to assure no packet is lost.
+  Ptr<Packet> m_segmented_rlcsdu;
+
   std::vector <RetxPdu> m_txedBuffer;  ///< Buffer for transmitted and retransmitted PDUs 
                                        ///< that have not been acked but are not considered 
                                        ///< for retransmission 
   std::vector <RetxPdu> m_retxBuffer;  ///< Buffer for PDUs considered for retransmission
+  std::vector <RetxSegPdu> m_retxSegBuffer;  // buffer for AM PDU segments
 
-    uint32_t m_txonBufferSize; ///< transmit on buffer size
-    uint32_t m_retxBufferSize; ///< retransmit buffer size
-    uint32_t m_txedBufferSize; ///< transmit ed buffer size
+  Ptr<CoDelQueueDisc> m_txonQueue;
 
-    bool     m_statusPduRequested; ///< status PDU requested
-    uint32_t m_statusPduBufferSize; ///< status PDU buffer size
+  ///< LL HO: stores RLC SDUs that is not acked 
+  ///< and forwarded to target eNB during lossless handover.
+  std::vector < Ptr<Packet> > m_transmittingRlcSdus;
+  uint32_t m_transmittingRlcSduBufferSize;
+  std::map <uint32_t, Ptr <Packet> > m_transmittingRlcSduBuffer;
+
+    uint32_t m_txonBufferSize;
+    uint32_t m_retxBufferSize;
+    uint32_t m_txedBufferSize;
+
+    bool     m_statusPduRequested;
+    uint32_t m_statusPduBufferSize;
 
-    /// PduBuffer structure
     struct PduBuffer
     {
-      SequenceNumber10  m_seqNumber; ///< sequence number
-      std::list < Ptr<Packet> >  m_byteSegments; ///< byte segments
+      SequenceNumber10  m_seqNumber;
+      std::list < Ptr<Packet> >  m_byteSegments;
 
-      bool      m_pduComplete; ///< PDU complete?
+      bool      m_pduComplete;
+      uint16_t  m_totalSize;
+      uint16_t  m_currSize;
     };
 
-    std::map <uint16_t, PduBuffer > m_rxonBuffer; ///< Reception buffer
+    std::map <uint16_t, PduBuffer > m_rxonBuffer; // Reception buffer
 
-    Ptr<Packet> m_controlPduBuffer;               ///< Control PDU buffer (just one PDU)
+    Ptr<Packet> m_controlPduBuffer;               // Control PDU buffer (just one PDU)
 
     // SDU reassembly
 //   std::vector < Ptr<Packet> > m_reasBuffer;     // Reassembling buffer
 // 
-    std::list < Ptr<Packet> > m_sdusBuffer;       ///< List of SDUs in a packet (PDU)
+    std::list < Ptr<Packet> > m_sdusBuffer;       // List of SDUs in a packet (PDU)
+    std::list < Ptr<Packet> > m_sdusAssembleBuffer;
 
   /**
    * State variables. See section 7.1 in TS 36.322
    */
   // Transmitting side
-  SequenceNumber10 m_vtA;                   ///< VT(A)
-  SequenceNumber10 m_vtMs;                  ///< VT(MS)
-  SequenceNumber10 m_vtS;                   ///< VT(S)
-  SequenceNumber10 m_pollSn;                ///< POLL_SN
+  SequenceNumber10 m_vtA;                   // VT(A)
+  SequenceNumber10 m_vtMs;                  // VT(MS)
+  SequenceNumber10 m_vtS;                   // VT(S)
+  SequenceNumber10 m_pollSn;                // POLL_SN
 
   // Receiving side
-  SequenceNumber10 m_vrR;                   ///< VR(R)
-  SequenceNumber10 m_vrMr;                  ///< VR(MR)
-  SequenceNumber10 m_vrX;                   ///< VR(X)
-  SequenceNumber10 m_vrMs;                  ///< VR(MS)
-  SequenceNumber10 m_vrH;                   ///< VR(H)
+  SequenceNumber10 m_vrR;                   // VR(R)
+  SequenceNumber10 m_vrMr;                  // VR(MR)
+  SequenceNumber10 m_vrX;                   // VR(X)
+  SequenceNumber10 m_vrMs;                  // VR(MS)
+  SequenceNumber10 m_vrH;                   // VR(H)
 
   /**
    * Counters. See section 7.1 in TS 36.322
    */
-  uint32_t m_pduWithoutPoll; ///< PDU without poll
-  uint32_t m_byteWithoutPoll; ///< byte without poll
+  uint32_t m_pduWithoutPoll;
+  uint32_t m_byteWithoutPoll;
 
   /**
    * Constants. See section 7.2 in TS 36.322
@@ -181,24 +232,24 @@
   /**
    * Timers. See section 7.3 in TS 36.322
    */
-  EventId m_pollRetransmitTimer; ///< poll retransmit timer
-  Time    m_pollRetransmitTimerValue; ///< poll retransmit time value
-  EventId m_reorderingTimer; ///< reordering timer
-  Time    m_reorderingTimerValue; ///< reordering timer value
-  EventId m_statusProhibitTimer; ///< status prohibit timer
-  Time    m_statusProhibitTimerValue; ///< status prohibit timer value
-  EventId m_rbsTimer; ///< RBS timer
-  Time    m_rbsTimerValue; ///< RBS timer value
+  EventId m_pollRetransmitTimer;
+  Time    m_pollRetransmitTimerValue;
+  EventId m_reorderingTimer;
+  Time    m_reorderingTimerValue;
+  EventId m_statusProhibitTimer;
+  Time    m_statusProhibitTimerValue;
+  EventId m_rbsTimer;
+  Time    m_rbsTimerValue;
 
   /**
    * Configurable parameters. See section 7.4 in TS 36.322
    */
-  uint16_t m_maxRetxThreshold;  ///< \todo How these parameters are configured???
-  uint16_t m_pollPdu; ///< poll PDU
-  uint16_t m_pollByte; ///< poll byte
+  uint16_t m_maxRetxThreshold;  /// \todo How these parameters are configured???
+  uint16_t m_pollPdu;
+  uint16_t m_pollByte;
   
-  bool m_txOpportunityForRetxAlwaysBigEnough; ///< transmit opportunity for retransmit? 
-  bool m_pollRetransmitTimerJustExpired; ///< poll retransmit timer just expired?
+  bool m_txOpportunityForRetxAlwaysBigEnough;
+  bool m_pollRetransmitTimerJustExpired;
 
   /**
    * SDU Reassembling state
@@ -206,16 +257,29 @@
   typedef enum { NONE            = 0,
                  WAITING_S0_FULL = 1,
                  WAITING_SI_SF   = 2 } ReassemblingState_t;
-  ReassemblingState_t m_reassemblingState; ///< reassembling state
-  Ptr<Packet> m_keepS0; ///< keep S0
+  ReassemblingState_t m_reassemblingState;
+  ReassemblingState_t m_assemblingState; //state of the RlcPduToRlcSdu assembling used for handover.
+  Ptr<Packet> m_keepS0;
+  Ptr<Packet> m_keepS0Reassemble;
 
   /**
    * Expected Sequence Number
    */
   SequenceNumber10 m_expectedSeqNumber;
 
-};
+  SequenceNumber10 m_reassembleExpectedSeqNumber;
 
+  std::map <uint8_t, uint16_t> m_harqIdToSnMap;
+
+  uint32_t m_maxTxBufferSize;
+
+  std::string m_bufferSizeFilename;
+  std::ofstream m_bufferSizeFile;
+  EventId m_traceBufferSizeEvent;
+
+  bool m_enableAqm;
+
+};
 
 } // namespace ns3
 
diff -Naru a/model/lte-rlc.cc b/model/lte-rlc.cc
--- a/model/lte-rlc.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -24,7 +28,7 @@
 
 #include "ns3/lte-rlc.h"
 #include "ns3/lte-rlc-tag.h"
-// #include "lte-mac-sap.h"
+#include "lte-mac-sap.h"
 #include "ns3/lte-rlc-sap.h"
 // #include "ff-mac-sched-sap.h"
 
@@ -33,26 +37,8 @@
 NS_LOG_COMPONENT_DEFINE ("LteRlc");
 
 
-/// LteRlcSpecificLteMacSapUser class
-class LteRlcSpecificLteMacSapUser : public LteMacSapUser
-{
-public:
-  /**
-   * Constructor
-   *
-   * \param rlc the RLC
-   */
-  LteRlcSpecificLteMacSapUser (LteRlc* rlc);
-
-  // Interface implemented from LteMacSapUser
-  virtual void NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
-  virtual void NotifyHarqDeliveryFailure ();
-  virtual void ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
-
-private:
-  LteRlcSpecificLteMacSapUser ();
-  LteRlc* m_rlc; ///< the RLC
-};
+///////////////////////////////////////
+
 
 LteRlcSpecificLteMacSapUser::LteRlcSpecificLteMacSapUser (LteRlc* rlc)
   : m_rlc (rlc)
@@ -64,9 +50,9 @@
 }
 
 void
-LteRlcSpecificLteMacSapUser::NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
+LteRlcSpecificLteMacSapUser::NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId)
 {
-  m_rlc->DoNotifyTxOpportunity (bytes, layer, harqId, componentCarrierId, rnti, lcid);
+  m_rlc->DoNotifyTxOpportunity (bytes, layer, harqId);
 }
 
 void
@@ -76,9 +62,15 @@
 }
 
 void
-LteRlcSpecificLteMacSapUser::ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
+LteRlcSpecificLteMacSapUser::NotifyHarqDeliveryFailure (uint8_t harqId)
+{
+  m_rlc->DoNotifyHarqDeliveryFailure (harqId);
+}
+
+void
+LteRlcSpecificLteMacSapUser::ReceivePdu (Ptr<Packet> p)
 {
-  m_rlc->DoReceivePdu (p, rnti, lcid);
+  m_rlc->DoReceivePdu (p);
 }
 
 
@@ -90,10 +82,12 @@
   : m_rlcSapUser (0),
     m_macSapProvider (0),
     m_rnti (0),
-    m_lcid (0)
+    m_lcid (0),
+    isMc(false) // TODO refactor this!!
 {
   NS_LOG_FUNCTION (this);
   m_rlcSapProvider = new LteRlcSpecificLteRlcSapProvider<LteRlc> (this);
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlc> (this);
   m_macSapUser = new LteRlcSpecificLteMacSapUser (this);
 }
 
@@ -115,6 +109,10 @@
                      "PDU received.",
                      MakeTraceSourceAccessor (&LteRlc::m_rxPdu),
                      "ns3::LteRlc::ReceiveTracedCallback")
+   .AddTraceSource ("TxCompletedCallback",
+                     "PDU acked.",
+                     MakeTraceSourceAccessor (&LteRlc::m_txCompletedCallback),
+                     "ns3::LteRlc::RetransmissionCountCallback")
     ;
   return tid;
 }
@@ -169,7 +167,30 @@
   return m_macSapUser;
 }
 
+void
+LteRlc::DoNotifyHarqDeliveryFailure (uint8_t harqId)
+{
+	NS_LOG_FUNCTION (this);
+}
 
+void
+LteRlc::SetUeDataParams(EpcX2Sap::UeDataParams params)
+{
+  isMc = true;
+  m_ueDataParams = params;
+}
+
+void 
+LteRlc::SetEpcX2RlcProvider (EpcX2RlcProvider * s)
+{
+  m_epcX2RlcProvider = s;
+}
+
+EpcX2RlcUser* 
+LteRlc::GetEpcX2RlcUser ()
+{
+  return m_epcX2RlcUser;
+}
 
 ////////////////////////////////////////
 
@@ -217,15 +238,16 @@
 }
 
 void
-LteRlcSm::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
+LteRlcSm::DoReceivePdu (Ptr<Packet> p)
 {
   NS_LOG_FUNCTION (this << p);
   // RLC Performance evaluation
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
-  p->RemovePacketTag (rlcTag);
-  delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag(rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
   NS_LOG_LOGIC (" RNTI=" << m_rnti 
                 << " LCID=" << (uint32_t) m_lcid 
                 << " size=" << p->GetSize () 
@@ -234,7 +256,7 @@
 }
 
 void
-LteRlcSm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
+LteRlcSm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId)
 {
   NS_LOG_FUNCTION (this << bytes);
   LteMacSapProvider::TransmitPduParameters params;
@@ -243,11 +265,10 @@
   params.lcid = m_lcid;
   params.layer = layer;
   params.harqProcessId = harqId;
-  params.componentCarrierId = componentCarrierId;
 
   // RLC Performance evaluation
   RlcTag tag (Simulator::Now());
-  params.pdu->AddPacketTag (tag);
+  params.pdu->AddByteTag (tag);
   NS_LOG_LOGIC (" RNTI=" << m_rnti 
                 << " LCID=" << (uint32_t) m_lcid 
                 << " size=" << bytes);
@@ -270,7 +291,7 @@
   LteMacSapProvider::ReportBufferStatusParameters p;
   p.rnti = m_rnti;
   p.lcid = m_lcid;
-  p.txQueueSize = 80000;
+  p.txQueueSize = 1000000;  // mmWave module: Arbitrarily changed full-buffer BSR to report 1MB available each subframe
   p.txQueueHolDelay = 10;
   p.retxQueueSize = 0;
   p.retxQueueHolDelay = 0;
@@ -278,6 +299,13 @@
   m_macSapProvider->ReportBufferStatus (p);
 }
 
+void 
+LteRlcSm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  NS_FATAL_ERROR("Not supported");
+}
+
 
 
 
diff -Naru a/model/lte-rlc.h b/model/lte-rlc.h
--- a/model/lte-rlc.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RLC_H
@@ -27,6 +31,7 @@
 #include "ns3/traced-value.h"
 #include "ns3/trace-source-accessor.h"
 #include "ns3/nstime.h"
+#include <ns3/epc-x2-sap.h>
 
 #include "ns3/object.h"
 
@@ -42,24 +47,39 @@
 // class LteMacSapProvider;
 // class LteMacSapUser;
 
+class LteRlc;
+
+class LteRlcSpecificLteMacSapUser : public LteMacSapUser
+{
+
+public:
+  LteRlcSpecificLteMacSapUser (LteRlc* rlc);
+
+  // Interface implemented from LteMacSapUser
+  virtual void NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId);
+  virtual void NotifyHarqDeliveryFailure ();
+  virtual void NotifyHarqDeliveryFailure (uint8_t harqId);
+  virtual void ReceivePdu (Ptr<Packet> p);
+
+private:
+  LteRlcSpecificLteMacSapUser ();
+  LteRlc* m_rlc;
+};
+
+
 /**
  * This abstract base class defines the API to interact with the Radio Link Control
  * (LTE_RLC) in LTE, see 3GPP TS 36.322
  *
  */
-class LteRlc : public Object // SimpleRefCount<LteRlc>
+class LteRlc : public Object 
 {
-  /// allow LteRlcSpecificLteMacSapUser class friend access
   friend class LteRlcSpecificLteMacSapUser;
-  /// allow LteRlcSpecificLteRlcSapProvider<LteRlc> class friend access
+  friend class EpcX2RlcSpecificUser<LteRlc>;
   friend class LteRlcSpecificLteRlcSapProvider<LteRlc>;
 public:
   LteRlc ();
   virtual ~LteRlc ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
@@ -92,6 +112,22 @@
   LteRlcSapProvider* GetLteRlcSapProvider ();
 
   /**
+   * Set the param needed for X2 tunneling
+   * \param the UeDataParams defined in RRC
+   */
+  void SetUeDataParams(EpcX2Sap::UeDataParams params);
+
+  /**
+   * \param s the EpcX2Rlc Provider to the Epc X2 interface
+   */
+  void SetEpcX2RlcProvider (EpcX2RlcProvider * s);
+
+  /**
+   * \return the EpcX2Rlc User, given to X2 to access Rlc SendMcPdcpPdu method
+   */
+  EpcX2RlcUser* GetEpcX2RlcUser ();
+
+  /**
    *
    *
    * \param s the MAC SAP Provider to be used by this LTE_RLC
@@ -129,51 +165,41 @@
   typedef void (* ReceiveTracedCallback)
     (uint16_t rnti, uint8_t lcid, uint32_t bytes, uint64_t delay);
 
+  /**
+   * TracedCallback signature for
+   *
+   * \param [in] rnti C-RNTI scheduled.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] bytes The packet size.
+   * \param [in] the number of RLC AM retransmissions for that packet
+   */
+  typedef void (* RetransmissionCountCallback)
+    (uint16_t rnti, uint8_t lcid, uint32_t bytes, uint32_t numRetx);
+
   /// \todo MRE What is the sense to duplicate all the interfaces here???
   // NB to avoid the use of multiple inheritance
   
 protected:
   // Interface forwarded by LteRlcSapProvider
-  /**
-   * Transmit PDCP PDU
-   * 
-   * \param p packet
-   */
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p) = 0;
 
-  LteRlcSapUser* m_rlcSapUser; ///< RLC SAP user
-  LteRlcSapProvider* m_rlcSapProvider; ///< RLC SAP provider
+  LteRlcSapUser* m_rlcSapUser;
+  LteRlcSapProvider* m_rlcSapProvider;
 
   // Interface forwarded by LteMacSapUser
-  /**
-   * Notify transmit opportunity
-   *
-   * \param bytes number of bytes
-   * \param layer the layer
-   * \param harqId the HARQ ID
-   * \param componentCarrierId component carrier ID
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */ 
-  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid) = 0;
-  /**
-   * Notify HARQ delivery failure
-   */ 
+  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId) = 0;
   virtual void DoNotifyHarqDeliveryFailure () = 0;
-  /**
-   * Receive PDU function
-   *
-   * \param p the packet
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */ 
-  virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid) = 0;
+  virtual void DoNotifyHarqDeliveryFailure (uint8_t harqId);
+  virtual void DoReceivePdu (Ptr<Packet> p) = 0;
 
-  LteMacSapUser* m_macSapUser; ///< MAC SAP user
-  LteMacSapProvider* m_macSapProvider; ///< MAC SAP provider
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params) = 0;
 
-  uint16_t m_rnti; ///< RNTI
-  uint8_t m_lcid; ///< LCID
+  LteMacSapUser* m_macSapUser;
+  LteMacSapProvider* m_macSapProvider;
+
+  uint16_t m_rnti;
+  uint8_t m_lcid;
 
   /**
    * Used to inform of a PDU delivery to the MAC SAP provider
@@ -184,6 +210,15 @@
    */
   TracedCallback<uint16_t, uint8_t, uint32_t, uint64_t> m_rxPdu;
 
+  TracedCallback<uint16_t, uint8_t, uint32_t, uint32_t> m_txCompletedCallback; // callback used to broadcast the number of retx for each RLC packet
+
+  // MC functionalities
+  // UeDataParams needed to forward data to MmWave
+  EpcX2Sap::UeDataParams m_ueDataParams;
+  bool isMc;
+  EpcX2RlcProvider* m_epcX2RlcProvider;
+  EpcX2RlcUser* m_epcX2RlcUser;
+
 };
 
 
@@ -201,23 +236,19 @@
 public:
   LteRlcSm ();
   virtual ~LteRlcSm ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual void DoInitialize ();
   virtual void DoDispose ();
 
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
-  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
+  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId);
   virtual void DoNotifyHarqDeliveryFailure ();
-  virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
+  virtual void DoReceivePdu (Ptr<Packet> p);
+  virtual void DoSendMcPdcpSdu (EpcX2Sap::UeDataParams params);
 
 
 
 private:
-  /// Report buffer status
   void ReportBufferStatus ();
 
 };
diff -Naru a/model/lte-rlc-sequence-number.h b/model/lte-rlc-sequence-number.h
--- a/model/lte-rlc-sequence-number.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc-sequence-number.h	2017-10-05 11:47:22.310601768 +0200
@@ -156,9 +156,9 @@
   bool operator > (const SequenceNumber10 &other) const
   {
     NS_ASSERT (m_modulusBase == other.m_modulusBase);
-    uint16_t v1 = (m_value - m_modulusBase) % 1024;
-    uint16_t v2 = (other.m_value - other.m_modulusBase) % 1024;
-    return v1 > v2;
+    SequenceNumber10 v1 ((m_value - m_modulusBase) % 1024);
+    SequenceNumber10 v2 ((other.m_value - other.m_modulusBase) % 1024);
+    return ( v1.GetValue () > v2.GetValue () );
   }
 
   /**
diff -Naru a/model/lte-rlc-tm.cc b/model/lte-rlc-tm.cc
--- a/model/lte-rlc-tm.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc-tm.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011,2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/simulator.h"
@@ -105,13 +109,19 @@
   m_rbsTimer.Cancel ();
 }
 
+void 
+LteRlcTm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  DoTransmitPdcpPdu(params.ueData);
+}
 
 /**
  * MAC SAP
  */
 
 void
-LteRlcTm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
+LteRlcTm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId)
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << bytes  << (uint32_t) layer << (uint32_t) harqId);
 
@@ -140,7 +150,7 @@
  
   // Sender timestamp
   RlcTag rlcTag (Simulator::Now ());
-  packet->ReplacePacketTag (rlcTag);
+  packet->AddByteTag (rlcTag);
   m_txPdu (m_rnti, m_lcid, packet->GetSize ());
 
   // Send RLC PDU to MAC layer
@@ -150,7 +160,6 @@
   params.lcid = m_lcid;
   params.layer = layer;
   params.harqProcessId = harqId;
-  params.componentCarrierId = componentCarrierId;
 
   m_macSapProvider->TransmitPdu (params);
 
@@ -168,16 +177,17 @@
 }
 
 void
-LteRlcTm::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
+LteRlcTm::DoReceivePdu (Ptr<Packet> p)
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
 
   // Receiver timestamp
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
-  p->RemovePacketTag (rlcTag);
-  delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag (rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
   m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
 
   // 5.1.1.2 Receive operations 
@@ -198,7 +208,6 @@
   if (! m_txBuffer.empty ())
     {
       RlcTag holTimeTag;
-      NS_ASSERT_MSG (m_txBuffer.front ()->PeekPacketTag (holTimeTag), "RlcTag is missing");
       m_txBuffer.front ()->PeekPacketTag (holTimeTag);
       holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
 
@@ -214,6 +223,20 @@
   r.retxQueueHolDelay = 0;
   r.statusPduSize = 0;
 
+  // from UM low lat
+  for (unsigned i = 0; i < m_txBuffer.size(); i++)
+  {
+    if (i == 20)  // only include up to the first 20 packets
+    {
+      break;
+    }
+    r.txPacketSizes.push_back (m_txBuffer[i]->GetSize ());
+    RlcTag holTimeTag;
+    m_txBuffer[i]->PeekPacketTag (holTimeTag);
+    holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+    r.txPacketDelays.push_back (holDelay.GetMicroSeconds ());
+  }
+
   NS_LOG_LOGIC ("Send ReportBufferStatus = " << r.txQueueSize << ", " << r.txQueueHolDelay );
   m_macSapProvider->ReportBufferStatus (r);
 }
diff -Naru a/model/lte-rlc-tm.h b/model/lte-rlc-tm.h
--- a/model/lte-rlc-tm.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc-tm.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011,2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Manuel Requena <manuel.requena@cttc.es> 
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RLC_TM_H
@@ -37,49 +41,33 @@
 public:
   LteRlcTm ();
   virtual ~LteRlcTm ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
   /**
    * RLC SAP
-   *
-   * \param p packet
    */
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
 
   /**
    * MAC SAP
-   * 
-   * \param bytes number of bytes
-   * \param layer the layer
-   * \param harqId HARQ ID
-   * \param componentCarrierId component carrier ID
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */
-  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
-  /**
-   * Notify HARQ deliver failure
    */
+  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId);
   virtual void DoNotifyHarqDeliveryFailure ();
-  virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
+  virtual void DoReceivePdu (Ptr<Packet> p);
+
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
 
 private:
-  /// Expire RBS timer function
   void ExpireRbsTimer (void);
-  /// Report buffer status
   void DoReportBufferStatus ();
 
 private:
-  uint32_t m_maxTxBufferSize; ///< maximum transmit buffer size
-  uint32_t m_txBufferSize; ///< transmit buffer size
-  std::vector < Ptr<Packet> > m_txBuffer; ///< Transmission buffer
+  uint32_t m_maxTxBufferSize;
+  uint32_t m_txBufferSize;
+  std::vector < Ptr<Packet> > m_txBuffer;       // Transmission buffer
 
-  EventId m_rbsTimer; ///< RBS timer
+  EventId m_rbsTimer;
 
 };
 
diff -Naru a/model/lte-rlc-um.cc b/model/lte-rlc-um.cc
--- a/model/lte-rlc-um.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc-um.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/simulator.h"
@@ -44,6 +48,8 @@
 {
   NS_LOG_FUNCTION (this);
   m_reassemblingState = WAITING_S0_FULL;
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlcUm> (this);
+  m_epcX2RlcProvider = 0;
 }
 
 LteRlcUm::~LteRlcUm ()
@@ -77,6 +83,12 @@
   LteRlc::DoDispose ();
 }
 
+uint32_t
+LteRlcUm::GetMaxBuff()
+{
+  return m_maxTxBufferSize;
+}
+
 /**
  * RLC SAP
  */
@@ -118,13 +130,19 @@
   m_rbsTimer.Cancel ();
 }
 
+void 
+LteRlcUm::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  DoTransmitPdcpPdu(params.ueData);
+}
 
 /**
  * MAC SAP
  */
 
 void
-LteRlcUm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
+LteRlcUm::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId)
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << bytes);
 
@@ -331,8 +349,7 @@
 
   // FIRST SEGMENT
   LteRlcSduStatusTag tag;
-  NS_ASSERT_MSG ((*it)->PeekPacketTag (tag), "LteRlcSduStatusTag is missing");
-  (*it)->PeekPacketTag (tag);
+  (*it)->RemovePacketTag (tag);
   if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
         (tag.GetStatus () == LteRlcSduStatusTag::FIRST_SEGMENT) )
     {
@@ -342,26 +359,19 @@
     {
       framingInfo |= LteRlcHeader::NO_FIRST_BYTE;
     }
+  (*it)->AddPacketTag (tag);
 
   while (it < dataField.end ())
     {
       NS_LOG_LOGIC ("Adding SDU/segment to packet, length = " << (*it)->GetSize ());
 
-      NS_ASSERT_MSG ((*it)->PeekPacketTag (tag), "LteRlcSduStatusTag is missing");
-      (*it)->RemovePacketTag (tag);
-      if (packet->GetSize () > 0)
-        {
-          packet->AddAtEnd (*it);
-        }
-      else
-        {
-          packet = (*it);
-        }
+      packet->AddAtEnd (*it);
       it++;
     }
 
   // LAST SEGMENT (Note: There could be only one and be the first one)
   it--;
+  (*it)->RemovePacketTag (tag);
   if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
         (tag.GetStatus () == LteRlcSduStatusTag::LAST_SEGMENT) )
     {
@@ -371,6 +381,7 @@
     {
       framingInfo |= LteRlcHeader::NO_LAST_BYTE;
     }
+  (*it)->AddPacketTag (tag);
 
   rlcHeader.SetFramingInfo (framingInfo);
 
@@ -379,7 +390,7 @@
 
   // Sender timestamp
   RlcTag rlcTag (Simulator::Now ());
-  packet->ReplacePacketTag (rlcTag);
+  packet->AddByteTag (rlcTag);
   m_txPdu (m_rnti, m_lcid, packet->GetSize ());
 
   // Send RLC PDU to MAC layer
@@ -389,7 +400,6 @@
   params.lcid = m_lcid;
   params.layer = layer;
   params.harqProcessId = harqId;
-  params.componentCarrierId = componentCarrierId;
 
   m_macSapProvider->TransmitPdu (params);
 
@@ -406,17 +416,24 @@
   NS_LOG_FUNCTION (this);
 }
 
+std::vector < Ptr<Packet> > 
+LteRlcUm::GetTxBuffer()
+{
+  return m_txBuffer;
+}
+
 void
-LteRlcUm::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
+LteRlcUm::DoReceivePdu (Ptr<Packet> p)
 {
   NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
 
   // Receiver timestamp
   RlcTag rlcTag;
   Time delay;
-  NS_ASSERT_MSG (p->PeekPacketTag (rlcTag), "RlcTag is missing");
-  p->RemovePacketTag (rlcTag);
-  delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+  if (p->FindFirstMatchingByteTag (rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
   m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
 
   // 5.1.2.2 Receive operations
@@ -671,7 +688,7 @@
                               */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -684,7 +701,7 @@
                               */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -708,7 +725,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -735,7 +752,7 @@
                                    */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -767,14 +784,14 @@
                               */
                               m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                               m_sdusBuffer.pop_front ();
-                              m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                              TriggerReceivePdcpPdu (m_keepS0);
 
                               /**
                                 * Deliver zero, one or multiple PDUs
                                 */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -797,14 +814,14 @@
                                   */
                                   m_keepS0->AddAtEnd (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
-                                  m_rlcSapUser->ReceivePdcpPdu (m_keepS0);
+                                  TriggerReceivePdcpPdu (m_keepS0);
 
                                   /**
                                   * Deliver zero, one or multiple PDUs
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -847,7 +864,7 @@
                                */
                               for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (*it);
+                                  TriggerReceivePdcpPdu (*it);
                                 }
                               m_sdusBuffer.clear ();
                       break;
@@ -860,7 +877,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -884,7 +901,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -911,7 +928,7 @@
                                   */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -948,7 +965,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -966,7 +983,7 @@
                                */
                               while ( m_sdusBuffer.size () > 1 )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
 
@@ -996,7 +1013,7 @@
                                */
                               while ( ! m_sdusBuffer.empty () )
                                 {
-                                  m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                   m_sdusBuffer.pop_front ();
                                 }
                       break;
@@ -1028,7 +1045,7 @@
                                    */
                                   while ( m_sdusBuffer.size () > 1 )
                                     {
-                                      m_rlcSapUser->ReceivePdcpPdu (m_sdusBuffer.front ());
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
                                       m_sdusBuffer.pop_front ();
                                     }
 
@@ -1057,6 +1074,22 @@
 
 }
 
+void
+LteRlcUm::TriggerReceivePdcpPdu(Ptr<Packet> p)
+{
+  if(!isMc) 
+  {
+    NS_LOG_INFO(this << " RlcUm forwards packet to PDCP (either from MmWave or LTE stack)");
+    m_rlcSapUser->ReceivePdcpPdu(p);
+  }
+  else
+  {
+    NS_LOG_INFO(this << " MmWave Rlc Um forwards packet to remote PDCP");
+    m_ueDataParams.ueData = p;
+    m_epcX2RlcProvider->ReceiveMcPdcpSdu(m_ueDataParams);
+  }
+}
+
 
 void
 LteRlcUm::ReassembleOutsideWindow (void)
@@ -1124,7 +1157,6 @@
   if (! m_txBuffer.empty ())
     {
       RlcTag holTimeTag;
-      NS_ASSERT_MSG (m_txBuffer.front ()->PeekPacketTag (holTimeTag), "RlcTag is missing");
       m_txBuffer.front ()->PeekPacketTag (holTimeTag);
       holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
 
diff -Naru a/model/lte-rlc-um.h b/model/lte-rlc-um.h
--- a/model/lte-rlc-um.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rlc-um.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_RLC_UM_H
@@ -23,6 +27,7 @@
 
 #include "ns3/lte-rlc-sequence-number.h"
 #include "ns3/lte-rlc.h"
+#include <ns3/epc-x2-sap.h>
 
 #include <ns3/event-id.h>
 #include <map>
@@ -37,96 +42,76 @@
 public:
   LteRlcUm ();
   virtual ~LteRlcUm ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
+  uint32_t GetMaxBuff();
+
   /**
    * RLC SAP
-   *
-   * \param p packet
    */
   virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
 
   /**
+   * RLC EPC X2 SAP
+   */
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
+
+  /**
    * MAC SAP
-   *
-   * \param bytes the number of bytes
-   * \param layer the layer
-   * \param harqId the HARQ ID
-   * \param componentCarrierId component carrier ID
-   * \param rnti the RNTI
-   * \param lcid the LCID
    */
-  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
+  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId);
   virtual void DoNotifyHarqDeliveryFailure ();
-  virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
+  virtual void DoReceivePdu (Ptr<Packet> p);
+
+  std::vector < Ptr<Packet> > GetTxBuffer();
+  uint32_t GetTxBufferSize()
+  {
+    return m_txBufferSize;
+  }
 
 private:
-  /// Expire reordering timer
   void ExpireReorderingTimer (void);
-  /// Expire RBS timer
   void ExpireRbsTimer (void);
 
-  /**
-   * Is inside reordering window function
-   *
-   * \param seqNumber the sequence number
-   * \returns true if inside the window
-   */
   bool IsInsideReorderingWindow (SequenceNumber10 seqNumber);
 
-  /// Reassemble outside window
   void ReassembleOutsideWindow (void);
-  /**
-   * Reassemble SN interval function
-   *
-   * \param lowSeqNumber the low sequence number
-   * \param highSeqNumber the high sequence number
-   */
   void ReassembleSnInterval (SequenceNumber10 lowSeqNumber, SequenceNumber10 highSeqNumber);
 
-  /**
-   * Reassemble and deliver function
-   *
-   * \param packet the packet
-   */
   void ReassembleAndDeliver (Ptr<Packet> packet);
+  void TriggerReceivePdcpPdu(Ptr<Packet> p);
 
-  /// Report buffer status
   void DoReportBufferStatus ();
 
 private:
-  uint32_t m_maxTxBufferSize; ///< maximum transmit buffer status
-  uint32_t m_txBufferSize; ///< transmit buffer size
-  std::vector < Ptr<Packet> > m_txBuffer;       ///< Transmission buffer
-  std::map <uint16_t, Ptr<Packet> > m_rxBuffer; ///< Reception buffer
-  std::vector < Ptr<Packet> > m_reasBuffer;     ///< Reassembling buffer
+  uint32_t m_maxTxBufferSize;
+  uint32_t m_txBufferSize;
+  std::vector < Ptr<Packet> > m_txBuffer;       // Transmission buffer
+  std::map <uint16_t, Ptr<Packet> > m_rxBuffer; // Reception buffer
+  std::vector < Ptr<Packet> > m_reasBuffer;     // Reassembling buffer
 
-  std::list < Ptr<Packet> > m_sdusBuffer;       ///< List of SDUs in a packet
+  std::list < Ptr<Packet> > m_sdusBuffer;       // List of SDUs in a packet
 
   /**
    * State variables. See section 7.1 in TS 36.322
    */
-  SequenceNumber10 m_sequenceNumber; ///< VT(US)
+  SequenceNumber10 m_sequenceNumber; // VT(US)
 
-  SequenceNumber10 m_vrUr;           ///< VR(UR)
-  SequenceNumber10 m_vrUx;           ///< VR(UX)
-  SequenceNumber10 m_vrUh;           ///< VR(UH)
+  SequenceNumber10 m_vrUr;           // VR(UR)
+  SequenceNumber10 m_vrUx;           // VR(UX)
+  SequenceNumber10 m_vrUh;           // VR(UH)
 
   /**
    * Constants. See section 7.2 in TS 36.322
    */
-  uint16_t m_windowSize; ///< windows size
+  uint16_t m_windowSize;
 
   /**
    * Timers. See section 7.3 in TS 36.322
    */
-  EventId m_reorderingTimer; ///< reordering timer
-  EventId m_rbsTimer; ///< RBS timer
+  EventId m_reorderingTimer;
+  EventId m_rbsTimer;
 
   /**
    * Reassembling state
@@ -134,14 +119,13 @@
   typedef enum { NONE            = 0,
                  WAITING_S0_FULL = 1,
                  WAITING_SI_SF   = 2 } ReassemblingState_t;
-  ReassemblingState_t m_reassemblingState; ///< reassembling state
-  Ptr<Packet> m_keepS0; ///< keep S0
+  ReassemblingState_t m_reassemblingState;
+  Ptr<Packet> m_keepS0;
 
   /**
    * Expected Sequence Number
    */
   SequenceNumber10 m_expectedSeqNumber;
-
 };
 
 
diff -Naru a/model/lte-rlc-um-lowlat.cc b/model/lte-rlc-um-lowlat.cc
--- a/model/lte-rlc-um-lowlat.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/lte-rlc-um-lowlat.cc	2017-10-05 11:47:22.310601768 +0200
@@ -0,0 +1,1292 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017, NYU WIRELESS, Tandon School of Engineering, New York University
+ * Copyright (c) 2017, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by:  Russell Ford
+ *                  Low lat 
+ *               Michele Polese <michele.polese@gmail.com>
+ *                  Dual Connectivity functionalities
+ */
+
+#include "lte-rlc-um-lowlat.h"
+
+#include "ns3/simulator.h"
+#include "ns3/log.h"
+
+#include "ns3/lte-rlc-header.h"
+#include "ns3/lte-rlc-sdu-status-tag.h"
+#include "ns3/lte-rlc-tag.h"
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("LteRlcUmLowLat");
+
+NS_OBJECT_ENSURE_REGISTERED (LteRlcUmLowLat);
+
+uint32_t LteRlcUmLowLat::m_numArrivalsToAvg = 20;
+
+LteRlcUmLowLat::LteRlcUmLowLat ()
+  : m_maxTxBufferSize (10 * 1024),
+    m_txBufferSize (0),
+    m_sequenceNumber (0),
+    m_vrUr (0),
+    m_vrUx (0),
+    m_vrUh (0),
+    m_windowSize (512),
+    m_expectedSeqNumber (0),
+		m_currTotalPacketSize (0),
+		//m_lastArrivalTime (0),
+		m_arrivalRate (0.0),
+    m_bsrReported(false)
+		//m_forgetFactor (0.1)
+{
+  NS_LOG_FUNCTION (this);
+  m_reassemblingState = WAITING_S0_FULL;
+  m_epcX2RlcUser = new EpcX2RlcSpecificUser<LteRlcUmLowLat> (this);
+  m_epcX2RlcProvider = 0;
+
+}
+
+LteRlcUmLowLat::~LteRlcUmLowLat ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+LteRlcUmLowLat::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::LteRlcUmLowLat")
+    .SetParent<LteRlc> ()
+    .SetGroupName("Lte")
+    .AddConstructor<LteRlcUmLowLat> ()
+    .AddAttribute ("MaxTxBufferSize",
+                   "Maximum Size of the Transmission Buffer (in Bytes)",
+                   UintegerValue (10 * 1024),
+                   MakeUintegerAccessor (&LteRlcUmLowLat::m_maxTxBufferSize),
+                   MakeUintegerChecker<uint32_t> ())
+	 .AddAttribute ("ReportBufferStatusTimer",
+									"How much to wait to issue a new Report Buffer Status since the last time "
+									"a new SDU was received",
+									TimeValue (MilliSeconds (20)),
+									MakeTimeAccessor (&LteRlcUmLowLat::m_rbsTimerValue),
+									MakeTimeChecker ())
+	 .AddAttribute ("ReorderingTimeExpires",
+									"Time to wait for out of order PDUs"
+									"a new SDU was received",
+									TimeValue (MilliSeconds (100.0)),
+									MakeTimeAccessor (&LteRlcUmLowLat::m_reorderingTimeExpires),
+									MakeTimeChecker ())
+    ;
+  return tid;
+}
+
+void
+LteRlcUmLowLat::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  m_reorderingTimer.Cancel ();
+  m_rbsTimer.Cancel ();
+
+  LteRlc::DoDispose ();
+}
+
+/**
+ * RLC SAP
+ */
+
+void
+LteRlcUmLowLat::DoTransmitPdcpPdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  if (m_txBufferSize + p->GetSize () <= m_maxTxBufferSize)
+    {
+      /** Store arrival time */
+      RlcTag timeTag (Simulator::Now ());
+      p->AddPacketTag (timeTag);
+
+      /** Store PDCP PDU */
+
+      LteRlcSduStatusTag tag;
+      tag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+      p->AddPacketTag (tag);
+
+      NS_LOG_LOGIC ("Tx Buffer: New packet added");
+      m_txBuffer.push_back (p);
+      m_txBufferSize += p->GetSize ();
+      NS_LOG_LOGIC ("NumOfBuffers = " << m_txBuffer.size() );
+      NS_LOG_LOGIC ("txBufferSize = " << m_txBufferSize);
+
+      if (m_recentArrivalTimes.size () == m_numArrivalsToAvg)
+      {
+      	m_recentArrivalTimes.pop_front ();
+      	m_currTotalPacketSize -= m_recentPacketSizes.front ();
+      	m_recentPacketSizes.pop_front ();
+      }
+      m_recentArrivalTimes.push_back ((uint32_t)timeTag.GetSenderTimestamp ().GetMicroSeconds ());
+      m_recentPacketSizes.push_back (p->GetSize ());
+      m_currTotalPacketSize += p->GetSize ();
+      double timeDiff = (m_recentArrivalTimes.back () - m_recentArrivalTimes.front ()) * 1e-6;
+      //m_arrivalRate = (1 - m_forgetFactor) * (p->GetSize () / timeDiff) + m_forgetFactor * m_arrivalRate;
+      m_arrivalRate = m_currTotalPacketSize / timeDiff;
+    }
+  else
+    {
+      // Discard full RLC SDU
+      NS_LOG_LOGIC ("TxBuffer is full. RLC SDU discarded");
+      NS_LOG_LOGIC ("MaxTxBufferSize = " << m_maxTxBufferSize);
+      NS_LOG_LOGIC ("txBufferSize    = " << m_txBufferSize);
+      NS_LOG_LOGIC ("packet size     = " << p->GetSize ());
+    }
+
+  /** Report Buffer Status */
+  DoReportBufferStatus ();
+  m_bsrReported = true;
+  m_rbsTimer.Cancel ();
+  m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcUmLowLat::ExpireRbsTimer, this);
+}
+
+void 
+LteRlcUmLowLat::DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this);
+  DoTransmitPdcpPdu(params.ueData);
+}
+
+/**
+ * MAC SAP
+ */
+
+void
+LteRlcUmLowLat::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << bytes);
+
+  if (bytes <= 2)
+    {
+      // Stingy MAC: Header fix part is 2 bytes, we need more bytes for the data
+      NS_LOG_LOGIC ("TX opportunity too small = " << bytes);
+      return;
+    }
+
+  if (bytes > m_txBufferSize)
+   {
+     NS_LOG_DEBUG("LteRlcUmLowLat rnti " << m_rnti << " lcid " << m_lcid << " allocated " << bytes << " bufsize " << m_txBufferSize);
+   }
+
+  Ptr<Packet> packet = Create<Packet> ();
+  LteRlcHeader rlcHeader;
+
+  // Build Data field
+  uint32_t nextSegmentSize = bytes - 2;
+  uint32_t nextSegmentId = 1;
+  uint32_t dataFieldTotalSize = 0;
+  uint32_t dataFieldAddedSize = 0;
+  std::vector < Ptr<Packet> > dataField;
+
+  // Remove the first packet from the transmission buffer.
+  // If only a segment of the packet is taken, then the remaining is given back later
+  if ( m_txBuffer.size () == 0 )
+    {
+      NS_LOG_LOGIC ("No data pending");
+      return;
+    }
+
+  NS_LOG_LOGIC ("SDUs in TxBuffer  = " << m_txBuffer.size ());
+  NS_LOG_LOGIC ("First SDU buffer  = " << *(m_txBuffer.begin()));
+  NS_LOG_LOGIC ("First SDU size    = " << (*(m_txBuffer.begin()))->GetSize ());
+  NS_LOG_LOGIC ("Next segment size = " << nextSegmentSize);
+  NS_LOG_LOGIC ("Remove SDU from TxBuffer");
+  Ptr<Packet> firstSegment = (*(m_txBuffer.begin ()))->Copy ();
+  m_txBufferSize -= (*(m_txBuffer.begin()))->GetSize ();
+  NS_LOG_LOGIC ("txBufferSize      = " << m_txBufferSize );
+  m_txBuffer.erase (m_txBuffer.begin ());
+
+  while ( firstSegment && (firstSegment->GetSize () > 0) && (nextSegmentSize > 0) )
+    {
+      NS_LOG_LOGIC ("WHILE ( firstSegment && firstSegment->GetSize > 0 && nextSegmentSize > 0 )");
+      NS_LOG_LOGIC ("    firstSegment size = " << firstSegment->GetSize ());
+      NS_LOG_LOGIC ("    nextSegmentSize   = " << nextSegmentSize);
+      if ( (firstSegment->GetSize () > nextSegmentSize) ||
+           // Segment larger than 2047 octets can only be mapped to the end of the Data field
+           (firstSegment->GetSize () > 2047)
+         )
+        {
+          // Take the minimum size, due to the 2047-bytes 3GPP exception
+          // This exception is due to the length of the LI field (just 11 bits)
+          uint32_t currSegmentSize = std::min (firstSegment->GetSize (), nextSegmentSize);
+
+          NS_LOG_LOGIC ("    IF ( firstSegment > nextSegmentSize ||");
+          NS_LOG_LOGIC ("         firstSegment > 2047 )");
+
+          // Segment txBuffer.FirstBuffer and
+          // Give back the remaining segment to the transmission buffer
+          Ptr<Packet> newSegment = firstSegment->CreateFragment (0, currSegmentSize);
+          NS_LOG_LOGIC ("    newSegment size   = " << newSegment->GetSize ());
+
+          // Status tag of the new and remaining segments
+          // Note: This is the only place where a PDU is segmented and
+          // therefore its status can change
+          LteRlcSduStatusTag oldTag, newTag;
+          firstSegment->RemovePacketTag (oldTag);
+          newSegment->RemovePacketTag (newTag);
+          if (oldTag.GetStatus () == LteRlcSduStatusTag::FULL_SDU)
+            {
+              newTag.SetStatus (LteRlcSduStatusTag::FIRST_SEGMENT);
+              oldTag.SetStatus (LteRlcSduStatusTag::LAST_SEGMENT);
+            }
+          else if (oldTag.GetStatus () == LteRlcSduStatusTag::LAST_SEGMENT)
+            {
+              newTag.SetStatus (LteRlcSduStatusTag::MIDDLE_SEGMENT);
+              //oldTag.SetStatus (LteRlcSduStatusTag::LAST_SEGMENT);
+            }
+
+          // Give back the remaining segment to the transmission buffer
+          firstSegment->RemoveAtStart (currSegmentSize);
+          NS_LOG_LOGIC ("    firstSegment size (after RemoveAtStart) = " << firstSegment->GetSize ());
+          if (firstSegment->GetSize () > 0)
+            {
+              firstSegment->AddPacketTag (oldTag);
+
+              m_txBuffer.insert (m_txBuffer.begin (), firstSegment);
+              m_txBufferSize += (*(m_txBuffer.begin()))->GetSize ();
+
+              NS_LOG_LOGIC ("    TX buffer: Give back the remaining segment");
+              NS_LOG_LOGIC ("    TX buffers = " << m_txBuffer.size ());
+              NS_LOG_LOGIC ("    Front buffer size = " << (*(m_txBuffer.begin()))->GetSize ());
+              NS_LOG_LOGIC ("    txBufferSize = " << m_txBufferSize );
+            }
+          else
+            {
+              // Whole segment was taken, so adjust tag
+              if (newTag.GetStatus () == LteRlcSduStatusTag::FIRST_SEGMENT)
+                {
+                  newTag.SetStatus (LteRlcSduStatusTag::FULL_SDU);
+                }
+              else if (newTag.GetStatus () == LteRlcSduStatusTag::MIDDLE_SEGMENT)
+                {
+                  newTag.SetStatus (LteRlcSduStatusTag::LAST_SEGMENT);
+                }
+            }
+          // Segment is completely taken or
+          // the remaining segment is given back to the transmission buffer
+          firstSegment = 0;
+
+          // Put status tag once it has been adjusted
+          newSegment->AddPacketTag (newTag);
+
+          // Add Segment to Data field
+          dataFieldAddedSize = newSegment->GetSize ();
+          dataFieldTotalSize += dataFieldAddedSize;
+          dataField.push_back (newSegment);
+          newSegment = 0;
+
+          // ExtensionBit (Next_Segment - 1) = 0
+          rlcHeader.PushExtensionBit (LteRlcHeader::DATA_FIELD_FOLLOWS);
+
+          // no LengthIndicator for the last one
+
+          nextSegmentSize -= dataFieldAddedSize;
+          nextSegmentId++;
+
+          // nextSegmentSize MUST be zero (only if segment is smaller or equal to 2047)
+
+          // (NO more segments) → exit
+          // break;
+        }
+      else if ( (nextSegmentSize - firstSegment->GetSize () <= 2) || (m_txBuffer.size () == 0) )
+        {
+          NS_LOG_LOGIC ("    IF nextSegmentSize - firstSegment->GetSize () <= 2 || txBuffer.size == 0");
+          // Add txBuffer.FirstBuffer to DataField
+          dataFieldAddedSize = firstSegment->GetSize ();
+          dataFieldTotalSize += dataFieldAddedSize;
+          dataField.push_back (firstSegment);
+          firstSegment = 0;
+
+          // ExtensionBit (Next_Segment - 1) = 0
+          rlcHeader.PushExtensionBit (LteRlcHeader::DATA_FIELD_FOLLOWS);
+
+          // no LengthIndicator for the last one
+
+          nextSegmentSize -= dataFieldAddedSize;
+          nextSegmentId++;
+
+          NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txBuffer.size ());
+          if (m_txBuffer.size () > 0)
+            {
+              NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txBuffer.begin()));
+              NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txBuffer.begin()))->GetSize ());
+            }
+          NS_LOG_LOGIC ("        Next segment size = " << nextSegmentSize);
+
+          // nextSegmentSize <= 2 (only if txBuffer is not empty)
+
+          // (NO more segments) → exit
+          // break;
+        }
+      else // (firstSegment->GetSize () < m_nextSegmentSize) && (m_txBuffer.size () > 0)
+        {
+          NS_LOG_LOGIC ("    IF firstSegment < NextSegmentSize && txBuffer.size > 0");
+          // Add txBuffer.FirstBuffer to DataField
+          dataFieldAddedSize = firstSegment->GetSize ();
+          dataFieldTotalSize += dataFieldAddedSize;
+          dataField.push_back (firstSegment);
+
+          // ExtensionBit (Next_Segment - 1) = 1
+          rlcHeader.PushExtensionBit (LteRlcHeader::E_LI_FIELDS_FOLLOWS);
+
+          // LengthIndicator (Next_Segment)  = txBuffer.FirstBuffer.length()
+          rlcHeader.PushLengthIndicator (firstSegment->GetSize ());
+
+          nextSegmentSize -= ((nextSegmentId % 2) ? (2) : (1)) + dataFieldAddedSize;
+          nextSegmentId++;
+
+          NS_LOG_LOGIC ("        SDUs in TxBuffer  = " << m_txBuffer.size ());
+          if (m_txBuffer.size () > 0)
+            {
+              NS_LOG_LOGIC ("        First SDU buffer  = " << *(m_txBuffer.begin()));
+              NS_LOG_LOGIC ("        First SDU size    = " << (*(m_txBuffer.begin()))->GetSize ());
+            }
+          NS_LOG_LOGIC ("        Next segment size = " << nextSegmentSize);
+          NS_LOG_LOGIC ("        Remove SDU from TxBuffer");
+
+          // (more segments)
+          firstSegment = (*(m_txBuffer.begin ()))->Copy ();
+          m_txBufferSize -= (*(m_txBuffer.begin()))->GetSize ();
+          m_txBuffer.erase (m_txBuffer.begin ());
+          NS_LOG_LOGIC ("        txBufferSize = " << m_txBufferSize );
+        }
+
+    }
+
+  // Build RLC header
+  rlcHeader.SetSequenceNumber (m_sequenceNumber++);
+
+  // Build RLC PDU with DataField and Header
+  std::vector< Ptr<Packet> >::iterator it;
+  it = dataField.begin ();
+
+  uint8_t framingInfo = 0;
+
+  // FIRST SEGMENT
+  LteRlcSduStatusTag tag;
+  (*it)->RemovePacketTag (tag);
+  if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
+        (tag.GetStatus () == LteRlcSduStatusTag::FIRST_SEGMENT) )
+    {
+      framingInfo |= LteRlcHeader::FIRST_BYTE;
+    }
+  else
+    {
+      framingInfo |= LteRlcHeader::NO_FIRST_BYTE;
+    }
+  (*it)->AddPacketTag (tag);
+
+  while (it < dataField.end ())
+    {
+      NS_LOG_LOGIC ("Adding SDU/segment to packet, length = " << (*it)->GetSize ());
+
+      packet->AddAtEnd (*it);
+      it++;
+    }
+
+  // LAST SEGMENT (Note: There could be only one and be the first one)
+  it--;
+  (*it)->RemovePacketTag (tag);
+  if ( (tag.GetStatus () == LteRlcSduStatusTag::FULL_SDU) ||
+        (tag.GetStatus () == LteRlcSduStatusTag::LAST_SEGMENT) )
+    {
+      framingInfo |= LteRlcHeader::LAST_BYTE;
+    }
+  else
+    {
+      framingInfo |= LteRlcHeader::NO_LAST_BYTE;
+    }
+  (*it)->AddPacketTag (tag);
+
+  rlcHeader.SetFramingInfo (framingInfo);
+
+  NS_LOG_LOGIC ("RLC header: " << rlcHeader);
+  packet->AddHeader (rlcHeader);
+
+  // Sender timestamp
+  RlcTag rlcTag (Simulator::Now ());
+  packet->AddByteTag (rlcTag);
+  m_txPdu (m_rnti, m_lcid, packet->GetSize ());
+
+  // Send RLC PDU to MAC layer
+  LteMacSapProvider::TransmitPduParameters params;
+  params.pdu = packet;
+  params.rnti = m_rnti;
+  params.lcid = m_lcid;
+  params.layer = layer;
+  params.harqProcessId = harqId;
+
+  m_macSapProvider->TransmitPdu (params);
+
+  if (! m_txBuffer.empty ())
+    {
+      m_rbsTimer.Cancel ();
+      m_rbsTimer = Simulator::Schedule (m_rbsTimerValue, &LteRlcUmLowLat::ExpireRbsTimer, this);
+    }
+
+  m_bsrReported = false;
+
+  DoReportBufferStatus ();
+}
+
+void
+LteRlcUmLowLat::DoNotifyHarqDeliveryFailure ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+std::vector < Ptr<Packet> > 
+LteRlcUmLowLat::GetTxBuffer()
+{
+  return m_txBuffer;
+}
+
+void
+LteRlcUmLowLat::DoReceivePdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  // Receiver timestamp
+  RlcTag rlcTag;
+  Time delay;
+  if (p->FindFirstMatchingByteTag (rlcTag))
+    {
+      delay = Simulator::Now() - rlcTag.GetSenderTimestamp ();
+    }
+  m_rxPdu (m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
+
+  // 5.1.2.2 Receive operations
+
+  // Get RLC header parameters
+  LteRlcHeader rlcHeader;
+  p->PeekHeader (rlcHeader);
+  NS_LOG_LOGIC ("RLC header: " << rlcHeader);
+  SequenceNumber10 seqNumber = rlcHeader.GetSequenceNumber ();
+
+  // 5.1.2.2.1 General
+  // The receiving UM RLC entity shall maintain a reordering window according to state variable VR(UH) as follows:
+  // - a SN falls within the reordering window if (VR(UH) - UM_Window_Size) <= SN < VR(UH);
+  // - a SN falls outside of the reordering window otherwise.
+  // When receiving an UMD PDU from lower layer, the receiving UM RLC entity shall:
+  // - either discard the received UMD PDU or place it in the reception buffer (see sub clause 5.1.2.2.2);
+  // - if the received UMD PDU was placed in the reception buffer:
+  // - update state variables, reassemble and deliver RLC SDUs to upper layer and start/stop t-Reordering as needed (see sub clause 5.1.2.2.3);
+  // When t-Reordering expires, the receiving UM RLC entity shall:
+  // - update state variables, reassemble and deliver RLC SDUs to upper layer and start t-Reordering as needed (see sub clause 5.1.2.2.4).
+
+  // 5.1.2.2.2 Actions when an UMD PDU is received from lower layer
+  // When an UMD PDU with SN = x is received from lower layer, the receiving UM RLC entity shall:
+  // - if VR(UR) < x < VR(UH) and the UMD PDU with SN = x has been received before; or
+  // - if (VR(UH) - UM_Window_Size) <= x < VR(UR):
+  //    - discard the received UMD PDU;
+  // - else:
+  //    - place the received UMD PDU in the reception buffer.
+
+  NS_LOG_LOGIC ("VR(UR) = " << m_vrUr);
+  NS_LOG_LOGIC ("VR(UX) = " << m_vrUx);
+  NS_LOG_LOGIC ("VR(UH) = " << m_vrUh);
+  NS_LOG_LOGIC ("SN = " << seqNumber);
+
+  m_vrUr.SetModulusBase (m_vrUh - m_windowSize);
+  m_vrUh.SetModulusBase (m_vrUh - m_windowSize);
+  seqNumber.SetModulusBase (m_vrUh - m_windowSize);
+
+  if ( ( (m_vrUr < seqNumber) && (seqNumber < m_vrUh) && (m_rxBuffer.count (seqNumber.GetValue ()) > 0) ) ||
+       ( ((m_vrUh - m_windowSize) <= seqNumber) && (seqNumber < m_vrUr) )
+     )
+    {
+      NS_LOG_LOGIC ("PDU discarded");
+      p = 0;
+      return;
+    }
+  else
+    {
+      NS_LOG_LOGIC ("Place PDU in the reception buffer");
+      m_rxBuffer[seqNumber.GetValue ()] = p;
+    }
+
+
+  // 5.1.2.2.3 Actions when an UMD PDU is placed in the reception buffer
+  // When an UMD PDU with SN = x is placed in the reception buffer, the receiving UM RLC entity shall:
+
+  // - if x falls outside of the reordering window:
+  //    - update VR(UH) to x + 1;
+  //    - reassemble RLC SDUs from any UMD PDUs with SN that falls outside of the reordering window, remove
+  //      RLC headers when doing so and deliver the reassembled RLC SDUs to upper layer in ascending order of the
+  //      RLC SN if not delivered before;
+  //    - if VR(UR) falls outside of the reordering window:
+  //        - set VR(UR) to (VR(UH) - UM_Window_Size);
+
+  if ( ! IsInsideReorderingWindow (seqNumber))
+    {
+      NS_LOG_LOGIC ("SN is outside the reordering window");
+
+      m_vrUh = seqNumber + 1;
+      NS_LOG_LOGIC ("New VR(UH) = " << m_vrUh);
+
+      ReassembleOutsideWindow ();
+
+      if ( ! IsInsideReorderingWindow (m_vrUr) )
+        {
+          m_vrUr = m_vrUh - m_windowSize;
+          NS_LOG_LOGIC ("VR(UR) is outside the reordering window");
+          NS_LOG_LOGIC ("New VR(UR) = " << m_vrUr);
+        }
+    }
+
+  // - if the reception buffer contains an UMD PDU with SN = VR(UR):
+  //    - update VR(UR) to the SN of the first UMD PDU with SN > current VR(UR) that has not been received;
+  //    - reassemble RLC SDUs from any UMD PDUs with SN < updated VR(UR), remove RLC headers when doing
+  //      so and deliver the reassembled RLC SDUs to upper layer in ascending order of the RLC SN if not delivered
+  //      before;
+
+  if ( m_rxBuffer.count (m_vrUr.GetValue ()) > 0 )
+    {
+      NS_LOG_LOGIC ("Reception buffer contains SN = " << m_vrUr);
+
+      std::map <uint16_t, Ptr<Packet> >::iterator it;
+      uint16_t newVrUr;
+      SequenceNumber10 oldVrUr = m_vrUr;
+
+      it = m_rxBuffer.find (m_vrUr.GetValue ());
+      newVrUr = (it->first) + 1;
+      while ( m_rxBuffer.count (newVrUr) > 0 )
+        {
+          newVrUr++;
+        }
+      m_vrUr = newVrUr;
+      NS_LOG_LOGIC ("New VR(UR) = " << m_vrUr);
+
+      ReassembleSnInterval (oldVrUr, m_vrUr);
+    }
+
+  // m_vrUh can change previously, set new modulus base
+  // for the t-Reordering timer-related comparisons
+  m_vrUr.SetModulusBase (m_vrUh - m_windowSize);
+  m_vrUx.SetModulusBase (m_vrUh - m_windowSize);
+  m_vrUh.SetModulusBase (m_vrUh - m_windowSize);
+
+  // - if t-Reordering is running:
+  //    - if VR(UX) <= VR(UR); or
+  //    - if VR(UX) falls outside of the reordering window and VR(UX) is not equal to VR(UH)::
+  //        - stop and reset t-Reordering;
+  if ( m_reorderingTimer.IsRunning () )
+    {
+      NS_LOG_LOGIC ("Reordering timer is running");
+
+      if ( (m_vrUx <= m_vrUr) ||
+           ((! IsInsideReorderingWindow (m_vrUx)) && (m_vrUx != m_vrUh)) )
+        {
+          NS_LOG_LOGIC ("Stop reordering timer");
+          m_reorderingTimer.Cancel ();
+        }
+    }
+
+  // - if t-Reordering is not running (includes the case when t-Reordering is stopped due to actions above):
+  //    - if VR(UH) > VR(UR):
+  //        - start t-Reordering;
+  //        - set VR(UX) to VR(UH).
+  if ( ! m_reorderingTimer.IsRunning () )
+    {
+      NS_LOG_LOGIC ("Reordering timer is not running");
+
+      if ( m_vrUh > m_vrUr )
+        {
+          NS_LOG_LOGIC ("VR(UH) > VR(UR)");
+          NS_LOG_LOGIC ("Start reordering timer");
+          m_reorderingTimer = Simulator::Schedule (m_reorderingTimeExpires,
+                                                   &LteRlcUmLowLat::ExpireReorderingTimer ,this);
+          m_vrUx = m_vrUh;
+          NS_LOG_LOGIC ("New VR(UX) = " << m_vrUx);
+        }
+    }
+
+}
+
+
+bool
+LteRlcUmLowLat::IsInsideReorderingWindow (SequenceNumber10 seqNumber)
+{
+  NS_LOG_FUNCTION (this << seqNumber);
+  NS_LOG_LOGIC ("Reordering Window: " <<
+                m_vrUh << " - " << m_windowSize << " <= " << seqNumber << " < " << m_vrUh);
+
+  m_vrUh.SetModulusBase (m_vrUh - m_windowSize);
+  seqNumber.SetModulusBase (m_vrUh - m_windowSize);
+
+  if ( ((m_vrUh - m_windowSize) <= seqNumber) && (seqNumber < m_vrUh))
+    {
+      NS_LOG_LOGIC (seqNumber << " is INSIDE the reordering window");
+      return true;
+    }
+  else
+    {
+      NS_LOG_LOGIC (seqNumber << " is OUTSIDE the reordering window");
+      return false;
+    }
+}
+
+
+void
+LteRlcUmLowLat::ReassembleAndDeliver (Ptr<Packet> packet)
+{
+  LteRlcHeader rlcHeader;
+  packet->RemoveHeader (rlcHeader);
+  uint8_t framingInfo = rlcHeader.GetFramingInfo ();
+  SequenceNumber10 currSeqNumber = rlcHeader.GetSequenceNumber ();
+  bool expectedSnLost;
+
+  if ( currSeqNumber != m_expectedSeqNumber )
+    {
+      expectedSnLost = true;
+      NS_LOG_LOGIC ("There are losses. Expected SN = " << m_expectedSeqNumber << ". Current SN = " << currSeqNumber);
+      m_expectedSeqNumber = currSeqNumber + 1;
+    }
+  else
+    {
+      expectedSnLost = false;
+      NS_LOG_LOGIC ("No losses. Expected SN = " << m_expectedSeqNumber << ". Current SN = " << currSeqNumber);
+      m_expectedSeqNumber++;
+    }
+
+  // Build list of SDUs
+  uint8_t extensionBit;
+  uint16_t lengthIndicator;
+  do
+    {
+      extensionBit = rlcHeader.PopExtensionBit ();
+      NS_LOG_LOGIC ("E = " << (uint16_t)extensionBit);
+
+      if ( extensionBit == 0 )
+        {
+          m_sdusBuffer.push_back (packet);
+        }
+      else // extensionBit == 1
+        {
+          lengthIndicator = rlcHeader.PopLengthIndicator ();
+          NS_LOG_LOGIC ("LI = " << lengthIndicator);
+
+          // Check if there is enough data in the packet
+          if ( lengthIndicator >= packet->GetSize () )
+            {
+              NS_LOG_LOGIC ("INTERNAL ERROR: Not enough data in the packet (" << packet->GetSize () << "). Needed LI=" << lengthIndicator);
+            }
+
+          // Split packet in two fragments
+          Ptr<Packet> data_field = packet->CreateFragment (0, lengthIndicator);
+          packet->RemoveAtStart (lengthIndicator);
+
+          m_sdusBuffer.push_back (data_field);
+        }
+    }
+  while ( extensionBit == 1 );
+
+  std::list < Ptr<Packet> >::iterator it;
+
+  // Current reassembling state
+  if      (m_reassemblingState == WAITING_S0_FULL)  NS_LOG_LOGIC ("Reassembling State = 'WAITING_S0_FULL'");
+  else if (m_reassemblingState == WAITING_SI_SF)    NS_LOG_LOGIC ("Reassembling State = 'WAITING_SI_SF'");
+  else                                              NS_LOG_LOGIC ("Reassembling State = Unknown state");
+
+  // Received framing Info
+  NS_LOG_LOGIC ("Framing Info = " << (uint16_t)framingInfo);
+
+  // Reassemble the list of SDUs (when there is no losses)
+  if (!expectedSnLost)
+    {
+      switch (m_reassemblingState)
+        {
+          case WAITING_S0_FULL:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                              * Deliver one or multiple PDUs
+                              */
+                              for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
+                                {
+                                  TriggerReceivePdcpPdu (*it);
+                                }
+                              m_sdusBuffer.clear ();
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                              * Deliver full PDUs
+                              */
+                              while ( m_sdusBuffer.size () > 1 )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+
+                              /**
+                              * Keep S0
+                              */
+                              m_keepS0 = m_sdusBuffer.front ();
+                              m_sdusBuffer.pop_front ();
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_reassemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_reassemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              if ( m_sdusBuffer.size () > 0 )
+                                {
+                                  /**
+                                   * Deliver zero, one or multiple PDUs
+                                   */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                   * Keep S0
+                                   */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                              * ERROR: Transition not possible
+                              */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                              * Deliver (Kept)S0 + SN
+                              */
+                              m_keepS0->AddAtEnd (m_sdusBuffer.front ());
+                              m_sdusBuffer.pop_front ();
+                              TriggerReceivePdcpPdu (m_keepS0);
+
+                              /**
+                                * Deliver zero, one or multiple PDUs
+                                */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                              * Keep SI
+                              */
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_keepS0->AddAtEnd (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                              else // m_sdusBuffer.size () > 1
+                                {
+                                  /**
+                                  * Deliver (Kept)S0 + SN
+                                  */
+                                  m_keepS0->AddAtEnd (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                  TriggerReceivePdcpPdu (m_keepS0);
+
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_reassemblingState);
+          break;
+        }
+    }
+  else // Reassemble the list of SDUs (when there are losses, i.e. the received SN is not the expected one)
+    {
+      switch (m_reassemblingState)
+        {
+          case WAITING_S0_FULL:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              for ( it = m_sdusBuffer.begin () ; it != m_sdusBuffer.end () ; it++ )
+                                {
+                                  TriggerReceivePdcpPdu (*it);
+                                }
+                              m_sdusBuffer.clear ();
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                               * Deliver full PDUs
+                               */
+                              while ( m_sdusBuffer.size () > 1 )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0 = m_sdusBuffer.front ();
+                              m_sdusBuffer.pop_front ();
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_reassemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_reassemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              if ( m_sdusBuffer.size () > 0 )
+                                {
+                                  /**
+                                  * Deliver zero, one or multiple PDUs
+                                  */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                  * Keep S0
+                                  */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                               * ERROR: Transition not possible
+                               */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          case WAITING_SI_SF:
+                  switch (framingInfo)
+                    {
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Deliver one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              m_reassemblingState = WAITING_SI_SF;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( m_sdusBuffer.size () > 1 )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+
+                              /**
+                               * Keep S0
+                               */
+                              m_keepS0 = m_sdusBuffer.front ();
+                              m_sdusBuffer.pop_front ();
+
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::LAST_BYTE):
+                              m_reassemblingState = WAITING_S0_FULL;
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              /**
+                               * Deliver zero, one or multiple PDUs
+                               */
+                              while ( ! m_sdusBuffer.empty () )
+                                {
+                                  TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      case (LteRlcHeader::NO_FIRST_BYTE | LteRlcHeader::NO_LAST_BYTE):
+                              if ( m_sdusBuffer.size () == 1 )
+                                {
+                                  m_reassemblingState = WAITING_S0_FULL;
+                                }
+                              else
+                                {
+                                  m_reassemblingState = WAITING_SI_SF;
+                                }
+
+                              /**
+                               * Discard S0
+                               */
+                              m_keepS0 = 0;
+
+                              /**
+                               * Discard SI or SN
+                               */
+                              m_sdusBuffer.pop_front ();
+
+                              if ( m_sdusBuffer.size () > 0 )
+                                {
+                                  /**
+                                   * Deliver zero, one or multiple PDUs
+                                   */
+                                  while ( m_sdusBuffer.size () > 1 )
+                                    {
+                                      TriggerReceivePdcpPdu (m_sdusBuffer.front ());
+                                      m_sdusBuffer.pop_front ();
+                                    }
+
+                                  /**
+                                   * Keep S0
+                                   */
+                                  m_keepS0 = m_sdusBuffer.front ();
+                                  m_sdusBuffer.pop_front ();
+                                }
+                      break;
+
+                      default:
+                              /**
+                                * ERROR: Transition not possible
+                                */
+                              NS_LOG_LOGIC ("INTERNAL ERROR: Transition not possible. FI = " << (uint32_t) framingInfo);
+                      break;
+                    }
+          break;
+
+          default:
+                NS_LOG_LOGIC ("INTERNAL ERROR: Wrong reassembling state = " << (uint32_t) m_reassemblingState);
+          break;
+        }
+    }
+
+}
+
+
+void
+LteRlcUmLowLat::ReassembleOutsideWindow (void)
+{
+  NS_LOG_LOGIC ("Reassemble Outside Window");
+
+  std::map <uint16_t, Ptr<Packet> >::iterator it;
+  it = m_rxBuffer.begin ();
+
+  while ( (it != m_rxBuffer.end ()) && ! IsInsideReorderingWindow (SequenceNumber10 (it->first)) )
+    {
+      NS_LOG_LOGIC ("SN = " << it->first);
+
+      // Reassemble RLC SDUs and deliver the PDCP PDU to upper layer
+      ReassembleAndDeliver (it->second);
+
+      std::map <uint16_t, Ptr<Packet> >::iterator it_tmp = it;
+      ++it;
+      m_rxBuffer.erase (it_tmp);
+    }
+
+  if (it != m_rxBuffer.end ())
+    {
+      NS_LOG_LOGIC ("(SN = " << it->first << ") is inside the reordering window");
+    }
+}
+
+void
+LteRlcUmLowLat::ReassembleSnInterval (SequenceNumber10 lowSeqNumber, SequenceNumber10 highSeqNumber)
+{
+  NS_LOG_LOGIC ("Reassemble SN between " << lowSeqNumber << " and " << highSeqNumber);
+
+  std::map <uint16_t, Ptr<Packet> >::iterator it;
+
+  SequenceNumber10 reassembleSn = lowSeqNumber;
+  NS_LOG_LOGIC ("reassembleSN = " << reassembleSn);
+  NS_LOG_LOGIC ("highSeqNumber = " << highSeqNumber);
+  while (reassembleSn < highSeqNumber)
+    {
+      NS_LOG_LOGIC ("reassembleSn < highSeqNumber");
+      it = m_rxBuffer.find (reassembleSn.GetValue ());
+      NS_LOG_LOGIC ("it->first  = " << it->first);
+      NS_LOG_LOGIC ("it->second = " << it->second);
+      if (it != m_rxBuffer.end () )
+        {
+          NS_LOG_LOGIC ("SN = " << it->first);
+
+          // Reassemble RLC SDUs and deliver the PDCP PDU to upper layer
+          ReassembleAndDeliver (it->second);
+
+          m_rxBuffer.erase (it);
+        }
+        
+      reassembleSn++;
+    }
+}
+
+
+void
+LteRlcUmLowLat::DoReportBufferStatus (void)
+{
+  if(!m_bsrReported)
+  {
+    Time holDelay (0);
+    uint32_t queueSize = 0;
+
+    if (! m_txBuffer.empty ())
+      {
+        RlcTag holTimeTag;
+        m_txBuffer.front ()->PeekPacketTag (holTimeTag);
+        holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+
+        queueSize = m_txBufferSize + 2 * m_txBuffer.size (); // Data in tx queue + estimated headers size
+      }
+
+    LteMacSapProvider::ReportBufferStatusParameters r;
+    r.rnti = m_rnti;
+    r.lcid = m_lcid;
+    r.txQueueSize = queueSize;
+    r.txQueueHolDelay = holDelay.GetMicroSeconds () ;
+    r.retxQueueSize = 0;
+    r.retxQueueHolDelay = 0;
+    r.statusPduSize = 0;
+
+    for (unsigned i = 0; i < m_txBuffer.size(); i++)
+    {
+      if (i == 20)  // only include up to the first 20 packets
+      {
+        break;
+      }
+      r.txPacketSizes.push_back (m_txBuffer[i]->GetSize ());
+      RlcTag holTimeTag;
+      m_txBuffer[i]->PeekPacketTag (holTimeTag);
+      holDelay = Simulator::Now () - holTimeTag.GetSenderTimestamp ();
+      r.txPacketDelays.push_back (holDelay.GetMicroSeconds ());
+    }
+
+    r.arrivalRate = m_arrivalRate;
+
+    NS_LOG_INFO ("Send ReportBufferStatus = " << r.txQueueSize << ", " << r.txQueueHolDelay << ", " << r.txPacketSizes.size());
+    m_macSapProvider->ReportBufferStatus (r);
+  }
+}
+
+
+void
+LteRlcUmLowLat::ExpireReorderingTimer (void)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid);
+  NS_LOG_LOGIC ("Reordering timer has expired");
+
+  // 5.1.2.2.4 Actions when t-Reordering expires
+  // When t-Reordering expires, the receiving UM RLC entity shall:
+  // - update VR(UR) to the SN of the first UMD PDU with SN >= VR(UX) that has not been received;
+  // - reassemble RLC SDUs from any UMD PDUs with SN < updated VR(UR), remove RLC headers when doing so
+  //   and deliver the reassembled RLC SDUs to upper layer in ascending order of the RLC SN if not delivered before;
+  // - if VR(UH) > VR(UR):
+  //    - start t-Reordering;
+  //    - set VR(UX) to VR(UH).
+
+  std::map <uint16_t, Ptr<Packet> >::iterator it;
+  SequenceNumber10 newVrUr = m_vrUx;
+
+  while ( (it = m_rxBuffer.find (newVrUr.GetValue ())) != m_rxBuffer.end () )
+    {
+      newVrUr++;
+    }
+  SequenceNumber10 oldVrUr = m_vrUr;
+  m_vrUr = newVrUr;
+  NS_LOG_LOGIC ("New VR(UR) = " << m_vrUr);
+
+  ReassembleSnInterval (oldVrUr, m_vrUr);
+
+  if ( m_vrUh > m_vrUr)
+    {
+      NS_LOG_LOGIC ("Start reordering timer");
+      m_reorderingTimer = Simulator::Schedule (m_reorderingTimeExpires,
+                                               &LteRlcUmLowLat::ExpireReorderingTimer, this);
+      m_vrUx = m_vrUh;
+      NS_LOG_LOGIC ("New VR(UX) = " << m_vrUx);
+    }
+}
+
+
+void
+LteRlcUmLowLat::ExpireRbsTimer (void)
+{
+  NS_LOG_LOGIC ("RBS Timer expires");
+
+  if (! m_txBuffer.empty ())
+    {
+      DoReportBufferStatus ();
+      m_rbsTimer = Simulator::Schedule (MilliSeconds (10), &LteRlcUmLowLat::ExpireRbsTimer, this);
+    }
+}
+
+
+void
+LteRlcUmLowLat::TriggerReceivePdcpPdu(Ptr<Packet> p)
+{
+  if(!isMc) 
+  {
+    NS_LOG_INFO(this << " RlcUmLowLat forwards packet to PDCP (either from MmWave or LTE stack)");
+    m_rlcSapUser->ReceivePdcpPdu(p);
+  }
+  else
+  {
+    NS_LOG_INFO(this << " MmWave Rlc Um LowLat forwards packet to remote PDCP");
+    m_ueDataParams.ueData = p;
+    m_epcX2RlcProvider->ReceiveMcPdcpSdu(m_ueDataParams);
+  }
+}
+
+} // namespace ns3
diff -Naru a/model/lte-rlc-um-lowlat.h b/model/lte-rlc-um-lowlat.h
--- a/model/lte-rlc-um-lowlat.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/lte-rlc-um-lowlat.h	2017-10-05 11:47:22.310601768 +0200
@@ -0,0 +1,149 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2017, NYU WIRELESS, Tandon School of Engineering, New York University
+ * Copyright (c) 2017, University of Padova, Dep. of Information Engineering, SIGNET lab
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ *
+ * Modified by:  Russell Ford
+ *                  Low lat
+ *               Michele Polese <michele.polese@gmail.com>
+ *                  Dual Connectivity functionalities
+ */
+
+#ifndef LTE_RLC_UM_LOWLAT_H
+#define LTE_RLC_UM_LOWLAT_H
+
+#include "ns3/lte-rlc-sequence-number.h"
+#include "ns3/lte-rlc.h"
+#include <ns3/epc-x2-sap.h>
+ 
+#include <ns3/event-id.h>
+#include <map>
+#include <deque>
+
+namespace ns3 {
+
+/**
+ * LTE RLC Unacknowledged Mode (UM), see 3GPP TS 36.322
+ */
+class LteRlcUmLowLat : public LteRlc
+{
+public:
+  LteRlcUmLowLat ();
+  virtual ~LteRlcUmLowLat ();
+  static TypeId GetTypeId (void);
+  virtual void DoDispose ();
+
+  /**
+   * RLC SAP
+   */
+  virtual void DoTransmitPdcpPdu (Ptr<Packet> p);
+
+  /**
+   * RLC EPC X2 SAP
+   */
+  virtual void DoSendMcPdcpSdu(EpcX2Sap::UeDataParams params);
+
+  /**
+   * MAC SAP
+   */
+  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId);
+  virtual void DoNotifyHarqDeliveryFailure ();
+  virtual void DoReceivePdu (Ptr<Packet> p);
+
+  std::vector < Ptr<Packet> > GetTxBuffer();
+  uint32_t GetTxBufferSize()
+  {
+    return m_txBufferSize;
+  }
+
+private:
+  void ExpireReorderingTimer (void);
+  void ExpireRbsTimer (void);
+
+  bool IsInsideReorderingWindow (SequenceNumber10 seqNumber);
+
+  void ReassembleOutsideWindow (void);
+  void ReassembleSnInterval (SequenceNumber10 lowSeqNumber, SequenceNumber10 highSeqNumber);
+
+  void ReassembleAndDeliver (Ptr<Packet> packet);
+  void TriggerReceivePdcpPdu(Ptr<Packet> p);
+
+  void DoReportBufferStatus ();
+
+private:
+  uint32_t m_maxTxBufferSize;
+  uint32_t m_txBufferSize;
+  std::vector < Ptr<Packet> > m_txBuffer;       // Transmission buffer
+  std::map <uint16_t, Ptr<Packet> > m_rxBuffer; // Reception buffer
+  std::vector < Ptr<Packet> > m_reasBuffer;     // Reassembling buffer
+
+  std::list < Ptr<Packet> > m_sdusBuffer;       // List of SDUs in a packet
+
+  /**
+   * State variables. See section 7.1 in TS 36.322
+   */
+  SequenceNumber10 m_sequenceNumber; // VT(US)
+
+  SequenceNumber10 m_vrUr;           // VR(UR)
+  SequenceNumber10 m_vrUx;           // VR(UX)
+  SequenceNumber10 m_vrUh;           // VR(UH)
+
+  /**
+   * Constants. See section 7.2 in TS 36.322
+   */
+  uint16_t m_windowSize;
+
+  /**
+   * Timers. See section 7.3 in TS 36.322
+   */
+  EventId m_reorderingTimer;
+  EventId m_rbsTimer;
+  Time    m_rbsTimerValue;
+
+  /**
+   * Reassembling state
+   */
+  typedef enum { NONE            = 0,
+                 WAITING_S0_FULL = 1,
+                 WAITING_SI_SF   = 2 } ReassemblingState_t;
+  ReassemblingState_t m_reassemblingState;
+  Ptr<Packet> m_keepS0;
+
+  /**
+   * Expected Sequence Number
+   */
+  SequenceNumber10 m_expectedSeqNumber;
+
+  std::deque <uint32_t> m_recentArrivalTimes;
+  std::deque <uint32_t> m_recentPacketSizes;
+  uint32_t	m_currTotalPacketSize;
+  //uint64_t m_lastArrivalTime;
+  double m_arrivalRate;
+  static uint32_t m_numArrivalsToAvg;				// average last N arrivals
+  //double	m_forgetFactor;
+  Time m_reorderingTimeExpires;
+
+  bool m_bsrReported;
+
+};
+
+
+} // namespace ns3
+
+#endif // MMWAVE_RLC_UM_H
diff -Naru a/model/lte-rrc-header.cc b/model/lte-rrc-header.cc
--- a/model/lte-rrc-header.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rrc-header.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,9 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Lluis Parcerisa <lparcerisa@cttc.cat>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "ns3/log.h"
@@ -28,7 +29,7 @@
 #include <sstream>
 
 #define MAX_DRB 11 // According to section 6.4 3GPP TS 36.331
-#define MAX_EARFCN 262143
+#define MAX_EARFCN 65535
 #define MAX_RAT_CAPABILITIES 8
 #define MAX_SI_MESSAGE 32
 #define MAX_SIB 32
@@ -39,8 +40,6 @@
 #define MAX_CELL_MEAS 32
 #define MAX_CELL_REPORT 8
 
-#define MAX_SCELL_REPORT 5
-#define MAX_SCELL_CONF 5
 namespace ns3 {
 
 NS_LOG_COMPONENT_DEFINE ("RrcHeader");
@@ -157,6 +156,9 @@
 
       // Serialize logicalChannelConfig
       SerializeLogicalChannelConfig (it->logicalChannelConfig);
+
+      // MmWave MC functionalities: is_mc field
+      SerializeBoolean (it->is_mc);
     }
 }
 
@@ -635,12 +637,8 @@
       measResults.haveMeasResultNeighCells = false;
     }
 
-    std::bitset<4> measResultOptional;
-    measResultOptional.set (3,  measResults.haveScellsMeas);
-    measResultOptional.set (2, false); //LocationInfo-r10
-    measResultOptional.set (1, false); // MeasResultForECID-r9
-    measResultOptional.set (0, measResults.haveMeasResultNeighCells);
-    SerializeSequence(measResultOptional,true);
+  // Serialize MeasResults sequence, 1 optional value, extension marker present
+  SerializeSequence (std::bitset<1> (measResults.haveMeasResultNeighCells),true);
 
   // Serialize measId
   SerializeInteger (measResults.measId,1,MAX_MEAS_ID);
@@ -713,40 +711,6 @@
             }
         }
     }
-    if (measResults.haveScellsMeas)
-      {
-        // Serialize measResultNeighCells
-        SerializeSequenceOf (measResults.measScellResultList.measResultScell.size (),MAX_SCELL_REPORT,1);
-        // serialize MeasResultServFreqList-r10 elements in the list
-        std::list<LteRrcSap::MeasResultScell>::iterator it;
-        for (it = measResults.measScellResultList.measResultScell.begin (); it != measResults.measScellResultList.measResultScell.end (); it++)
-          {
-            // Serialize measId
-            SerializeInteger (it->servFreqId,0,MAX_MEAS_ID); // ToDo: change with FreqId, currently is the componentCarrierId
-             // Serialize MeasResultServFreqList
-            std::bitset<2> measResultScellPresent;
-            measResultScellPresent[0] = measResults.measScellResultList.haveMeasurementResultsServingSCells;
-            measResultScellPresent[1] = measResults.measScellResultList.haveMeasurementResultsNeighCell; // Not implemented
-            SerializeSequence (measResultScellPresent,true);
-
-            // Serialize measResult
-            std::bitset<2> measResultScellFieldsPresent;
-            measResultScellFieldsPresent[1] = it->haveRsrpResult;
-            measResultScellFieldsPresent[0] = it->haveRsrqResult;
-            SerializeSequence (measResultScellFieldsPresent,true);
-
-            if (it->haveRsrpResult)
-              {
-                SerializeInteger (it->rsrpResult,0,97);
-              }
-
-            if (it->haveRsrqResult)
-              {
-                SerializeInteger (it->rsrqResult,0,34);
-              }
-            
-          }
-      }
 }
 
 void
@@ -1712,281 +1676,6 @@
         }
     }
 }
-  void
-  RrcAsn1Header::SerializeNonCriticalExtensionConfiguration (LteRrcSap::NonCriticalExtensionConfiguration nonCriticalExtension) const
-  {
-    // 3 optional fields. Extension marker not present.
-    std::bitset<3> noncriticalExtension_v1020;
-    noncriticalExtension_v1020.set (2,0); // No sCellToRealeaseList-r10
-    noncriticalExtension_v1020.set (1,1); // sCellToAddModList-r10
-    noncriticalExtension_v1020.set (0,0); // No nonCriticalExtension RRCConnectionReconfiguration-v1130-IEs
-    SerializeSequence (noncriticalExtension_v1020,false);
-    if (!nonCriticalExtension.sCellsToAddModList.empty ())
-      {
-        SerializeSequenceOf (nonCriticalExtension.sCellsToAddModList.size (),MAX_OBJECT_ID,1);
-        for (std::list<LteRrcSap::SCellToAddMod>::iterator it = nonCriticalExtension.sCellsToAddModList.begin (); it != nonCriticalExtension.sCellsToAddModList.end (); it++)
-          {
-            std::bitset<4> sCellToAddMod_r10;
-            sCellToAddMod_r10.set (3,1); // sCellIndex
-            sCellToAddMod_r10.set (2,1); // CellIdentification
-            sCellToAddMod_r10.set (1,1); // RadioResourceConfigCommonSCell
-            sCellToAddMod_r10.set (0,it->haveRadioResourceConfigDedicatedSCell); // No nonCriticalExtension RRC
-            SerializeSequence (sCellToAddMod_r10, false);
-            SerializeInteger (it->sCellIndex,1,MAX_OBJECT_ID); //sCellIndex
-
-            // Serialize CellIdentification
-            std::bitset<2> cellIdentification_r10;
-            cellIdentification_r10.set(1,1); // phyCellId-r10
-            cellIdentification_r10.set(0,1); // dl-CarrierFreq-r10
-            SerializeSequence (cellIdentification_r10, false);
-
-            SerializeInteger (it->cellIdentification.physCellId,1,65536);
-            SerializeInteger (it->cellIdentification.dlCarrierFreq,1,MAX_EARFCN);
-            
-            //Serialize RadioResourceConfigCommonSCell
-            SerializeRadioResourceConfigCommonSCell (it->radioResourceConfigCommonSCell);
-            
-            if (it->haveRadioResourceConfigDedicatedSCell)
-              {
-                //Serialize RadioResourceConfigDedicatedSCell
-                SerializeRadioResourceDedicatedSCell (it->radioResourceConfigDedicateSCell);
-              }
-            
-          }
-      }
-    else
-      {
-        //        NS_ASSERT_MSG ( this << "NonCriticalExtension.sCellsToAddModList cannot be empty ", false);
-      }
-  
-  }
-  void
-  RrcAsn1Header::SerializeRadioResourceConfigCommonSCell (LteRrcSap::RadioResourceConfigCommonSCell rrccsc) const
-  {
-    // 2 optional fields. Extension marker not present.
-    std::bitset<2> radioResourceConfigCommonSCell_r10;
-    radioResourceConfigCommonSCell_r10.set (1,rrccsc.haveNonUlConfiguration); // NonUlConfiguration
-    radioResourceConfigCommonSCell_r10.set (0,rrccsc.haveUlConfiguration); // UlConfiguration
-    SerializeSequence (radioResourceConfigCommonSCell_r10,false);
-     
-    if (rrccsc.haveNonUlConfiguration)
-      {
-        // 5 optional fields. Extension marker not present.
-        std::bitset<5> nonUlConfiguration_r10;
-        nonUlConfiguration_r10.set (4,1); // Dl- bandwidth --> convert in enum
-        nonUlConfiguration_r10.set (3,1); // AntennaInfoCommon-r10
-        nonUlConfiguration_r10.set (2,0); // phich-Config-r10 Not Implemented
-        nonUlConfiguration_r10.set (1,1); // pdschConfigCommon
-        nonUlConfiguration_r10.set (0,0); // Tdd-Config-r10 Not Implemented
-        SerializeSequence (nonUlConfiguration_r10,false);
-
-        SerializeInteger (rrccsc.nonUlConfiguration.dlBandwidth,6,100); 
-        
-        std::bitset<1> antennaInfoCommon_r10;
-        antennaInfoCommon_r10.set (0,1);
-        SerializeSequence (antennaInfoCommon_r10,false);
-        SerializeInteger (rrccsc.nonUlConfiguration.antennaInfoCommon.antennaPortsCount,0,65536);
-        
-        std::bitset<2> pdschConfigCommon_r10;
-        pdschConfigCommon_r10.set (1,1);
-        pdschConfigCommon_r10.set (0,1);
-        SerializeSequence (pdschConfigCommon_r10,false);
-        
-        SerializeInteger (rrccsc.nonUlConfiguration.pdschConfigCommon.referenceSignalPower,-60,50);
-        SerializeInteger (rrccsc.nonUlConfiguration.pdschConfigCommon.pb,0,3); 
-        
-      }
-    if (rrccsc.haveUlConfiguration)
-      {
-        //Serialize Ul Configuration
-        // 7 optional fields. Extension marker present.
-        std::bitset<7> UlConfiguration_r10;
-        UlConfiguration_r10.set (6,1); // ul-Configuration-r10
-        UlConfiguration_r10.set (5,0); // p-Max-r10 Not Implemented
-        UlConfiguration_r10.set (4,1); // uplinkPowerControlCommonSCell-r10
-        UlConfiguration_r10.set (3,0); // soundingRS-UL-ConfigCommon-r10
-        UlConfiguration_r10.set (2,0); // ul-CyclicPrefixLength-r10
-        UlConfiguration_r10.set (1,1); // prach-ConfigSCell-r10
-        UlConfiguration_r10.set (0,0); // pusch-ConfigCommon-r10 Not Implemented
-        SerializeSequence (UlConfiguration_r10,true);
-
-        //Serialize ulFreqInfo
-         std::bitset<3> FreqInfo_r10;
-         FreqInfo_r10.set (2,1); // ulCarrierFreq
-         FreqInfo_r10.set (1,1); // UlBandwidth
-         FreqInfo_r10.set (0,0); // additionalSpectrumEmissionSCell-r10 Not Implemented
-         SerializeSequence (FreqInfo_r10,false);
-         
-         SerializeInteger (rrccsc.ulConfiguration.ulFreqInfo.ulCarrierFreq,0,MAX_EARFCN);
-         SerializeInteger (rrccsc.ulConfiguration.ulFreqInfo.ulBandwidth,6,100);
-
-         //Serialize UlPowerControllCommonSCell
-         std::bitset<2> UlPowerControlCommonSCell_r10;
-         UlPowerControlCommonSCell_r10.set (1,0); // p0-NominalPUSCH-r10 Not Implemented       
-         UlPowerControlCommonSCell_r10.set (0,1); // alpha
-         SerializeSequence (UlPowerControlCommonSCell_r10,false);
-         
-         SerializeInteger (rrccsc.ulConfiguration.ulPowerControlCommonSCell.alpha,0,65536);
-
-         //Serialize soundingRs-UlConfigCommon
-         //Not Implemented
-
-         //Serialize PrachConfigSCell
-         std::bitset<1> prachConfigSCell_r10;
-         prachConfigSCell_r10.set(0,1);
-         SerializeSequence(prachConfigSCell_r10,false);
-         SerializeInteger (rrccsc.ulConfiguration.prachConfigSCell.index,0,256);          
-      }
-
-     
-  }
-  void
-  RrcAsn1Header::SerializeRadioResourceDedicatedSCell (LteRrcSap::RadioResourceConfigDedicatedSCell rrcdsc) const
-  {
-    //Serialize RadioResourceConfigDedicatedSCell
-    std::bitset<1> RadioResourceConfigDedicatedSCell_r10;
-    RadioResourceConfigDedicatedSCell_r10.set (0,1);
-    SerializeSequence (RadioResourceConfigDedicatedSCell_r10,false);
-
-    LteRrcSap::PhysicalConfigDedicatedSCell pcdsc = rrcdsc.physicalConfigDedicatedSCell;
-    SerializePhysicalConfigDedicatedSCell (pcdsc);
-  }
-  
-  void
-  RrcAsn1Header::SerializePhysicalConfigDedicatedSCell (LteRrcSap::PhysicalConfigDedicatedSCell pcdsc) const
-  {
-    std::bitset<2> pcdscOpt;
-    pcdscOpt.set (1,pcdsc.haveNonUlConfiguration);
-    pcdscOpt.set (0,pcdsc.haveUlConfiguration);
-    SerializeSequence (pcdscOpt, true);
-
-    if (pcdsc.haveNonUlConfiguration)
-      {
-        //Serialize NonUl configuration
-        std::bitset<4> nulOpt;
-        nulOpt.set (3,pcdsc.haveAntennaInfoDedicated);
-        nulOpt.set (2,0);  // crossCarrierSchedulingConfig-r10 Not Implemented
-        nulOpt.set (1,0);  // csi-RS-Config-r10 Not Implemented
-        nulOpt.set (0, pcdsc.havePdschConfigDedicated); // pdsch-ConfigDedicated-r10
-        SerializeSequence (nulOpt,false);
-        
-        if (pcdsc.haveAntennaInfoDedicated)
-          {
-            // Serialize antennaInfo choice
-            // 2 options. Selected: 0 ("explicitValue" of type "AntennaInfoDedicated")
-            SerializeChoice (2,0,false);
-
-            // Serialize AntennaInfoDedicated sequence
-            // 1 optional parameter, not present. No extension marker.
-            SerializeSequence (std::bitset<1> (0),false);
-
-            // Serialize transmissionMode
-            // Assuming the value in the struct is the enum index
-            SerializeEnum (8,pcdsc.antennaInfo.transmissionMode);
-
-            // Serialize ue-TransmitAntennaSelection choice
-            SerializeChoice (2,0,false);
-
-            // Serialize release
-            SerializeNull ();
-          }
-        if (pcdsc.havePdschConfigDedicated)
-          {
-            // Serialize Pdsch-ConfigDedicated Sequence:
-            // 0 optional / default fields, no extension marker.
-            SerializeSequence (std::bitset<0> (),false);
-
-            // Serialize  p-a
-            // Assuming the value in the struct is the enum index
-            SerializeEnum (8,pcdsc.pdschConfigDedicated.pa);
-
-            // Serialize release
-            SerializeNull ();
-          }
-
-
-      }
-    if (pcdsc.haveUlConfiguration)
-      {
-        //Serialize Ul Configuration
-        std::bitset<7> ulOpt;
-        ulOpt.set (6, pcdsc.haveAntennaInfoUlDedicated);// antennaInfoUL-r10
-        ulOpt.set (5,0); // pusch-ConfigDedicatedSCell-r10 not present 
-        ulOpt.set (4,0); // uplinkPowerControlDedicatedSCell-r10 not present
-        ulOpt.set (3,0); // cqi-ReportConfigSCell-r10 not present
-        ulOpt.set (2,pcdsc.haveSoundingRsUlConfigDedicated);// soundingRS-UL-ConfigDedicated-r10
-        ulOpt.set (1,0);  // soundingRS-UL-ConfigDedicated-v1020 not present
-        ulOpt.set (0,0); // soundingRS-UL-ConfigDedicatedAperiodic-r10 not present
-        SerializeSequence (ulOpt,false);
-        
-        if (pcdsc.haveAntennaInfoUlDedicated)
-          {
-            // Serialize antennaInfo choice
-            // 2 options. Selected: 0 ("explicitValue" of type "AntennaInfoDedicated")
-            SerializeChoice (2,0,false);
-
-            // Serialize AntennaInfoDedicated sequence
-            // 1 optional parameter, not present. No extension marker.
-            SerializeSequence (std::bitset<1> (0),false);
-
-            // Serialize transmissionMode
-            // Assuming the value in the struct is the enum index
-            SerializeEnum (8,pcdsc.antennaInfoUl.transmissionMode);
-
-            // Serialize ue-TransmitAntennaSelection choice
-            SerializeChoice (2,0,false);
-
-            // Serialize release
-            SerializeNull ();
-          }
-        if (pcdsc.haveSoundingRsUlConfigDedicated)
-          {
-            // Serialize SoundingRS-UL-ConfigDedicated choice:
-            switch (pcdsc.soundingRsUlConfigDedicated.type)
-              {
-              case LteRrcSap::SoundingRsUlConfigDedicated::RESET:
-                SerializeChoice (2,0,false);
-                SerializeNull ();
-                break;
-
-              case LteRrcSap::SoundingRsUlConfigDedicated::SETUP:
-              default:
-                // 2 options, selected: 1 (setup)
-                SerializeChoice (2,1,false);
-
-                // Serialize setup sequence
-                // 0 optional / default fields, no extension marker.
-                SerializeSequence (std::bitset<0> (),false);
-
-                // Serialize srs-Bandwidth
-                SerializeEnum (4,pcdsc.soundingRsUlConfigDedicated.srsBandwidth);
-
-                // Serialize  srs-HoppingBandwidth
-                SerializeEnum (4,0);
-
-                // Serialize freqDomainPosition
-                SerializeInteger (0,0,23);
-
-                // Serialize duration
-                SerializeBoolean (false);
-
-                // Serialize srs-ConfigIndex
-                SerializeInteger (pcdsc.soundingRsUlConfigDedicated.srsConfigIndex,0,1023);
-
-                // Serialize transmissionComb
-                SerializeInteger (0,0,1);
-
-                // Serialize cyclicShift
-                SerializeEnum (8,0);
-
-                break;
-              }
-              
-          }
-      
-
-      }
-  }
 
 Buffer::Iterator
 RrcAsn1Header::DeserializeThresholdEutra (LteRrcSap::ThresholdEutra * thresholdEutra, Buffer::Iterator bIterator)
@@ -2323,6 +2012,8 @@
           bIterator = DeserializeLogicalChannelConfig (&drbToAddMod.logicalChannelConfig,bIterator);
         }
 
+      bIterator = DeserializeBoolean(&drbToAddMod.is_mc,bIterator);
+
       drbToAddModList->insert (drbToAddModList->end (),drbToAddMod);
     }
   return bIterator;
@@ -2574,326 +2265,6 @@
   NS_FATAL_ERROR ("RrcAsn1Header Print() function must also specify LteRrcSap::RadioResourceConfigDedicated as a second argument");
 }
 
-  Buffer::Iterator
-  RrcAsn1Header::DeserializeNonCriticalExtensionConfig (LteRrcSap::NonCriticalExtensionConfiguration *nonCriticalExtension, Buffer::Iterator bIterator)
-  {
-    NS_LOG_FUNCTION (this);
-    std::bitset<2> nonCriticalExtension_v890;
-    bIterator = DeserializeSequence (&nonCriticalExtension_v890, false,bIterator);
-    
-    if (nonCriticalExtension_v890[0])
-      {
-        // Continue to analyze future Release optional fields
-        std::bitset<3> nonCriticalExtension_v920;
-        bIterator = DeserializeSequence (&nonCriticalExtension_v920, false, bIterator);
-        if (nonCriticalExtension_v920[0])
-          {
-            // Continue to deserialize futere Release optional fields
-            std::bitset<3> nonCriticalExtension_v1020;
-            bIterator = DeserializeSequence (&nonCriticalExtension_v1020, false, bIterator);
-            NS_ASSERT (!nonCriticalExtension_v1020[2]); // No sCellToRealeaseList-r10
-            NS_ASSERT (nonCriticalExtension_v1020[1]); // sCellToAddModList-r10
-            NS_ASSERT (!nonCriticalExtension_v1020[0]); // No nonCriticalExtension RRCConnectionReconfiguration-v1130-IEs
-
-            int numElems;
-            bIterator = DeserializeSequenceOf (&numElems,MAX_OBJECT_ID,1,bIterator);
-            nonCriticalExtension->sCellsToAddModList.clear ();
-            // Deserialize SCellToAddMod
-            for (int i = 0; i < numElems; i++)
-              {
-                std::bitset<4> sCellToAddMod_r10;
-                bIterator = DeserializeSequence (&sCellToAddMod_r10, false, bIterator); 
-                
-                LteRrcSap::SCellToAddMod sctam;
-                // Deserialize sCellIndex
-                NS_ASSERT (sCellToAddMod_r10[3]); // sCellIndex
-                int n;
-                bIterator = DeserializeInteger (&n,1,MAX_OBJECT_ID,bIterator);
-                sctam.sCellIndex = n;
-                // Deserialize CellIdentification
-                NS_ASSERT (sCellToAddMod_r10[2]); // CellIdentification
-                bIterator = DeserializeCellIdentification (&sctam.cellIdentification, bIterator);
-
-                // Deserialize RadioResourceConfigCommonSCell
-                NS_ASSERT (sCellToAddMod_r10[1]);
-                bIterator = DeserializeRadioResourceConfigCommonSCell (&sctam.radioResourceConfigCommonSCell, bIterator);
-                sctam.haveRadioResourceConfigDedicatedSCell = sCellToAddMod_r10[0];
-                if (sCellToAddMod_r10[0])
-                  {
-                    //Deserialize RadioResourceConfigDedicatedSCell
-                    bIterator = DeserializeRadioResourceConfigDedicatedSCell (&sctam.radioResourceConfigDedicateSCell, bIterator);
-                  }
-
-                nonCriticalExtension->sCellsToAddModList.insert (nonCriticalExtension->sCellsToAddModList.end (), sctam);
-              }
-          }
-      }
-
-    return bIterator;
-  }
-
-  Buffer::Iterator 
-  RrcAsn1Header::DeserializeCellIdentification (LteRrcSap::CellIdentification *ci, Buffer::Iterator bIterator)
-  {
-    NS_LOG_FUNCTION (this);
-    std::bitset<2> cellIdentification_r10;
-    bIterator = DeserializeSequence (&cellIdentification_r10,false,bIterator);
-    NS_ASSERT(cellIdentification_r10[1]); // phyCellId-r10
-    int n1;
-    bIterator = DeserializeInteger (&n1,1,65536,bIterator);
-    ci->physCellId = n1;
-    int n2;
-    NS_ASSERT (cellIdentification_r10[0]); // dl-CarrierFreq-r10
-    bIterator = DeserializeInteger (&n2,1,MAX_EARFCN,bIterator);
-    ci->dlCarrierFreq = n2;
-
-    return bIterator;
-  }
-
-  Buffer::Iterator 
-  RrcAsn1Header::DeserializeRadioResourceConfigCommonSCell (LteRrcSap::RadioResourceConfigCommonSCell *rrccsc, Buffer::Iterator bIterator)
-  {
-    NS_LOG_FUNCTION (this);
-    std::bitset<2> radioResourceConfigCommonSCell_r10;
-    bIterator = DeserializeSequence (&radioResourceConfigCommonSCell_r10,false,bIterator);
-    rrccsc->haveNonUlConfiguration = radioResourceConfigCommonSCell_r10[1];
-    rrccsc->haveUlConfiguration = radioResourceConfigCommonSCell_r10[0];
-    if (rrccsc->haveNonUlConfiguration)
-      {
-        std::bitset<5> nonUlConfiguration_r10;
-        bIterator = DeserializeSequence (&nonUlConfiguration_r10,false,bIterator);
-        int n;
-        bIterator = DeserializeInteger (&n,6,100,bIterator);
-        rrccsc->nonUlConfiguration.dlBandwidth = n;
-
-        std::bitset<1> antennaInfoCommon_r10;
-        bIterator = DeserializeSequence (&antennaInfoCommon_r10,false,bIterator);
-        bIterator = DeserializeInteger (&n,0,65536,bIterator);
-        rrccsc->nonUlConfiguration.antennaInfoCommon.antennaPortsCount = n;
-
-        std::bitset<2> pdschConfigCommon_r10;
-        bIterator = DeserializeSequence (&pdschConfigCommon_r10,false,bIterator);
-        bIterator = DeserializeInteger (&n,-60,50,bIterator);
-        rrccsc->nonUlConfiguration.pdschConfigCommon.referenceSignalPower = n;
-        bIterator = DeserializeInteger (&n,0,3,bIterator);
-        rrccsc->nonUlConfiguration.pdschConfigCommon.pb = n;
-      }
-    if (rrccsc->haveUlConfiguration)
-      {
-        std::bitset<7> UlConfiguration_r10;
-        bIterator = DeserializeSequence (&UlConfiguration_r10,true,bIterator);
-        
-        std::bitset<3> FreqInfo_r10;
-        bIterator = DeserializeSequence (&FreqInfo_r10,false,bIterator);
-        int n;
-        bIterator = DeserializeInteger (&n,0,MAX_EARFCN,bIterator);
-        rrccsc->ulConfiguration.ulFreqInfo.ulCarrierFreq = n;
-        bIterator = DeserializeInteger (&n,6,100,bIterator);
-        rrccsc->ulConfiguration.ulFreqInfo.ulBandwidth = n;
-
-        std::bitset<2> UlPowerControlCommonSCell_r10;
-        bIterator = DeserializeSequence (&UlPowerControlCommonSCell_r10,false,bIterator);
-        bIterator = DeserializeInteger (&n,0,65536,bIterator);
-        rrccsc->ulConfiguration.ulPowerControlCommonSCell.alpha = n;
-         
-        std::bitset<1> prachConfigSCell_r10;
-        bIterator = DeserializeSequence (&prachConfigSCell_r10,false,bIterator);
-        bIterator = DeserializeInteger (&n,0,256,bIterator);
-        rrccsc->ulConfiguration.prachConfigSCell.index = n;
-      }    
-    
-    return bIterator;
-  }
-
-  Buffer::Iterator 
-  RrcAsn1Header::DeserializeRadioResourceConfigDedicatedSCell (LteRrcSap::RadioResourceConfigDedicatedSCell *rrcdsc, Buffer::Iterator bIterator)
-  {
-    NS_LOG_FUNCTION (this);
-    std::bitset<1> RadioResourceConfigDedicatedSCell_r10;
-    bIterator = DeserializeSequence (&RadioResourceConfigDedicatedSCell_r10,false,bIterator);
-    bIterator = DeserializePhysicalConfigDedicatedSCell (&rrcdsc->physicalConfigDedicatedSCell, bIterator);
-
-    return bIterator;
-  }
-
-  Buffer::Iterator 
-  RrcAsn1Header::DeserializePhysicalConfigDedicatedSCell (LteRrcSap::PhysicalConfigDedicatedSCell *pcdsc, Buffer::Iterator bIterator)
-  {
-    NS_LOG_FUNCTION (this);
-    std::bitset<2> pcdscOpt;
-    bIterator = DeserializeSequence (&pcdscOpt,true,bIterator);
-    pcdsc->haveNonUlConfiguration = pcdscOpt[1];
-    pcdsc->haveUlConfiguration = pcdscOpt[0];    
-    if (pcdsc->haveNonUlConfiguration)
-      {
-         std::bitset<4> nulOpt;
-         bIterator = DeserializeSequence (&nulOpt,false,bIterator);
-         pcdsc->haveAntennaInfoDedicated = nulOpt[3];  
-         NS_ASSERT(!nulOpt[2]); // crossCarrierSchedulingConfig-r10 Not Implemented
-         NS_ASSERT(!nulOpt[1]); // csi-RS-Config-r10 Not Implemented
-         pcdsc->havePdschConfigDedicated = nulOpt[0];  
-
-         if (pcdsc->haveAntennaInfoDedicated)
-           {
-             // Deserialize antennaInfo
-             int sel;
-             bIterator = DeserializeChoice (2,false,&sel,bIterator);
-             if (sel == 1)
-               {
-                 bIterator = DeserializeNull (bIterator);
-               }
-             else if (sel == 0)
-               {
-                 std::bitset<1> codebookSubsetRestrictionPresent;
-                 bIterator = DeserializeSequence (&codebookSubsetRestrictionPresent,false,bIterator);
-
-                 int txmode;
-                 bIterator = DeserializeEnum (8,&txmode,bIterator);
-                 pcdsc->antennaInfo.transmissionMode = txmode;
-
-                 if (codebookSubsetRestrictionPresent[0])
-                   {
-                     // Deserialize codebookSubsetRestriction
-                     NS_FATAL_ERROR ("Not implemented yet");
-                     // ...
-                   }
-
-                 int txantennaselchosen;
-                 bIterator = DeserializeChoice (2,false,&txantennaselchosen,bIterator);
-                 if (txantennaselchosen == 0)
-                   {
-                     // Deserialize ue-TransmitAntennaSelection release
-                     bIterator = DeserializeNull (bIterator);
-                   }
-                 else if (txantennaselchosen == 1)
-                   {
-                     // Deserialize ue-TransmitAntennaSelection setup
-                     NS_FATAL_ERROR ("Not implemented yet");
-                     // ...
-                   }
-               }
-           }
-         if (pcdsc->havePdschConfigDedicated)
-           {
-             // Deserialize pdsch-ConfigDedicated
-             std::bitset<0> bitset0;
-             bIterator = DeserializeSequence (&bitset0,false,bIterator);
-
-             int slct;
-
-             // Deserialize p-a
-             bIterator = DeserializeEnum (8,&slct,bIterator);
-             pcdsc->pdschConfigDedicated.pa = slct;
-
-             bIterator = DeserializeNull (bIterator);
-           }
-        
-      }
-    if (pcdsc->haveUlConfiguration)
-      {
-         std::bitset<7> ulOpt;
-         bIterator = DeserializeSequence (&ulOpt,false,bIterator);
-         pcdsc->haveAntennaInfoUlDedicated = ulOpt[6];
-         NS_ASSERT(!ulOpt[5]); // pusch-ConfigDedicatedSCell-r10 not present
-         NS_ASSERT(!ulOpt[4]); // uplinkPowerControlDedicatedSCell-r10 not present
-         NS_ASSERT(!ulOpt[3]); // cqi-ReportConfigSCell-r10 not present
-         pcdsc->haveSoundingRsUlConfigDedicated = ulOpt[2];
-         NS_ASSERT(!ulOpt[1]); // soundingRS-UL-ConfigDedicated-v1020 not present
-         NS_ASSERT(!ulOpt[0]); // soundingRS-UL-ConfigDedicatedAperiodic-r10 not present
-         
-         if (pcdsc->haveAntennaInfoUlDedicated)
-           {
-             // Deserialize antennaInfo
-             int sel;
-             bIterator = DeserializeChoice (2,false,&sel,bIterator);
-             if (sel == 1)
-               {
-                 bIterator = DeserializeNull (bIterator);
-               }
-             else if (sel == 0)
-               {
-                 std::bitset<1> codebookSubsetRestrictionPresent;
-                 bIterator = DeserializeSequence (&codebookSubsetRestrictionPresent,false,bIterator);
-
-                 int txmode;
-                 bIterator = DeserializeEnum (8,&txmode,bIterator);
-                 pcdsc->antennaInfoUl.transmissionMode = txmode;
-
-                 if (codebookSubsetRestrictionPresent[0])
-                   {
-                     // Deserialize codebookSubsetRestriction
-                     NS_FATAL_ERROR ("Not implemented yet");
-                     // ...
-                   }
-
-                 int txantennaselchosen;
-                 bIterator = DeserializeChoice (2,false,&txantennaselchosen,bIterator);
-                 if (txantennaselchosen == 0)
-                   {
-                     // Deserialize ue-TransmitAntennaSelection release
-                     bIterator = DeserializeNull (bIterator);
-                   }
-                 else if (txantennaselchosen == 1)
-                   {
-                     // Deserialize ue-TransmitAntennaSelection setup
-                     NS_FATAL_ERROR ("Not implemented yet");
-                     // ...
-                   }
-               }
-           }
-         if (pcdsc->haveSoundingRsUlConfigDedicated)
-           {
-             // Deserialize soundingRS-UL-ConfigDedicated
-             int sel;
-             bIterator = DeserializeChoice (2,false,&sel,bIterator);
-
-             if (sel == 0)
-               {
-                 pcdsc->soundingRsUlConfigDedicated.type = LteRrcSap::SoundingRsUlConfigDedicated::RESET;
-
-                 bIterator = DeserializeNull (bIterator);
-               }
-
-             else if (sel == 1)
-               {
-                 pcdsc->soundingRsUlConfigDedicated.type = LteRrcSap::SoundingRsUlConfigDedicated::SETUP;
-
-                 std::bitset<0> bitset0;
-                 bIterator = DeserializeSequence (&bitset0,false,bIterator);
-
-                 int slct;
-
-                 // Deserialize srs-Bandwidth
-                 bIterator = DeserializeEnum (4,&slct,bIterator);
-                 pcdsc->soundingRsUlConfigDedicated.srsBandwidth = slct;
-
-                 // Deserialize srs-HoppingBandwidth
-                 bIterator = DeserializeEnum (4,&slct,bIterator);
-
-                 // Deserialize freqDomainPosition
-                 bIterator = DeserializeInteger (&slct,0,23,bIterator);
-
-                 // Deserialize duration
-                 bool duration;
-                 bIterator = DeserializeBoolean (&duration,bIterator);
-
-                 // Deserialize srs-ConfigIndex
-                 bIterator = DeserializeInteger (&slct,0,1023,bIterator);
-                 pcdsc->soundingRsUlConfigDedicated.srsConfigIndex = slct;
-
-                 // Deserialize transmissionComb
-                 bIterator = DeserializeInteger (&slct,0,1,bIterator);
-
-                 // Deserialize cyclicShift
-                 bIterator = DeserializeEnum (8,&slct,bIterator);
-               }
-           }
-
-
-      }
-
-    return bIterator;
-  }
 void
 RrcAsn1Header::Print (std::ostream &os, LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) const
 {
@@ -3532,9 +2903,8 @@
 {
   int n;
   std::bitset<0> b0;
-  std::bitset<4> measResultOptionalPresent;
-  //    bIterator = DeserializeSequence (&measResultNeighCellsPresent,true,bIterator);
-  bIterator = DeserializeSequence (&measResultOptionalPresent,true,bIterator);
+  std::bitset<1> measResultNeighCellsPresent;
+  bIterator = DeserializeSequence (&measResultNeighCellsPresent,true,bIterator);
 
   // Deserialize measId
   bIterator = DeserializeInteger (&n, 1, MAX_MEAS_ID, bIterator);
@@ -3551,8 +2921,7 @@
   bIterator = DeserializeInteger (&n, 0, 34, bIterator);
   measResults->rsrqResult = n;
 
-  measResults->haveMeasResultNeighCells = measResultOptionalPresent[0];
-  measResults->haveScellsMeas = measResultOptionalPresent[3];
+  measResults->haveMeasResultNeighCells = measResultNeighCellsPresent[0];
   if ( measResults->haveMeasResultNeighCells)
     {
       int measResultNeighCellsChoice;
@@ -3655,52 +3024,7 @@
           // ...
         }
     }
-    if (measResults->haveScellsMeas)
-      {
 
-        int numElems;
-        bIterator = DeserializeSequenceOf (&numElems,MAX_SCELL_REPORT,1,bIterator);
-        for (int i = 0; i < numElems; i++)
-          {
-            LteRrcSap::MeasResultScell measResultScell;
-            int measScellId;
-            // Deserialize measId
-            bIterator = DeserializeInteger (&measScellId, 1,MAX_SCELL_REPORT,bIterator);
-            measResultScell.servFreqId = measScellId;
-            std::bitset<2> measResultScellPresent;
-            bIterator = DeserializeSequence (&measResultScellPresent,true,bIterator);
-            measResults->measScellResultList.haveMeasurementResultsServingSCells = measResultScellPresent[0];
-           measResults->measScellResultList.haveMeasurementResultsNeighCell = measResultScellPresent[1];
-           if (measResults->measScellResultList.haveMeasurementResultsServingSCells)
-             {
-               // Deserialize measResult
-               std::bitset<2> measResultOpts;
-               bIterator = DeserializeSequence (&measResultOpts, true, bIterator);
-
-               measResultScell.haveRsrpResult = measResultOpts[1];
-               if (measResultOpts[1])
-                 {
-                   // Deserialize rsrpResult
-                   bIterator = DeserializeInteger (&n,0,97,bIterator);
-                   measResultScell.rsrpResult = n;
-                 }
-
-               measResultScell.haveRsrqResult = measResultOpts[0];
-               if (measResultOpts[0])
-                 {
-                   // Deserialize rsrqResult
-                   bIterator = DeserializeInteger (&n,0,34,bIterator);
-                   measResultScell.rsrqResult = n;
-                 }
-             }
-           if (measResults->measScellResultList.haveMeasurementResultsNeighCell)
-             {
-               // Deserialize measResultBestNeighCell
-             }
-           measResults->measScellResultList.measResultScell.push_back (measResultScell);
-          }
-        
-      }
   return bIterator;
 }
 
@@ -4642,7 +3966,7 @@
   SerializeEnum (8,m_establishmentCause);
 
   // Serialize spare : BIT STRING (SIZE (1))
-  SerializeBitstring (std::bitset<1> ());
+  SerializeBitstring (m_spare);
 
   // Finish serialization
   FinalizeSerialization ();
@@ -4651,7 +3975,7 @@
 uint32_t
 RrcConnectionRequestHeader::Deserialize (Buffer::Iterator bIterator)
 {
-  std::bitset<1> dummy;
+  //std::bitset<1> dummy;
   std::bitset<0> optionalOrDefaultMask;
   int selectedOption;
 
@@ -4682,7 +4006,7 @@
   bIterator = DeserializeEnum (8,&selectedOption,bIterator);
 
   // Deserialize spare
-  bIterator = DeserializeBitstring (&dummy,bIterator);
+  bIterator = DeserializeBitstring (&m_spare,bIterator);
 
   return GetSerializedSize ();
 }
@@ -4692,6 +4016,7 @@
 {
   m_mTmsi = std::bitset<32> ((uint32_t)msg.ueIdentity);
   m_mmec = std::bitset<8> ((uint32_t)(msg.ueIdentity >> 32));
+  m_spare = std::bitset<1> (msg.isMc); 
   m_isDataSerialized = false;
 }
 
@@ -4700,7 +4025,7 @@
 {
   LteRrcSap::RrcConnectionRequest msg;
   msg.ueIdentity = (((uint64_t) m_mmec.to_ulong ()) << 32) | (m_mTmsi.to_ulong ());
-
+  msg.isMc = (bool) m_spare[0];
   return msg;
 }
 
@@ -4716,6 +4041,157 @@
   return m_mTmsi;
 }
 
+std::bitset<1>
+RrcConnectionRequestHeader::GetIsMc () const
+{
+  return m_spare;
+}
+
+//////////////////// RrcConnectionRequest class ////////////////////////
+
+// Constructor
+RrcConnectToMmWaveHeader::RrcConnectToMmWaveHeader () : RrcDlCcchMessage ()
+{
+  m_mmWaveId = std::bitset<16> (0ul);
+}
+
+// Destructor
+RrcConnectToMmWaveHeader::~RrcConnectToMmWaveHeader ()
+{
+}
+
+TypeId
+RrcConnectToMmWaveHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::RrcConnectToMmWaveHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+  ;
+  return tid;
+}
+
+void
+RrcConnectToMmWaveHeader::Print (std::ostream &os) const
+{
+  os << "MmWaveId:" << m_mmWaveId << std::endl;
+}
+
+void
+RrcConnectToMmWaveHeader::PreSerialize () const
+{
+  m_serializationResult = Buffer ();
+
+  SerializeDlCcchMessage (4);
+
+  // Serialize mmWaveId : MMEC ::= BIT STRING (SIZE (16))
+  SerializeBitstring (m_mmWaveId);
+
+  // Finish serialization
+  FinalizeSerialization ();
+}
+
+uint32_t
+RrcConnectToMmWaveHeader::Deserialize (Buffer::Iterator bIterator)
+{
+
+  bIterator = DeserializeDlCcchMessage (bIterator);
+
+  // Deserialize mmWaveId
+  bIterator = DeserializeBitstring (&m_mmWaveId,bIterator);
+
+  return GetSerializedSize ();
+}
+
+void
+RrcConnectToMmWaveHeader::SetMessage (uint16_t mmWaveId)
+{
+  m_mmWaveId = std::bitset<16> ((uint16_t)mmWaveId);
+  m_isDataSerialized = false;
+}
+
+uint16_t
+RrcConnectToMmWaveHeader::GetMessage () const
+{
+  uint16_t mmWaveId = (uint16_t)(m_mmWaveId.to_ulong ());
+  return mmWaveId;
+}
+
+//////////////////// RrcNotifySecondaryConnectedHeader class ////////////////////////
+
+// Constructor
+RrcNotifySecondaryConnectedHeader::RrcNotifySecondaryConnectedHeader ()
+{
+  m_mmWaveId = std::bitset<16> (0ul);
+  m_mmWaveRnti = std::bitset<16> (0ul);
+}
+
+// Destructor
+RrcNotifySecondaryConnectedHeader::~RrcNotifySecondaryConnectedHeader ()
+{
+}
+
+TypeId
+RrcNotifySecondaryConnectedHeader::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::RrcNotifySecondaryConnectedHeader")
+    .SetParent<Header> ()
+    .SetGroupName("Lte")
+  ;
+  return tid;
+}
+
+void
+RrcNotifySecondaryConnectedHeader::Print (std::ostream &os) const
+{
+  os << "MmWaveId:" << m_mmWaveId << std::endl;
+  os << "MmWaveRnti:" << m_mmWaveRnti << std::endl;
+}
+
+void
+RrcNotifySecondaryConnectedHeader::PreSerialize () const
+{
+  m_serializationResult = Buffer ();
+
+  SerializeUlDcchMessage (5);
+
+  // Serialize mmWaveId : MMEC ::= BIT STRING (SIZE (16))
+  SerializeBitstring (m_mmWaveId);
+  SerializeBitstring (m_mmWaveRnti);
+
+  // Finish serialization
+  FinalizeSerialization ();
+}
+
+uint32_t
+RrcNotifySecondaryConnectedHeader::Deserialize (Buffer::Iterator bIterator)
+{
+
+  bIterator = DeserializeUlDcchMessage (bIterator);
+
+  // Deserialize mmWaveId
+  bIterator = DeserializeBitstring (&m_mmWaveId,bIterator);
+  bIterator = DeserializeBitstring (&m_mmWaveRnti,bIterator);
+
+  return GetSerializedSize ();
+}
+
+void
+RrcNotifySecondaryConnectedHeader::SetMessage (uint16_t mmWaveId, uint16_t mmWaveRnti)
+{
+  m_mmWaveRnti = std::bitset<16> ((uint16_t)mmWaveRnti);
+  m_mmWaveId = std::bitset<16> ((uint16_t)mmWaveId);
+  m_isDataSerialized = false;
+}
+
+std::pair<uint16_t, uint16_t>
+RrcNotifySecondaryConnectedHeader::GetMessage () const
+{
+  uint16_t mmWaveId = (uint16_t)(m_mmWaveId.to_ulong ());
+  uint16_t mmWaveRnti = (uint16_t)(m_mmWaveRnti.to_ulong ());
+  
+  return std::pair<uint16_t, uint16_t>(mmWaveId, mmWaveRnti);
+}
+
 
 //////////////////// RrcConnectionSetup class ////////////////////////
 RrcConnectionSetupHeader::RrcConnectionSetupHeader ()
@@ -5092,6 +4568,91 @@
   return m_rrcTransactionIdentifier;
 }
 
+//////////////////// RrcConnectionSwitchHeader class ////////////////////////
+
+RrcConnectionSwitchHeader::RrcConnectionSwitchHeader ()
+{
+}
+
+RrcConnectionSwitchHeader::~RrcConnectionSwitchHeader ()
+{
+}
+
+void
+RrcConnectionSwitchHeader::PreSerialize () const
+{
+  m_serializationResult = Buffer ();
+
+  // Serialize DCCH message
+  SerializeDlDcchMessage (6);
+
+  // Serialize rrc-TransactionIdentifier
+  SerializeInteger (m_msg.rrcTransactionIdentifier,0,3);
+
+  // Serialize the number of brbId
+  SerializeInteger(m_msg.drbidList.size(), 0, 255);
+
+  std::vector<uint8_t>::iterator drbIt = m_msg.drbidList.begin();
+  for(; drbIt != m_msg.drbidList.end(); ++drbIt)
+  {
+    SerializeInteger(*drbIt, 0, 255);
+  }
+
+  SerializeInteger(m_msg.useMmWaveConnection, 0, 65535);
+
+  // Finish serialization
+  FinalizeSerialization ();
+}
+
+uint32_t
+RrcConnectionSwitchHeader::Deserialize (Buffer::Iterator bIterator)
+{
+  int n;
+  bIterator = DeserializeDlDcchMessage (bIterator);
+  bIterator = DeserializeInteger (&n,0,3,bIterator);
+  m_msg.rrcTransactionIdentifier = (uint8_t)n;
+
+  bIterator = DeserializeInteger (&n,0,255,bIterator);
+  int listSize = n;
+
+  for(int i = 0; i < listSize; i++)
+  {
+    bIterator = DeserializeInteger (&n,0,255,bIterator);
+    uint8_t drb = (uint8_t)n;
+    m_msg.drbidList.push_back(drb);
+  }
+
+  bIterator = DeserializeInteger (&n,0,65535,bIterator);
+  m_msg.useMmWaveConnection = (uint16_t)n;
+
+  return GetSerializedSize ();
+}
+
+void
+RrcConnectionSwitchHeader::Print (std::ostream &os) const
+{
+  os << "rrcTransactionIdentifier: " << (int) m_msg.rrcTransactionIdentifier << std::endl;
+}
+
+void
+RrcConnectionSwitchHeader::SetMessage (LteRrcSap::RrcConnectionSwitch msg)
+{
+  m_msg = msg;
+  m_isDataSerialized = false;
+}
+
+LteRrcSap::RrcConnectionSwitch
+RrcConnectionSwitchHeader::GetMessage () const
+{
+  return m_msg;
+}
+
+uint8_t
+RrcConnectionSwitchHeader::GetRrcTransactionIdentifier () const
+{
+  return m_msg.rrcTransactionIdentifier;
+}
+
 //////////////////// RrcConnectionReconfigurationHeader class ////////////////////////
 
 RrcConnectionReconfigurationHeader::RrcConnectionReconfigurationHeader ()
@@ -5132,7 +4693,7 @@
   options.set (3,0); // No dedicatedInfoNASList
   options.set (2,m_haveRadioResourceConfigDedicated);
   options.set (1,0); // No securityConfigHO
-  options.set (0,m_haveNonCriticalExtension); // Implemented nonCriticalExtension because compatibility with R10 - CA
+  options.set (0,0); // No nonCriticalExtension
   SerializeSequence (options,false);
 
   if (m_haveMeasConfig)
@@ -5238,28 +4799,6 @@
     {
       // Serialize RadioResourceConfigDedicated
       SerializeRadioResourceConfigDedicated (m_radioResourceConfigDedicated);
-      }
-
-    if (m_haveNonCriticalExtension)
-      {
-        // Serialize NonCriticalExtension RRCConnectionReconfiguration-v890-IEs sequence:
-        // 2 optional fields. Extension marker not present.
-        std::bitset<2> noncriticalExtension_v890;
-        noncriticalExtension_v890.set (1,0); // No lateNonCriticalExtension
-        noncriticalExtension_v890.set (0,m_haveNonCriticalExtension); // Implemented nonCriticalExtension because compatibility with R10 - CA
-        //Enable RRCCoonectionReconfiguration-v920-IEs
-        SerializeSequence (noncriticalExtension_v890,false);
-  	  
-        // Serialize NonCriticalExtension RRCConnectionReconfiguration-v920-IEs sequence:
-        // 3 optional fields. Extension marker not present.
-        std::bitset<3> noncriticalExtension_v920;
-        noncriticalExtension_v920.set (1,0); // No otehrConfig-r9
-        noncriticalExtension_v920.set (1,0); // No fullConfig-r9
-        //Enable RRCCoonectionReconfiguration-v1020-IEs
-        noncriticalExtension_v920.set (0,m_haveNonCriticalExtension); // Implemented nonCriticalExtension because compatibility with R10 - CA
-        SerializeSequence (noncriticalExtension_v920,false);
-  	  
-        SerializeNonCriticalExtensionConfiguration (m_nonCriticalExtension); //Serializing RRCConnectionReconfiguration-r8-IEs
     }
 
   // Finish serialization
@@ -5449,10 +4988,8 @@
             }
 
           // nonCriticalExtension
-            m_haveNonCriticalExtension = rrcConnRecOpts[0];
-            if (m_haveNonCriticalExtension)
+          if (rrcConnRecOpts[0])
             {
-                bIterator = DeserializeNonCriticalExtensionConfig (&m_nonCriticalExtension,bIterator);
               // ...
             }
         }
@@ -5708,8 +5245,6 @@
   m_mobilityControlInfo = msg.mobilityControlInfo;
   m_haveRadioResourceConfigDedicated = msg.haveRadioResourceConfigDedicated;
   m_radioResourceConfigDedicated = msg.radioResourceConfigDedicated;
-  m_haveNonCriticalExtension = msg.haveNonCriticalExtension;
-  m_nonCriticalExtension = msg.nonCriticalExtension;
 
   m_isDataSerialized = false;
 }
@@ -5726,8 +5261,6 @@
   msg.mobilityControlInfo = m_mobilityControlInfo;
   msg.haveRadioResourceConfigDedicated = m_haveRadioResourceConfigDedicated;
   msg.radioResourceConfigDedicated = m_radioResourceConfigDedicated;
-  msg.haveNonCriticalExtension = m_haveNonCriticalExtension;
-  msg.nonCriticalExtension = m_nonCriticalExtension;
 
   return msg;
 }
@@ -5772,18 +5305,6 @@
 RrcConnectionReconfigurationHeader::GetRadioResourceConfigDedicated ()
 {
   return m_radioResourceConfigDedicated;
-  }
-
-  bool
-  RrcConnectionReconfigurationHeader::GetHaveNonCriticalExtensionConfig ()
-  {
-    return m_haveNonCriticalExtension;
-  }
-
-  LteRrcSap::NonCriticalExtensionConfiguration
-  RrcConnectionReconfigurationHeader::GetNonCriticalExtensionConfig ()
-  {
-    return m_nonCriticalExtension;
 }
 
 bool
@@ -6876,7 +6397,7 @@
               os << "      havePlmnIdentityList = " << !it->cgiInfo.plmnIdentityList.empty () << std::endl;
               if (!it->cgiInfo.plmnIdentityList.empty ())
                 {
-                  for (std::list<uint32_t>::iterator it2 = it->cgiInfo.plmnIdentityList.begin (); it2 != it->cgiInfo.plmnIdentityList.end (); it2++)
+                  for (std::list<uint32_t>::iterator it2 = it->cgiInfo.plmnIdentityList.begin (); it2 != it->cgiInfo.plmnIdentityList.begin (); it2++)
                     {
                       os << "         plmnId : " << *it2 << std::endl;
                     }
@@ -7081,7 +6602,7 @@
   else if (n == 0)
     {
       // Deserialize c1
-      bIterator = DeserializeChoice (2,false,&m_messageType,bIterator);
+      bIterator = DeserializeChoice (3,false,&m_messageType,bIterator);
     }
 
   return bIterator;
@@ -7094,7 +6615,7 @@
   // Choose c1
   SerializeChoice (2,0,false);
   // Choose message type
-  SerializeChoice (2,messageType,false);
+  SerializeChoice (3,messageType,false);
 }
 
 ///////////////////  RrcDlCcchMessage //////////////////////////////////
@@ -7142,9 +6663,8 @@
   else if (n == 0)
     {
       // Deserialize c1
-      bIterator = DeserializeChoice (4,false,&m_messageType,bIterator);
+      bIterator = DeserializeChoice (5,false,&m_messageType,bIterator);
     }
-
   return bIterator;
 }
 
@@ -7155,7 +6675,7 @@
   // Choose c1
   SerializeChoice (2,0,false);
   // Choose message type
-  SerializeChoice (4,messageType,false);
+  SerializeChoice (5,messageType,false);
 }
 
 } // namespace ns3
diff -Naru a/model/lte-rrc-header.h b/model/lte-rrc-header.h
--- a/model/lte-rrc-header.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rrc-header.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,9 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Lluis Parcerisa <lparcerisa@cttc.cat>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef RRC_HEADER_H
@@ -35,10 +36,6 @@
 namespace ns3 {
 
 /**
- * \ingroup lte
- */
-
-/**
  * This class extends Asn1Header functions, adding serialization/deserialization
  * of some Information elements defined in 3GPP TS 36.331
  */
@@ -46,306 +43,49 @@
 {
 public:
   RrcAsn1Header ();
-  /**
-   * Get message type
-   *
-   * \returns the message type
-   */
   int GetMessageType ();
 
 protected:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
   // Inherited from Asn1Header
+  static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   uint32_t Deserialize (Buffer::Iterator bIterator) = 0;
   virtual void PreSerialize (void) const = 0;
 
   // Serialization functions
-  /**
-   * Serialize SRB to add mod list function
-   *
-   * \param srbToAddModList std::list<LteRrcSap::SrbToAddMod>
-   */
   void SerializeSrbToAddModList (std::list<LteRrcSap::SrbToAddMod> srbToAddModList) const;
-  /**
-   * Serialize DRB to add mod list function
-   *
-   * \param drbToAddModList std::list<LteRrcSap::SrbToAddMod>
-   */
   void SerializeDrbToAddModList (std::list<LteRrcSap::DrbToAddMod> drbToAddModList) const;
-  /**
-   * Serialize logicala channel config function
-   *
-   * \param logicalChannelConfig LteRrcSap::LogicalChannelConfig
-   */
   void SerializeLogicalChannelConfig (LteRrcSap::LogicalChannelConfig logicalChannelConfig) const;
-  /**
-   * Serialize radio resource config function
-   *
-   * \param radioResourceConfigDedicated LteRrcSap::RadioResourceConfigDedicated
-   */
   void SerializeRadioResourceConfigDedicated (LteRrcSap::RadioResourceConfigDedicated radioResourceConfigDedicated) const;
-  /**
-   * Serialize physical config dedicated function
-   *
-   * \param physicalConfigDedicated LteRrcSap::PhysicalConfigDedicated
-   */
   void SerializePhysicalConfigDedicated (LteRrcSap::PhysicalConfigDedicated physicalConfigDedicated) const;
-  /**
-   * Serialize physical config dedicated function
-   *
-   * \param pcdsc LteRrcSap::PhysicalConfigDedicatedSCell
-   */
-  void SerializePhysicalConfigDedicatedSCell (LteRrcSap::PhysicalConfigDedicatedSCell pcdsc) const;
-  /**
-   * Serialize system information block type 1 function
-   *
-   * \param systemInformationBlockType1 LteRrcSap::SystemInformationBlockType1
-   */
   void SerializeSystemInformationBlockType1 (LteRrcSap::SystemInformationBlockType1 systemInformationBlockType1) const;
-  /**
-   * Serialize system information block type 2 function
-   *
-   * \param systemInformationBlockType2 LteRrcSap::SystemInformationBlockType2
-   */
   void SerializeSystemInformationBlockType2 (LteRrcSap::SystemInformationBlockType2 systemInformationBlockType2) const;
-  /**
-   * Serialize system information block type 2 function
-   *
-   * \param radioResourceConfigCommon LteRrcSap::RadioResourceConfigCommon
-   */
   void SerializeRadioResourceConfigCommon (LteRrcSap::RadioResourceConfigCommon radioResourceConfigCommon) const;
-  /**
-   * Serialize radio resource config common SIB function
-   *
-   * \param radioResourceConfigCommonSib LteRrcSap::RadioResourceConfigCommonSib
-   */
   void SerializeRadioResourceConfigCommonSib (LteRrcSap::RadioResourceConfigCommonSib radioResourceConfigCommonSib) const;
-  /**
-   * Serialize measure results function
-   *
-   * \param measResults LteRrcSap::MeasResults
-   */
   void SerializeMeasResults (LteRrcSap::MeasResults measResults) const;
-  /**
-   * Serialize PLMN identity function
-   *
-   * \param plmnId the PLMN ID
-   */
   void SerializePlmnIdentity (uint32_t plmnId) const;
-  /**
-   * Serialize RACH config common function
-   *
-   * \param rachConfigCommon LteRrcSap::RachConfigCommon
-   */
   void SerializeRachConfigCommon (LteRrcSap::RachConfigCommon rachConfigCommon) const;
-  /**
-   * Serialize measure config function
-   *
-   * \param measConfig LteRrcSap::MeasConfig
-   */
   void SerializeMeasConfig (LteRrcSap::MeasConfig measConfig) const;
-  /**
-   * Serialize non critical extension config function
-   *
-   * \param nonCriticalExtensionConfiguration LteRrcSap::NonCriticalExtensionConfiguration
-   */
-  void SerializeNonCriticalExtensionConfiguration (LteRrcSap::NonCriticalExtensionConfiguration nonCriticalExtensionConfiguration) const;
-  /**
-   * Serialize radio resource config common SCell function
-   *
-   * \param rrccsc LteRrcSap::RadioResourceConfigCommonSCell
-   */
-  void SerializeRadioResourceConfigCommonSCell (LteRrcSap::RadioResourceConfigCommonSCell rrccsc) const;
-  /**
-   * Serialize radio resource dedicated SCell function
-   *
-   * \param rrcdsc LteRrcSap::RadioResourceConfigDedicatedSCell
-   */
-  void SerializeRadioResourceDedicatedSCell (LteRrcSap::RadioResourceConfigDedicatedSCell rrcdsc) const;
-  /**
-   * Serialize Q offset range function
-   *
-   * \param qOffsetRange q offset range
-   */
   void SerializeQoffsetRange (int8_t qOffsetRange) const;
-  /**
-   * Serialize threshold eutra function
-   *
-   * \param thresholdEutra LteRrcSap::ThresholdEutra
-   */
   void SerializeThresholdEutra (LteRrcSap::ThresholdEutra thresholdEutra) const;
   
   // Deserialization functions
-  /**
-   * Deserialize DRB to add mod list function
-   *
-   * \param drbToAddModLis std::list<LteRrcSap::DrbToAddMod> *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeDrbToAddModList (std::list<LteRrcSap::DrbToAddMod> *drbToAddModLis, Buffer::Iterator bIterator);
-  /**
-   * Deserialize SRB to add mod list function
-   *
-   * \param srbToAddModList std::list<LteRrcSap::SrbToAddMod> *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeSrbToAddModList (std::list<LteRrcSap::SrbToAddMod> *srbToAddModList, Buffer::Iterator bIterator);
-  /**
-   * Deserialize logical channel config function
-   *
-   * \param logicalChannelConfig LteRrcSap::LogicalChannelConfig *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeLogicalChannelConfig (LteRrcSap::LogicalChannelConfig *logicalChannelConfig, Buffer::Iterator bIterator);
-  /**
-   * Deserialize radio resource config dedicated function
-   *
-   * \param radioResourceConfigDedicated LteRrcSap::RadioResourceConfigDedicated *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeRadioResourceConfigDedicated (LteRrcSap::RadioResourceConfigDedicated *radioResourceConfigDedicated, Buffer::Iterator bIterator);
-  /**
-   * Deserialize physical config dedicated function
-   *
-   * \param physicalConfigDedicated LteRrcSap::PhysicalConfigDedicated *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializePhysicalConfigDedicated (LteRrcSap::PhysicalConfigDedicated *physicalConfigDedicated, Buffer::Iterator bIterator);
-  /**
-   * Deserialize system information block type 1 function
-   *
-   * \param systemInformationBlockType1 LteRrcSap::SystemInformationBlockType1 *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeSystemInformationBlockType1 (LteRrcSap::SystemInformationBlockType1 *systemInformationBlockType1, Buffer::Iterator bIterator);
-  /**
-   * Deserialize system information block type 2 function
-   *
-   * \param systemInformationBlockType2 LteRrcSap::SystemInformationBlockType2 *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeSystemInformationBlockType2 (LteRrcSap::SystemInformationBlockType2 *systemInformationBlockType2, Buffer::Iterator bIterator);
-  /**
-   * Deserialize radio resource config common function
-   *
-   * \param radioResourceConfigCommon LteRrcSap::RadioResourceConfigCommon *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeRadioResourceConfigCommon (LteRrcSap::RadioResourceConfigCommon *radioResourceConfigCommon, Buffer::Iterator bIterator);
-  /**
-   * Deserialize radio resource config common SIB function
-   *
-   * \param radioResourceConfigCommonSib LteRrcSap::RadioResourceConfigCommonSib *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeRadioResourceConfigCommonSib (LteRrcSap::RadioResourceConfigCommonSib *radioResourceConfigCommonSib, Buffer::Iterator bIterator);
-  /**
-   * Deserialize measure results function
-   *
-   * \param measResults LteRrcSap::MeasResults *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeMeasResults (LteRrcSap::MeasResults *measResults, Buffer::Iterator bIterator);
-  /**
-   * Deserialize PLMN identity function
-   *
-   * \param plmnId the PLMN ID
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializePlmnIdentity (uint32_t *plmnId, Buffer::Iterator bIterator);
-  /**
-   * Deserialize RACH config common function
-   *
-   * \param rachConfigCommon LteRrcSap::RachConfigCommon *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeRachConfigCommon (LteRrcSap::RachConfigCommon * rachConfigCommon, Buffer::Iterator bIterator);
-  /**
-   * Deserialize measure config function
-   *
-   * \param measConfig LteRrcSap::MeasConfig *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeMeasConfig (LteRrcSap::MeasConfig * measConfig, Buffer::Iterator bIterator);
-  /**
-   * Deserialize Qoffset range function
-   *
-   * \param qOffsetRange Qoffset range
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeQoffsetRange (int8_t * qOffsetRange, Buffer::Iterator bIterator);
-  /**
-   * Deserialize threshold eutra function
-   *
-   * \param thresholdEutra LteRrcSap::ThresholdEutra *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeThresholdEutra (LteRrcSap::ThresholdEutra * thresholdEutra, Buffer::Iterator bIterator);
-  /**
-   * Deserialize non critical extension config function
-   *
-   * \param nonCriticalExtension LteRrcSap::NonCriticalExtensionConfiguration *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
-  Buffer::Iterator DeserializeNonCriticalExtensionConfig (LteRrcSap::NonCriticalExtensionConfiguration * nonCriticalExtension, Buffer::Iterator bIterator);
-  /**
-   * Deserialize cell identification function
-   *
-   * \param ci LteRrcSap::CellIdentification *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
-  Buffer::Iterator DeserializeCellIdentification (LteRrcSap::CellIdentification * ci, Buffer::Iterator bIterator);
-  /**
-   * Deserialize radio resource config common SCell function
-   *
-   * \param rrccsc LteRrcSap::RadioResourceConfigCommonSCell *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
-  Buffer::Iterator DeserializeRadioResourceConfigCommonSCell (LteRrcSap::RadioResourceConfigCommonSCell * rrccsc, Buffer::Iterator bIterator);
-  /**
-   * Deserialize radio resource config dedicated SCell function
-   *
-   * \param rrcdsc LteRrcSap::RadioResourceConfigDedicatedSCell *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
-  Buffer::Iterator DeserializeRadioResourceConfigDedicatedSCell (LteRrcSap::RadioResourceConfigDedicatedSCell * rrcdsc, Buffer::Iterator bIterator);
-  /**
-   * Deserialize physical config dedicated SCell function
-   *
-   * \param pcdsc LteRrcSap::PhysicalConfigDedicatedSCell *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
-  Buffer::Iterator DeserializePhysicalConfigDedicatedSCell (LteRrcSap::PhysicalConfigDedicatedSCell *pcdsc, Buffer::Iterator bIterator);
 
-  /**
-   * This function prints the object, for debugging purposes.
-   * @param os The output stream to use (i.e. std::cout)
-   */
   void Print (std::ostream &os) const;
   /**
    * This function prints RadioResourceConfigDedicated IE, for debugging purposes.
@@ -375,18 +115,7 @@
   void PreSerialize () const;
 
 protected:
-  /**
-   * Serialize UL DCCH message function
-   *
-   * \param msgType message type
-   */
   void SerializeUlDcchMessage (int msgType) const;
-  /**
-   * Deserialize UL DCCH message function
-   *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeUlDcchMessage (Buffer::Iterator bIterator);
 };
 
@@ -406,18 +135,7 @@
   void PreSerialize () const;
 
 protected:
-  /**
-   * Serialize DL DCCH message function
-   *
-   * \param msgType message type
-   */
   void SerializeDlDcchMessage (int msgType) const;
-  /**
-   * Deserialize DL DCCH message function
-   *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeDlDcchMessage (Buffer::Iterator bIterator);
 };
 
@@ -437,18 +155,7 @@
   void PreSerialize () const;
 
 protected:
-  /**
-   * Serialize UL CCCH message function
-   *
-   * \param msgType message type
-   */
   void SerializeUlCcchMessage (int msgType) const;
-  /**
-   * Deserialize DL CCCH message function
-   *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeUlCcchMessage (Buffer::Iterator bIterator);
 };
 
@@ -468,18 +175,7 @@
   void PreSerialize () const;
 
 protected:
-  /**
-   * Serialize DL CCCH message function
-   *
-   * \param msgType message type
-   */
   void SerializeDlCcchMessage (int msgType) const;
-  /**
-   * Deserialize DL CCCH message function
-   *
-   * \param bIterator buffer iterator
-   * \returns buffer iterator
-   */
   Buffer::Iterator DeserializeDlCcchMessage (Buffer::Iterator bIterator);
 };
 
@@ -492,12 +188,8 @@
   RrcConnectionRequestHeader ();
   ~RrcConnectionRequestHeader ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
   // Inherited from RrcAsn1Header 
+  static TypeId GetTypeId (void);
   void PreSerialize () const;
   uint32_t Deserialize (Buffer::Iterator bIterator);
   void Print (std::ostream &os) const;
@@ -526,16 +218,88 @@
    */
   std::bitset<32> GetMtmsi () const;
 
+  std::bitset<1> GetIsMc () const;
+
 private:
-  std::bitset<8> m_mmec; ///< MMEC
-  std::bitset<32> m_mTmsi; ///< TMSI
-  /// EstablishmentCause enumeration
+  std::bitset<8> m_mmec;
+  std::bitset<32> m_mTmsi;
   enum
   {
     EMERGENCY = 0, HIGHPRIORITYACCESS, MT_ACCESS,
     MO_SIGNALLING, MO_DATA, SPARE3, SPARE2, SPARE1
-  } m_establishmentCause; ///< the establishent cause
-  std::bitset<1> m_spare; ///< spare bit
+  } m_establishmentCause;
+  std::bitset<1> m_spare;
+};
+
+class RrcConnectToMmWaveHeader : public RrcDlCcchMessage
+{
+public:
+  RrcConnectToMmWaveHeader();
+  ~RrcConnectToMmWaveHeader();
+
+  // Inherited from RrcAsn1Header 
+  static TypeId GetTypeId (void);
+  void PreSerialize () const;
+  uint32_t Deserialize (Buffer::Iterator bIterator);
+  void Print (std::ostream &os) const;
+
+  /**
+   //TODO doc
+   */
+  void SetMessage (uint16_t mmWaveId);
+
+  uint16_t GetMessage () const;
+
+private:
+  std::bitset<16> m_mmWaveId;
+};
+
+class RrcNotifySecondaryConnectedHeader : public RrcUlDcchMessage
+{
+public:
+  RrcNotifySecondaryConnectedHeader();
+  ~RrcNotifySecondaryConnectedHeader();
+
+  // Inherited from RrcAsn1Header 
+  static TypeId GetTypeId (void);
+  void PreSerialize () const;
+  uint32_t Deserialize (Buffer::Iterator bIterator);
+  void Print (std::ostream &os) const;
+
+  /**
+   //TODO doc
+   */
+  void SetMessage (uint16_t mmWaveId, uint16_t mmWaveRnti);
+
+  std::pair<uint16_t, uint16_t> GetMessage () const;
+
+private:
+  std::bitset<16> m_mmWaveId;
+  std::bitset<16> m_mmWaveRnti;
+};
+
+class RrcConnectionSwitchHeader : public RrcDlDcchMessage
+{
+public:
+  RrcConnectionSwitchHeader();
+  ~RrcConnectionSwitchHeader();
+
+  // Inherited from RrcAsn1Header 
+  static TypeId GetTypeId (void);
+  void PreSerialize () const;
+  uint32_t Deserialize (Buffer::Iterator bIterator);
+  void Print (std::ostream &os) const;
+
+  /**
+   //TODO doc
+   */
+  void SetMessage (LteRrcSap::RrcConnectionSwitch msg);
+
+  LteRrcSap::RrcConnectionSwitch GetMessage () const;
+  uint8_t GetRrcTransactionIdentifier () const;
+
+private:
+  mutable LteRrcSap::RrcConnectionSwitch m_msg;
 };
 
 /**
@@ -607,8 +371,8 @@
   std::list<uint8_t> GetDrbToReleaseList () const;
 
 private:
-  uint8_t m_rrcTransactionIdentifier; ///< RRC transaction identifier
-  mutable LteRrcSap::RadioResourceConfigDedicated m_radioResourceConfigDedicated; ///< radio resource config dedicated
+  uint8_t m_rrcTransactionIdentifier;
+  mutable LteRrcSap::RadioResourceConfigDedicated m_radioResourceConfigDedicated;
 };
 
 /**
@@ -644,7 +408,7 @@
   uint8_t GetRrcTransactionIdentifier () const;
 
 private:
-  uint8_t m_rrcTransactionIdentifier; ///< RRC transaction identifier
+  uint8_t m_rrcTransactionIdentifier;
 
 };
 
@@ -681,7 +445,7 @@
   uint8_t GetRrcTransactionIdentifier () const;
 
 private:
-  uint8_t m_rrcTransactionIdentifier; ///< RRC transaction identifier
+  uint8_t m_rrcTransactionIdentifier;
 
 };
 
@@ -760,18 +524,6 @@
   LteRrcSap::RadioResourceConfigDedicated GetRadioResourceConfigDedicated () const; 
 
   /**
-  * Getter for m_haveNonCriticalExtension
-  * @return m_haveNonCriticalExtension
-  */
-  bool GetHaveNonCriticalExtensionConfig ();
-
-  /**
-  * Getter for m_nonCriticalExtension
-  * @return m_nonCriticalExtension
-  */
-  LteRrcSap::NonCriticalExtensionConfiguration GetNonCriticalExtensionConfig ();  
-
-  /**
   * Gets m_radioResourceConfigDedicated.havePhysicalConfigDedicated
   * @return m_radioResourceConfigDedicated.havePhysicalConfigDedicated
   */
@@ -802,15 +554,13 @@
   std::list<uint8_t> GetDrbToReleaseList () const;
 
 private:
-  uint8_t m_rrcTransactionIdentifier; ///< RRC transaction identifier
-  bool m_haveMeasConfig; ///< have measure config?
-  LteRrcSap::MeasConfig m_measConfig; ///< the measure config
-  bool m_haveMobilityControlInfo; ///< have mobility control info?
-  LteRrcSap::MobilityControlInfo m_mobilityControlInfo; ///< the modility control info
-  bool m_haveRadioResourceConfigDedicated; ///< have radio resource config dedicated?
-  LteRrcSap::RadioResourceConfigDedicated m_radioResourceConfigDedicated; ///< the radio resource config dedicated
-  bool m_haveNonCriticalExtension; ///< Have critical extension
-  LteRrcSap::NonCriticalExtensionConfiguration m_nonCriticalExtension; ///< the critical extension
+  uint8_t m_rrcTransactionIdentifier;
+  bool m_haveMeasConfig;
+  LteRrcSap::MeasConfig m_measConfig;
+  bool m_haveMobilityControlInfo;
+  LteRrcSap::MobilityControlInfo m_mobilityControlInfo;
+  bool m_haveRadioResourceConfigDedicated;
+  LteRrcSap::RadioResourceConfigDedicated m_radioResourceConfigDedicated;
 };
 
 /**
@@ -845,7 +595,7 @@
   LteRrcSap::AsConfig GetAsConfig () const;
 
 private:
-  LteRrcSap::AsConfig m_asConfig; ///< AS config
+  LteRrcSap::AsConfig m_asConfig;
 };
 
 /**
@@ -887,8 +637,8 @@
   LteRrcSap::ReestablishmentCause GetReestablishmentCause () const;
 
 private:
-  LteRrcSap::ReestabUeIdentity m_ueIdentity; ///< UE identity
-  LteRrcSap::ReestablishmentCause m_reestablishmentCause; ///< reestablishment cause
+  LteRrcSap::ReestabUeIdentity m_ueIdentity;
+  LteRrcSap::ReestablishmentCause m_reestablishmentCause;
 };
 
 /**
@@ -930,8 +680,8 @@
   LteRrcSap::RadioResourceConfigDedicated GetRadioResourceConfigDedicated () const;
 
 private:
-  uint8_t m_rrcTransactionIdentifier; ///< RRC transaction identifier
-  LteRrcSap::RadioResourceConfigDedicated m_radioResourceConfigDedicated; ///< radio resource config dedicated
+  uint8_t m_rrcTransactionIdentifier;
+  LteRrcSap::RadioResourceConfigDedicated m_radioResourceConfigDedicated;
 };
 
 /**
@@ -966,7 +716,7 @@
   uint8_t GetRrcTransactionIdentifier () const;
 
 private:
-  uint8_t m_rrcTransactionIdentifier; ///< RRC transaction identifier
+  uint8_t m_rrcTransactionIdentifier;
 };
 
 /**
@@ -996,7 +746,7 @@
   LteRrcSap::RrcConnectionReestablishmentReject GetMessage () const;
 
 private:
-  LteRrcSap::RrcConnectionReestablishmentReject m_rrcConnectionReestablishmentReject; ///< RRC connection reestablishmnet reject
+  LteRrcSap::RrcConnectionReestablishmentReject m_rrcConnectionReestablishmentReject;
 };
 
 /**
@@ -1026,7 +776,7 @@
   LteRrcSap::RrcConnectionRelease GetMessage () const;
 
 private:
-  LteRrcSap::RrcConnectionRelease m_rrcConnectionRelease; ///< RRC connection release
+  LteRrcSap::RrcConnectionRelease m_rrcConnectionRelease;
 };
 
 /**
@@ -1056,7 +806,7 @@
   LteRrcSap::RrcConnectionReject GetMessage () const;
 
 private:
-  LteRrcSap::RrcConnectionReject m_rrcConnectionReject; ///< RRC connection reject
+  LteRrcSap::RrcConnectionReject m_rrcConnectionReject;
 };
 
 /**
@@ -1086,7 +836,7 @@
   LteRrcSap::MeasurementReport GetMessage () const;
 
 private:
-  LteRrcSap::MeasurementReport m_measurementReport; ///< measurement report
+  LteRrcSap::MeasurementReport m_measurementReport;
 
 };
 
diff -Naru a/model/lte-rrc-protocol-ideal.cc b/model/lte-rrc-protocol-ideal.cc
--- a/model/lte-rrc-protocol-ideal.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rrc-protocol-ideal.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/fatal-error.h>
@@ -35,13 +39,7 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteRrcProtocolIdeal");
 
-/**
- * \ingroup lte
- *
- */
-
-/// RRC ideal message delay
-static const Time RRC_IDEAL_MSG_DELAY = MilliSeconds (0);
+static const Time RRC_IDEAL_MSG_DELAY = MicroSeconds (500);
 
 NS_OBJECT_ENSURE_REGISTERED (LteUeRrcProtocolIdeal);
 
@@ -171,9 +169,20 @@
 }
 
 void 
+LteUeRrcProtocolIdeal::DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+   Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+                        &LteEnbRrcSapProvider::RecvRrcSecondaryCellInitialAccessSuccessful,
+                        m_enbRrcSapProvider,
+                        m_rnti, 
+                        mmWaveRnti,
+                        mmWaveCellId);
+}
+
+void 
 LteUeRrcProtocolIdeal::SetEnbRrcSapProvider ()
 {
-  uint16_t cellId = m_rrc->GetCellId ();  
+uint16_t cellId = m_rrc->GetCellId ();  
 
   // walk list of all nodes to get the peer eNB
   Ptr<LteEnbNetDevice> enbDev;
@@ -196,7 +205,7 @@
             }
           else
             {
-              if (enbDev->HasCellId (cellId))
+              if (enbDev->GetCellId () == cellId)
                 {
                   found = true;          
                   break;
@@ -207,7 +216,8 @@
   NS_ASSERT_MSG (found, " Unable to find eNB with CellId =" << cellId);
   m_enbRrcSapProvider = enbDev->GetRrc ()->GetLteEnbRrcSapProvider ();  
   Ptr<LteEnbRrcProtocolIdeal> enbRrcProtocolIdeal = enbDev->GetRrc ()->GetObject<LteEnbRrcProtocolIdeal> ();
-  enbRrcProtocolIdeal->SetUeRrcSapProvider (m_rnti, m_ueRrcSapProvider);
+  enbRrcProtocolIdeal->SetUeRrcSapProvider (m_rnti, m_ueRrcSapProvider);  
+  
 }
 
 
@@ -329,9 +339,9 @@
 }
 
 void 
-LteEnbRrcProtocolIdeal::DoSendSystemInformation (uint16_t cellId, LteRrcSap::SystemInformation msg)
+LteEnbRrcProtocolIdeal::DoSendSystemInformation (LteRrcSap::SystemInformation msg)
 {
-  NS_LOG_FUNCTION (this << cellId);
+  NS_LOG_FUNCTION (this << m_cellId);
   // walk list of all nodes to get UEs with this cellId
   Ptr<LteUeRrc> ueRrc;
   for (NodeList::Iterator i = NodeList::Begin (); i != NodeList::End (); ++i)
@@ -345,7 +355,7 @@
             {
               Ptr<LteUeRrc> ueRrc = ueDev->GetRrc ();              
               NS_LOG_LOGIC ("considering UE IMSI " << ueDev->GetImsi () << " that has cellId " << ueRrc->GetCellId ());
-              if (ueRrc->GetCellId () == cellId)
+              if (ueRrc->GetCellId () == m_cellId)
                 {       
                   NS_LOG_LOGIC ("sending SI to IMSI " << ueDev->GetImsi ());
                   ueRrc->GetLteUeRrcSapProvider ()->RecvSystemInformation (msg);
@@ -413,6 +423,24 @@
 		       msg);
 }
 
+void 
+LteEnbRrcProtocolIdeal::DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg)
+{
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+           &LteUeRrcSapProvider::RecvRrcConnectionSwitch,
+           GetUeRrcSapProvider (rnti), 
+           msg);
+}
+
+void 
+LteEnbRrcProtocolIdeal::DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  Simulator::Schedule (RRC_IDEAL_MSG_DELAY, 
+           &LteUeRrcSapProvider::RecvRrcConnectToMmWave,
+           GetUeRrcSapProvider (rnti), 
+           mmWaveCellId);
+}
+
 /*
  * The purpose of LteEnbRrcProtocolIdeal is to avoid encoding
  * messages. In order to do so, we need to have some form of encoding for
@@ -425,10 +453,10 @@
  * 
  */
 
-static std::map<uint32_t, LteRrcSap::HandoverPreparationInfo> g_handoverPreparationInfoMsgMap; ///< handover preparation info message map
-static uint32_t g_handoverPreparationInfoMsgIdCounter = 0; ///< handover preparation info message ID counter
+static std::map<uint32_t, LteRrcSap::HandoverPreparationInfo> g_handoverPreparationInfoMsgMap;
+static uint32_t g_handoverPreparationInfoMsgIdCounter = 0;
 
-/**
+/*
  * This header encodes the map key discussed above. We keep this
  * private since it should not be used outside this file.
  * 
@@ -436,22 +464,8 @@
 class IdealHandoverPreparationInfoHeader : public Header
 {
 public:
-  /**
-   * Get the message ID function
-   *
-   * \returns the message ID
-   */
   uint32_t GetMsgId ();
-  /**
-   * Set the message ID function
-   *
-   * \param id the message ID 
-   */
   void SetMsgId (uint32_t id);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual void Print (std::ostream &os) const;
@@ -460,7 +474,7 @@
   virtual uint32_t Deserialize (Buffer::Iterator start);
 
 private:
-  uint32_t m_msgId; ///< message ID
+  uint32_t m_msgId;
 };
 
 uint32_t 
@@ -546,10 +560,10 @@
 
 
 
-static std::map<uint32_t, LteRrcSap::RrcConnectionReconfiguration> g_handoverCommandMsgMap; ///< handover command message map
-static uint32_t g_handoverCommandMsgIdCounter = 0; ///< handover command message ID counter
+static std::map<uint32_t, LteRrcSap::RrcConnectionReconfiguration> g_handoverCommandMsgMap;
+static uint32_t g_handoverCommandMsgIdCounter = 0;
 
-/**
+/*
  * This header encodes the map key discussed above. We keep this
  * private since it should not be used outside this file.
  * 
@@ -557,22 +571,8 @@
 class IdealHandoverCommandHeader : public Header
 {
 public:
-  /**
-   * Get the message ID function
-   *
-   * \returns the message ID
-   */
   uint32_t GetMsgId ();
-  /**
-   * Set the message ID function
-   *
-   * \param id the message ID
-   */
   void SetMsgId (uint32_t id);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
   virtual TypeId GetInstanceTypeId (void) const;
   virtual void Print (std::ostream &os) const;
@@ -581,7 +581,7 @@
   virtual uint32_t Deserialize (Buffer::Iterator start);
 
 private:
-  uint32_t m_msgId; ///< message ID
+  uint32_t m_msgId;
 };
 
 uint32_t 
diff -Naru a/model/lte-rrc-protocol-ideal.h b/model/lte-rrc-protocol-ideal.h
--- a/model/lte-rrc-protocol-ideal.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rrc-protocol-ideal.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,6 +17,9 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -38,8 +42,6 @@
 
 
 /**
- * \ingroup lte
- *
  * Models the transmission of RRC messages from the UE to the eNB in
  * an ideal fashion, without errors and without consuming any radio
  * resources. 
@@ -47,7 +49,6 @@
  */
 class LteUeRrcProtocolIdeal : public Object
 {
-  /// allow MemberLteUeRrcSapUser<LteUeRrcProtocolIdeal> class friend access
   friend class MemberLteUeRrcSapUser<LteUeRrcProtocolIdeal>;
 
 public:
@@ -57,87 +58,32 @@
 
   // inherited from Object
   virtual void DoDispose (void);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  /**
-   * Set LTE UE RRC SAP provider function
-   *
-   * \param p LTE UE RRC SAP provider
-   */
   void SetLteUeRrcSapProvider (LteUeRrcSapProvider* p);
-  /**
-   * Get LTE UE RRC SAP user function
-   *
-   * \returns LTE UE RRC SAP user
-   */
   LteUeRrcSapUser* GetLteUeRrcSapUser ();
   
-  /**
-   * Set LTE UE RRC  function
-   *
-   * \param rrc LTE UE RRC 
-   */
   void SetUeRrc (Ptr<LteUeRrc> rrc);
   
 
 private:
 
   // methods forwarded from LteUeRrcSapUser
-  /**
-   * Setup function
-   *
-   * \param params LteUeRrcSapUser::SetupParameters 
-   */
   void DoSetup (LteUeRrcSapUser::SetupParameters params);
-  /**
-   * Send RRC connection request function
-   *
-   * \param msg LteRrcSap::RrcConnectionRequest 
-   */
   void DoSendRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg);
-  /**
-   * Send RRC connection setup completed function
-   *
-   * \param msg LteRrcSap::RrcConnectionSetupCompleted 
-   */
   void DoSendRrcConnectionSetupCompleted (LteRrcSap::RrcConnectionSetupCompleted msg);
-  /**
-   * Send RRC connection reconfiguration completed function
-   *
-   * \param msg LteRrcSap::RrcConnectionReconfigurationCompleted 
-   */
   void DoSendRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg);
-  /**
-   * Send RRC connection reestablishment request function
-   *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest 
-   */
   void DoSendRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg);
-  /**
-   * Send RRC connection reestablishment complete function
-   *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest 
-   */
   void DoSendRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg);
-  /**
-   * Send measurement report function
-   *
-   * \param msg LteRrcSap::MeasurementReport 
-   */
   void DoSendMeasurementReport (LteRrcSap::MeasurementReport msg);
-
-  /// Set ENB RRC SAP provider
+  void DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
   void SetEnbRrcSapProvider ();
 
-  Ptr<LteUeRrc> m_rrc; ///< the RRC
-  uint16_t m_rnti; ///< the RNTI
-  LteUeRrcSapProvider* m_ueRrcSapProvider; ///< the UE RRC SAP provider
-  LteUeRrcSapUser* m_ueRrcSapUser; ///< the RRC SAP user
-  LteEnbRrcSapProvider* m_enbRrcSapProvider; ///< the ENB RRC SAP provider
+  Ptr<LteUeRrc> m_rrc;
+  uint16_t m_rnti;
+  LteUeRrcSapProvider* m_ueRrcSapProvider;
+  LteUeRrcSapUser* m_ueRrcSapUser;
+  LteEnbRrcSapProvider* m_enbRrcSapProvider;
   
 };
 
@@ -150,7 +96,6 @@
  */
 class LteEnbRrcProtocolIdeal : public Object
 {
-  /// allow MemberLteEnbRrcSapUser<LteEnbRrcProtocolIdeal> class friend access
   friend class MemberLteEnbRrcSapUser<LteEnbRrcProtocolIdeal>;
 
 public:
@@ -160,153 +105,42 @@
 
   // inherited from Object
   virtual void DoDispose (void);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  /**
-   * Set LTE ENB RRC SAP provider function
-   *
-   * \param p the LTE ENB RRC SAP provider 
-   */
   void SetLteEnbRrcSapProvider (LteEnbRrcSapProvider* p);
-  /**
-   * Get LTE ENB RRC SAP user function
-   *
-   * \returns LTE ENB RRC SAP user
-   */
   LteEnbRrcSapUser* GetLteEnbRrcSapUser ();
 
-  /**
-   * Set the cell ID function
-   *
-   * \param cellId the cell ID 
-   */
   void SetCellId (uint16_t cellId);
 
-  /**
-   * Get LTE UE RRC SAP provider function
-   *
-   * \param rnti the RNTI
-   * \returns LTE UE RRC SAP provider
-   */
   LteUeRrcSapProvider* GetUeRrcSapProvider (uint16_t rnti);
-  /**
-   * Set UE RRC SAP provider function
-   *
-   * \param rnti the RNTI
-   * \param p the UE RRC SAP provider 
-   */
   void SetUeRrcSapProvider (uint16_t rnti, LteUeRrcSapProvider* p);
 
 private:
 
   // methods forwarded from LteEnbRrcSapUser
-  /**
-   * Setup UE function
-   *
-   * \param rnti the RNTI
-   * \param params LteEnbRrcSapUser::SetupUeParameters 
-   */
   void DoSetupUe (uint16_t rnti, LteEnbRrcSapUser::SetupUeParameters params);
-  /**
-   * Remove UE function
-   *
-   * \param rnti the RNTI
-   */
   void DoRemoveUe (uint16_t rnti);
-  /**
-   * Send system information function
-   *
-   * \param cellId cell ID
-   * \param msg LteRrcSap::SystemInformation
-   */
-  void DoSendSystemInformation (uint16_t cellId, LteRrcSap::SystemInformation msg);
-  /**
-   * Send system information function
-   *
-   * \param msg LteRrcSap::SystemInformation
-   */
+  void DoSendSystemInformation (LteRrcSap::SystemInformation msg);
   void SendSystemInformation (LteRrcSap::SystemInformation msg);
-  /**
-   * Send RRC connection setup function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionSetup
-   */
   void DoSendRrcConnectionSetup (uint16_t rnti, LteRrcSap::RrcConnectionSetup msg);
-  /**
-   * Send RRC connection reconfiguration function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReconfiguration
-   */
   void DoSendRrcConnectionReconfiguration (uint16_t rnti, LteRrcSap::RrcConnectionReconfiguration msg);
-  /**
-   * Send RRC connection reestablishment function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReestablishment
-   */
   void DoSendRrcConnectionReestablishment (uint16_t rnti, LteRrcSap::RrcConnectionReestablishment msg);
-  /**
-   * Send RRC connection reestablishment reject function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReestablishmentReject
-   */
   void DoSendRrcConnectionReestablishmentReject (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentReject msg);
-  /**
-   * Send RRC connection release function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionRelease
-   */
   void DoSendRrcConnectionRelease (uint16_t rnti, LteRrcSap::RrcConnectionRelease msg);
-  /**
-   * Send RRC connection reject function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReject
-   */
   void DoSendRrcConnectionReject (uint16_t rnti, LteRrcSap::RrcConnectionReject msg);
-  /**
-   * Encode handover preparation information function
-   *
-   * \param msg LteRrcSap::HandoverPreparationInfo
-   * \returns the packet
-   */
+  void DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg);
+  void DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId);
   Ptr<Packet> DoEncodeHandoverPreparationInformation (LteRrcSap::HandoverPreparationInfo msg);
-  /**
-   * Encode handover preparation information function
-   *
-   * \param p the packet
-   * \returns LteRrcSap::HandoverPreparationInfo
-   */
   LteRrcSap::HandoverPreparationInfo DoDecodeHandoverPreparationInformation (Ptr<Packet> p);
-  /**
-   * Encode handover command function
-   *
-   * \param msg LteRrcSap::RrcConnectionReconfiguration
-   * \returns rnti the RNTI
-   */
   Ptr<Packet> DoEncodeHandoverCommand (LteRrcSap::RrcConnectionReconfiguration msg);
-  /**
-   * Decode handover command function
-   *
-   * \param p the packet
-   * \returns LteRrcSap::RrcConnectionReconfiguration
-   */
   LteRrcSap::RrcConnectionReconfiguration DoDecodeHandoverCommand (Ptr<Packet> p);
 
 
-  uint16_t m_rnti; ///< the RNTI
-  uint16_t m_cellId; ///< the cell ID
-  LteEnbRrcSapProvider* m_enbRrcSapProvider; ///< the ENB RRC SAP provider
-  LteEnbRrcSapUser* m_enbRrcSapUser; ///< the ENB RRC SAP user
-  std::map<uint16_t, LteUeRrcSapProvider*> m_enbRrcSapProviderMap; ///< the LTE UE RRC SAP provider
+  uint16_t m_rnti;
+  uint16_t m_cellId;
+  LteEnbRrcSapProvider* m_enbRrcSapProvider;
+  LteEnbRrcSapUser* m_enbRrcSapUser;
+  std::map<uint16_t, LteUeRrcSapProvider*> m_enbRrcSapProviderMap;
   
 };
 
diff -Naru a/model/lte-rrc-protocol-real.cc b/model/lte-rrc-protocol-real.cc
--- a/model/lte-rrc-protocol-real.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rrc-protocol-real.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Lluis Parcerisa <lparcerisa@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/fatal-error.h>
@@ -36,8 +40,7 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteRrcProtocolReal");
 
-/// RRC real message delay
-const Time RRC_REAL_MSG_DELAY = MilliSeconds (0); 
+const Time RRC_REAL_MSG_DELAY = MicroSeconds (500); 
 
 NS_OBJECT_ENSURE_REGISTERED (LteUeRrcProtocolReal);
 
@@ -111,19 +114,26 @@
   m_rnti = m_rrc->GetRnti ();
   SetEnbRrcSapProvider ();
 
-  Ptr<Packet> packet = Create<Packet> ();
-
-  RrcConnectionRequestHeader rrcConnectionRequestHeader;
-  rrcConnectionRequestHeader.SetMessage (msg);
-
-  packet->AddHeader (rrcConnectionRequestHeader);
-
-  LteRlcSapProvider::TransmitPdcpPduParameters transmitPdcpPduParameters;
-  transmitPdcpPduParameters.pdcpPdu = packet;
-  transmitPdcpPduParameters.rnti = m_rnti;
-  transmitPdcpPduParameters.lcid = 0;
+  Simulator::Schedule (RRC_REAL_MSG_DELAY, 
+                       &LteEnbRrcSapProvider::RecvRrcConnectionRequest,
+                       m_enbRrcSapProvider,
+                       m_rnti, 
+                       msg);
+
+  // real RRC code
+  // Ptr<Packet> packet = Create<Packet> ();
+
+  // RrcConnectionRequestHeader rrcConnectionRequestHeader;
+  // rrcConnectionRequestHeader.SetMessage (msg);
+
+  // packet->AddHeader (rrcConnectionRequestHeader);
+
+  // LteRlcSapProvider::TransmitPdcpPduParameters transmitPdcpPduParameters;
+  // transmitPdcpPduParameters.pdcpPdu = packet;
+  // transmitPdcpPduParameters.rnti = m_rnti;
+  // transmitPdcpPduParameters.lcid = 0;
 
-  m_setupParameters.srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+  // m_setupParameters.srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
 }
 
 void 
@@ -166,7 +176,7 @@
   transmitPdcpSduParameters.pdcpSdu = packet;
   transmitPdcpSduParameters.rnti = m_rnti;
   transmitPdcpSduParameters.lcid = 1;
-
+  NS_LOG_INFO("Tx RRC Connection reconf completed");
   m_setupParameters.srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
 }
 
@@ -194,6 +204,28 @@
 }
 
 void 
+LteUeRrcProtocolReal::DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_rnti = m_rrc->GetRnti ();
+  SetEnbRrcSapProvider ();
+
+  Ptr<Packet> packet = Create<Packet> ();
+
+  RrcNotifySecondaryConnectedHeader rrcNotifyHeader;
+  rrcNotifyHeader.SetMessage (mmWaveCellId, mmWaveRnti);
+
+  packet->AddHeader (rrcNotifyHeader);
+
+  LtePdcpSapProvider::TransmitPdcpSduParameters transmitPdcpSduParameters;
+  transmitPdcpSduParameters.pdcpSdu = packet;
+  transmitPdcpSduParameters.rnti = m_rnti;
+  transmitPdcpSduParameters.lcid = 1;
+
+  m_setupParameters.srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
+}
+
+
+void 
 LteUeRrcProtocolReal::DoSendRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg)
 {
   Ptr<Packet> packet = Create<Packet> ();
@@ -256,7 +288,7 @@
             }
           else
             {
-              if (enbDev->HasCellId (cellId))
+              if (enbDev->GetCellId () == cellId)
                 {
                   found = true;
                   break;
@@ -282,6 +314,7 @@
   RrcConnectionReestablishmentRejectHeader rrcConnectionReestablishmentRejectHeader;
   RrcConnectionSetupHeader rrcConnectionSetupHeader;
   RrcConnectionRejectHeader rrcConnectionRejectHeader;
+  RrcConnectToMmWaveHeader rrcConnectToMmWaveHeader;
 
   // Declare possible messages
   LteRrcSap::RrcConnectionReestablishment rrcConnectionReestablishmentMsg;
@@ -316,6 +349,12 @@
       rrcConnectionSetupMsg = rrcConnectionSetupHeader.GetMessage ();
       m_ueRrcSapProvider->RecvRrcConnectionSetup (rrcConnectionSetupMsg);
       break;
+    case 4:
+      // RrcConnectToMmWave
+      p->RemoveHeader (rrcConnectToMmWaveHeader);
+      uint16_t mmWaveCellId = rrcConnectToMmWaveHeader.GetMessage ();
+      m_ueRrcSapProvider->RecvRrcConnectToMmWave(mmWaveCellId);
+      break;
     }
 }
 
@@ -329,11 +368,12 @@
   // Declare possible headers to receive
   RrcConnectionReconfigurationHeader rrcConnectionReconfigurationHeader;
   RrcConnectionReleaseHeader rrcConnectionReleaseHeader;
+  RrcConnectionSwitchHeader rrcSwitchHeader;
 
   // Declare possible messages to receive
   LteRrcSap::RrcConnectionReconfiguration rrcConnectionReconfigurationMsg;
   LteRrcSap::RrcConnectionRelease rrcConnectionReleaseMsg;
-
+  LteRrcSap::RrcConnectionSwitch rrcConnectionSwitchMsg;
   // Deserialize packet and call member recv function with appropiate structure
   switch ( rrcDlDcchMessage.GetMessageType () )
     {
@@ -347,6 +387,11 @@
       rrcConnectionReleaseMsg = rrcConnectionReleaseHeader.GetMessage ();
       //m_ueRrcSapProvider->RecvRrcConnectionRelease (rrcConnectionReleaseMsg);
       break;
+    case 6:
+      params.pdcpSdu->RemoveHeader (rrcSwitchHeader);
+      rrcConnectionSwitchMsg = rrcSwitchHeader.GetMessage ();
+      m_ueRrcSapProvider->RecvRrcConnectionSwitch (rrcConnectionSwitchMsg);
+      break;
     }
 }
 
@@ -504,9 +549,9 @@
 }
 
 void 
-LteEnbRrcProtocolReal::DoSendSystemInformation (uint16_t cellId, LteRrcSap::SystemInformation msg)
+LteEnbRrcProtocolReal::DoSendSystemInformation (LteRrcSap::SystemInformation msg)
 {
-  NS_LOG_FUNCTION (this << cellId);
+    NS_LOG_FUNCTION (this << m_cellId);
   // walk list of all nodes to get UEs with this cellId
   Ptr<LteUeRrc> ueRrc;
   for (NodeList::Iterator i = NodeList::Begin (); i != NodeList::End (); ++i)
@@ -520,7 +565,7 @@
             {
               Ptr<LteUeRrc> ueRrc = ueDev->GetRrc ();
               NS_LOG_LOGIC ("considering UE IMSI " << ueDev->GetImsi () << " that has cellId " << ueRrc->GetCellId ());
-              if (ueRrc->GetCellId () == cellId)
+              if (ueRrc->GetCellId () == m_cellId)
                 {
                   NS_LOG_LOGIC ("sending SI to IMSI " << ueDev->GetImsi ());
                   ueRrc->GetLteUeRrcSapProvider ()->RecvSystemInformation (msg);
@@ -531,7 +576,7 @@
                 }
             }
         }
-    } 
+    }
 }
 
 void 
@@ -549,7 +594,15 @@
   transmitPdcpPduParameters.rnti = rnti;
   transmitPdcpPduParameters.lcid = 0;
 
-  m_setupUeParametersMap.at (rnti).srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+  if (m_setupUeParametersMap.find (rnti) == m_setupUeParametersMap.end () )
+    {
+      NS_LOG_ERROR("RNTI not found in Enb setup parameters Map!");
+    }
+  else
+    {
+      NS_LOG_INFO("Queue RRC connection setup " << packet << " rnti " << rnti << " cellId " << m_cellId);
+      m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+    }
 }
 
 void 
@@ -570,6 +623,43 @@
   m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
 }
 
+
+void 
+LteEnbRrcProtocolReal::DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg)
+{
+  Ptr<Packet> packet = Create<Packet> ();
+
+  RrcConnectionSwitchHeader rrcSwitchHeader;
+  rrcSwitchHeader.SetMessage (msg);
+
+  packet->AddHeader (rrcSwitchHeader);
+
+  LtePdcpSapProvider::TransmitPdcpSduParameters transmitPdcpSduParameters;
+  transmitPdcpSduParameters.pdcpSdu = packet;
+  transmitPdcpSduParameters.rnti = rnti;
+  transmitPdcpSduParameters.lcid = 1;
+
+  m_setupUeParametersMap[rnti].srb1SapProvider->TransmitPdcpSdu (transmitPdcpSduParameters);
+}
+
+void 
+LteEnbRrcProtocolReal::DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveId)
+{
+  Ptr<Packet> packet = Create<Packet> ();
+
+  RrcConnectToMmWaveHeader connectToMmWaveHeader;
+  connectToMmWaveHeader.SetMessage(mmWaveId);
+
+  packet->AddHeader (connectToMmWaveHeader);
+
+  LteRlcSapProvider::TransmitPdcpPduParameters transmitPdcpPduParameters;
+  transmitPdcpPduParameters.pdcpPdu = packet;
+  transmitPdcpPduParameters.rnti = rnti;
+  transmitPdcpPduParameters.lcid = 0;
+
+  m_setupUeParametersMap[rnti].srb0SapProvider->TransmitPdcpPdu (transmitPdcpPduParameters);
+}
+
 void 
 LteEnbRrcProtocolReal::DoSendRrcConnectionReconfiguration (uint16_t rnti, LteRrcSap::RrcConnectionReconfiguration msg)
 {
@@ -683,6 +773,7 @@
   RrcConnectionReconfigurationCompleteHeader rrcConnectionReconfigurationCompleteHeader;
   RrcConnectionReestablishmentCompleteHeader rrcConnectionReestablishmentCompleteHeader;
   RrcConnectionSetupCompleteHeader rrcConnectionSetupCompleteHeader;
+  RrcNotifySecondaryConnectedHeader rrcNotifyHeader;
 
   // Declare possible messages to receive
   LteRrcSap::MeasurementReport measurementReportMsg;
@@ -713,6 +804,12 @@
       rrcConnectionSetupCompletedMsg = rrcConnectionSetupCompleteHeader.GetMessage ();
       m_enbRrcSapProvider->RecvRrcConnectionSetupCompleted (params.rnti, rrcConnectionSetupCompletedMsg);
       break;
+    case 5:
+      params.pdcpSdu->RemoveHeader (rrcNotifyHeader);
+      std::pair<uint16_t, uint16_t> rrcNotifyPair;
+      rrcNotifyPair = rrcNotifyHeader.GetMessage ();
+      m_enbRrcSapProvider->RecvRrcSecondaryCellInitialAccessSuccessful (params.rnti, rrcNotifyPair.second, rrcNotifyPair.first);
+      break;
     }
 }
 
diff -Naru a/model/lte-rrc-protocol-real.h b/model/lte-rrc-protocol-real.h
--- a/model/lte-rrc-protocol-real.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rrc-protocol-real.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Lluis Parcerisa <lparcerisa@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -42,8 +46,6 @@
 
 
 /**
- * \ingroup lte
- *
  * Models the transmission of RRC messages from the UE to the eNB in
  * a real fashion, by creating real RRC PDUs and transmitting them
  * over Signaling Radio Bearers using radio resources allocated by the
@@ -52,11 +54,8 @@
  */
 class LteUeRrcProtocolReal : public Object
 {
-  /// allow MemberLteUeRrcSapUser<LteUeRrcProtocolReal> class friend access
   friend class MemberLteUeRrcSapUser<LteUeRrcProtocolReal>;
-  /// allow LteRlcSpecificLteRlcSapUser<LteUeRrcProtocolReal> class friend access
   friend class LteRlcSpecificLteRlcSapUser<LteUeRrcProtocolReal>;
-  /// allow LtePdcpSpecificLtePdcpSapUser<LteUeRrcProtocolReal> class friend access
   friend class LtePdcpSpecificLtePdcpSapUser<LteUeRrcProtocolReal>;
 
 public:
@@ -65,101 +64,37 @@
 
   // inherited from Object
   virtual void DoDispose (void);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  /**
-   * Set LTE UE RRC SAP provider function
-   *
-   * \param p the LTE UE RRC SAP provider 
-   */
   void SetLteUeRrcSapProvider (LteUeRrcSapProvider* p);
-  /**
-   * Get LTE UE RRC SAP user function
-   *
-   * \returns LTE UE RRC SAP user
-   */
   LteUeRrcSapUser* GetLteUeRrcSapUser ();
 
-  /**
-   * Set UE RRC function
-   *
-   * \param rrc the LTE UE RRC 
-   */
   void SetUeRrc (Ptr<LteUeRrc> rrc);
 
 
 private:
   // methods forwarded from LteUeRrcSapUser
-  /**
-   * Setup function
-   *
-   * \param params LteUeRrcSapUser::SetupParameters 
-   */
   void DoSetup (LteUeRrcSapUser::SetupParameters params);
-  /**
-   * Send RRC connection request function
-   *
-   * \param msg LteRrcSap::RrcConnectionRequest 
-   */
   void DoSendRrcConnectionRequest (LteRrcSap::RrcConnectionRequest msg);
-  /**
-   * Send RRC connection setup completed function
-   *
-   * \param msg LteRrcSap::RrcConnectionSetupCompleted 
-   */
   void DoSendRrcConnectionSetupCompleted (LteRrcSap::RrcConnectionSetupCompleted msg);
-  /**
-   * Send RRC connection reconfiguration setup completed function
-   *
-   * \param msg LteRrcSap::RrcConnectionReconfigurationCompleted 
-   */
   void DoSendRrcConnectionReconfigurationCompleted (LteRrcSap::RrcConnectionReconfigurationCompleted msg);
-  /**
-   * Send RRC connection reestablishment request function
-   *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentRequest 
-   */
   void DoSendRrcConnectionReestablishmentRequest (LteRrcSap::RrcConnectionReestablishmentRequest msg);
-  /**
-   * Send RRC connection reestablishment complete function
-   *
-   * \param msg LteRrcSap::RrcConnectionReestablishmentComplete 
-   */
   void DoSendRrcConnectionReestablishmentComplete (LteRrcSap::RrcConnectionReestablishmentComplete msg);
-  /**
-   * Send measurement report function
-   *
-   * \param msg LteRrcSap::MeasurementReport 
-   */
   void DoSendMeasurementReport (LteRrcSap::MeasurementReport msg);
+  void DoSendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
-  /// Set ENB RRC SAP provider
   void SetEnbRrcSapProvider ();
-  /**
-   * Receive PDCP PDU function
-   *
-   * \param p the packet 
-   */
   void DoReceivePdcpPdu (Ptr<Packet> p);
-  /**
-   * Receive PDCP SDU function
-   *
-   * \param params LtePdcpSapUser::ReceivePdcpSduParameters 
-   */
   void DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params);
 
-  Ptr<LteUeRrc> m_rrc; ///< the RRC
-  uint16_t m_rnti; ///< the RNTI
-  LteUeRrcSapProvider* m_ueRrcSapProvider; ///< UE RRC SAP provider
-  LteUeRrcSapUser* m_ueRrcSapUser; ///< UE RRC SAP user
-  LteEnbRrcSapProvider* m_enbRrcSapProvider; ///< ENB RRC SAP provider
+  Ptr<LteUeRrc> m_rrc;
+  uint16_t m_rnti;
+  LteUeRrcSapProvider* m_ueRrcSapProvider;
+  LteUeRrcSapUser* m_ueRrcSapUser;
+  LteEnbRrcSapProvider* m_enbRrcSapProvider;
 
-  LteUeRrcSapUser::SetupParameters m_setupParameters; ///< setup parameters
-  LteUeRrcSapProvider::CompleteSetupParameters m_completeSetupParameters; ///< complete setup parameters
+  LteUeRrcSapUser::SetupParameters m_setupParameters;
+  LteUeRrcSapProvider::CompleteSetupParameters m_completeSetupParameters;
 
 };
 
@@ -173,13 +108,9 @@
  */
 class LteEnbRrcProtocolReal : public Object
 {
-  /// allow MemberLteEnbRrcSapUser<LteEnbRrcProtocolReal> class friend access
   friend class MemberLteEnbRrcSapUser<LteEnbRrcProtocolReal>;
-  /// allow LtePdcpSpecificLtePdcpSapUser<LteEnbRrcProtocolReal> class friend access
   friend class LtePdcpSpecificLtePdcpSapUser<LteEnbRrcProtocolReal>;
-  /// allow LteRlcSpecificLteRlcSapUser<LteEnbRrcProtocolReal> class friend access
   friend class LteRlcSpecificLteRlcSapUser<LteEnbRrcProtocolReal>;
-  /// allow RealProtocolRlcSapUser class friend access
   friend class RealProtocolRlcSapUser;
 
 public:
@@ -188,182 +119,53 @@
 
   // inherited from Object
   virtual void DoDispose (void);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  /**
-   * Set LTE ENB RRC SAP provider function
-   *
-   * \param p LteEnbRrcSapProvider * 
-   */
   void SetLteEnbRrcSapProvider (LteEnbRrcSapProvider* p);
-  /**
-   * Get LTE ENB RRC SAP user function
-   *
-   * \returns LteEnbRrcSapUser * 
-   */
   LteEnbRrcSapUser* GetLteEnbRrcSapUser ();
 
-  /**
-   * Set cell ID function
-   *
-   * \param cellId the cell ID 
-   */
   void SetCellId (uint16_t cellId);
 
-  /**
-   * Get UE RRC SAP provider function
-   *
-   * \param rnti the RNTI
-   * \returns LteUeRrcSapProvider * 
-   */
   LteUeRrcSapProvider* GetUeRrcSapProvider (uint16_t rnti);
-  /**
-   * Set UE RRC SAP provider function
-   *
-   * \param rnti the RNTI
-   * \param p LteUeRrcSapProvider *
-   */
   void SetUeRrcSapProvider (uint16_t rnti, LteUeRrcSapProvider* p);
 
 private:
   // methods forwarded from LteEnbRrcSapUser
-  /**
-   * Setup UE function
-   *
-   * \param rnti the RNTI
-   * \param params LteEnbRrcSapUser::SetupUeParameters
-   */
   void DoSetupUe (uint16_t rnti, LteEnbRrcSapUser::SetupUeParameters params);
-  /**
-   * Remove UE function
-   *
-   * \param rnti the RNTI
-   */
   void DoRemoveUe (uint16_t rnti);
-  /**
-   * Send system information function
-   *
-   * \param cellId cell ID
-   * \param msg LteRrcSap::SystemInformation
-   */
-  void DoSendSystemInformation (uint16_t cellId, LteRrcSap::SystemInformation msg);
-  /**
-   * Send system information function
-   *
-   * \param cellId cell ID
-   * \param msg LteRrcSap::SystemInformation
-   */
-  void SendSystemInformation (uint16_t cellId, LteRrcSap::SystemInformation msg);
-  /**
-   * Send RRC connection setup function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionSetup
-   */
+  void DoSendSystemInformation (LteRrcSap::SystemInformation msg);
+  void SendSystemInformation (LteRrcSap::SystemInformation msg);
   void DoSendRrcConnectionSetup (uint16_t rnti, LteRrcSap::RrcConnectionSetup msg);
-  /**
-   * Send RRC connection reconfiguration function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReconfiguration
-   */
   void DoSendRrcConnectionReconfiguration (uint16_t rnti, LteRrcSap::RrcConnectionReconfiguration msg);
-  /**
-   * Send RRC connection reestabishment function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReestablishment
-   */
   void DoSendRrcConnectionReestablishment (uint16_t rnti, LteRrcSap::RrcConnectionReestablishment msg);
-  /**
-   * Send RRC connection reestabishment reject function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReestablishmentReject
-   */
   void DoSendRrcConnectionReestablishmentReject (uint16_t rnti, LteRrcSap::RrcConnectionReestablishmentReject msg);
-  /**
-   * Send RRC connection release function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionRelease
-   */
   void DoSendRrcConnectionRelease (uint16_t rnti, LteRrcSap::RrcConnectionRelease msg);
-  /**
-   * Send RRC connection reject function
-   *
-   * \param rnti the RNTI
-   * \param msg LteRrcSap::RrcConnectionReject
-   */
   void DoSendRrcConnectionReject (uint16_t rnti, LteRrcSap::RrcConnectionReject msg);
-  /**
-   * Encode handover preparation information function
-   *
-   * \param msg LteRrcSap::HandoverPreparationInfo
-   * \returns the packet
-   */
+  void DoSendRrcConnectionSwitch (uint16_t rnti, LteRrcSap::RrcConnectionSwitch msg);
+  void DoSendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId);
   Ptr<Packet> DoEncodeHandoverPreparationInformation (LteRrcSap::HandoverPreparationInfo msg);
-  /**
-   * Decode handover preparation information function
-   *
-   * \param p the packet
-   * \returns LteRrcSap::HandoverPreparationInfo
-   */
   LteRrcSap::HandoverPreparationInfo DoDecodeHandoverPreparationInformation (Ptr<Packet> p);
-  /**
-   * Encode handover command function
-   *
-   * \param msg LteRrcSap::RrcConnectionReconfiguration
-   * \returns the packet
-   */
   Ptr<Packet> DoEncodeHandoverCommand (LteRrcSap::RrcConnectionReconfiguration msg);
-  /**
-   * Decode handover command function
-   *
-   * \param p the packet
-   * \returns LteRrcSap::RrcConnectionReconfiguration
-   */
   LteRrcSap::RrcConnectionReconfiguration DoDecodeHandoverCommand (Ptr<Packet> p);
 
-  /**
-   * Receive PDCP SDU function
-   *
-   * \param params LtePdcpSapUser::ReceivePdcpSduParameters
-   */
   void DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params);
-  /**
-   * Receive PDCP PDU function
-   *
-   * \param rnti the RNTI
-   * \param p the packet
-   */
   void DoReceivePdcpPdu (uint16_t rnti, Ptr<Packet> p);
 
-  uint16_t m_rnti; ///< the RNTI
-  uint16_t m_cellId; ///< the cell ID
-  LteEnbRrcSapProvider* m_enbRrcSapProvider; ///< ENB RRC SAP provider
-  LteEnbRrcSapUser* m_enbRrcSapUser; ///< ENB RRC SAP user
-  std::map<uint16_t, LteUeRrcSapProvider*> m_enbRrcSapProviderMap; ///< ENB RRC SAP provider map
-  std::map<uint16_t, LteEnbRrcSapUser::SetupUeParameters> m_setupUeParametersMap; ///< setup UE parameters map
-  std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters> m_completeSetupUeParametersMap; ///< complete setup UE parameters map
+  uint16_t m_rnti;
+  uint16_t m_cellId;
+  LteEnbRrcSapProvider* m_enbRrcSapProvider;
+  LteEnbRrcSapUser* m_enbRrcSapUser;
+  std::map<uint16_t, LteUeRrcSapProvider*> m_enbRrcSapProviderMap;
+  std::map<uint16_t, LteEnbRrcSapUser::SetupUeParameters> m_setupUeParametersMap;
+  std::map<uint16_t, LteEnbRrcSapProvider::CompleteSetupUeParameters> m_completeSetupUeParametersMap;
 
 };
 
+///////////////////////////////////////
 
-/// RealProtocolRlcSapUser class
 class RealProtocolRlcSapUser : public LteRlcSapUser
 {
 public:
-  /**
-   * Real protocol RC SAP user
-   *
-   * \param pdcp LteEnbRrcProtocolReal *
-   * \param rnti the RNTI
-   */
   RealProtocolRlcSapUser (LteEnbRrcProtocolReal* pdcp, uint16_t rnti);
 
   // Interface implemented from LteRlcSapUser
@@ -371,8 +173,8 @@
 
 private:
   RealProtocolRlcSapUser ();
-  LteEnbRrcProtocolReal* m_pdcp; ///< PDCP
-  uint16_t m_rnti; ///< RNTI
+  LteEnbRrcProtocolReal* m_pdcp;
+  uint16_t m_rnti;
 };
 
 
diff -Naru a/model/lte-rrc-sap.h b/model/lte-rrc-sap.h
--- a/model/lte-rrc-sap.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-rrc-sap.h	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Authors: Nicola Baldo <nbaldo@cttc.es>
  *          Lluis Parcerisa <lparcerisa@cttc.cat>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -58,106 +62,95 @@
 public:
   virtual ~LteRrcSap ();
 
-  /// Constraint values
+  // Constraint values
+
   static const uint8_t MaxReportCells = 255;
 
   // Information Elements
-  /// PlmnIdentityInfo structure
+
   struct PlmnIdentityInfo
   {
-    uint32_t plmnIdentity; ///< PLMN identity
+    uint32_t plmnIdentity;
   };
 
-  /// CellAccessRelatedInfo structure
   struct CellAccessRelatedInfo
   {
-    PlmnIdentityInfo plmnIdentityInfo; ///< PLMN identity info
-    uint32_t cellIdentity; ///< cell identity
-    bool csgIndication; ///< CSG indication
-    uint32_t csgIdentity; ///< CSG identity
+    PlmnIdentityInfo plmnIdentityInfo;
+    uint32_t cellIdentity;
+    bool csgIndication;
+    uint32_t csgIdentity;
   };
 
-  /// CellSelectionInfo structure
   struct CellSelectionInfo
   {
     int8_t qRxLevMin; ///< INTEGER (-70..-22), actual value = IE value * 2 [dBm].
     int8_t qQualMin; ///< INTEGER (-34..-3), actual value = IE value [dB].
   };
 
-  /// FreqInfo structure
   struct FreqInfo
   {
-    uint32_t ulCarrierFreq; ///< UL carrier frequency
-    uint8_t ulBandwidth; ///< UL bandwidth
+    uint16_t ulCarrierFreq;
+    uint8_t ulBandwidth;
   };
 
-  /// RlcConfig structure
   struct RlcConfig
   {
-    /// the direction choice
-    enum direction
+    enum
     {
       AM,
       UM_BI_DIRECTIONAL,
       UM_UNI_DIRECTIONAL_UL,
-      UM_UNI_DIRECTIONAL_DL
-    } choice; ///< direction choice
+      UM_UNI_DIRECTIONAL_DL,
+      UM_BI_DIRECTIONAL_LOWLAT
+    } choice;
   };
 
-  /// LogicalChannelConfig structure
   struct LogicalChannelConfig
   {
-    uint8_t priority; ///< priority
-    uint16_t prioritizedBitRateKbps; ///< prioritized bit rate Kbps
-    uint16_t bucketSizeDurationMs; ///< bucket size duration ms
-    uint8_t logicalChannelGroup; ///< logical channel group
+    uint8_t priority;
+    uint16_t prioritizedBitRateKbps;
+    uint16_t bucketSizeDurationMs;
+    uint8_t logicalChannelGroup;
   };
 
-  /// SoundingRsUlConfigCommon structure
   struct SoundingRsUlConfigCommon
   {
-    /// the config action
-    enum action
+    enum
     {
       SETUP, RESET
-    } type; ///< action type
-    uint8_t srsBandwidthConfig; ///< SRS bandwidth config
-    uint8_t srsSubframeConfig; ///< SRS subframe config
+    } type;
+    uint8_t srsBandwidthConfig;
+    uint8_t srsSubframeConfig;
   };
 
-  /// SoundingRsUlConfigDedicated structure
   struct SoundingRsUlConfigDedicated
   {
-    /// the config action
-    enum action
+    enum
     {
       SETUP, RESET
-    } type; ///< action type
-    uint8_t srsBandwidth; ///< SRS bandwidth
-    uint16_t srsConfigIndex; ///< SRS config index
+    } type;
+    uint8_t srsBandwidth;
+    uint16_t srsConfigIndex;
   };
 
-  /// AntennaInfoDedicated structure
   struct AntennaInfoDedicated
   {
-    uint8_t transmissionMode; ///< transmission mode
+    uint8_t transmissionMode;
   };
 
-  /// PdschConfigCommon structure
   struct PdschConfigCommon
   {
-    int8_t referenceSignalPower;  ///< INTEGER (-60..50),
-    int8_t pb;                    ///< INTEGER (0..3),
+	int8_t referenceSignalPower;  // INTEGER (-60..50),
+    int8_t pb;                    // INTEGER (0..3),
   };
 
-  /// PdschConfigDedicated structure
   struct PdschConfigDedicated
   {
-    /**
+    /*
      * P_A values, TS 36.331 6.3.2 PDSCH-Config
      * ENUMERATED { dB-6, dB-4dot77, dB-3, dB-1dot77, dB0, dB1, dB2, dB3 }
      */
-    enum db
+    enum
     {
       dB_6,
       dB_4dot77,
@@ -168,15 +161,9 @@
       dB2,
       dB3
     };
-    uint8_t pa; ///< P_A value
+    uint8_t pa;
   };
 
-  /**
-   * Convert PDSCH config dedicated function
-   *
-   * \param pdschConfigDedicated PdschConfigDedicated
-   * \returns double value
-   */
   static double ConvertPdschConfigDedicated2Double (PdschConfigDedicated pdschConfigDedicated)
   {
     double pa = 0;
@@ -212,122 +199,109 @@
     return pa;
   }
 
-  /// PhysicalConfigDedicated structure
   struct PhysicalConfigDedicated
   {
-    bool haveSoundingRsUlConfigDedicated; ///< have sounding RS UL config dedicated?
-    SoundingRsUlConfigDedicated soundingRsUlConfigDedicated; ///< sounding RS UL config dedicated
-    bool haveAntennaInfoDedicated; ///< have antenna info dedicated?
-    AntennaInfoDedicated antennaInfo; ///< antenna info
-    bool havePdschConfigDedicated; ///< have PDSCH config dedicated?
-    PdschConfigDedicated pdschConfigDedicated; ///< PDSCH config dedicated
+    bool haveSoundingRsUlConfigDedicated;
+    SoundingRsUlConfigDedicated soundingRsUlConfigDedicated;
+    bool haveAntennaInfoDedicated;
+    AntennaInfoDedicated antennaInfo;
+    bool havePdschConfigDedicated;
+    PdschConfigDedicated pdschConfigDedicated;
   };
 
 
-  /// SrbToAddMod structure
   struct SrbToAddMod
   {
-    uint8_t srbIdentity; ///< SB identity
-    LogicalChannelConfig logicalChannelConfig; ///< logical channel config
+    uint8_t srbIdentity;
+    LogicalChannelConfig logicalChannelConfig;
   };
 
-  /// DrbToAddMod structure
   struct DrbToAddMod
   {
-    uint8_t epsBearerIdentity; ///< EPS bearer identity
-    uint8_t drbIdentity; ///< DRB identity
-    RlcConfig rlcConfig; ///< RLC config
-    uint8_t logicalChannelIdentity; ///< logical channel identify
-    LogicalChannelConfig logicalChannelConfig; ///< logical channel config
+    uint8_t epsBearerIdentity;
+    uint8_t drbIdentity;
+    RlcConfig rlcConfig;
+    uint8_t logicalChannelIdentity;
+    LogicalChannelConfig logicalChannelConfig;
+    bool is_mc;
   };
 
-  /// PreambleInfo structure
   struct PreambleInfo
   {
-    uint8_t numberOfRaPreambles; ///< number of RA preambles
+    uint8_t numberOfRaPreambles;
   };
 
-  /// RaSupervisionInfo structure
   struct RaSupervisionInfo
   {
-    uint8_t preambleTransMax; ///< preamble transmit maximum
-    uint8_t raResponseWindowSize; ///< RA response window size
+    uint8_t preambleTransMax;
+    uint8_t raResponseWindowSize;
   };
 
-  /// RachConfigCommon structure
   struct RachConfigCommon
   {
-    PreambleInfo preambleInfo; ///< preamble info
-    RaSupervisionInfo raSupervisionInfo; ///< RA supervision info
+    PreambleInfo preambleInfo;
+    RaSupervisionInfo raSupervisionInfo;
   };
 
-  /// RadioResourceConfigCommon structure
   struct RadioResourceConfigCommon
   {
-    RachConfigCommon rachConfigCommon; ///< RACH config common
+    RachConfigCommon rachConfigCommon;
   };
 
-  /// RadioResourceConfigCommonSib structure
   struct RadioResourceConfigCommonSib
   {
-    RachConfigCommon rachConfigCommon; ///< RACH config common
-    PdschConfigCommon pdschConfigCommon; ///< PDSCH config common
+    RachConfigCommon rachConfigCommon;
+    PdschConfigCommon pdschConfigCommon;
   };
 
-  /// RadioResourceConfigDedicated structure
   struct RadioResourceConfigDedicated
   {
-    std::list<SrbToAddMod> srbToAddModList; ///< SRB to add mod list
-    std::list<DrbToAddMod> drbToAddModList; ///< DRB to add mod list
-    std::list<uint8_t> drbToReleaseList; ///< DRB to release list
-    bool havePhysicalConfigDedicated; ///< have physical config dedicated?
-    PhysicalConfigDedicated physicalConfigDedicated; ///< physical config dedicated
+    std::list<SrbToAddMod> srbToAddModList;
+    std::list<DrbToAddMod> drbToAddModList;
+    std::list<uint8_t> drbToReleaseList;
+    bool havePhysicalConfigDedicated;
+    PhysicalConfigDedicated physicalConfigDedicated;
   };
 
-  /// QuantityConfig structure
   struct QuantityConfig
   {
-    uint8_t filterCoefficientRSRP; ///< filter coefficient RSRP
-    uint8_t filterCoefficientRSRQ; ///< filter coefficient RSRQ
+    uint8_t filterCoefficientRSRP;
+    uint8_t filterCoefficientRSRQ;
   };
 
-  /// CellsToAddMod structure
   struct CellsToAddMod
   {
-    uint8_t cellIndex; ///< cell index
-    uint16_t physCellId; ///< Phy cell ID
-    int8_t cellIndividualOffset; ///< cell individual offset
+    uint8_t cellIndex;
+    uint16_t physCellId;
+    int8_t cellIndividualOffset;
   };
 
-  /// PhysCellIdRange structure
   struct PhysCellIdRange
   {
-    uint16_t start; ///< starting cell ID
-    bool haveRange; ///< has a range?
-    uint16_t range; ///< the range
+    uint16_t start;
+    bool haveRange;
+    uint16_t range;
   };
 
-  /// BlackCellsToAddMod structure
   struct BlackCellsToAddMod
   {
-    uint8_t cellIndex; ///< cell index
-    PhysCellIdRange physCellIdRange; ///< Phy cell ID range
+    uint8_t cellIndex;
+    PhysCellIdRange physCellIdRange;
   };
 
-  /// MeasObjectEutra structure
   struct MeasObjectEutra
   {
-    uint32_t carrierFreq; ///< carrier frequency
-    uint8_t allowedMeasBandwidth; ///< allowed measure bandwidth
-    bool presenceAntennaPort1; ///< antenna port 1 present?
-    uint8_t neighCellConfig; ///< neighbor cell config
-    int8_t offsetFreq; ///< offset frequency
-    std::list<uint8_t> cellsToRemoveList; ///< cells to remove list
-    std::list<CellsToAddMod> cellsToAddModList; ///< cells to add mod list
-    std::list<uint8_t> blackCellsToRemoveList; ///< black cells to remove list
-    std::list<BlackCellsToAddMod> blackCellsToAddModList; ///< black cells to add mod list
-    bool haveCellForWhichToReportCGI; ///< have cell for which to report CGI?
-    uint8_t cellForWhichToReportCGI; ///< cell for which to report CGI
+    uint16_t carrierFreq;
+    uint8_t allowedMeasBandwidth;
+    bool presenceAntennaPort1;
+    uint8_t neighCellConfig;
+    int8_t offsetFreq;
+    std::list<uint8_t> cellsToRemoveList;
+    std::list<CellsToAddMod> cellsToAddModList;
+    std::list<uint8_t> blackCellsToRemoveList;
+    std::list<BlackCellsToAddMod> blackCellsToAddModList;
+    bool haveCellForWhichToReportCGI;
+    uint8_t cellForWhichToReportCGI;
   };
 
   /**
@@ -341,7 +315,6 @@
    */
   struct ThresholdEutra
   {
-    /// Threshold enumeration
     enum
     {
       THRESHOLD_RSRP, ///< RSRP is used for the threshold.
@@ -353,21 +326,19 @@
   /// Specifies criteria for triggering of an E-UTRA measurement reporting event.
   struct ReportConfigEutra
   {
-    /// Trigger enumeration
     enum
     {
-      EVENT,      ///< event report
-      PERIODICAL  ///< periodical report
-    } triggerType; ///< trigger type
+      EVENT,
+      PERIODICAL
+    } triggerType;
 
-    /// Event enumeration
     enum
     {
       EVENT_A1, ///< Event A1: Serving becomes better than absolute threshold.
       EVENT_A2, ///< Event A2: Serving becomes worse than absolute threshold.
       EVENT_A3, ///< Event A3: Neighbour becomes amount of offset better than PCell.
       EVENT_A4, ///< Event A4: Neighbour becomes better than absolute threshold.
-      EVENT_A5  ///< Event A5: PCell becomes worse than absolute `threshold1` AND Neighbour becomes better than another absolute `threshold2`.
+      EVENT_A5 ///< Event A5: PCell becomes worse than absolute `threshold1` AND Neighbour becomes better than another absolute `threshold2`.
 
     } eventId; ///< Choice of E-UTRA event triggered reporting criteria.
 
@@ -386,21 +357,18 @@
     /// Time during which specific criteria for the event needs to be met in order to trigger a measurement report.
     uint16_t timeToTrigger;
 
-    /// the report purpose
-    enum report
+    enum
     {
       REPORT_STRONGEST_CELLS,
       REPORT_CGI
-    } purpose; ///< purpose
+    } purpose;
 
-    /// Trigger type enumeration
     enum
     {
       RSRP, ///< Reference Signal Received Power
       RSRQ ///< Reference Signal Received Quality
     } triggerQuantity; ///< The quantities used to evaluate the triggering condition for the event, see 3GPP TS 36.214.
 
-    /// Report type enumeration
     enum
     {
       SAME_AS_TRIGGER_QUANTITY,
@@ -410,7 +378,6 @@
     /// Maximum number of cells, excluding the serving cell, to be included in the measurement report.
     uint8_t maxReportCells;
 
-    /// Report interval enumeration
     enum
     {
       MS120,
@@ -434,141 +401,123 @@
     /// Number of measurement reports applicable, always assumed to be infinite.
     uint8_t reportAmount;
 
-    /// Report config eutra function
     ReportConfigEutra ();
 
   }; // end of struct ReportConfigEutra
 
-  /// MeasObjectToAddMod structure
   struct MeasObjectToAddMod
   {
-    uint8_t measObjectId; ///< measure object ID
-    MeasObjectEutra measObjectEutra; ///< measure object eutra
+    uint8_t measObjectId;
+    MeasObjectEutra measObjectEutra;
   };
 
-  /// ReportConfigToAddMod structure
   struct ReportConfigToAddMod
   {
-    uint8_t reportConfigId; ///< report config ID
-    ReportConfigEutra reportConfigEutra; ///< report config eutra
+    uint8_t reportConfigId;
+    ReportConfigEutra reportConfigEutra;
   };
 
-  /// MeasIdToAddMod structure
   struct MeasIdToAddMod
   {
-    uint8_t measId; ///< measure ID
-    uint8_t measObjectId; ///< measure object ID
-    uint8_t reportConfigId; ///< report config ID
+    uint8_t measId;
+    uint8_t measObjectId;
+    uint8_t reportConfigId;
   };
 
-  /// MeasGapConfig structure
   struct MeasGapConfig
   {
-    /// the action type
-    enum action
+    enum
     {
       SETUP, RESET
-    } type; ///< action type
-    /// the gap offest
-    enum gap
+    } type;
+    enum
     {
       GP0, GP1
-    } gapOffsetChoice; ///< gap offset
-    uint8_t gapOffsetValue; ///< gap offset value
+    } gapOffsetChoice;
+    uint8_t gapOffsetValue;
   };
 
-  /// MobilityStateParameters structure
   struct MobilityStateParameters
   {
-    uint8_t tEvaluation; ///< evaluation
-    uint8_t tHystNormal; ///< hyst normal
-    uint8_t nCellChangeMedium; ///< cell change medium
-    uint8_t nCellChangeHigh; ///< cell change high
+    uint8_t tEvaluation;
+    uint8_t tHystNormal;
+    uint8_t nCellChangeMedium;
+    uint8_t nCellChangeHigh;
   };
 
-  /// SpeedStateScaleFactors structure
   struct SpeedStateScaleFactors
   {
     // 25 = oDot25, 50 = oDot5, 75 = oDot75, 100 = lDot0
-    uint8_t sfMedium; ///< scale factor medium
-    uint8_t sfHigh; ///< scale factor high
+    uint8_t sfMedium;
+    uint8_t sfHigh;
   };
 
-  /// SpeedStatePars structure
   struct SpeedStatePars
   {
-    /// the action type
-    enum action
+    enum
     {
       SETUP,
       RESET
-    } type; ///< action type
-    MobilityStateParameters mobilityStateParameters; ///< mobility state parameters
-    SpeedStateScaleFactors timeToTriggerSf; ///< time to trigger scale factors
+    } type;
+    MobilityStateParameters mobilityStateParameters;
+    SpeedStateScaleFactors timeToTriggerSf;
   };
 
-  /// MeasConfig structure
   struct MeasConfig
   {
-    std::list<uint8_t> measObjectToRemoveList; ///< measure object to remove list
-    std::list<MeasObjectToAddMod> measObjectToAddModList; ///< measure object to add mod list
-    std::list<uint8_t> reportConfigToRemoveList; ///< report config to remove list
-    std::list<ReportConfigToAddMod> reportConfigToAddModList; ///< report config to add mod list
-    std::list<uint8_t> measIdToRemoveList; ///< measure ID to remove list
-    std::list<MeasIdToAddMod> measIdToAddModList; ///< measure ID to add mod list
-    bool haveQuantityConfig; ///< have quantity config?
-    QuantityConfig quantityConfig; ///< quantity config
-    bool haveMeasGapConfig; ///< have measure gap config?
-    MeasGapConfig measGapConfig; ///< measure gap config
-    bool haveSmeasure; ///< have S measure?
-    uint8_t sMeasure; ///< S measure
-    bool haveSpeedStatePars; ///< have speed state parameters?
-    SpeedStatePars speedStatePars; ///< speed state parameters
+    std::list<uint8_t> measObjectToRemoveList;
+    std::list<MeasObjectToAddMod> measObjectToAddModList;
+    std::list<uint8_t> reportConfigToRemoveList;
+    std::list<ReportConfigToAddMod> reportConfigToAddModList;
+    std::list<uint8_t> measIdToRemoveList;
+    std::list<MeasIdToAddMod> measIdToAddModList;
+    bool haveQuantityConfig;
+    QuantityConfig quantityConfig;
+    bool haveMeasGapConfig;
+    MeasGapConfig measGapConfig;
+    bool haveSmeasure;
+    uint8_t sMeasure;
+    bool haveSpeedStatePars;
+    SpeedStatePars speedStatePars;
   };
 
-  /// CarrierFreqEutra structure
   struct CarrierFreqEutra
   {
-    uint32_t dlCarrierFreq; ///< DL carrier frequency
-    uint32_t ulCarrierFreq; ///< UL carrier frequency
+    uint16_t dlCarrierFreq;
+    uint16_t ulCarrierFreq;
   };
 
-  /// CarrierBandwidthEutra structure
   struct CarrierBandwidthEutra
   {
-    uint8_t dlBandwidth; ///< DL bandwidth
-    uint8_t ulBandwidth; ///< UL bandwidth
+    uint8_t dlBandwidth;
+    uint8_t ulBandwidth;
   };
 
-  /// RachConfigDedicated structure
   struct RachConfigDedicated
   {
-    uint8_t raPreambleIndex; ///< RA preamble index
-    uint8_t raPrachMaskIndex; ///< RA PRACH mask index
+    uint8_t raPreambleIndex;
+    uint8_t raPrachMaskIndex;
   };
 
-  /// MobilityControlInfo structure
   struct MobilityControlInfo
   {
-    uint16_t targetPhysCellId; ///< target Phy cell ID
-    bool haveCarrierFreq; ///< have carrier frequency?
-    CarrierFreqEutra carrierFreq; ///< carrier frequency
-    bool haveCarrierBandwidth; ///< have carrier bandwidth?
-    CarrierBandwidthEutra carrierBandwidth; ///< carrier bandwidth
-    uint16_t newUeIdentity; ///< new UE identity
-    RadioResourceConfigCommon radioResourceConfigCommon; ///< radio resource config common
-    bool haveRachConfigDedicated; ///< Have RACH config dedicated?
-    RachConfigDedicated rachConfigDedicated; ///< RACH config dedicated
+    uint16_t targetPhysCellId;
+    bool haveCarrierFreq;
+    CarrierFreqEutra carrierFreq;
+    bool haveCarrierBandwidth;
+    CarrierBandwidthEutra carrierBandwidth;
+    uint16_t newUeIdentity;
+    RadioResourceConfigCommon radioResourceConfigCommon;
+    bool haveRachConfigDedicated;
+    RachConfigDedicated rachConfigDedicated;
   };
 
-  /// ReestabUeIdentity structure
   struct ReestabUeIdentity
   {
-    uint16_t cRnti; ///< RNTI
-    uint16_t physCellId; ///< Phy cell ID
+    uint16_t cRnti;
+    uint16_t physCellId;
   };
 
-  /// ReestablishmentCause enumeration
   enum ReestablishmentCause
   {
     RECONFIGURATION_FAILURE,
@@ -576,324 +525,151 @@
     OTHER_FAILURE
   };
 
-  /// MasterInformationBlock structure
   struct MasterInformationBlock
   {
-    uint8_t dlBandwidth; ///< DL bandwidth
-    uint8_t systemFrameNumber; ///< system frame number
+    uint8_t dlBandwidth;
+    uint8_t systemFrameNumber;
   };
 
-  /// SystemInformationBlockType1 structure
   struct SystemInformationBlockType1
   {
-    CellAccessRelatedInfo cellAccessRelatedInfo; ///< cell access related info
-    CellSelectionInfo cellSelectionInfo; ///< cell selection info
+    CellAccessRelatedInfo cellAccessRelatedInfo;
+    CellSelectionInfo cellSelectionInfo;
   };
 
-  /// SystemInformationBlockType2 structure
   struct SystemInformationBlockType2
   {
-    RadioResourceConfigCommonSib radioResourceConfigCommon; ///< radio resource config common
-    FreqInfo freqInfo; ///< frequency info
+    RadioResourceConfigCommonSib radioResourceConfigCommon;
+    FreqInfo freqInfo;
   };
 
-  /// SystemInformation structure
   struct SystemInformation
   {
-    bool haveSib2; ///< have SIB2?
-    SystemInformationBlockType2 sib2; ///< SIB2
+    bool haveSib2;
+    SystemInformationBlockType2 sib2;
   };
 
-  /// AsConfig structure
   struct AsConfig
   {
-    MeasConfig sourceMeasConfig; ///< source measure config
-    RadioResourceConfigDedicated sourceRadioResourceConfig; ///< source radio resource config
-    uint16_t sourceUeIdentity; ///< source UE identity
-    MasterInformationBlock sourceMasterInformationBlock; ///< source master information block
-    SystemInformationBlockType1 sourceSystemInformationBlockType1; ///< source system information block type 1
-    SystemInformationBlockType2 sourceSystemInformationBlockType2; ///< source system information block type 2
-    uint32_t sourceDlCarrierFreq; ///< source DL carrier frequency
+    MeasConfig sourceMeasConfig;
+    RadioResourceConfigDedicated sourceRadioResourceConfig;
+    uint16_t sourceUeIdentity;
+    MasterInformationBlock sourceMasterInformationBlock;
+    SystemInformationBlockType1 sourceSystemInformationBlockType1;
+    SystemInformationBlockType2 sourceSystemInformationBlockType2;
+    uint16_t sourceDlCarrierFreq;
   };
 
-  /// CgiInfo structure
   struct CgiInfo
   {
-    uint32_t plmnIdentity; ///< PLMN identity
-    uint32_t cellIdentity; ///< cell identity
-    uint16_t trackingAreaCode; ///< tracking area code
-    std::list<uint32_t> plmnIdentityList; ///< PLMN identity list
+    uint32_t plmnIdentity;
+    uint32_t cellIdentity;
+    uint16_t trackingAreaCode;
+    std::list<uint32_t> plmnIdentityList;
   };
 
-  /// MeasResultEutra structure
   struct MeasResultEutra
   {
-    uint16_t physCellId; ///< Phy cell ID
-    bool haveCgiInfo; ///< have CGI info?
-    CgiInfo cgiInfo; ///< CGI info
-    bool haveRsrpResult; ///< have RSRP result
-    uint8_t rsrpResult; ///< RSRP result
-    bool haveRsrqResult; ///< have RSRQ result?
-    uint8_t rsrqResult; ///< RSRQ result
-  };
-
-  /// MeasResultScell structure
-  struct MeasResultScell
-  {
-    uint16_t servFreqId; ///< service frequency ID
-    bool haveRsrpResult; ///< have RSRP result?
-    uint8_t rsrpResult; ///< the RSRP result
-    bool haveRsrqResult; ///< have RSRQ result?
-    uint8_t rsrqResult; ///< the RSRQ result
+    uint16_t physCellId;
+    bool haveCgiInfo;
+    CgiInfo cgiInfo;
+    bool haveRsrpResult;
+    uint8_t rsrpResult;
+    bool haveRsrqResult;
+    uint8_t rsrqResult;
   };
 
-  /// MeasResultBestNeighCell structure
-  struct MeasResultBestNeighCell
-  {
-    uint16_t servFreqId; ///< service frequency ID
-    uint16_t physCellId; ///< physical cell ID
-    bool haveRsrpResult; ///< have RSRP result?
-    uint8_t rsrpResult; ///< the RSRP result
-    bool haveRsrqResult; ///< have RSRQ result?
-    uint8_t rsrqResult; ///< the RSRQ result
-  };
-
-  /// MeasResultServFreqList
-  struct MeasResultServFreqList
-  {
-    bool haveMeasurementResultsServingSCells; ///< have measure results serving Scells
-    std::list<MeasResultScell> measResultScell; ///< measure results Scells
-    bool haveMeasurementResultsNeighCell; ///< always false since not implemented
-    std::list<MeasResultBestNeighCell> measResultBestNeighCell; ///< measure result best neighbor cell
-  };
-
-  /// MeasResults structure
   struct MeasResults
   {
-    uint8_t measId; ///< measure ID
-    uint8_t rsrpResult; ///< RSRP result
-    uint8_t rsrqResult; ///< RSRQ result
-    bool haveMeasResultNeighCells; ///< have measure result neighbor cells
-    std::list<MeasResultEutra> measResultListEutra; ///< measure result list eutra
-    bool haveScellsMeas; ///< has SCells measure
-    MeasResultServFreqList measScellResultList; ///< measure SCell result list
+    uint8_t measId;
+    uint8_t rsrpResult;
+    uint8_t rsrqResult;
+    bool haveMeasResultNeighCells;
+    std::list<MeasResultEutra> measResultListEutra;
   };
 
   // Messages
 
-  /// RrcConnectionRequest structure
   struct RrcConnectionRequest
   {
-    uint64_t ueIdentity; ///< UE identity
+    uint64_t ueIdentity;
+    bool isMc;
   };
 
-  /// RrcConnectionSetup structure
   struct RrcConnectionSetup
   {
-    uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
-    RadioResourceConfigDedicated radioResourceConfigDedicated; ///< radio resource config dedicated
+    uint8_t rrcTransactionIdentifier;
+    RadioResourceConfigDedicated radioResourceConfigDedicated;
   };
 
-  /// RrcConnectionSetupCompleted structure
   struct RrcConnectionSetupCompleted
   {
-    uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
-  };
-
-
-  /// CellIdentification structure
-  struct CellIdentification
-  {
-    uint32_t physCellId; ///< physical cell ID
-    uint32_t dlCarrierFreq; ///<  ARFCN - valueEUTRA
-  };
-
-  /// AntennaInfoCommon structure
-  struct AntennaInfoCommon
-  {
-    uint16_t antennaPortsCount; ///< antenna ports count
-  };
-
-  /// UlPowerControlCommonSCell structure
-  struct UlPowerControlCommonSCell
-  {
-    uint16_t alpha; ///< alpha value
-  };
-  
-  /// PrachConfigSCell structure
-  struct PrachConfigSCell
-  {
-    uint16_t index; ///< the index
+    uint8_t rrcTransactionIdentifier;
   };
 
-  /// NonUlConfiguration structure
-  struct NonUlConfiguration
-  {
-    // 3GPP TS 36.311 v.11.10 R11 pag.220
-    /// 1: Cell characteristics
-    uint16_t dlBandwidth;
-    /// 2: Physical configuration, general antennaInfoCommon-r10
-    AntennaInfoCommon antennaInfoCommon;
-    // 3: Physical configuration, control phich-Config-r10
-    // Not Implemented
-    /// 4: Physical configuration, physical channels pdsch-ConfigCommon-r10
-    PdschConfigCommon pdschConfigCommon;
-    // 5: tdd-Config-r10
-    //Not Implemented
-  };
-
-  /// UlConfiguration structure
-  struct UlConfiguration 
-  { 
-    FreqInfo ulFreqInfo; ///< UL frequency info
-    UlPowerControlCommonSCell ulPowerControlCommonSCell; ///< 3GPP TS 36.331 v.11.10 R11 pag.223 
-    SoundingRsUlConfigCommon soundingRsUlConfigCommon; ///< sounding RS UL config common
-    PrachConfigSCell prachConfigSCell; ///< PRACH config SCell
-    //PushConfigCommon pushConfigCommon; //NOT IMPLEMENTED!
-  };
-
-  /// AntennaInfoUl structure
-  struct AntennaInfoUl
-  {
-    uint8_t transmissionMode; ///< transmission mode
-  };
-
-  /// PuschConfigDedicatedSCell structure
-  struct PuschConfigDedicatedSCell
-  {
-    /// 3GPP TS 36.331 v.11.10 R11 page 216
-    uint16_t nPuschIdentity;
-  };
-
-  /// UlPowerControlDedicatedSCell structure
-  struct UlPowerControlDedicatedSCell
-  {
-    /// 3GPP TS 36.331 v.11.10 R11 page 234
-    uint16_t pSrsOffset;
-  };
-
-  /// PhysicalConfigDedicatedSCell structure
-  struct PhysicalConfigDedicatedSCell
-  {
-    // Non-Ul Configuration
-    bool haveNonUlConfiguration; ///< have non UL configuration?
-    bool haveAntennaInfoDedicated; ///< have antenna info dedicated?
-    AntennaInfoDedicated antennaInfo; ///< antenna info dedicated
-    bool crossCarrierSchedulingConfig; ///< currently implemented as boolean variable --> implementing crossCarrierScheduling is out of the scope of this GSoC proposal
-    bool havePdschConfigDedicated; ///< have PDSCH config dedicated?
-    PdschConfigDedicated pdschConfigDedicated; ///< PDSCH config dedicated
-
-    // Ul Configuration
-    bool haveUlConfiguration; ///< have UL configuration?
-    bool haveAntennaInfoUlDedicated; ///< have antenna info UL dedicated?
-    AntennaInfoDedicated antennaInfoUl; ///< antenna info UL
-    PuschConfigDedicatedSCell pushConfigDedicatedSCell; ///< PUSCH config dedicated SCell
-    UlPowerControlDedicatedSCell  ulPowerControlDedicatedSCell; ///< UL power control dedicated SCell
-    bool haveSoundingRsUlConfigDedicated; ///< have sounding RS UL config dedicated?
-    SoundingRsUlConfigDedicated soundingRsUlConfigDedicated; ///< sounding RS UL config dedicated
-  };
-
-  /// RadioResourceConfigCommonSCell
-  struct RadioResourceConfigCommonSCell
-  {
-    bool haveNonUlConfiguration; ///< have non UL configuration?
-    NonUlConfiguration nonUlConfiguration; ///< non UL configuration
-    bool haveUlConfiguration; ///< have UL configuration
-    UlConfiguration ulConfiguration; ///< UL configuration
-  };
-
-  /// RadioResourceConfigDedicatedSCell structure
-  struct RadioResourceConfigDedicatedSCell
-  {
-    PhysicalConfigDedicatedSCell physicalConfigDedicatedSCell; ///< physical config dedicated SCell
-  };
-
-  /// SCellToAddMod structure
-  struct SCellToAddMod
-  {
-    uint32_t sCellIndex; ///< SCell index
-    CellIdentification cellIdentification; ///< cell identification
-    RadioResourceConfigCommonSCell radioResourceConfigCommonSCell; ///< radio resource config common SCell
-    bool haveRadioResourceConfigDedicatedSCell; ///< have radio resource config dedicated SCell?
-    RadioResourceConfigDedicatedSCell radioResourceConfigDedicateSCell; ///< radio resource config dedicated SCell
-  };
-
-  /// NonCriticalExtensionConfiguration structure
-  struct NonCriticalExtensionConfiguration
-  {
-    std::list<SCellToAddMod> sCellsToAddModList; ///< SCell to add mod list
-    std::list<uint32_t> sCellToReleaseList; ///< SCell to release list
-  };
-
-  /// RrcConnectionReconfiguration structure
   struct RrcConnectionReconfiguration
   {
-    uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
-    bool haveMeasConfig; ///< have measure config
-    MeasConfig measConfig; ///< measure config
-    bool haveMobilityControlInfo; ///< have mobility control info
-    MobilityControlInfo mobilityControlInfo; ///< mobility control info
-    bool haveRadioResourceConfigDedicated; ///< have radio resource config dedicated
-    RadioResourceConfigDedicated radioResourceConfigDedicated; ///< radio resource config dedicated
-    bool haveNonCriticalExtension; ///< have critical extension?
-    /// 3GPP TS 36.331 v.11.10 R11 Sec. 6.2.2 pag. 147 (also known as ETSI TS 136 331 v.11.10 Feb-2015)
-    NonCriticalExtensionConfiguration nonCriticalExtension;
- };
+    uint8_t rrcTransactionIdentifier;
+    bool haveMeasConfig;
+    MeasConfig measConfig;
+    bool haveMobilityControlInfo;
+    MobilityControlInfo mobilityControlInfo;
+    bool haveRadioResourceConfigDedicated;
+    RadioResourceConfigDedicated radioResourceConfigDedicated;
+  };
 
-  /// RrcConnectionReconfigurationCompleted structure
   struct RrcConnectionReconfigurationCompleted
   {
-    uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
+    uint8_t rrcTransactionIdentifier;
   };
 
 
-  /// RrcConnectionReestablishmentRequest structure
   struct RrcConnectionReestablishmentRequest
   {
-    ReestabUeIdentity ueIdentity; ///< UE identity
-    ReestablishmentCause reestablishmentCause; ///< reestablishment cause
+    ReestabUeIdentity ueIdentity;
+    ReestablishmentCause reestablishmentCause;
   };
 
-  /// RrcConnectionReestablishment structure
   struct RrcConnectionReestablishment
   {
-    uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
-    RadioResourceConfigDedicated radioResourceConfigDedicated; ///< radio resource config dedicated
+    uint8_t rrcTransactionIdentifier;
+    RadioResourceConfigDedicated radioResourceConfigDedicated;
   };
 
-  /// RrcConnectionReestablishmentComplete structure
   struct RrcConnectionReestablishmentComplete
   {
-    uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
+    uint8_t rrcTransactionIdentifier;
   };
 
-  /// RrcConnectionReestablishmentReject structure
   struct RrcConnectionReestablishmentReject
   {
   };
 
-  /// RrcConnectionRelease structure
   struct RrcConnectionRelease
   {
-    uint8_t rrcTransactionIdentifier; ///< RRC transaction identifier
+    uint8_t rrcTransactionIdentifier;
+  };
+
+  struct RrcConnectionSwitch
+  {
+    uint8_t rrcTransactionIdentifier;
+    std::vector<uint8_t> drbidList;
+    uint16_t useMmWaveConnection;
   };
 
-  /// RrcConnectionReject structure
   struct RrcConnectionReject
   {
-    uint8_t waitTime; ///< wait time
+    uint8_t waitTime;
   };
 
-  /// HandoverPreparationInfo structure
   struct HandoverPreparationInfo
   {
-    AsConfig asConfig; ///< AS config
+    AsConfig asConfig;
   };
 
-  /// MeasurementReport structure
   struct MeasurementReport
   {
-    MeasResults measResults; ///< measure results
+    MeasResults measResults;
   };
 
 };
@@ -909,17 +685,12 @@
 class LteUeRrcSapUser : public LteRrcSap
 {
 public:
-  /// SetupParameters structure
   struct SetupParameters
   {
-    LteRlcSapProvider* srb0SapProvider; ///< SRB0 SAP provider
-    LtePdcpSapProvider* srb1SapProvider; ///< SRB1 SAP provider
+    LteRlcSapProvider* srb0SapProvider;
+    LtePdcpSapProvider* srb1SapProvider;
   };
 
-  /**
-   * \brief Setup function
-   * \param params the setup parameters
-   */
   virtual void Setup (SetupParameters params) = 0;
 
   /**
@@ -970,6 +741,8 @@
    */
   virtual void SendMeasurementReport (MeasurementReport msg) = 0;
 
+  virtual void SendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId) = 0;
+
 };
 
 
@@ -982,17 +755,12 @@
 class LteUeRrcSapProvider : public LteRrcSap
 {
 public:
-  /// CompleteSetupParameters structure
   struct CompleteSetupParameters
   {
-    LteRlcSapUser* srb0SapUser; ///< SRB0 SAP user
-    LtePdcpSapUser* srb1SapUser; ///< SRB1 SAP user
+    LteRlcSapUser* srb0SapUser;
+    LtePdcpSapUser* srb1SapUser;
   };
 
-  /**
-   * \brief Complete setup function
-   * \param params the complete setup parameters
-   */
   virtual void CompleteSetup (CompleteSetupParameters params) = 0;
 
   /**
@@ -1051,6 +819,22 @@
    */
   virtual void RecvRrcConnectionReject (RrcConnectionReject msg) = 0;
 
+  /**
+   * \brief Receive an _RRCConnectionSwitch_ message from the serving eNodeB
+   *        to switch data connection from LTE to MmWave or viceversa
+   *        (added to support MC functionalities)
+   * \param msg the message
+   */
+  virtual void RecvRrcConnectionSwitch (RrcConnectionSwitch msg) = 0;
+
+  /**
+   * \brief Receive an _RRCConnectToMmWave_ message from the serving eNodeB
+   *        during an RRC connection establishment procedure
+   *        (added to support MC functionalities).
+   * \param msg the message
+   */
+  virtual void RecvRrcConnectToMmWave (uint16_t mmWaveCellId) = 0;
+
 };
 
 
@@ -1063,33 +847,22 @@
 class LteEnbRrcSapUser : public LteRrcSap
 {
 public:
-  /// SetupUeParameters structure
   struct SetupUeParameters
   {
-    LteRlcSapProvider* srb0SapProvider; ///< SRB0 SAP provider
-    LtePdcpSapProvider* srb1SapProvider; ///< SRB1 SAP provider
+    LteRlcSapProvider* srb0SapProvider;
+    LtePdcpSapProvider* srb1SapProvider;
   };
 
-  /**
-   * \brief Setup UE function
-   * \param rnti the RNTI
-   * \param params the setup UE parameters
-   */
   virtual void SetupUe (uint16_t rnti, SetupUeParameters params) = 0;
-  /**
-   * \brief Remove UE function
-   * \param rnti the RNTI
-   */
   virtual void RemoveUe (uint16_t rnti) = 0;
 
   /**
    * \brief Send a _SystemInformation_ message to all attached UEs
    *        during a system information acquisition procedure
    *        (Section 5.2.2 of TS 36.331).
-   * \param cellId cell ID
    * \param msg the message
    */
-  virtual void SendSystemInformation (uint16_t cellId, SystemInformation msg) = 0;
+  virtual void SendSystemInformation (SystemInformation msg) = 0;
 
   /**
    * \brief Send an _RRCConnectionSetup_ message to a UE
@@ -1146,28 +919,25 @@
   virtual void SendRrcConnectionReject (uint16_t rnti, RrcConnectionReject msg) = 0;
 
   /**
-   * \brief Encode handover prepration information
-   * \param msg HandoverPreparationInfo
-   * \returns the packet
+   * \brief Send an _RRCConnectionSwitch_ message to a UE
+   *        (added to support MC functionalities).
+   * \param rnti the RNTI of the destination UE
+   * \param msg the message
    */
-  virtual Ptr<Packet> EncodeHandoverPreparationInformation (HandoverPreparationInfo msg) = 0;
+  virtual void SendRrcConnectionSwitch (uint16_t rnti, RrcConnectionSwitch msg) = 0;
+
   /**
-   * \brief Decode handover prepration information
-   * \param p the packet
-   * \returns HandoverPreparationInfo
+   * \brief Send an _RRCConnectToMmWave_ message to a UE
+   *        during an RRC connection establishment procedure
+   *        (added to support MC functionalities).
+   * \param rnti the RNTI of the destination UE
+   * \param mmWaveCellId the cellId to which connect
    */
+  virtual void SendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId) = 0;
+
+  virtual Ptr<Packet> EncodeHandoverPreparationInformation (HandoverPreparationInfo msg) = 0;
   virtual HandoverPreparationInfo DecodeHandoverPreparationInformation (Ptr<Packet> p) = 0;
-  /**
-   * \brief Encode handover command
-   * \param msg RrcConnectionReconfiguration
-   * \returns the packet
-   */
   virtual Ptr<Packet> EncodeHandoverCommand (RrcConnectionReconfiguration msg) = 0;
-  /**
-   * \brief Decode handover command
-   * \param p the packet
-   * \returns RrcConnectionReconfiguration
-   */
   virtual RrcConnectionReconfiguration DecodeHandoverCommand (Ptr<Packet> p) = 0;
 
 };
@@ -1182,18 +952,12 @@
 class LteEnbRrcSapProvider : public LteRrcSap
 {
 public:
-  /// CompleteSetupUeParameters structure
   struct CompleteSetupUeParameters
   {
-    LteRlcSapUser* srb0SapUser; ///< SRB0 SAP user
-    LtePdcpSapUser* srb1SapUser; ///< SRB1 SAP user
+    LteRlcSapUser* srb0SapUser;
+    LtePdcpSapUser* srb1SapUser;
   };
 
-  /**
-   * \brief Complete setup UE function
-   * \param rnti the RNTI of UE which sent the message
-   * \param params CompleteSetupUeParameters
-   */
   virtual void CompleteSetupUe (uint16_t rnti, CompleteSetupUeParameters params) = 0;
 
   /**
@@ -1255,6 +1019,7 @@
    */
   virtual void RecvMeasurementReport (uint16_t rnti, MeasurementReport msg) = 0;
 
+  virtual void RecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId) = 0;
 };
 
 
@@ -1276,11 +1041,6 @@
 class MemberLteUeRrcSapUser : public LteUeRrcSapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteUeRrcSapUser (C* owner);
 
   // inherited from LteUeRrcSapUser
@@ -1291,10 +1051,11 @@
   virtual void SendRrcConnectionReestablishmentRequest (RrcConnectionReestablishmentRequest msg);
   virtual void SendRrcConnectionReestablishmentComplete (RrcConnectionReestablishmentComplete msg);
   virtual void SendMeasurementReport (MeasurementReport msg);
+  virtual void SendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
 private:
   MemberLteUeRrcSapUser ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -1357,6 +1118,13 @@
   m_owner->DoSendMeasurementReport (msg);
 }
 
+template <class C>
+void
+MemberLteUeRrcSapUser<C>::SendNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoSendNotifySecondaryCellConnected (mmWaveRnti, mmWaveCellId);
+}
+
 /**
  * Template for the implementation of the LteUeRrcSapProvider as a member
  * of an owner class of type C to which all methods are forwarded
@@ -1366,11 +1134,6 @@
 class MemberLteUeRrcSapProvider : public LteUeRrcSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteUeRrcSapProvider (C* owner);
 
   // methods inherited from LteUeRrcSapProvider go here
@@ -1382,10 +1145,12 @@
   virtual void RecvRrcConnectionReestablishmentReject (RrcConnectionReestablishmentReject msg);
   virtual void RecvRrcConnectionRelease (RrcConnectionRelease msg);
   virtual void RecvRrcConnectionReject (RrcConnectionReject msg);
+  virtual void RecvRrcConnectToMmWave (uint16_t mmWaveCellId);
+  virtual void RecvRrcConnectionSwitch (RrcConnectionSwitch msg);
 
 private:
   MemberLteUeRrcSapProvider ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -1455,6 +1220,19 @@
   Simulator::ScheduleNow (&C::DoRecvRrcConnectionReject, m_owner, msg);
 }
 
+template <class C>
+void
+MemberLteUeRrcSapProvider<C>::RecvRrcConnectToMmWave (uint16_t mmWaveCellId)
+{
+  Simulator::ScheduleNow (&C::DoRecvRrcConnectToMmWave, m_owner, mmWaveCellId);
+}
+
+template <class C>
+void
+MemberLteUeRrcSapProvider<C>::RecvRrcConnectionSwitch (RrcConnectionSwitch msg)
+{
+  Simulator::ScheduleNow (&C::DoRecvRrcConnectionSwitch, m_owner, msg);
+}
 
 /**
  * Template for the implementation of the LteEnbRrcSapUser as a member
@@ -1465,24 +1243,21 @@
 class MemberLteEnbRrcSapUser : public LteEnbRrcSapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteEnbRrcSapUser (C* owner);
 
   // inherited from LteEnbRrcSapUser
 
   virtual void SetupUe (uint16_t rnti, SetupUeParameters params);
   virtual void RemoveUe (uint16_t rnti);
-  virtual void SendSystemInformation (uint16_t cellId, SystemInformation msg);
+  virtual void SendSystemInformation (SystemInformation msg);
   virtual void SendRrcConnectionSetup (uint16_t rnti, RrcConnectionSetup msg);
   virtual void SendRrcConnectionReconfiguration (uint16_t rnti, RrcConnectionReconfiguration msg);
   virtual void SendRrcConnectionReestablishment (uint16_t rnti, RrcConnectionReestablishment msg);
   virtual void SendRrcConnectionReestablishmentReject (uint16_t rnti, RrcConnectionReestablishmentReject msg);
   virtual void SendRrcConnectionRelease (uint16_t rnti, RrcConnectionRelease msg);
   virtual void SendRrcConnectionReject (uint16_t rnti, RrcConnectionReject msg);
+  virtual void SendRrcConnectionSwitch (uint16_t rnti, RrcConnectionSwitch msg);
+  virtual void SendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId);
   virtual Ptr<Packet> EncodeHandoverPreparationInformation (HandoverPreparationInfo msg);
   virtual HandoverPreparationInfo DecodeHandoverPreparationInformation (Ptr<Packet> p);
   virtual Ptr<Packet> EncodeHandoverCommand (RrcConnectionReconfiguration msg);
@@ -1490,7 +1265,7 @@
 
 private:
   MemberLteEnbRrcSapUser ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -1520,9 +1295,9 @@
 
 template <class C>
 void
-MemberLteEnbRrcSapUser<C>::SendSystemInformation (uint16_t cellId, SystemInformation msg)
+MemberLteEnbRrcSapUser<C>::SendSystemInformation (SystemInformation msg)
 {
-  m_owner->DoSendSystemInformation (cellId, msg);
+  m_owner->DoSendSystemInformation (msg);
 }
 
 template <class C>
@@ -1568,6 +1343,20 @@
 }
 
 template <class C>
+void
+MemberLteEnbRrcSapUser<C>::SendRrcConnectionSwitch (uint16_t rnti, RrcConnectionSwitch msg)
+{
+  m_owner->DoSendRrcConnectionSwitch (rnti, msg);
+}
+
+template <class C>
+void
+MemberLteEnbRrcSapUser<C>::SendRrcConnectToMmWave (uint16_t rnti, uint16_t mmWaveCellId)
+{
+  m_owner->DoSendRrcConnectToMmWave (rnti, mmWaveCellId);
+}
+
+template <class C>
 Ptr<Packet>
 MemberLteEnbRrcSapUser<C>::EncodeHandoverPreparationInformation (HandoverPreparationInfo msg)
 {
@@ -1605,11 +1394,6 @@
 class MemberLteEnbRrcSapProvider : public LteEnbRrcSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner
-   */
   MemberLteEnbRrcSapProvider (C* owner);
 
   // methods inherited from LteEnbRrcSapProvider go here
@@ -1621,10 +1405,11 @@
   virtual void RecvRrcConnectionReestablishmentRequest (uint16_t rnti, RrcConnectionReestablishmentRequest msg);
   virtual void RecvRrcConnectionReestablishmentComplete (uint16_t rnti, RrcConnectionReestablishmentComplete msg);
   virtual void RecvMeasurementReport (uint16_t rnti, MeasurementReport msg);
+  virtual void RecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId);
 
 private:
   MemberLteEnbRrcSapProvider ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -1687,6 +1472,13 @@
   Simulator::ScheduleNow (&C::DoRecvMeasurementReport, m_owner, rnti, msg);
 }
 
+template <class C>
+void
+MemberLteEnbRrcSapProvider<C>::RecvRrcSecondaryCellInitialAccessSuccessful (uint16_t rnti, uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  Simulator::ScheduleNow (&C::DoRecvRrcSecondaryCellInitialAccessSuccessful, m_owner, rnti, mmWaveRnti, mmWaveCellId);
+}
+
 
 
 
diff -Naru a/model/lte-spectrum-phy.cc b/model/lte-spectrum-phy.cc
--- a/model/lte-spectrum-phy.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-spectrum-phy.cc	2017-10-05 11:47:22.310601768 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2009, 2011 CTTC
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Nicola Baldo <nbaldo@cttc.es>
  *         Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <marco.miozzo@cttc.es> (add physical error model)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -44,15 +48,14 @@
 NS_LOG_COMPONENT_DEFINE ("LteSpectrumPhy");
 
 
-/// duration of SRS portion of UL subframe  
-/// = 1 symbol for SRS -1ns as margin to avoid overlapping simulator events
+// duration of SRS portion of UL subframe  
+// = 1 symbol for SRS -1ns as margin to avoid overlapping simulator events
 static const Time UL_SRS_DURATION = NanoSeconds (71429 -1);  
 
-/// duration of the control portion of a subframe
-/// = 0.001 / 14 * 3 (ctrl fixed to 3 symbols) -1ns as margin to avoid overlapping simulator events
+// duration of the control portion of a subframe
+// = 0.001 / 14 * 3 (ctrl fixed to 3 symbols) -1ns as margin to avoid overlapping simulator events
 static const Time DL_CTRL_DURATION = NanoSeconds (214286 -1);
 
-/// Effective coding rate
 static const double EffectiveCodingRate[29] = {
   0.08,
   0.1,
@@ -98,26 +101,12 @@
 {
 }
 
-/**
- * Equality operator
- *
- * \param a lhs
- * \param b rhs
- * \returns true if rnti and layer are equal
- */
 bool
 operator == (const TbId_t &a, const TbId_t &b)
 {
   return ( (a.m_rnti == b.m_rnti) && (a.m_layer == b.m_layer) );
 }
 
-/**
- * Less than operator
- *
- * \param a lhs
- * \param b rhs
- * \returns true if rnti less than ro rnti equal and layer less than
- */
 bool
 operator < (const TbId_t& a, const TbId_t& b)
 {
@@ -129,9 +118,8 @@
 LteSpectrumPhy::LteSpectrumPhy ()
   : m_state (IDLE),
     m_cellId (0),
-    m_componentCarrierId (0),
-    m_transmissionMode (0),
-    m_layersNum (1)
+  m_transmissionMode (0),
+  m_layersNum (1)
 {
   NS_LOG_FUNCTION (this);
   m_random = CreateObject<UniformRandomVariable> ();
@@ -174,13 +162,6 @@
   SpectrumPhy::DoDispose ();
 } 
 
-/**
- * Output stream output operator
- *
- * \param os output stream
- * \param s state
- * \returns output stream
- */
 std::ostream& operator<< (std::ostream& os, LteSpectrumPhy::State s)
 {
   switch (s)
@@ -349,7 +330,7 @@
   m_txControlMessageList.clear ();
   m_rxPacketBurstList.clear ();
   m_txPacketBurst = 0;
-  m_rxSpectrumModel = 0;
+  //m_rxSpectrumModel = 0;
 }
 
 
@@ -1007,7 +988,6 @@
           params.m_rv = (*itTb).second.rv;
           params.m_ndi = (*itTb).second.ndi;
           params.m_correctness = (uint8_t)!(*itTb).second.corrupt;
-          params.m_ccId = m_componentCarrierId;
           if ((*itTb).second.downlink)
             {
               // DL
@@ -1086,7 +1066,7 @@
                         if (itHarq==harqDlInfoMap.end ())
                           {
                             DlInfoListElement_s harqDlInfo;
-                            harqDlInfo.m_harqStatus.resize (m_layersNum, DlInfoListElement_s::ACK);
+                            harqDlInfo.m_harqStatus.resize (m_layersNum, DlInfoListElement_s::NACK);
                             harqDlInfo.m_rnti = tbId.m_rnti;
                             harqDlInfo.m_harqProcessId = (*itTb).second.harqProcessId;
                             if ((*itTb).second.corrupt)
@@ -1213,11 +1193,6 @@
   m_cellId = cellId;
 }
 
-void
-LteSpectrumPhy::SetComponentCarrierId (uint8_t componentCarrierId)
-{
-  m_componentCarrierId = componentCarrierId;
-}
 
 void
 LteSpectrumPhy::AddRsPowerChunkProcessor (Ptr<LteChunkProcessor> p)
diff -Naru a/model/lte-spectrum-phy.h b/model/lte-spectrum-phy.h
--- a/model/lte-spectrum-phy.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-spectrum-phy.h	2017-10-05 11:47:22.310601768 +0200
@@ -44,20 +44,13 @@
 
 namespace ns3 {
 
-/// TbId_t sturcture
 struct TbId_t
 {
-  uint16_t m_rnti; ///< RNTI
-  uint8_t m_layer; ///< layer
+  uint16_t m_rnti;
+  uint8_t m_layer;
   
   public:
   TbId_t ();
-  /**
-   * Constructor
-   *
-   * \param a rnti
-   * \param b layer
-   */
   TbId_t (const uint16_t a, const uint8_t b);
   
   friend bool operator == (const TbId_t &a, const TbId_t &b);
@@ -65,22 +58,21 @@
 };
 
   
-/// tbInfo_t structure
 struct tbInfo_t
 {
-  uint8_t ndi; ///< ndi
-  uint16_t size; ///< size
-  uint8_t mcs; ///< mcs
-  std::vector<int> rbBitmap; ///< rb bitmap
-  uint8_t harqProcessId; ///< HARQ process id
-  uint8_t rv; ///< rv
-  double mi; ///< mi
-  bool downlink; ///< whether is downlink
-  bool corrupt; ///< whether is corrupt
-  bool harqFeedbackSent; ///< is HARQ feedback sent
+  uint8_t ndi;
+  uint16_t size;
+  uint8_t mcs;
+  std::vector<int> rbBitmap;
+  uint8_t harqProcessId;
+  uint8_t rv;
+  double mi;
+  bool downlink;
+  bool corrupt;
+  bool harqFeedbackSent;
 };
 
-typedef std::map<TbId_t, tbInfo_t> expectedTbs_t; ///< expectedTbs_t typedef
+typedef std::map<TbId_t, tbInfo_t> expectedTbs_t;
 
 
 class LteNetDevice;
@@ -90,6 +82,15 @@
 struct LteSpectrumSignalParametersDlCtrlFrame;
 struct LteSpectrumSignalParametersUlSrsFrame;
 
+
+/**
+* this method is invoked by the LteSpectrumPhy to notify the PHY that the
+* transmission of a given packet has been completed.
+*
+* @param packet the Packet whose TX has been completed.
+*/
+typedef Callback< void, Ptr<const Packet> > LtePhyTxEndCallback;
+
 /**
 * This method is used by the LteSpectrumPhy to notify the PHY that a
 * previously started RX attempt has terminated without success
@@ -143,7 +144,6 @@
 
 /**
  * \ingroup lte
- * \class LteSpectrumPhy
  *
  * The LteSpectrumPhy models the physical layer of LTE
  *
@@ -165,12 +165,8 @@
     IDLE, TX_DL_CTRL, TX_DATA, TX_UL_SRS, RX_DL_CTRL, RX_DATA, RX_UL_SRS
   };
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
   // inherited from Object
+  static TypeId GetTypeId (void);
   virtual void DoDispose ();
 
   // inherited from SpectrumPhy
@@ -182,25 +178,10 @@
   Ptr<const SpectrumModel> GetRxSpectrumModel () const;
   Ptr<AntennaModel> GetRxAntenna ();
   void StartRx (Ptr<SpectrumSignalParameters> params);
-  /**
-   * \brief Start receive data function
-   * \param params Ptr<LteSpectrumSignalParametersDataFrame>
-   */
   void StartRxData (Ptr<LteSpectrumSignalParametersDataFrame> params);
-  /**
-   * \brief Start receive DL control function
-   * \param lteDlCtrlRxParams Ptr<LteSpectrumSignalParametersDlCtrlFrame>
-   */
   void StartRxDlCtrl (Ptr<LteSpectrumSignalParametersDlCtrlFrame> lteDlCtrlRxParams);
-  /**
-   * \brief Start receive UL SRS function
-   * \param lteUlSrsRxParams Ptr<LteSpectrumSignalParametersUlSrsFrame>
-   */
   void StartRxUlSrs (Ptr<LteSpectrumSignalParametersUlSrsFrame> lteUlSrsRxParams);
-  /**
-   * \brief Set HARQ phy function
-   * \param harq the HARQ phy module
-   */
+
   void SetHarqPhyModule (Ptr<LteHarqPhy> harq);
 
   /**
@@ -264,6 +245,15 @@
   */
   bool StartTxUlSrsFrame ();
 
+
+  /**
+   * set the callback for the end of a TX, as part of the
+   * interconnections between the PHY and the MAC
+   *
+   * @param c the callback
+   */
+  void SetLtePhyTxEndCallback (LtePhyTxEndCallback c);
+
   /**
    * set the callback for the end of a RX in error, as part of the
    * interconnections between the PHY and the MAC
@@ -333,11 +323,6 @@
    */
   void SetCellId (uint16_t cellId);
 
-  /**
-   *
-   * \param componentCarrierId the component carrier id
-   */
-  void SetComponentCarrierId (uint8_t componentCarrierId);
 
   /**
   *
@@ -396,7 +381,6 @@
   * \param map the map of RB(s) used
   * \param layer the layer (in case of MIMO tx)
   * \param harqId the id of the HARQ process (valid only for DL)
-  * \param rv the rv
   * \param downlink true when the TB is for DL
   */
   void AddExpectedTb (uint16_t  rnti, uint8_t ndi, uint16_t size, uint8_t mcs, std::vector<int> map, uint8_t layer, uint8_t harqId, uint8_t rv, bool downlink);
@@ -423,7 +407,6 @@
    */
   Ptr<SpectrumChannel> GetChannel ();
 
-  /// allow LteUePhy class friend access
   friend class LteUePhy;
   
  /**
@@ -437,87 +420,69 @@
   int64_t AssignStreams (int64_t stream);
 
 private:
-  /** 
-  * \brief Change state function
-  * 
-  * \param newState the new state to set
-  */
   void ChangeState (State newState);
-  /// End transmit data function
   void EndTxData ();
-  /// End transmit DL control function
   void EndTxDlCtrl ();
-  /// End transmit UL SRS function
   void EndTxUlSrs ();
-  /// End receive data function
   void EndRxData ();
-  /// End receive DL control function
   void EndRxDlCtrl ();
-  /// End receive UL SRS function
   void EndRxUlSrs ();
   
-  /** 
-  * \brief Set transmit mode gain function
-  * 
-  * \param txMode the transmit mode
-  * \param gain the gain to set
-  */
   void SetTxModeGain (uint8_t txMode, double gain);
   
 
-  Ptr<MobilityModel> m_mobility; ///< the modility model
-  Ptr<AntennaModel> m_antenna; ///< the antenna model
-  Ptr<NetDevice> m_device; ///< the device
+  Ptr<MobilityModel> m_mobility;
+  Ptr<AntennaModel> m_antenna;
+  Ptr<NetDevice> m_device;
 
-  Ptr<SpectrumChannel> m_channel; ///< the channel
+  Ptr<SpectrumChannel> m_channel;
 
-  Ptr<const SpectrumModel> m_rxSpectrumModel; ///< the spectrum model
-  Ptr<SpectrumValue> m_txPsd; ///< the transmit PSD
-  Ptr<PacketBurst> m_txPacketBurst; ///< the transmit packet burst
-  std::list<Ptr<PacketBurst> > m_rxPacketBurstList; ///< the receive burst list
+  Ptr<const SpectrumModel> m_rxSpectrumModel;
+  Ptr<SpectrumValue> m_txPsd;
+  Ptr<PacketBurst> m_txPacketBurst;
+  std::list<Ptr<PacketBurst> > m_rxPacketBurstList;
   
-  std::list<Ptr<LteControlMessage> > m_txControlMessageList; ///< the transmit control message list
-  std::list<Ptr<LteControlMessage> > m_rxControlMessageList; ///< the receive control message list
+  std::list<Ptr<LteControlMessage> > m_txControlMessageList;
+  std::list<Ptr<LteControlMessage> > m_rxControlMessageList;
   
   
-  State m_state; ///< the state
-  Time m_firstRxStart; ///< the first receive start
-  Time m_firstRxDuration; ///< the first receive duration
+  State m_state;
+  Time m_firstRxStart;
+  Time m_firstRxDuration;
 
-  TracedCallback<Ptr<const PacketBurst> > m_phyTxStartTrace; ///< the phy transmit start trace callback
-  TracedCallback<Ptr<const PacketBurst> > m_phyTxEndTrace; ///< the phy transmit end trace callback
-  TracedCallback<Ptr<const PacketBurst> > m_phyRxStartTrace; ///< the phy receive start trace callback
-  TracedCallback<Ptr<const Packet> >      m_phyRxEndOkTrace; ///< the phy receive end ok trace callback
-  TracedCallback<Ptr<const Packet> >      m_phyRxEndErrorTrace; ///< the phy receive end error trace callback
+  TracedCallback<Ptr<const PacketBurst> > m_phyTxStartTrace;
+  TracedCallback<Ptr<const PacketBurst> > m_phyTxEndTrace;
+  TracedCallback<Ptr<const PacketBurst> > m_phyRxStartTrace;
+  TracedCallback<Ptr<const Packet> >      m_phyRxEndOkTrace;
+  TracedCallback<Ptr<const Packet> >      m_phyRxEndErrorTrace;
 
-  LtePhyRxDataEndErrorCallback   m_ltePhyRxDataEndErrorCallback; ///< the LTE phy receive data end error callback 
-  LtePhyRxDataEndOkCallback      m_ltePhyRxDataEndOkCallback; ///< the LTE phy receive data end ok callback
+  LtePhyRxDataEndErrorCallback   m_ltePhyRxDataEndErrorCallback;
+  LtePhyRxDataEndOkCallback      m_ltePhyRxDataEndOkCallback;
   
-  LtePhyRxCtrlEndOkCallback     m_ltePhyRxCtrlEndOkCallback; ///< the LTE phy receive control end ok callback
-  LtePhyRxCtrlEndErrorCallback  m_ltePhyRxCtrlEndErrorCallback; ///< the LTE phy receive control end error callback
-  LtePhyRxPssCallback  m_ltePhyRxPssCallback; ///< the LTE phy receive PSS callback
+  LtePhyRxCtrlEndOkCallback     m_ltePhyRxCtrlEndOkCallback;
+  LtePhyRxCtrlEndErrorCallback  m_ltePhyRxCtrlEndErrorCallback;
+  LtePhyRxPssCallback  m_ltePhyRxPssCallback;
 
-  Ptr<LteInterference> m_interferenceData; ///< the data interference
-  Ptr<LteInterference> m_interferenceCtrl; ///< the control interference
+  Ptr<LteInterference> m_interferenceData;
+  Ptr<LteInterference> m_interferenceCtrl;
 
-  uint16_t m_cellId; ///< the cell ID
+  uint16_t m_cellId;
   
-  uint8_t m_componentCarrierId; ///< the component carrier ID
-  expectedTbs_t m_expectedTbs; ///< the expected TBS
-  SpectrumValue m_sinrPerceived; ///< the preceived SINR 
+  expectedTbs_t m_expectedTbs;
+  SpectrumValue m_sinrPerceived;
 
   /// Provides uniform random variables.
   Ptr<UniformRandomVariable> m_random;
-  bool m_dataErrorModelEnabled; ///< when true (default) the phy error model is enabled
-  bool m_ctrlErrorModelEnabled; ///< when true (default) the phy error model is enabled for DL ctrl frame
+  bool m_dataErrorModelEnabled; // when true (default) the phy error model is enabled
+  bool m_ctrlErrorModelEnabled; // when true (default) the phy error model is enabled for DL ctrl frame
   
-  uint8_t m_transmissionMode; ///< for UEs: store the transmission mode
-  uint8_t m_layersNum; ///< layers num
-  std::vector <double> m_txModeGain; ///< duplicate value of LteUePhy
-
-  Ptr<LteHarqPhy> m_harqPhyModule; ///< the HARQ phy module
-  LtePhyDlHarqFeedbackCallback m_ltePhyDlHarqFeedbackCallback; ///< the LTE phy DL HARQ feedback callback
-  LtePhyUlHarqFeedbackCallback m_ltePhyUlHarqFeedbackCallback; ///< the LTE phy UL HARQ feedback callback
+  uint8_t m_transmissionMode; // for UEs: store the transmission mode
+  uint8_t m_layersNum;
+  std::vector <double> m_txModeGain; // duplicate value of LteUePhy
+
+  Ptr<LteHarqPhy> m_harqPhyModule;
+  LtePhyDlHarqFeedbackCallback m_ltePhyDlHarqFeedbackCallback;
+  LtePhyUlHarqFeedbackCallback m_ltePhyUlHarqFeedbackCallback;
 
 
   /**
@@ -533,10 +498,10 @@
    */
   TracedCallback<PhyReceptionStatParameters> m_ulPhyReception;
 
-  EventId m_endTxEvent; ///< end transmit event
-  EventId m_endRxDataEvent; ///< end receive data event
-  EventId m_endRxDlCtrlEvent; ///< end receive DL control event
-  EventId m_endRxUlSrsEvent; ///< end receive UL SRS event
+  EventId m_endTxEvent;
+  EventId m_endRxDataEvent;
+  EventId m_endRxDlCtrlEvent;
+  EventId m_endRxUlSrsEvent;
   
 
 };
diff -Naru a/model/lte-spectrum-value-helper.cc b/model/lte-spectrum-value-helper.cc
--- a/model/lte-spectrum-value-helper.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-spectrum-value-helper.cc	2017-10-05 11:47:22.314601784 +0200
@@ -56,15 +56,15 @@
  */
 static const struct EutraChannelNumbers
 {
-  uint8_t band; ///< band
-  double fDlLow; ///<  DL low
-  uint32_t nOffsDl; ///< number offset DL
-  uint32_t rangeNdl1; ///< range DL 1
-  uint32_t rangeNdl2; ///< range DL 2
-  double fUlLow; ///< UL low
-  uint32_t nOffsUl;  ///< number offset UL
-  uint32_t rangeNul1; ///< range UL 1
-  uint32_t rangeNul2; ///< range UL 2
+  uint8_t band;
+  double fDlLow;
+  uint16_t nOffsDl; 
+  uint16_t rangeNdl1;
+  uint16_t rangeNdl2;
+  double fUlLow;
+  uint16_t nOffsUl; 
+  uint16_t rangeNul1;
+  uint16_t rangeNul2;
 } g_eutraChannelNumbers[] = {
   { 1, 2110, 0, 0, 599, 1920, 18000, 18000, 18599},
   { 2, 1930, 600, 600, 1199, 1850, 18600, 18600, 19199},
@@ -93,13 +93,12 @@
   { 38, 2570, 37750, 37750, 38249, 2570, 37750, 37750, 38249},
   { 39, 1880, 38250, 38250, 38649, 1880, 38250, 38250, 38649},
   { 40, 2300, 38650, 38650, 39649, 2300, 38650, 38650, 39649}
-}; ///< eutra channel numbers
+};
 
-/// number of EUTRA bands
 #define NUM_EUTRA_BANDS (sizeof (g_eutraChannelNumbers) / sizeof (EutraChannelNumbers))
 
 double 
-LteSpectrumValueHelper::GetCarrierFrequency (uint32_t earfcn)
+LteSpectrumValueHelper::GetCarrierFrequency (uint16_t earfcn)
 {
   NS_LOG_FUNCTION (earfcn);
   if (earfcn < 7000)
@@ -114,62 +113,38 @@
     }
 }
 
-uint16_t
-LteSpectrumValueHelper::GetDownlinkCarrierBand (uint32_t nDl)
+double 
+LteSpectrumValueHelper::GetDownlinkCarrierFrequency (uint16_t nDl)
 {
   NS_LOG_FUNCTION (nDl);
   for (uint16_t i = 0; i < NUM_EUTRA_BANDS; ++i)
     {
-      if (g_eutraChannelNumbers[i].rangeNdl1 <= nDl &&
-          g_eutraChannelNumbers[i].rangeNdl2 >= nDl)
+      if ((g_eutraChannelNumbers[i].rangeNdl1 <= nDl)
+          && (g_eutraChannelNumbers[i].rangeNdl2 >= nDl))
         {
           NS_LOG_LOGIC ("entry " << i << " fDlLow=" << g_eutraChannelNumbers[i].fDlLow);
-          return i;
+          return 1.0e6 * (g_eutraChannelNumbers[i].fDlLow + 0.1 * (nDl - g_eutraChannelNumbers[i].nOffsDl));
         }
     }
   NS_LOG_ERROR ("invalid EARFCN " << nDl);
-  return NUM_EUTRA_BANDS;
+  return 0.0;
 }
 
-uint16_t
-LteSpectrumValueHelper::GetUplinkCarrierBand (uint32_t nUl)
+double 
+LteSpectrumValueHelper::GetUplinkCarrierFrequency (uint16_t nUl)
 {
   NS_LOG_FUNCTION (nUl);
   for (uint16_t i = 0; i < NUM_EUTRA_BANDS; ++i)
     {
-      if (g_eutraChannelNumbers[i].rangeNul1 <= nUl &&
-          g_eutraChannelNumbers[i].rangeNul2 >= nUl)
+      if ((g_eutraChannelNumbers[i].rangeNul1 <= nUl)
+          && (g_eutraChannelNumbers[i].rangeNul2 >= nUl))
         {
           NS_LOG_LOGIC ("entry " << i << " fUlLow=" << g_eutraChannelNumbers[i].fUlLow);
-          return i;
+          return 1.0e6 * (g_eutraChannelNumbers[i].fUlLow + 0.1 * (nUl - g_eutraChannelNumbers[i].nOffsUl));
         }
     }
   NS_LOG_ERROR ("invalid EARFCN " << nUl);
-  return NUM_EUTRA_BANDS;
-}
-
-double
-LteSpectrumValueHelper::GetDownlinkCarrierFrequency (uint32_t nDl)
-{
-  NS_LOG_FUNCTION (nDl);
-  uint16_t i = GetDownlinkCarrierBand (nDl);
-  if (i == NUM_EUTRA_BANDS)
-    {
-      return 0.0;
-    }
-  return 1.0e6 * (g_eutraChannelNumbers[i].fDlLow + 0.1 * (nDl - g_eutraChannelNumbers[i].nOffsDl));
-}
-
-double
-LteSpectrumValueHelper::GetUplinkCarrierFrequency (uint32_t nUl)
-{
-  NS_LOG_FUNCTION (nUl);
-  uint16_t i = GetUplinkCarrierBand (nUl);
-  if (i == NUM_EUTRA_BANDS)
-    {
-      return 0.0;
-    }
-  return 1.0e6 * (g_eutraChannelNumbers[i].fUlLow + 0.1 * (nUl - g_eutraChannelNumbers[i].nOffsUl));
+  return 0.0;
 }
 
 double 
@@ -198,33 +173,19 @@
 
 
 
-/// LteSpectrumModelId structure
 struct LteSpectrumModelId
 {
-  /**
-   * Constructor
-   *
-   * \param f earfcn
-   * \param b bandwidth
-   */
-  LteSpectrumModelId (uint32_t f, uint8_t b);
-  uint32_t earfcn; ///< EARFCN
-  uint8_t  bandwidth; ///< bandwidth
+  LteSpectrumModelId (uint16_t f, uint8_t b);
+  uint16_t earfcn;
+  uint8_t  bandwidth;
 };
 
-LteSpectrumModelId::LteSpectrumModelId (uint32_t f, uint8_t b)
+LteSpectrumModelId::LteSpectrumModelId (uint16_t f, uint8_t b)
   : earfcn (f), 
     bandwidth (b)
 {
 }
 
-/**
- * Constructor
- *
- * \param a lhs
- * \param b rhs
- * \returns true if earfcn less than of if earfcn equal and bandwidth less than
- */
 bool
 operator < (const LteSpectrumModelId& a, const LteSpectrumModelId& b)
 {
@@ -232,11 +193,11 @@
 }
  
 
-static std::map<LteSpectrumModelId, Ptr<SpectrumModel> > g_lteSpectrumModelMap; ///< LTE spectrum model map
+static std::map<LteSpectrumModelId, Ptr<SpectrumModel> > g_lteSpectrumModelMap;
 
 
 Ptr<SpectrumModel>
-LteSpectrumValueHelper::GetSpectrumModel (uint32_t earfcn, uint8_t txBandwidthConfiguration)
+LteSpectrumValueHelper::GetSpectrumModel (uint16_t earfcn, uint8_t txBandwidthConfiguration)
 {
   NS_LOG_FUNCTION (earfcn << (uint16_t) txBandwidthConfiguration);
   Ptr<SpectrumModel> ret;
@@ -271,7 +232,7 @@
 }
 
 Ptr<SpectrumValue> 
-LteSpectrumValueHelper::CreateTxPowerSpectralDensity (uint32_t earfcn, uint8_t txBandwidthConfiguration, double powerTx, std::vector <int> activeRbs)
+LteSpectrumValueHelper::CreateTxPowerSpectralDensity (uint16_t earfcn, uint8_t txBandwidthConfiguration, double powerTx, std::vector <int> activeRbs)
 {
   NS_LOG_FUNCTION (earfcn << (uint16_t) txBandwidthConfiguration << powerTx << activeRbs);
 
@@ -295,7 +256,7 @@
 }
 
 Ptr<SpectrumValue>
-LteSpectrumValueHelper::CreateTxPowerSpectralDensity (uint32_t earfcn, uint8_t txBandwidthConfiguration, double powerTx, std::map<int, double> powerTxMap, std::vector <int> activeRbs)
+LteSpectrumValueHelper::CreateTxPowerSpectralDensity (uint16_t earfcn, uint8_t txBandwidthConfiguration, double powerTx, std::map<int, double> powerTxMap, std::vector <int> activeRbs)
 {
   NS_LOG_FUNCTION (earfcn << (uint16_t) txBandwidthConfiguration << activeRbs);
 
@@ -306,6 +267,7 @@
   double powerTxW = std::pow (10., (powerTx - 30) / 10);
   double basicPowerTxW = std::pow (10., (powerTx - 30) / 10);
 
+  double txPowerDensity = (powerTxW / (txBandwidthConfiguration * 180000));
 
   for (std::vector <int>::iterator it = activeRbs.begin (); it != activeRbs.end (); it++)
     {
@@ -313,8 +275,6 @@
 
       std::map<int, double>::iterator powerIt = powerTxMap.find (rbId);
 
-      double txPowerDensity;
-
       if (powerIt != powerTxMap.end ())
         {
           powerTxW = std::pow (10., (powerIt->second - 30) / 10);
@@ -336,7 +296,7 @@
 
 
 Ptr<SpectrumValue>
-LteSpectrumValueHelper::CreateNoisePowerSpectralDensity (uint32_t earfcn, uint8_t txBandwidthConfiguration, double noiseFigure)
+LteSpectrumValueHelper::CreateNoisePowerSpectralDensity (uint16_t earfcn, uint8_t txBandwidthConfiguration, double noiseFigure)
 {
   NS_LOG_FUNCTION (earfcn << (uint16_t) txBandwidthConfiguration << noiseFigure);
   Ptr<SpectrumModel> model = GetSpectrumModel (earfcn, txBandwidthConfiguration);
diff -Naru a/model/lte-spectrum-value-helper.h b/model/lte-spectrum-value-helper.h
--- a/model/lte-spectrum-value-helper.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-spectrum-value-helper.h	2017-10-05 11:47:22.314601784 +0200
@@ -45,36 +45,18 @@
    *
    * \return the carrier frequency in Hz
    */
-  static double GetCarrierFrequency (uint32_t earfcn);
+  static double GetCarrierFrequency (uint16_t earfcn);
 
   /**
-   * Converts downlink EARFCN to corresponding LTE frequency band number.
-   *
-   * \param earfcn the EARFCN
-   *
-   * \return the downlink carrier band
-   */
-  static uint16_t GetDownlinkCarrierBand (uint32_t nDl);
-
-  /**
-   * Converts uplink EARFCN to corresponding LTE frequency band number.
-   *
-   * \param earfcn the EARFCN
-   *
-   * \return the uplink carrier band
-   */
-  static uint16_t GetUplinkCarrierBand (uint32_t nDl);
-
-  /**
-   * Calculates the downlink carrier frequency from the E-UTRA Absolute
+   * Calculates the dowlink carrier frequency from the E-UTRA Absolute
    * Radio Frequency Channel Number (EARFCN) using the formula in 3GPP TS
    * 36.101 section 5.7.3 "Carrier frequency and EARFCN".
    *
    * \param earfcn the EARFCN
    *
-   * \return the downlink carrier frequency in Hz
+   * \return the dowlink carrier frequency in Hz
    */
-  static double GetDownlinkCarrierFrequency (uint32_t earfcn);
+  static double GetDownlinkCarrierFrequency (uint16_t earfcn);
 
   /**
    * Calculates the uplink carrier frequency from the E-UTRA Absolute
@@ -85,7 +67,7 @@
    *
    * \return the uplink carrier frequency in Hz
    */
-  static double GetUplinkCarrierFrequency (uint32_t earfcn);
+  static double GetUplinkCarrierFrequency (uint16_t earfcn);
 
   /**
    *
@@ -109,7 +91,7 @@
    * configuration. If such SpectrumModel does not exist, it is
    * created.
    */
-  static Ptr<SpectrumModel> GetSpectrumModel (uint32_t earfcn, uint8_t bandwidth);
+  static Ptr<SpectrumModel> GetSpectrumModel (uint16_t earfcn, uint8_t bandwidth);
 
 
   /**
@@ -125,7 +107,7 @@
    *
    * \return a pointer to a newly allocated SpectrumValue representing the TX Power Spectral Density in W/Hz for each Resource Block
    */
-  static Ptr<SpectrumValue> CreateTxPowerSpectralDensity (uint32_t earfcn,
+  static Ptr<SpectrumValue> CreateTxPowerSpectralDensity (uint16_t earfcn,
                                                           uint8_t bandwidth,
                                                           double powerTx,
                                                           std::vector <int> activeRbs);
@@ -146,7 +128,7 @@
    *
    * \return a pointer to a newly allocated SpectrumValue representing the TX Power Spectral Density in W/Hz for each Resource Block
    */
-  static Ptr<SpectrumValue> CreateTxPowerSpectralDensity (uint32_t earfcn,
+  static Ptr<SpectrumValue> CreateTxPowerSpectralDensity (uint16_t earfcn,
                                                           uint8_t bandwidth,
                                                           double powerTx,
                                                           std::map<int, double> powerTxMap,
@@ -163,7 +145,7 @@
    *
    * \return a pointer to a newly allocated SpectrumValue representing the noise Power Spectral Density in W/Hz for each Resource Block
    */
-  static Ptr<SpectrumValue> CreateNoisePowerSpectralDensity (uint32_t earfcn, uint8_t bandwidth, double noiseFigure);
+  static Ptr<SpectrumValue> CreateNoisePowerSpectralDensity (uint16_t earfcn, uint8_t bandwidth, double noiseFigure);
 
   /**
    *  create a SpectrumValue that models the power spectral density of AWGN
diff -Naru a/model/lte-ue-ccm-rrc-sap.cc b/model/lte-ue-ccm-rrc-sap.cc
--- a/model/lte-ue-ccm-rrc-sap.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-ccm-rrc-sap.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#include "lte-ue-ccm-rrc-sap.h"
-
-namespace ns3 {
-
-
-LteUeCcmRrcSapProvider::~LteUeCcmRrcSapProvider ()
-{
-}
-
-
-LteUeCcmRrcSapUser::~LteUeCcmRrcSapUser ()
-{
-}
-
-
-} // end of namespace ns3
diff -Naru a/model/lte-ue-ccm-rrc-sap.h b/model/lte-ue-ccm-rrc-sap.h
--- a/model/lte-ue-ccm-rrc-sap.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-ccm-rrc-sap.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#ifndef LTE_UE_CCM_RRC_SAP_H
-#define LTE_UE_CCM_RRC_SAP_H
-
-#include <ns3/lte-rrc-sap.h>
-#include <ns3/eps-bearer.h>
-#include <ns3/lte-ue-cmac-sap.h>
-#include <ns3/lte-mac-sap.h>
-#include <map>
-
-
-namespace ns3 {
-  class LteUeCmacSapProvider;
-  class LteMacSapUser;
-
-  /**
- * \brief Service Access Point (SAP) offered by the UE component carrier manager 
- *  to the UE RRC.
- *
- * This is the *Component Carrier Management SAP Provider*, i.e., the part of the SAP
- * that contains the component carrier manager methods called by the Ue RRC
- * instance.
- */
-class LteUeCcmRrcSapProvider
-{
-
-/// allow  LteMacSapUser class friend access
-friend class LteMacSapUser;
- 
-public:
-
-  virtual ~LteUeCcmRrcSapProvider ();
-  /// LcsConfig structure
-  struct LcsConfig
-  {
-    uint8_t componentCarrierId; ///< component carrier ID
-    LteUeCmacSapProvider::LogicalChannelConfig *lcConfig; ///< logical channel config
-    LteMacSapUser *msu; ///< MSU
-  };
-
-  /** 
-   * add a new Logical Channel (LC) 
-   * 
-   * \param lcId is the Logical Channel Id
-   * \param lcConfig is a single structure contains logical Channel Id, Logical Channel config and Component Carrier Id
-   * \param msu is the pointer to LteMacSapUser related to the Rlc instance
-   * \return vector of LcsConfig contains the lc configuration for each Mac
-   *                the size of the vector is equal to the number of component
-   *                carrier enabled.
-   *
-   * The Logical Channel configurations for each component carrier depend on the 
-   * algorithm used to split the traffic between the component carriers themself.
-   */
-  virtual  std::vector<LteUeCcmRrcSapProvider::LcsConfig> AddLc (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu) = 0;
-
-  /**
-   * \brief Remove an existing Logical Channel for a Ue in the LteUeComponentCarrierManager
-   * \param lcid the Logical Channel Id
-   * \return vector of integer the componentCarrierId of the componentCarrier
-   *                where the bearer is enabled
-   */
-  virtual std::vector<uint16_t> RemoveLc (uint8_t lcid) = 0;
-  /// Notify reconfiguration msg function
-  virtual void NotifyConnectionReconfigurationMsg () = 0;
-
-  
-  /**
-   * \brief Add the Signal Bearer for a specif Ue in LteUeComponenCarrierManager
-   * \param lcid the Logical Channel Id
-   * \param lcConfig this structure it is hard-coded in the LteEnbRrc
-   * \param msu it is the MacSapUser of the Rlc istance
-   * \return the LteMacSapUser of the ComponentCarrierManager
-   *
-   */
-  virtual LteMacSapUser* ConfigureSignalBearer (uint8_t lcid,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu) = 0;
-
-}; // end of class LteUeCcmRrcSapProvider
-
-/// MemberLteUeCcmRrcSapProvider class
-template <class C>
-class MemberLteUeCcmRrcSapProvider : public LteUeCcmRrcSapProvider
-{
-public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
-  MemberLteUeCcmRrcSapProvider (C* owner);
-
-  // inherited from LteUeCcmRrcSapProvider
-  virtual std::vector<uint16_t> RemoveLc (uint8_t lcid);
-  virtual std::vector<LteUeCcmRrcSapProvider::LcsConfig> AddLc (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu);
-  virtual void NotifyConnectionReconfigurationMsg ();
-  virtual LteMacSapUser* ConfigureSignalBearer (uint8_t lcid,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu);
-  
-private:
-  C* m_owner; ///< the owner class
-};
-
-template <class C>
-MemberLteUeCcmRrcSapProvider<C>::MemberLteUeCcmRrcSapProvider (C* owner)
-  : m_owner (owner)
-{
-}
-
-template <class C>
-std::vector<uint16_t> MemberLteUeCcmRrcSapProvider<C>::RemoveLc (uint8_t lcid)
-{
-  return m_owner->DoRemoveLc (lcid);
-}
-
-template <class C>
-std::vector<LteUeCcmRrcSapProvider::LcsConfig> MemberLteUeCcmRrcSapProvider<C>::AddLc (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu)
-{
-  return m_owner->DoAddLc (lcId, lcConfig, msu);
-}
-
-template <class C>
-void MemberLteUeCcmRrcSapProvider<C>::NotifyConnectionReconfigurationMsg ()
-{
-  m_owner->DoNotifyConnectionReconfigurationMsg ();
-}
-
-
-template <class C>
-LteMacSapUser* MemberLteUeCcmRrcSapProvider<C>::ConfigureSignalBearer (uint8_t lcid,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu)
-{
-  return m_owner->DoConfigureSignalBearer (lcid, lcConfig, msu);
-}
-
-
-/**
- * \brief Service Access Point (SAP) offered by the UE RRC to the UE CCM.
- *
- * This is the *Component Carrier Management SAP User*, i.e., the part of the SAP
- * that contains the UE RRC methods called by the UE CCM instance.
- */
-class LteUeCcmRrcSapUser
-{
- 
-public:
-  virtual ~LteUeCcmRrcSapUser ();
-
-  /**
-   * this function will be used after the RRC notify to ComponentCarrierManager
-   * that a reconfiguration message with Secondary component carrier (SCc) arrived or not
-   * the method it is called only if the SCc wasn't set up
-   * \param componentCarrierList component carrier list
-   */
-  virtual void ComponentCarrierEnabling (std::vector<uint8_t> componentCarrierList) = 0;
-
-}; // end of class LteUeCcmRrcSapUser
-
-  /// MemberLteUeCcmRrcSapUser class
-  template <class C>
-  class MemberLteUeCcmRrcSapUser : public LteUeCcmRrcSapUser
-  {
-  public:
-    /**
-     * Constructor
-     *
-     * \param owner the owner class
-     */
-    MemberLteUeCcmRrcSapUser (C* owner);
-    //inherited from LteUeCcmRrcSapUser
-    virtual void ComponentCarrierEnabling (std::vector<uint8_t> componentCarrierList);
-
-  private:
-  C* m_owner; ///< the owner class
-};
-
-template <class C>
-MemberLteUeCcmRrcSapUser<C>::MemberLteUeCcmRrcSapUser (C* owner)
-  : m_owner (owner)
-{
-}
-  
-template <class C>
-void MemberLteUeCcmRrcSapUser<C>::ComponentCarrierEnabling (std::vector<uint8_t> componentCarrierList)
-{
-  m_owner->DoComponentCarrierEnabling (componentCarrierList);
-}
-  
-} // end of namespace ns3
-
-
-#endif /* LTE_UE_CCM_RRC_SAP_H */
-
diff -Naru a/model/lte-ue-cmac-sap.h b/model/lte-ue-cmac-sap.h
--- a/model/lte-ue-cmac-sap.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-cmac-sap.h	2017-10-05 11:47:22.314601784 +0200
@@ -42,19 +42,13 @@
 public:
   virtual ~LteUeCmacSapProvider ();
 
-  /// RachConfig structure
   struct RachConfig
   {
-    uint8_t numberOfRaPreambles; ///< number of RA preambles
-    uint8_t preambleTransMax; ///< preamble transmit maximum
-    uint8_t raResponseWindowSize; ///< RA response window size
+    uint8_t numberOfRaPreambles;
+    uint8_t preambleTransMax;
+    uint8_t raResponseWindowSize;
   };
   
-  /** 
-   * Configure RACH function 
-   *
-   * \param rc the RACH config
-   */
   virtual void ConfigureRach (RachConfig rc) = 0;
 
   /** 
@@ -75,13 +69,12 @@
   virtual void StartNonContentionBasedRandomAccessProcedure (uint16_t rnti, uint8_t rapId, uint8_t prachMask) = 0;
 
 
-  /// LogicalChannelConfig structure
   struct LogicalChannelConfig
   {
-    uint8_t priority; ///< priority
-    uint16_t prioritizedBitRateKbps; ///< prioritize bit rate Kbps
-    uint16_t bucketSizeDurationMs; ///< bucket size duration ms
-    uint8_t logicalChannelGroup; ///< logical channel group
+    uint8_t priority;
+    uint16_t prioritizedBitRateKbps;
+    uint16_t bucketSizeDurationMs;
+    uint8_t logicalChannelGroup;
   };
   
   /** 
@@ -106,12 +99,6 @@
    */
   virtual void Reset () = 0;
   
-  /**
-   *
-   * \param rnti the cell-specific UE identifier
-   */
-  virtual void SetRnti (uint16_t rnti) = 0;
-
 };
 
 
diff -Naru a/model/lte-ue-component-carrier-manager.cc b/model/lte-ue-component-carrier-manager.cc
--- a/model/lte-ue-component-carrier-manager.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-component-carrier-manager.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#include "lte-ue-component-carrier-manager.h"
-#include <ns3/log.h>
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("LteUeComponentCarrierManager");
-NS_OBJECT_ENSURE_REGISTERED (LteUeComponentCarrierManager);
-
-LteUeComponentCarrierManager::LteUeComponentCarrierManager ()
-{
-}
-
-LteUeComponentCarrierManager::~LteUeComponentCarrierManager ()
-{
-}
-
-TypeId
-LteUeComponentCarrierManager::GetTypeId ()
-{
-  static TypeId tid = TypeId ("ns3::LteUeComponentCarrierManager")
-                      .SetParent<Object> ()
-                      .SetGroupName("Lte");
-  return tid;
-}
-
-void
-LteUeComponentCarrierManager::DoDispose ()
-{
-}
-
-bool 
-LteUeComponentCarrierManager::SetComponentCarrierMacSapProviders (uint8_t componentCarrierId, LteMacSapProvider* sap)
-{
-  NS_LOG_FUNCTION (this);
-  bool result = false;
-  std::map <uint8_t, LteMacSapProvider*>::iterator it;
-  it=m_macSapProvidersMap.find (componentCarrierId);
-  if (componentCarrierId > m_noOfComponentCarriers)
-    {
-      NS_FATAL_ERROR ("Inconsistent componentCarrierId or you didn't call SetNumberOfComponentCarriers before calling this method");
-    }
-  if (it != m_macSapProvidersMap.end ())
-    {
-      NS_FATAL_ERROR ("Tried to allocated an existing componentCarrierId");
-    }
-  else
-    {
-      m_macSapProvidersMap.insert (std::pair<uint8_t, LteMacSapProvider*>(componentCarrierId, sap));
-      result = true;
-    }
-  return result;
-  
-}
-
-void
-LteUeComponentCarrierManager::SetNumberOfComponentCarriers (uint8_t noOfComponentCarriers)
-{
-  NS_LOG_FUNCTION (this);
-  m_noOfComponentCarriers = noOfComponentCarriers;
-}
-
-
-} // end of namespace ns3
diff -Naru a/model/lte-ue-component-carrier-manager.h b/model/lte-ue-component-carrier-manager.h
--- a/model/lte-ue-component-carrier-manager.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-component-carrier-manager.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,113 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#ifndef LTE_UE_COMPONENT_CARRIER_MANAGER_H
-#define LTE_UE_COMPONENT_CARRIER_MANAGER_H
-
-#include <ns3/object.h>
-#include <ns3/lte-rrc-sap.h>
-#include <ns3/lte-ue-ccm-rrc-sap.h>
-#include <ns3/lte-mac-sap.h>
-#include <map>
-#include <vector>
-
-namespace ns3 {
-
-
-class LteUeCcmRrcSapUser;
-class LteUeCcmRrcSapProvider;
-
-class LteMacSapUser;
-class LteMacSapProvider;
-
-
-/**
- * \brief The abstract base class of a Component Carrier Manager* for UE 
-  that operates using the component carrier manager SAP interface.
- *
- */
-class LteUeComponentCarrierManager : public Object
-{
-
-public:
-  LteUeComponentCarrierManager ();
-  virtual ~LteUeComponentCarrierManager ();
-
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId ();
-
-  /**
-   * \brief Set the "user" part of the ComponentCarrier Management SAP interface
-   * that this UE component carrier manager will interact with.
-   * \param s a reference to the "user" part of the interface, typically a
-   *          member of an LteEnbRrc instance
-   */
-  virtual void SetLteCcmRrcSapUser (LteUeCcmRrcSapUser* s) = 0;
-
-  /**
-   * \brief Exports the "provider" part of the ComponentCarrier Management SAP interface.
-   * \return the reference to the "provider" part of the interface, typically to
-   *         be kept by an LteUeRrc instance
-   */
-  virtual LteUeCcmRrcSapProvider* GetLteCcmRrcSapProvider () = 0;
-  
-  /**
-   * \brief Returns the MAC sap provider interface that if forwarding calls to the
-   * instance of the LteUeComponentCarrierManager.
-   * \return the reference to the "provider" part of the interface
-   */
-  virtual LteMacSapProvider* GetLteMacSapProvider () = 0;
-
-  /**
-   * \brief Sets a pointer to SAP interface of MAC instance for the specified carrier.
-   * \param componentCarrierId the component carrier id
-   * \param sap the pointer to the sap interface
-   * \return whether the settings of the sap provider was successful
-   */
-  bool SetComponentCarrierMacSapProviders (uint8_t componentCarrierId, LteMacSapProvider* sap);
-
-  /**
-   * \brief Sets number of component carriers that are supported by this UE.
-   * \param noOfComponentCarriers numbr of compoent carriers
-   */
-  void SetNumberOfComponentCarriers (uint8_t noOfComponentCarriers);
-
-protected:
-
-  // inherited from Object
-  virtual void DoDispose ();
-
-  std::map<uint8_t, LteMacSapUser*> m_lcAttached; //!< Map of pointers to SAP interfaces of the RLC instance of the flows of this UE.
-  std::map<uint8_t, std::map<uint8_t, LteMacSapProvider*> > m_componentCarrierLcMap; //!< Flow configuration per flow Id of this UE.
-  uint16_t m_noOfComponentCarriers; //!<// The number of component carriers that this UE can support.
-  uint16_t m_noOfComponentCarriersEnabled; //!< The number of enabled component carriers that are enabled for this UE.
-  std::map <uint8_t, LteMacSapProvider*> m_macSapProvidersMap; //!< Map of pointers to SAP to interfaces of the MAC instance if the flows of this UE.
-
-}; // end of class LteUeComponentCarrierManager
-
-
-} // end of namespace ns3
-
-
-#endif /* LTE_UE_COMPONENT_CARRIER_MANAGER_H */
diff -Naru a/model/lte-ue-cphy-sap.h b/model/lte-ue-cphy-sap.h
--- a/model/lte-ue-cphy-sap.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-cphy-sap.h	2017-10-05 11:47:22.314601784 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>,
  *         Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_UE_CPHY_SAP_H
@@ -66,7 +70,7 @@
    * and periodically returning measurement reports to RRC via
    * LteUeCphySapUser::ReportUeMeasurements function.
    */
-  virtual void StartCellSearch (uint32_t dlEarfcn) = 0;
+  virtual void StartCellSearch (uint16_t dlEarfcn) = 0;
 
   /**
    * \brief Tell the PHY entity to synchronize with a given eNodeB over the
@@ -101,7 +105,7 @@
    * LteUeCphySapProvider::SetDlBandwidth can be called afterwards to increase
    * the bandwidth.
    */
-  virtual void SynchronizeWithEnb (uint16_t cellId, uint32_t dlEarfcn) = 0;
+  virtual void SynchronizeWithEnb (uint16_t cellId, uint16_t dlEarfcn) = 0;
 
   /**
    * \param dlBandwidth the DL bandwidth in number of PRBs
@@ -114,7 +118,7 @@
    * \param ulEarfcn the uplink carrier frequency (EARFCN)
    * \param ulBandwidth the UL bandwidth in number of PRBs
    */
-  virtual void ConfigureUplink (uint32_t ulEarfcn, uint8_t ulBandwidth) = 0;
+  virtual void ConfigureUplink (uint16_t ulEarfcn, uint8_t ulBandwidth) = 0;
 
   /**
    * \brief Configure referenceSignalPower
@@ -169,16 +173,14 @@
    */
   struct UeMeasurementsElement
   {
-    uint16_t m_cellId; ///< cell ID
-    double m_rsrp;  ///< [dBm]
-    double m_rsrq;  ///< [dB]
+    uint16_t m_cellId;
+    double m_rsrp;  // [dBm]
+    double m_rsrq;  // [dB]
   };
 
-  /// UeMeasurementsParameters structure
   struct UeMeasurementsParameters
   {
-    std::vector <struct UeMeasurementsElement> m_ueMeasurementsList; ///< UE measurement list
-    uint8_t m_componentCarrierId; ///< component carrier ID
+    std::vector <struct UeMeasurementsElement> m_ueMeasurementsList;
   };
 
 
@@ -211,6 +213,8 @@
    */
   virtual void ReportUeMeasurements (UeMeasurementsParameters params) = 0;
 
+  virtual void NotifyRadioLinkFailure (double lastSinrValue) = 0;
+
 };
 
 
@@ -225,20 +229,15 @@
 class MemberLteUeCphySapProvider : public LteUeCphySapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteUeCphySapProvider (C* owner);
 
   // inherited from LteUeCphySapProvider
   virtual void Reset ();
-  virtual void StartCellSearch (uint32_t dlEarfcn);
+  virtual void StartCellSearch (uint16_t dlEarfcn);
   virtual void SynchronizeWithEnb (uint16_t cellId);
-  virtual void SynchronizeWithEnb (uint16_t cellId, uint32_t dlEarfcn);
+  virtual void SynchronizeWithEnb (uint16_t cellId, uint16_t dlEarfcn);
   virtual void SetDlBandwidth (uint8_t dlBandwidth);
-  virtual void ConfigureUplink (uint32_t ulEarfcn, uint8_t ulBandwidth);
+  virtual void ConfigureUplink (uint16_t ulEarfcn, uint8_t ulBandwidth);
   virtual void ConfigureReferenceSignalPower (int8_t referenceSignalPower);
   virtual void SetRnti (uint16_t rnti);
   virtual void SetTransmissionMode (uint8_t txMode);
@@ -247,7 +246,7 @@
 
 private:
   MemberLteUeCphySapProvider ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -270,7 +269,7 @@
 
 template <class C>
 void
-MemberLteUeCphySapProvider<C>::StartCellSearch (uint32_t dlEarfcn)
+MemberLteUeCphySapProvider<C>::StartCellSearch (uint16_t dlEarfcn)
 {
   m_owner->DoStartCellSearch (dlEarfcn);
 }
@@ -284,7 +283,7 @@
 
 template <class C>
 void
-MemberLteUeCphySapProvider<C>::SynchronizeWithEnb (uint16_t cellId, uint32_t dlEarfcn)
+MemberLteUeCphySapProvider<C>::SynchronizeWithEnb (uint16_t cellId, uint16_t dlEarfcn)
 {
   m_owner->DoSynchronizeWithEnb (cellId, dlEarfcn);
 }
@@ -298,7 +297,7 @@
 
 template <class C>
 void 
-MemberLteUeCphySapProvider<C>::ConfigureUplink (uint32_t ulEarfcn, uint8_t ulBandwidth)
+MemberLteUeCphySapProvider<C>::ConfigureUplink (uint16_t ulEarfcn, uint8_t ulBandwidth)
 {
   m_owner->DoConfigureUplink (ulEarfcn, ulBandwidth);
 }
@@ -348,11 +347,6 @@
 class MemberLteUeCphySapUser : public LteUeCphySapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param owner the owner class
-   */
   MemberLteUeCphySapUser (C* owner);
 
   // methods inherited from LteUeCphySapUser go here
@@ -362,9 +356,11 @@
                                                 LteRrcSap::SystemInformationBlockType1 sib1);
   virtual void ReportUeMeasurements (LteUeCphySapUser::UeMeasurementsParameters params);
 
+  virtual void NotifyRadioLinkFailure (double lastSinrValue);
+
 private:
   MemberLteUeCphySapUser ();
-  C* m_owner; ///< the owner class
+  C* m_owner;
 };
 
 template <class C>
@@ -401,6 +397,14 @@
   m_owner->DoReportUeMeasurements (params);
 }
 
+template <class C>
+void
+MemberLteUeCphySapUser<C>::NotifyRadioLinkFailure (double lastSinrValue)
+{
+  m_owner->DoNotifyRadioLinkFailure(lastSinrValue);
+}
+
+
 
 } // namespace ns3
 
diff -Naru a/model/lte-ue-mac.cc b/model/lte-ue-mac.cc
--- a/model/lte-ue-mac.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-mac.cc	2017-10-05 11:47:22.314601784 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,6 +18,9 @@
  *
  * Author: Nicola Baldo  <nbaldo@cttc.es>
  * Author: Marco Miozzo <mmiozzo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 
@@ -48,28 +52,22 @@
 // SAP forwarders
 ///////////////////////////////////////////////////////////
 
-/// UeMemberLteUeCmacSapProvider class
+
 class UeMemberLteUeCmacSapProvider : public LteUeCmacSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the UE MAC
-   */
   UeMemberLteUeCmacSapProvider (LteUeMac* mac);
 
   // inherited from LteUeCmacSapProvider
   virtual void ConfigureRach (RachConfig rc);
   virtual void StartContentionBasedRandomAccessProcedure ();
   virtual void StartNonContentionBasedRandomAccessProcedure (uint16_t rnti, uint8_t preambleId, uint8_t prachMask);
-  virtual void SetRnti (uint16_t rnti);
   virtual void AddLc (uint8_t lcId, LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu);
   virtual void RemoveLc (uint8_t lcId);
   virtual void Reset ();
 
 private:
-  LteUeMac* m_mac; ///< the UE MAC
+  LteUeMac* m_mac;
 };
 
 
@@ -96,11 +94,6 @@
   m_mac->DoStartNonContentionBasedRandomAccessProcedure (rnti, preambleId, prachMask);
 }
 
- void
- UeMemberLteUeCmacSapProvider::SetRnti (uint16_t rnti)
- {
-   m_mac->DoSetRnti (rnti);
- }
 
 void
 UeMemberLteUeCmacSapProvider::AddLc (uint8_t lcId, LogicalChannelConfig lcConfig, LteMacSapUser* msu)
@@ -120,15 +113,9 @@
   m_mac->DoReset ();
 }
 
-/// UeMemberLteMacSapProvider class
 class UeMemberLteMacSapProvider : public LteMacSapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the UE MAC
-   */
   UeMemberLteMacSapProvider (LteUeMac* mac);
 
   // inherited from LteMacSapProvider
@@ -136,7 +123,7 @@
   virtual void ReportBufferStatus (ReportBufferStatusParameters params);
 
 private:
-  LteUeMac* m_mac; ///< the UE MAC
+  LteUeMac* m_mac;
 };
 
 
@@ -160,17 +147,10 @@
 
 
 
-/**
- * UeMemberLteUePhySapUser
- */
+
 class UeMemberLteUePhySapUser : public LteUePhySapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param mac the UE MAC
-   */
   UeMemberLteUePhySapUser (LteUeMac* mac);
 
   // inherited from LtePhySapUser
@@ -179,7 +159,7 @@
   virtual void ReceiveLteControlMessage (Ptr<LteControlMessage> msg);
 
 private:
-  LteUeMac* m_mac; ///< the UE MAC
+  LteUeMac* m_mac;
 };
 
 UeMemberLteUePhySapUser::UeMemberLteUePhySapUser (LteUeMac* mac) : m_mac (mac)
@@ -248,7 +228,6 @@
   m_cmacSapProvider = new UeMemberLteUeCmacSapProvider (this);
   m_uePhySapUser = new UeMemberLteUePhySapUser (this);
   m_raPreambleUniformVariable = CreateObject<UniformRandomVariable> ();
-  m_componentCarrierId = 0;
 }
 
 
@@ -300,11 +279,6 @@
   return m_cmacSapProvider;
 }
 
-void
-LteUeMac::SetComponentCarrierId (uint8_t index)
-{
-  m_componentCarrierId = index;
-}
 
 void
 LteUeMac::DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params)
@@ -321,9 +295,7 @@
 
 void
 LteUeMac::DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params)
-{
-  NS_LOG_FUNCTION (this << (uint32_t) params.lcid);
-  
+{  
   std::map <uint8_t, LteMacSapProvider::ReportBufferStatusParameters>::iterator it;
   
   
@@ -367,6 +339,7 @@
   for (it = m_ulBsrReceived.begin (); it != m_ulBsrReceived.end (); it++)
     {
       uint8_t lcid = it->first;
+      NS_LOG_INFO("LTE lcid of BSR " << (uint16_t)lcid << " queue size " << (*it).second.txQueueSize);
       std::map <uint8_t, LcInfo>::iterator lcInfoMapIt;
       lcInfoMapIt = m_lcInfoMap.find (lcid);
       NS_ASSERT (lcInfoMapIt !=  m_lcInfoMap.end ());
@@ -406,6 +379,7 @@
 void
 LteUeMac::SendRaPreamble (bool contention)
 {
+  NS_LOG_INFO("SendRaPreamble " << (uint16_t)m_raPreambleId << " contention " << contention);
   NS_LOG_FUNCTION (this << (uint32_t) m_raPreambleId << contention);
   // Since regular UL LteControlMessages need m_ulConfigured = true in
   // order to be sent by the UE, the rach preamble needs to be sent
@@ -458,12 +432,7 @@
     {
       NS_ASSERT_MSG (raResponse.m_grant.m_tbSize > lc0BsrIt->second.txQueueSize, 
                      "segmentation of Message 3 is not allowed");
-      // this function can be called only from primary carrier
-      if (m_componentCarrierId > 0)
-        {
-          NS_FATAL_ERROR ("Function called on wrong componentCarrier");
-        }
-      lc0InfoIt->second.macSapUser->NotifyTxOpportunity (raResponse.m_grant.m_tbSize, 0, 0, m_componentCarrierId, m_rnti, lc0Lcid); 
+      lc0InfoIt->second.macSapUser->NotifyTxOpportunity (raResponse.m_grant.m_tbSize, 0, 0); 
       lc0BsrIt->second.txQueueSize = 0;
     }
 }
@@ -514,14 +483,6 @@
   RandomlySelectAndSendRaPreamble ();
 }
 
-void
-LteUeMac::DoSetRnti (uint16_t rnti)
-{
-  NS_LOG_FUNCTION (this);
-  m_rnti = rnti;
-}
-
-
 void 
 LteUeMac::DoStartNonContentionBasedRandomAccessProcedure (uint16_t rnti, uint8_t preambleId, uint8_t prachMask)
 {
@@ -537,8 +498,11 @@
 LteUeMac::DoAddLc (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu)
 {
   NS_LOG_FUNCTION (this << " lcId" << (uint32_t) lcId);
-  NS_ASSERT_MSG (m_lcInfoMap.find (lcId) == m_lcInfoMap.end (), "cannot add channel because LCID " << lcId << " is already present");
-  
+
+  // comment this assert in order to allow RLC updates
+  //NS_ASSERT_MSG (m_lcInfoMap.find (lcId) == m_lcInfoMap.end (), "cannot add channel because LCID " << lcId << " is already present");
+
+  NS_LOG_DEBUG("Add LC in " << m_rnti << " lcid " << (uint32_t)lcId);  
   LcInfo lcInfo;
   lcInfo.lcConfig = lcConfig;
   lcInfo.macSapUser = msu;
@@ -589,7 +553,8 @@
       std::map <uint8_t, LcInfo>::const_iterator it = m_lcInfoMap.find (tag.GetLcid ());
       if (it != m_lcInfoMap.end ())
         {
-          it->second.macSapUser->ReceivePdu (p, m_rnti, tag.GetLcid ());
+          NS_LOG_INFO("LteUeMac ReceivePhyPdu");
+          it->second.macSapUser->ReceivePdu (p);
         }
       else
         {
@@ -661,7 +626,7 @@
                 {
                   if ((statusPduPriority) && ((*itBsr).second.statusPduSize == statusPduMinSize))
                     {
-                      (*it).second.macSapUser->NotifyTxOpportunity ((*itBsr).second.statusPduSize, 0, 0, m_componentCarrierId, m_rnti, (*it).first);
+                      (*it).second.macSapUser->NotifyTxOpportunity ((*itBsr).second.statusPduSize, 0, 0);
                       NS_LOG_LOGIC (this << "\t" << bytesPerActiveLc << " send  " << (*itBsr).second.statusPduSize << " status bytes to LC " << (uint32_t)(*it).first << " statusQueue " << (*itBsr).second.statusPduSize << " retxQueue" << (*itBsr).second.retxQueueSize << " txQueue" <<  (*itBsr).second.txQueueSize);
                       (*itBsr).second.statusPduSize = 0;
                       break;
@@ -672,7 +637,7 @@
                       NS_LOG_LOGIC (this << "\t" << bytesPerActiveLc << " bytes to LC " << (uint32_t)(*it).first << " statusQueue " << (*itBsr).second.statusPduSize << " retxQueue" << (*itBsr).second.retxQueueSize << " txQueue" <<  (*itBsr).second.txQueueSize);
                       if (((*itBsr).second.statusPduSize > 0) && (bytesForThisLc > (*itBsr).second.statusPduSize))
                         {
-                          (*it).second.macSapUser->NotifyTxOpportunity ((*itBsr).second.statusPduSize, 0, 0, m_componentCarrierId, m_rnti, (*it).first);
+                          (*it).second.macSapUser->NotifyTxOpportunity ((*itBsr).second.statusPduSize, 0, 0);
                           bytesForThisLc -= (*itBsr).second.statusPduSize;
                           NS_LOG_DEBUG (this << " serve STATUS " << (*itBsr).second.statusPduSize);
                           (*itBsr).second.statusPduSize = 0;
@@ -692,7 +657,7 @@
                           if ((*itBsr).second.retxQueueSize > 0)
                             {
                               NS_LOG_DEBUG (this << " serve retx DATA, bytes " << bytesForThisLc);
-                              (*it).second.macSapUser->NotifyTxOpportunity (bytesForThisLc, 0, 0, m_componentCarrierId, m_rnti, (*it).first);
+                              (*it).second.macSapUser->NotifyTxOpportunity (bytesForThisLc, 0, 0);
                               if ((*itBsr).second.retxQueueSize >= bytesForThisLc)
                                 {
                                   (*itBsr).second.retxQueueSize -= bytesForThisLc;
@@ -720,7 +685,7 @@
                                   rlcOverhead = 2;
                                 }
                               NS_LOG_DEBUG (this << " serve tx DATA, bytes " << bytesForThisLc << ", RLC overhead " << rlcOverhead);
-                              (*it).second.macSapUser->NotifyTxOpportunity (bytesForThisLc, 0, 0, m_componentCarrierId, m_rnti, (*it).first);
+                              (*it).second.macSapUser->NotifyTxOpportunity (bytesForThisLc, 0, 0);
                               if ((*itBsr).second.txQueueSize >= bytesForThisLc - rlcOverhead)
                                 {
                                   (*itBsr).second.txQueueSize -= bytesForThisLc - rlcOverhead;
diff -Naru a/model/lte-ue-mac.h b/model/lte-ue-mac.h
--- a/model/lte-ue-mac.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-mac.h	2017-10-05 11:47:22.314601784 +0200
@@ -42,45 +42,20 @@
 
 class LteUeMac :   public Object
 {
-  /// allow UeMemberLteUeCmacSapProvider class friend access
   friend class UeMemberLteUeCmacSapProvider;
-  /// allow UeMemberLteMacSapProvider class friend access
   friend class UeMemberLteMacSapProvider;
-  /// allow UeMemberLteUePhySapUser class friend access
   friend class UeMemberLteUePhySapUser;
 
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
   LteUeMac ();
   virtual ~LteUeMac ();
   virtual void DoDispose (void);
 
-  /**
-  * \brief Get the LTE MAC SAP provider
-  * \return a pointer to the LTE MAC SAP provider
-  */
   LteMacSapProvider*  GetLteMacSapProvider (void);
-  /**
-  * \brief Set the LTE UE CMAC SAP user
-  * \param s the LTE UE CMAC SAP User
-  */
   void  SetLteUeCmacSapUser (LteUeCmacSapUser* s);
-  /**
-  * \brief Get the LTE CMAC SAP provider
-  * \return a pointer to the LTE CMAC SAP provider
-  */
   LteUeCmacSapProvider*  GetLteUeCmacSapProvider (void);
-  
-  /**
-  * \brief Set the component carried ID
-  * \param index the component carrier ID
-  */
-  void SetComponentCarrierId (uint8_t index);
 
   /**
   * \brief Get the PHY SAP user
@@ -114,151 +89,74 @@
 
 private:
   // forwarded from MAC SAP
- /**
-  * Transmit PDU function
-  *
-  * \param params LteMacSapProvider::TransmitPduParameters
-  */
   void DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params);
- /**
-  * Report buffers status function
-  *
-  * \param params LteMacSapProvider::ReportBufferStatusParameters
-  */
   void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params);
 
   // forwarded from UE CMAC SAP
- /**
-  * Configure RACH function
-  *
-  * \param rc LteUeCmacSapProvider::RachConfig
-  */
   void DoConfigureRach (LteUeCmacSapProvider::RachConfig rc);
- /**
-  * Start contention based random access procedure function
-  */
   void DoStartContentionBasedRandomAccessProcedure ();
- /**
-  * Set RNTI
-  *
-  * \param rnti the RNTI
-  */
-  void DoSetRnti (uint16_t rnti);
- /**
-  * Start non contention based random access procedure function
-  *
-  * \param rnti the RNTI
-  * \param rapId the RAPID
-  * \param prachMask the PRACH mask
-  */
   void DoStartNonContentionBasedRandomAccessProcedure (uint16_t rnti, uint8_t rapId, uint8_t prachMask);
- /**
-  * Add LC function
-  *
-  * \param lcId the LCID
-  * \param lcConfig the logical channel config
-  * \param msu the MSU
-  */
   void DoAddLc (uint8_t lcId, LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu);
- /**
-  * Remove LC function
-  *
-  * \param lcId the LCID
-  */
   void DoRemoveLc (uint8_t lcId);
-  /// Reset function
   void DoReset ();
 
   // forwarded from PHY SAP
- /**
-  * Receive Phy PDU function
-  *
-  * \param p the packet
-  */
   void DoReceivePhyPdu (Ptr<Packet> p);
- /**
-  * Receive LTE control message function
-  *
-  * \param msg the LTE control message
-  */
   void DoReceiveLteControlMessage (Ptr<LteControlMessage> msg);
   
   // internal methods
-  /// Randomly sleect and send RA preamble function
   void RandomlySelectAndSendRaPreamble ();
- /**
-  * Send RA preamble function
-  *
-  * \param contention if true randomly select and send te RA preamble
-  */
   void SendRaPreamble (bool contention);
-  /// Start waiting for RA response function
   void StartWaitingForRaResponse ();
- /**
-  * Receive the RA response function
-  *
-  * \param raResponse RA response received
-  */
   void RecvRaResponse (BuildRarListElement_s raResponse);
- /**
-  * RA response timeout function
-  *
-  * \param contention if true randomly select and send te RA preamble
-  */
   void RaResponseTimeout (bool contention);
-  /// Send report buffer status
   void SendReportBufferStatus (void);
-  /// Refresh HARQ processes packet buffer function
   void RefreshHarqProcessesPacketBuffer (void);
 
-  /// component carrier Id --> used to address sap
-  uint8_t m_componentCarrierId;
-
 private:
 
-  /// LcInfo structure
   struct LcInfo
   {
-    LteUeCmacSapProvider::LogicalChannelConfig lcConfig; ///< logical channel config
-    LteMacSapUser* macSapUser; ///< MAC SAP user
+    LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+    LteMacSapUser* macSapUser;
   };
 
-  std::map <uint8_t, LcInfo> m_lcInfoMap; ///< logical channel info map
+  std::map <uint8_t, LcInfo> m_lcInfoMap;
 
-  LteMacSapProvider* m_macSapProvider; ///< MAC SAP provider
+  LteMacSapProvider* m_macSapProvider;
 
-  LteUeCmacSapUser* m_cmacSapUser; ///< CMAC SAP user
-  LteUeCmacSapProvider* m_cmacSapProvider; ///< CMAC SAP provider
+  LteUeCmacSapUser* m_cmacSapUser;
+  LteUeCmacSapProvider* m_cmacSapProvider;
 
-  LteUePhySapProvider* m_uePhySapProvider; ///< UE Phy SAP provider
-  LteUePhySapUser* m_uePhySapUser; ///< UE Phy SAP user
+  LteUePhySapProvider* m_uePhySapProvider;
+  LteUePhySapUser* m_uePhySapUser;
   
-  std::map <uint8_t, LteMacSapProvider::ReportBufferStatusParameters> m_ulBsrReceived; ///< BSR received from RLC (the last one)
+  std::map <uint8_t, LteMacSapProvider::ReportBufferStatusParameters> m_ulBsrReceived; // BSR received from RLC (the last one)
   
   
-  Time m_bsrPeriodicity; ///< BSR periodicity
-  Time m_bsrLast; ///< BSR last
+  Time m_bsrPeriodicity;
+  Time m_bsrLast;
   
-  bool m_freshUlBsr; ///< true when a BSR has been received in the last TTI
+  bool m_freshUlBsr; // true when a BSR has been received in the last TTI
 
-  uint8_t m_harqProcessId; ///< HARQ process ID
-  std::vector < Ptr<PacketBurst> > m_miUlHarqProcessesPacket; ///< Packets under trasmission of the UL HARQ processes
-  std::vector < uint8_t > m_miUlHarqProcessesPacketTimer; ///< timer for packet life in the buffer
+  uint8_t m_harqProcessId;
+  std::vector < Ptr<PacketBurst> > m_miUlHarqProcessesPacket; // Packets under trasmission of the UL HARQ processes
+  std::vector < uint8_t > m_miUlHarqProcessesPacketTimer; // timer for packet life in the buffer
 
-  uint16_t m_rnti; ///< RNTI
+  uint16_t m_rnti;
 
-  bool m_rachConfigured; ///< is RACH configured?
-  LteUeCmacSapProvider::RachConfig m_rachConfig; ///< RACH configuration
-  uint8_t m_raPreambleId; ///< RA preamble ID
-  uint8_t m_preambleTransmissionCounter; ///< preamble tranamission counter
-  uint16_t m_backoffParameter; ///< backoff parameter
-  EventId m_noRaResponseReceivedEvent; ///< no RA response received event ID
-  Ptr<UniformRandomVariable> m_raPreambleUniformVariable; ///< RA preamble random variable
+  bool m_rachConfigured;
+  LteUeCmacSapProvider::RachConfig m_rachConfig;
+  uint8_t m_raPreambleId;
+  uint8_t m_preambleTransmissionCounter;
+  uint16_t m_backoffParameter;
+  EventId m_noRaResponseReceivedEvent;
+  Ptr<UniformRandomVariable> m_raPreambleUniformVariable;
 
-  uint32_t m_frameNo; ///< frame number
-  uint32_t m_subframeNo; ///< subframe number
-  uint8_t m_raRnti; ///< RA RNTI
-  bool m_waitingForRaResponse; ///< waiting for RA response
+  uint32_t m_frameNo;
+  uint32_t m_subframeNo;
+  uint8_t m_raRnti;
+  bool m_waitingForRaResponse;
 };
 
 } // namespace ns3
diff -Naru a/model/lte-ue-net-device.cc b/model/lte-ue-net-device.cc
--- a/model/lte-ue-net-device.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-net-device.cc	2017-10-05 11:47:22.314601784 +0200
@@ -18,9 +18,6 @@
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Nicola Baldo <nbaldo@cttc.es>
  *         Marco Miozzo <mmiozzo@cttc.es>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
  */
 
 #include "ns3/llc-snap-header.h"
@@ -46,9 +43,6 @@
 #include <ns3/ipv4-l3-protocol.h>
 #include <ns3/log.h>
 #include "epc-tft.h"
-#include <ns3/lte-ue-component-carrier-manager.h>
-#include <ns3/object-map.h>
-#include <ns3/object-factory.h>
 
 namespace ns3 {
 
@@ -74,15 +68,16 @@
                    PointerValue (),
                    MakePointerAccessor (&LteUeNetDevice::m_rrc),
                    MakePointerChecker <LteUeRrc> ())
-    .AddAttribute ("LteUeComponentCarrierManager",
-                   "The ComponentCarrierManager associated to this UeNetDevice",
+    .AddAttribute ("LteUeMac",
+                   "The MAC associated to this UeNetDevice",
                    PointerValue (),
-                   MakePointerAccessor (&LteUeNetDevice::m_componentCarrierManager),
-                   MakePointerChecker <LteUeComponentCarrierManager> ())
-    .AddAttribute ("ComponentCarrierMapUe", "List of all component Carrier.",
-                   ObjectMapValue (),
-                   MakeObjectMapAccessor (&LteUeNetDevice::m_ccMap),
-                   MakeObjectMapChecker<ComponentCarrierUe> ())
+                   MakePointerAccessor (&LteUeNetDevice::m_mac),
+                   MakePointerChecker <LteUeMac> ())
+    .AddAttribute ("LteUePhy",
+                   "The PHY associated to this UeNetDevice",
+                   PointerValue (),
+                   MakePointerAccessor (&LteUeNetDevice::m_phy),
+                   MakePointerChecker <LteUePhy> ())
     .AddAttribute ("Imsi",
                    "International Mobile Subscriber Identity assigned to this UE",
                    UintegerValue (0),
@@ -94,7 +89,7 @@
                    UintegerValue (100),
                    MakeUintegerAccessor (&LteUeNetDevice::SetDlEarfcn,
                                          &LteUeNetDevice::GetDlEarfcn),
-                   MakeUintegerChecker<uint32_t> (0, 262143))
+                   MakeUintegerChecker<uint16_t> (0, 6149))
     .AddAttribute ("CsgId",
                    "The Closed Subscriber Group (CSG) identity that this UE is associated with, "
                    "i.e., giving the UE access to cells which belong to this particular CSG. "
@@ -126,17 +121,14 @@
 {
   NS_LOG_FUNCTION (this);
   m_targetEnb = 0;
-
+  m_mac->Dispose ();
+  m_mac = 0;
   m_rrc->Dispose ();
   m_rrc = 0;
-  
+  m_phy->Dispose ();
+  m_phy = 0;
   m_nas->Dispose ();
   m_nas = 0;
-  for (uint32_t i = 0; i < m_ccMap.size (); i++)
-    {
-      m_ccMap.at (i)->Dispose ();
-    }
-  m_componentCarrierManager->Dispose ();
   LteNetDevice::DoDispose ();
 }
 
@@ -168,7 +160,7 @@
 LteUeNetDevice::GetMac (void) const
 {
   NS_LOG_FUNCTION (this);
-  return m_ccMap.at (0)->GetMac ();
+  return m_mac;
 }
 
 
@@ -184,14 +176,7 @@
 LteUeNetDevice::GetPhy (void) const
 {
   NS_LOG_FUNCTION (this);
-  return m_ccMap.at (0)->GetPhy ();
-}
-
-Ptr<LteUeComponentCarrierManager>
-LteUeNetDevice::GetComponentCarrierManager (void) const
-{
-  NS_LOG_FUNCTION (this);
-  return m_componentCarrierManager;
+  return m_phy;
 }
 
 Ptr<EpcUeNas>
@@ -208,7 +193,7 @@
   return m_imsi;
 }
 
-uint32_t
+uint16_t
 LteUeNetDevice::GetDlEarfcn () const
 {
   NS_LOG_FUNCTION (this);
@@ -216,7 +201,7 @@
 }
 
 void
-LteUeNetDevice::SetDlEarfcn (uint32_t earfcn)
+LteUeNetDevice::SetDlEarfcn (uint16_t earfcn)
 {
   NS_LOG_FUNCTION (this << earfcn);
   m_dlEarfcn = earfcn;
@@ -252,31 +237,14 @@
   return m_targetEnb;
 }
 
-std::map < uint8_t, Ptr<ComponentCarrierUe> >
-LteUeNetDevice::GetCcMap ()
-{
-  return m_ccMap;
-}
-
-void
-LteUeNetDevice::SetCcMap (std::map< uint8_t, Ptr<ComponentCarrierUe> > ccm)
-{
-  m_ccMap = ccm;
-}
-
 void 
 LteUeNetDevice::DoInitialize (void)
 {
   NS_LOG_FUNCTION (this);
   m_isConstructed = true;
   UpdateConfig ();
-
-  std::map< uint8_t, Ptr<ComponentCarrierUe> >::iterator it;
-  for (it = m_ccMap.begin (); it != m_ccMap.end (); ++it)
-    {
-      it->second->GetPhy ()->Initialize ();
-      it->second->GetMac ()->Initialize ();
-    }
+  m_phy->Initialize ();
+  m_mac->Initialize ();
   m_rrc->Initialize ();
 }
 
@@ -286,7 +254,7 @@
   NS_LOG_FUNCTION (this << dest << protocolNumber);
   if (protocolNumber != Ipv4L3Protocol::PROT_NUMBER)
     {
-      NS_LOG_INFO ("unsupported protocol " << protocolNumber << ", only IPv4 is supported");
+      NS_LOG_INFO("unsupported protocol " << protocolNumber << ", only IPv4 is supported");
       return true;
     }  
   return m_nas->Send (packet);
diff -Naru a/model/lte-ue-net-device.h b/model/lte-ue-net-device.h
--- a/model/lte-ue-net-device.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-net-device.h	2017-10-05 11:47:22.314601784 +0200
@@ -17,9 +17,6 @@
  *
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Nicola Baldo <nbaldo@cttc.es>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
  */
 
 #ifndef LTE_UE_NET_DEVICE_H
@@ -32,9 +29,7 @@
 #include "ns3/nstime.h"
 #include "ns3/lte-phy.h"
 #include "ns3/eps-bearer.h"
-#include "ns3/component-carrier-ue.h"
-#include <vector>
-#include <map>
+
 
 namespace ns3 {
 
@@ -48,7 +43,6 @@
 class LteUeRrc;
 class EpcUeNas;
 class EpcTft;
-class LteUeComponentCarrierManager;
 
 /**
  * \ingroup lte
@@ -58,10 +52,6 @@
 {
 
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
   LteUeNetDevice (void);
@@ -72,40 +62,15 @@
   // inherited from NetDevice
   virtual bool Send (Ptr<Packet> packet, const Address& dest, uint16_t protocolNumber);
 
-  /**
-   * \brief Get the MAC.
-   * \return the LTE UE MAC
-   */
+
   Ptr<LteUeMac> GetMac (void) const;
 
-  /**
-   * \brief Get the RRC.
-   * \return the LTE UE RRC
-   */
   Ptr<LteUeRrc> GetRrc () const;
 
-  /**
-   * \brief Get the Phy.
-   * \return the LTE UE Phy
-   */
   Ptr<LteUePhy> GetPhy (void) const;
 
-  /**
-   * \brief Get the NAS.
-   * \return the LTE UE NAS
-   */
   Ptr<EpcUeNas> GetNas (void) const;
-  
-  /**
-   * \brief Get the componentn carrier manager.
-   * \return the LTE UE component carrier manager
-   */
-  Ptr<LteUeComponentCarrierManager> GetComponentCarrierManager (void) const;
 
-  /**
-   * \brief Get the IMSI.
-   * \return the IMSI
-   */
   uint64_t GetImsi () const;
 
   /**
@@ -114,7 +79,7 @@
    * Note that real-life handset typically supports more than one EARFCN, but
    * the sake of simplicity we assume only one EARFCN is supported.
    */
-  uint32_t GetDlEarfcn () const;
+  uint16_t GetDlEarfcn () const;
 
   /**
    * \param earfcn the downlink carrier frequency (EARFCN)
@@ -122,7 +87,7 @@
    * Note that real-life handset typically supports more than one EARFCN, but
    * the sake of simplicity we assume only one EARFCN is supported.
    */
-  void SetDlEarfcn (uint32_t earfcn);
+  void SetDlEarfcn (uint16_t earfcn);
 
   /**
    * \brief Returns the CSG ID the UE is currently a member of.
@@ -155,19 +120,6 @@
    */
   Ptr<LteEnbNetDevice> GetTargetEnb (void);
 
-  /**
-   * \brief Set the ComponentCarrier Map for the UE
-   * \param ccm the map of ComponentCarrierUe
-   */
-  void SetCcMap (std::map< uint8_t, Ptr<ComponentCarrierUe> > ccm);
-
-  /**
-   * \brief Get the ComponentCarrier Map for the UE
-   * \returns the map of ComponentCarrierUe
-   */
-  std::map< uint8_t, Ptr<ComponentCarrierUe> >  GetCcMap (void);
-
-
 
 protected:
   // inherited from Object
@@ -175,7 +127,7 @@
 
 
 private:
-  bool m_isConstructed; ///< is constructed?
+  bool m_isConstructed;
 
   /**
    * \brief Propagate attributes and configuration to sub-modules.
@@ -188,19 +140,18 @@
    */
   void UpdateConfig ();
 
-  Ptr<LteEnbNetDevice> m_targetEnb; ///< target ENB
-
-  Ptr<LteUeRrc> m_rrc; ///< the RRC
-  Ptr<EpcUeNas> m_nas; ///< the NAS
-  Ptr<LteUeComponentCarrierManager> m_componentCarrierManager; ///< the component carrier manager
+  Ptr<LteEnbNetDevice> m_targetEnb;
 
-  uint64_t m_imsi; ///< the IMSI
+  Ptr<LteUeMac> m_mac;
+  Ptr<LteUePhy> m_phy;
+  Ptr<LteUeRrc> m_rrc;
+  Ptr<EpcUeNas> m_nas;
 
-  uint32_t m_dlEarfcn; /**< downlink carrier frequency */
+  uint64_t m_imsi;
 
-  uint32_t m_csgId; ///< the CSG ID
+  uint16_t m_dlEarfcn; /**< downlink carrier frequency */
 
-  std::map < uint8_t, Ptr<ComponentCarrierUe> > m_ccMap; ///< CC map
+  uint32_t m_csgId;
 
 }; // end of class LteUeNetDevice
 
diff -Naru a/model/lte-ue-phy.cc b/model/lte-ue-phy.cc
--- a/model/lte-ue-phy.cc	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-phy.cc	2017-10-05 11:47:22.314601784 +0200
@@ -1,6 +1,7 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2010 TELEMATICS LAB, DEE - Politecnico di Bari
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,6 +19,9 @@
  * Author: Giuseppe Piro  <g.piro@poliba.it>
  *         Marco Miozzo <marco.miozzo@cttc.es>
  *         Nicola Baldo <nbaldo@cttc.es>
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include <ns3/object-factory.h>
@@ -70,15 +74,10 @@
 // member SAP forwarders
 ////////////////////////////////////////
 
-/// UeMemberLteUePhySapProvider class
+
 class UeMemberLteUePhySapProvider : public LteUePhySapProvider
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param phy the LTE UE Phy
-   */
   UeMemberLteUePhySapProvider (LteUePhy* phy);
 
   // inherited from LtePhySapProvider
@@ -87,7 +86,7 @@
   virtual void SendRachPreamble (uint32_t prachId, uint32_t raRnti);
 
 private:
-  LteUePhy* m_phy; ///< the Phy
+  LteUePhy* m_phy;
 };
 
 UeMemberLteUePhySapProvider::UeMemberLteUePhySapProvider (LteUePhy* phy) : m_phy (phy)
@@ -146,8 +145,8 @@
 
 LteUePhy::LteUePhy (Ptr<LteSpectrumPhy> dlPhy, Ptr<LteSpectrumPhy> ulPhy)
   : LtePhy (dlPhy, ulPhy),
-    m_p10CqiPeriodicity (MilliSeconds (1)),  // ideal behavior
-    m_a30CqiPeriodicity (MilliSeconds (1)),  // ideal behavior
+    m_p10CqiPeriocity (MilliSeconds (1)),  // ideal behavior
+    m_a30CqiPeriocity (MilliSeconds (1)),  // ideal behavior
     m_uePhySapUser (0),
     m_ueCphySapUser (0),
     m_state (CELL_SEARCH),
@@ -492,9 +491,9 @@
   if (m_dlConfigured && m_ulConfigured && (m_rnti > 0))
     {
       // check periodic wideband CQI
-      if (Simulator::Now () > m_p10CqiLast + m_p10CqiPeriodicity)
+      if (Simulator::Now () > m_p10CqiLast + m_p10CqiPeriocity)
         {
-          Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
+          //Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
           Ptr<DlCqiLteControlMessage> msg = CreateDlCqiFeedbackMessage (sinr);
           if (msg)
             {
@@ -503,9 +502,9 @@
           m_p10CqiLast = Simulator::Now ();
         }
       // check aperiodic high-layer configured subband CQI
-      if  (Simulator::Now () > m_a30CqiLast + m_a30CqiPeriodicity)
+      if  (Simulator::Now () > m_a30CqiLast + m_a30CqiPeriocity)
         {
-          Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
+          //Ptr<LteUeNetDevice> thisDevice = GetDevice ()->GetObject<LteUeNetDevice> ();
           Ptr<DlCqiLteControlMessage> msg = CreateDlCqiFeedbackMessage (sinr);
           if (msg)
             {
@@ -543,9 +542,9 @@
           rbNum++;
         }
       double avSinr = (rbNum > 0) ? (sum / rbNum) : DBL_MAX;
-      NS_LOG_INFO (this << " cellId " << m_cellId << " rnti " << m_rnti << " RSRP " << rsrp << " SINR " << avSinr << " ComponentCarrierId " << (uint16_t) m_componentCarrierId);
+      NS_LOG_INFO (this << " cellId " << m_cellId << " rnti " << m_rnti << " RSRP " << rsrp << " SINR " << avSinr);
 
-      m_reportCurrentCellRsrpSinrTrace (m_cellId, m_rnti, rsrp, avSinr, (uint16_t) m_componentCarrierId);
+      m_reportCurrentCellRsrpSinrTrace (m_cellId, m_rnti, rsrp, avSinr, 0);
       m_rsrpSinrSampleCounter = 0;
     }
 
@@ -617,7 +616,7 @@
 
   NS_ASSERT (m_state != CELL_SEARCH);
   NS_ASSERT (m_cellId > 0);
-
+  
   SpectrumValue mixedSinr = (m_rsReceivedPower * m_paLinear);
   if (m_dataInterferencePowerUpdated)
     {
@@ -715,7 +714,7 @@
   Ptr<DlCqiLteControlMessage> msg = Create<DlCqiLteControlMessage> ();
   CqiListElement_s dlcqi;
   std::vector<int> cqi;
-  if (Simulator::Now () > m_p10CqiLast + m_p10CqiPeriodicity)
+  if (Simulator::Now () > m_p10CqiLast + m_p10CqiPeriocity)
     {
       cqi = m_amc->CreateCqiFeedbacks (newSinr, m_dlBandwidth);
 
@@ -754,7 +753,7 @@
       dlcqi.m_wbPmi = 0; // not yet used
       // dl.cqi.m_sbMeasResult others CQI report modes: not yet implemented
     }
-  else if (Simulator::Now () > m_a30CqiLast + m_a30CqiPeriodicity)
+  else if (Simulator::Now () > m_a30CqiLast + m_a30CqiPeriocity)
     {
       cqi = m_amc->CreateCqiFeedbacks (newSinr, GetRbgSize ());
       int nLayer = TransmissionModesLayers::TxMode2LayerNum (m_transmissionMode);
@@ -822,18 +821,16 @@
                          << " RSRP " << avg_rsrp
                          << " (nSamples " << (uint16_t)(*it).second.rsrpNum << ")"
                          << " RSRQ " << avg_rsrq
-                         << " (nSamples " << (uint16_t)(*it).second.rsrqNum << ")"
-                         << " ComponentCarrierID " << (uint16_t)m_componentCarrierId);
+                         << " (nSamples " << (uint16_t)(*it).second.rsrqNum << ")");
 
       LteUeCphySapUser::UeMeasurementsElement newEl;
       newEl.m_cellId = (*it).first;
       newEl.m_rsrp = avg_rsrp;
       newEl.m_rsrq = avg_rsrq;
       ret.m_ueMeasurementsList.push_back (newEl);
-      ret.m_componentCarrierId = m_componentCarrierId;
 
       // report to UE measurements trace
-      m_reportUeMeasurements (m_rnti, (*it).first, avg_rsrp, avg_rsrq, ((*it).first == m_cellId ? 1 : 0), m_componentCarrierId);
+      m_reportUeMeasurements (m_rnti, (*it).first, avg_rsrp, avg_rsrq, ((*it).first == m_cellId ? 1 : 0));
     }
 
   // report to RRC
@@ -871,7 +868,6 @@
   NS_LOG_FUNCTION (this);
 
   std::list<Ptr<LteControlMessage> >::iterator it;
-  NS_LOG_DEBUG (this << " I am rnti = " << m_rnti << " and I received msgs " << (uint16_t) msgList.size ());
   for (it = msgList.begin (); it != msgList.end (); it++)
     {
       Ptr<LteControlMessage> msg = (*it);
@@ -956,7 +952,6 @@
           params.m_size = dci.m_tbSize;
           params.m_rv = harqInfoList.size ();
           params.m_ndi = dci.m_ndi;
-          params.m_ccId = m_componentCarrierId;
           m_ulPhyTransmission (params);
           // pass the info to the MAC
           m_uePhySapUser->ReceiveLteControlMessage (msg);
@@ -964,6 +959,7 @@
       else if (msg->GetMessageType () == LteControlMessage::RAR)
         {
           Ptr<RarLteControlMessage> rarMsg = DynamicCast<RarLteControlMessage> (msg);
+          NS_LOG_INFO("Rx rar in LteUePhy, rarMsg rnti " << rarMsg->GetRaRnti() << " m_raRnti " << m_raRnti);
           if (rarMsg->GetRaRnti () == m_raRnti)
             {
               for (std::list<RarLteControlMessage::Rar>::const_iterator it = rarMsg->RarListBegin (); it != rarMsg->RarListEnd (); ++it)
@@ -1086,6 +1082,8 @@
   NS_LOG_FUNCTION (this << frameNo << subframeNo);
 
   NS_ASSERT_MSG (frameNo > 0, "the SRS index check code assumes that frameNo starts at 1");
+  NS_LOG_INFO ("Lte UE " << m_rnti << " frame " << frameNo << " subframe " << subframeNo);
+
 
   // refresh internal variables
   m_rsReceivedPowerUpdated = false;
@@ -1231,7 +1229,7 @@
 } // end of void LteUePhy::DoReset ()
 
 void
-LteUePhy::DoStartCellSearch (uint32_t dlEarfcn)
+LteUePhy::DoStartCellSearch (uint16_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << dlEarfcn);
   m_dlEarfcn = dlEarfcn;
@@ -1240,7 +1238,7 @@
 }
 
 void
-LteUePhy::DoSynchronizeWithEnb (uint16_t cellId, uint32_t dlEarfcn)
+LteUePhy::DoSynchronizeWithEnb (uint16_t cellId, uint16_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << cellId << dlEarfcn);
   m_dlEarfcn = dlEarfcn;
@@ -1302,7 +1300,7 @@
 
 
 void 
-LteUePhy::DoConfigureUplink (uint32_t ulEarfcn, uint8_t ulBandwidth)
+LteUePhy::DoConfigureUplink (uint16_t ulEarfcn, uint8_t ulBandwidth)
 {
   m_ulEarfcn = ulEarfcn;
   m_ulBandwidth = ulBandwidth;
diff -Naru a/model/lte-ue-phy.h b/model/lte-ue-phy.h
--- a/model/lte-ue-phy.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-phy.h	2017-10-05 11:47:22.314601784 +0200
@@ -51,9 +51,7 @@
 class LteUePhy : public LtePhy
 {
 
-  /// allow UeMemberLteUePhySapProvider class friend access
   friend class UeMemberLteUePhySapProvider;
-  /// allow MemberLteUeCphySapProvider<LteUePhy> class friend access
   friend class MemberLteUeCphySapProvider<LteUePhy>;
 
 public:
@@ -81,12 +79,8 @@
 
   virtual ~LteUePhy ();
 
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
   // inherited from Object
+  static TypeId GetTypeId (void);
   virtual void DoInitialize (void);
   virtual void DoDispose (void);
 
@@ -196,40 +190,18 @@
   // inherited from LtePhy
   virtual void GenerateCtrlCqiReport (const SpectrumValue& sinr);
   virtual void GenerateDataCqiReport (const SpectrumValue& sinr);
-  /**
-  * \brief Create the mixed CQI report
-  *
-  * \param sinr SINR values vector
-  */
   virtual void GenerateMixedCqiReport (const SpectrumValue& sinr);
   virtual void ReportInterference (const SpectrumValue& interf);
-  /**
-  * \brief Create the mixed CQI report
-  *
-  * \param interf interference values vector
-  */
   virtual void ReportDataInterference (const SpectrumValue& interf);
   virtual void ReportRsReceivedPower (const SpectrumValue& power);
 
   // callbacks for LteSpectrumPhy
-  /**
-  * \brief Receive LTE control message list function
-  *
-  * \param msgList LTE control message list
-  */
-  virtual void ReceiveLteControlMessageList (std::list<Ptr<LteControlMessage> > msgList);
-  /**
-  * \brief Receive PSS function
-  *
-  * \param cellId the cell ID
-  * \param p PSS list
-  */
+  virtual void ReceiveLteControlMessageList (std::list<Ptr<LteControlMessage> >);
   virtual void ReceivePss (uint16_t cellId, Ptr<SpectrumValue> p);
 
 
   /**
    * \brief PhySpectrum received a new PHY-PDU
-   * \param p the packet received
    */
   void PhyPduReceived (Ptr<Packet> p);
 
@@ -250,13 +222,11 @@
 
   /**
    * \brief PhySpectrum generated a new DL HARQ feedback
-   * \param mes the DlInfoListElement_s
    */
   virtual void ReceiveLteDlHarqFeedback (DlInfoListElement_s mes);
 
   /**
    * \brief Set the HARQ PHY module
-   * \param harq the HARQ PHY module
    */
   void SetHarqPhyModule (Ptr<LteHarqPhy> harq);
 
@@ -283,11 +253,9 @@
    * \param [in] rnti
    * \param [in] rsrp
    * \param [in] sinr
-   * \param [in] componentCarrierId
    */
   typedef void (* RsrpSinrTracedCallback)
-    (uint16_t cellId, uint16_t rnti,
-     double rsrp, double sinr, uint8_t componentCarrierId);
+    (uint16_t cellId, uint16_t rnti, double rsrp, double sinr, uint8_t ccId);
 
   /**
    * TracedCallback signature for cell RSRP and RSRQ.
@@ -297,69 +265,22 @@
    * \param [in] rsrp
    * \param [in] rsrq
    * \param [in] isServingCell
-   * \param [in] componentCarrierId
    */
   typedef void (* RsrpRsrqTracedCallback)
     (uint16_t rnti, uint16_t cellId, double rsrp, double rsrq,
-     bool isServingCell, uint8_t componentCarrierId);
+     bool isServingCell);
 
 private:
 
-  /**
-   * Set transmit mode 1 gain function
-   *
-   * \param [in] gain
-   */
   void SetTxMode1Gain (double gain);
-  /**
-   * Set transmit mode 2 gain function
-   *
-   * \param [in] gain
-   */
   void SetTxMode2Gain (double gain);
-  /**
-   * Set transmit mode 3 gain function
-   *
-   * \param [in] gain
-   */
   void SetTxMode3Gain (double gain);
-  /**
-   * Set transmit mode 4 gain function
-   *
-   * \param [in] gain
-   */
   void SetTxMode4Gain (double gain);
-  /**
-   * Set transmit mode 5 gain function
-   *
-   * \param [in] gain
-   */
   void SetTxMode5Gain (double gain);
-  /**
-   * Set transmit mode 6 gain function
-   *
-   * \param [in] gain
-   */
   void SetTxMode6Gain (double gain);
-  /**
-   * Set transmit mode 7 gain function
-   *
-   * \param [in] gain
-   */
   void SetTxMode7Gain (double gain);
-  /**
-   * Set transmit mode gain function
-   *
-   * \param [in] txMode
-   * \param [in] gain
-   */
   void SetTxModeGain (uint8_t txMode, double gain);
 
-  /**
-   * queue subchannels for transmission function
-   *
-   * \param [in] rbMap
-   */
   void QueueSubChannelsForTransmission (std::vector <int> rbMap);
 
 
@@ -388,73 +309,21 @@
   void SwitchToState (State s);
 
   // UE CPHY SAP methods
-  /// Reset function
   void DoReset ();
-  /**
-   * Start the cell search function
-   * \param dlEarfcn the DL EARFCN
-   */
-  void DoStartCellSearch (uint32_t dlEarfcn);
-  /**
-   * Synchronize with ENB function
-   * \param cellId the cell ID
-   */
+  void DoStartCellSearch (uint16_t dlEarfcn);
   void DoSynchronizeWithEnb (uint16_t cellId);
-  /**
-   * Synchronize with ENB function
-   * \param cellId the cell ID
-   * \param dlEarfcn the DL EARFCN
-   */
-  void DoSynchronizeWithEnb (uint16_t cellId, uint32_t dlEarfcn);
-  /**
-   * Set DL bandwidth function
-   * \param dlBandwidth the DL bandwidth
-   */
-  void DoSetDlBandwidth (uint8_t dlBandwidth);
-  /**
-   * Configure UL uplink function
-   * \param ulEarfcn UL EARFCN
-   * \param ulBandwidth the UL bandwidth
-   */
-  void DoConfigureUplink (uint32_t ulEarfcn, uint8_t ulBandwidth);
-  /**
-   * Configure reference signal power function
-   * \param referenceSignalPower reference signal power
-   */
+  void DoSynchronizeWithEnb (uint16_t cellId, uint16_t dlEarfcn);
+  void DoSetDlBandwidth (uint8_t ulBandwidth);
+  void DoConfigureUplink (uint16_t ulEarfcn, uint8_t ulBandwidth);
   void DoConfigureReferenceSignalPower (int8_t referenceSignalPower);
-  /**
-   * Set RNTI function
-   * \param rnti the RNTI
-   */
   void DoSetRnti (uint16_t rnti);
-  /**
-   * Set transmission mode function
-   * \param txMode the transmission mode
-   */
   void DoSetTransmissionMode (uint8_t txMode);
-  /**
-   * Set SRS configuration index function
-   * \param srcCi the SRS configuration index
-   */
   void DoSetSrsConfigurationIndex (uint16_t srcCi);
-  /**
-   * Set PA function
-   * \param pa the PA value
-   */
   void DoSetPa (double pa);
 
   // UE PHY SAP methods 
   virtual void DoSendMacPdu (Ptr<Packet> p);
-  /**
-   * Send LTE conrol message function
-   * \param msg the LTE control message
-   */
   virtual void DoSendLteControlMessage (Ptr<LteControlMessage> msg);
-  /**
-   * Send RACH preamble function
-   * \param prachId the RACH preamble ID
-   * \param raRnti the rnti
-   */
   virtual void DoSendRachPreamble (uint32_t prachId, uint32_t raRnti);
 
   /// A list of sub channels to use in TX.
@@ -462,10 +331,10 @@
   /// A list of sub channels to use in RX.
   std::vector <int> m_subChannelsForReception;
 
-  std::vector< std::vector <int> > m_subChannelsForTransmissionQueue; ///< subchannels for transmission queue
+  std::vector< std::vector <int> > m_subChannelsForTransmissionQueue;
 
 
-  Ptr<LteAmc> m_amc; ///< AMC
+  Ptr<LteAmc> m_amc;
 
   /**
    * The `EnableUplinkPowerControl` attribute. If true, Uplink Power Control
@@ -476,37 +345,37 @@
   Ptr<LteUePowerControl> m_powerControl;
 
   /// Wideband Periodic CQI. 2, 5, 10, 16, 20, 32, 40, 64, 80 or 160 ms.
-  Time m_p10CqiPeriodicity;
-  Time m_p10CqiLast; ///< last periodic CQI
+  Time m_p10CqiPeriocity;
+  Time m_p10CqiLast;
 
   /**
    * SubBand Aperiodic CQI. Activated by DCI format 0 or Random Access Response
    * Grant.
    * \note Defines a periodicity for academic studies.
    */
-  Time m_a30CqiPeriodicity;
-  Time m_a30CqiLast; ///< last aperiodic CQI
+  Time m_a30CqiPeriocity;
+  Time m_a30CqiLast;
 
-  LteUePhySapProvider* m_uePhySapProvider; ///< UE Phy SAP provider
-  LteUePhySapUser* m_uePhySapUser; ///< UE Phy SAP user
+  LteUePhySapProvider* m_uePhySapProvider;
+  LteUePhySapUser* m_uePhySapUser;
 
-  LteUeCphySapProvider* m_ueCphySapProvider; ///< UE CPhy SAP provider
-  LteUeCphySapUser* m_ueCphySapUser; ///< UE CPhy SAP user
+  LteUeCphySapProvider* m_ueCphySapProvider;
+  LteUeCphySapUser* m_ueCphySapUser;
 
-  uint16_t  m_rnti; ///< the RNTI
+  uint16_t  m_rnti;
  
-  uint8_t m_transmissionMode; ///< the transmission mode
-  std::vector <double> m_txModeGain; ///< the transmit mode gain
+  uint8_t m_transmissionMode;
+  std::vector <double> m_txModeGain;
 
-  uint16_t m_srsPeriodicity; ///< SRS periodicity
-  uint16_t m_srsSubframeOffset; ///< SRS subframe offset
-  uint16_t m_srsConfigured; ///< SRS configured
-  Time     m_srsStartTime; ///< SRS start time
+  uint16_t m_srsPeriodicity;
+  uint16_t m_srsSubframeOffset;
+  uint16_t m_srsConfigured;
+  Time     m_srsStartTime;
 
-  double m_paLinear; ///< PA linear
+  double m_paLinear;
 
-  bool m_dlConfigured; ///< DL configured?
-  bool m_ulConfigured; ///< UL configured?
+  bool m_dlConfigured;
+  bool m_ulConfigured;
 
   /// The current UE PHY state.
   State m_state;
@@ -519,24 +388,23 @@
   /// \todo Can be removed.
   uint8_t m_subframeNo;
 
-  bool m_rsReceivedPowerUpdated; ///< RS receive power updated?
-  SpectrumValue m_rsReceivedPower; ///< RS receive power
+  bool m_rsReceivedPowerUpdated;
+  SpectrumValue m_rsReceivedPower;
 
-  bool m_rsInterferencePowerUpdated; ///< RS interference power updated?
-  SpectrumValue m_rsInterferencePower; ///< RS interference power
+  bool m_rsInterferencePowerUpdated;
+  SpectrumValue m_rsInterferencePower;
 
-  bool m_dataInterferencePowerUpdated; ///< data interference power updated?
-  SpectrumValue m_dataInterferencePower; ///< data interference power
+  bool m_dataInterferencePowerUpdated;
+  SpectrumValue m_dataInterferencePower;
 
-  bool m_pssReceived; ///< PSS received?
-  /// PssElement structure
-  struct PssElement 
+  bool m_pssReceived;
+  struct PssElement
   {
-    uint16_t cellId; ///< cell ID
-    double pssPsdSum; ///< PSS PSD sum
-    uint16_t nRB; ///< number of RB
+    uint16_t cellId;
+    double pssPsdSum;
+    uint16_t nRB;
   };
-  std::list <PssElement> m_pssList; ///< PSS list
+  std::list <PssElement> m_pssList;
 
   /**
    * The `RsrqUeMeasThreshold` attribute. Receive threshold for PSS on RSRQ
@@ -566,15 +434,15 @@
   /// \todo Can be removed.
   Time m_ueMeasurementsFilterLast;
 
-  Ptr<LteHarqPhy> m_harqPhyModule; ///< HARQ phy module
+  Ptr<LteHarqPhy> m_harqPhyModule;
 
-  uint32_t m_raPreambleId; ///< RA preamble ID
-  uint32_t m_raRnti; ///< RA rnti
+  uint32_t m_raPreambleId;
+  uint32_t m_raRnti;
 
   /**
    * The `ReportCurrentCellRsrpSinr` trace source. Trace information regarding
    * RSRP and average SINR (see TS 36.214). Exporting cell ID, RNTI, RSRP, and
-   * SINR. Moreover it reports the m_componentCarrierId.
+   * SINR.
    */
   TracedCallback<uint16_t, uint16_t, double, double, uint8_t> m_reportCurrentCellRsrpSinrTrace;
   /**
@@ -582,21 +450,17 @@
    * RSRP-SINR stats.
    */
   uint16_t m_rsrpSinrSamplePeriod;
-  /**
-   * The `RsrpSinrSampleCounter` attribute. The sampling counter for reporting
-   * RSRP-SINR stats.
-   */
   uint16_t m_rsrpSinrSampleCounter;
 
   /**
    * The `ReportUeMeasurements` trace source. Contains trace information
    * regarding RSRP and RSRQ measured from a specific cell (see TS 36.214).
    * Exporting RNTI, the ID of the measured cell, RSRP (in dBm), RSRQ (in dB),
-   * and whether the cell is the serving cell. Moreover it report the m_componentCarrierId.
+   * and whether the cell is the serving cell.
    */
-  TracedCallback<uint16_t, uint16_t, double, double, bool, uint8_t> m_reportUeMeasurements;
+  TracedCallback<uint16_t, uint16_t, double, double, bool> m_reportUeMeasurements;
 
-  EventId m_sendSrsEvent; ///< send SRS event
+  EventId m_sendSrsEvent;
 
   /**
    * The `UlPhyTransmission` trace source. Contains trace information regarding
diff -Naru a/model/lte-ue-phy-sap.h b/model/lte-ue-phy-sap.h
--- a/model/lte-ue-phy-sap.h	2017-10-05 11:46:52.214493974 +0200
+++ b/model/lte-ue-phy-sap.h	2017-10-05 11:47:22.314601784 +0200
@@ -57,7 +57,6 @@
    * send a preamble on the PRACH
    * 
    * \param prachId the ID of the preamble
-   * \param raRnti the RA rnti
    */
   virtual void SendRachPreamble (uint32_t prachId, uint32_t raRnti) = 0;
 
diff -Naru a/model/lte-ue-rrc.cc b/model/lte-ue-rrc.cc
--- a/model/lte-ue-rrc.cc	2017-10-05 11:46:52.218493988 +0200
+++ b/model/lte-ue-rrc.cc	2017-10-05 11:47:22.314601784 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011, 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,9 +18,9 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
  *         Budiarto Herman <budiarto.herman@magister.fi>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #include "lte-ue-rrc.h"
@@ -35,7 +36,17 @@
 #include <ns3/lte-rlc-um.h>
 #include <ns3/lte-rlc-am.h>
 #include <ns3/lte-pdcp.h>
+#include <ns3/mc-ue-pdcp.h>
 #include <ns3/lte-radio-bearer-info.h>
+#include <ns3/lte-ue-mac.h>
+#include <ns3/lte-rlc-am-header.h>
+
+#include <ns3/lte-rlc-sdu-status-tag.h>
+#include <ns3/lte-pdcp-header.h>
+#include <ns3/lte-rlc-um-lowlat.h>
+#include "ns3/lte-pdcp-tag.h"
+#include <ns3/lte-rlc-sap.h>
+
 
 #include <cmath>
 
@@ -47,15 +58,9 @@
 // CMAC SAP forwarder
 /////////////////////////////
 
-/// UeMemberLteUeCmacSapUser class
 class UeMemberLteUeCmacSapUser : public LteUeCmacSapUser
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param rrc the RRC class
-   */
   UeMemberLteUeCmacSapUser (LteUeRrc* rrc);
 
   virtual void SetTemporaryCellRnti (uint16_t rnti);
@@ -63,7 +68,7 @@
   virtual void NotifyRandomAccessFailed ();
 
 private:
-  LteUeRrc* m_rrc; ///< the RRC class
+  LteUeRrc* m_rrc;
 };
 
 UeMemberLteUeCmacSapUser::UeMemberLteUeCmacSapUser (LteUeRrc* rrc)
@@ -131,11 +136,11 @@
 
 
 LteUeRrc::LteUeRrc ()
-  : m_cmacSapProvider (0),
+  : m_cphySapProvider (0),
+    m_cmacSapProvider (0),
     m_rrcSapUser (0),
     m_macSapProvider (0),
     m_asSapUser (0),
-    m_ccmRrcSapProvider (0),
     m_state (IDLE_START),
     m_imsi (0),
     m_rnti (0),
@@ -146,19 +151,18 @@
     m_hasReceivedSib1 (false),
     m_hasReceivedSib2 (false),
     m_csgWhiteList (0),
-    m_numberOfComponentCarriers (MIN_NO_CC)
+    m_ncRaStarted (true)
 {
   NS_LOG_FUNCTION (this);
-  m_cphySapUser.push_back (new MemberLteUeCphySapUser<LteUeRrc> (this));
-  m_cmacSapUser.push_back (new UeMemberLteUeCmacSapUser (this));
-  m_cphySapProvider.push_back(0);
-  m_cmacSapProvider.push_back(0);
+  m_cphySapUser = new MemberLteUeCphySapUser<LteUeRrc> (this);
+  m_cmacSapUser = new UeMemberLteUeCmacSapUser (this);
   m_rrcSapProvider = new MemberLteUeRrcSapProvider<LteUeRrc> (this);
   m_drbPdcpSapUser = new LtePdcpSpecificLtePdcpSapUser<LteUeRrc> (this);
   m_asSapProvider = new MemberLteAsSapProvider<LteUeRrc> (this);
-  m_ccmRrcSapUser = new MemberLteUeCcmRrcSapUser<LteUeRrc> (this);
+  //m_onLte = true; // MC devices first connect to a LTE macro eNB
 }
 
+
 LteUeRrc::~LteUeRrc ()
 {
   NS_LOG_FUNCTION (this);
@@ -168,22 +172,13 @@
 LteUeRrc::DoDispose ()
 {
   NS_LOG_FUNCTION (this);
-  for ( uint16_t i = 0; i < m_numberOfComponentCarriers; i++)
-   {
-      delete m_cphySapUser.at(i);
-      delete m_cmacSapUser.at(i);
-   }
-  m_cphySapUser.clear ();
-  m_cmacSapUser.clear ();
+  delete m_cphySapUser;
+  delete m_cmacSapUser;
   delete m_rrcSapProvider;
   delete m_drbPdcpSapUser;
   delete m_asSapProvider;
-  delete m_ccmRrcSapUser;
-  m_cphySapProvider.erase(m_cphySapProvider.begin(), m_cphySapProvider.end());
-  m_cphySapProvider.clear();
-  m_cmacSapProvider.erase(m_cmacSapProvider.begin(), m_cmacSapProvider.end());
-  m_cmacSapProvider.clear();
   m_drbMap.clear ();
+  m_rlcMap.clear ();
 }
 
 TypeId
@@ -191,12 +186,16 @@
 {
   static TypeId tid = TypeId ("ns3::LteUeRrc")
     .SetParent<Object> ()
-    .SetGroupName ("Lte")
+    .SetGroupName("Lte")
     .AddConstructor<LteUeRrc> ()
     .AddAttribute ("DataRadioBearerMap", "List of UE RadioBearerInfo for Data Radio Bearers by LCID.",
                    ObjectMapValue (),
                    MakeObjectMapAccessor (&LteUeRrc::m_drbMap),
                    MakeObjectMapChecker<LteDataRadioBearerInfo> ())
+    .AddAttribute ("DataRadioRlcMap", "List of UE RLC for Secondary Connection by LCID.",
+                   ObjectMapValue (),
+                   MakeObjectMapAccessor (&LteUeRrc::m_rlcMap),
+                   MakeObjectMapChecker<RlcBearerInfo> ())
     .AddAttribute ("Srb0", "SignalingRadioBearerInfo for SRB0",
                    PointerValue (),
                    MakePointerAccessor (&LteUeRrc::m_srb0),
@@ -277,6 +276,24 @@
                      "trace fired upon failure of a handover procedure",
                      MakeTraceSourceAccessor (&LteUeRrc::m_handoverEndErrorTrace),
                      "ns3::LteUeRrc::ImsiCidRntiTracedCallback")
+    .AddTraceSource ("SwitchToLte",
+                     "trace fired upon switching to LTE RAT",
+                     MakeTraceSourceAccessor (&LteUeRrc::m_switchToLteTrace),
+                     "ns3::LteUeRrc::ImsiCidRntiTracedCallback")
+    .AddTraceSource ("SwitchToMmWave",
+                     "trace fired upon switching to MmWave RAT",
+                     MakeTraceSourceAccessor (&LteUeRrc::m_switchToMmWaveTrace),
+                     "ns3::LteUeRrc::ImsiCidRntiTracedCallback")
+    .AddAttribute ("SecondaryRRC",
+                     "True if this is the RRC in charge of the secondary cell (MmWaveCell) for a MC device",
+                     BooleanValue (false),
+                     MakeBooleanAccessor (&LteUeRrc::m_isSecondaryRRC),
+                     MakeBooleanChecker ())
+    .AddAttribute ("InterRatHoCapable",
+                     "True if this RRC supports hard handover between LTE and MmWave",
+                     BooleanValue (false),
+                     MakeBooleanAccessor (&LteUeRrc::m_interRatHoCapable),
+                     MakeBooleanChecker ())
   ;
   return tid;
 }
@@ -286,56 +303,44 @@
 LteUeRrc::SetLteUeCphySapProvider (LteUeCphySapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_cphySapProvider.at(0) = s;
+  m_cphySapProvider = s;
+  m_lteCphySapProvider = s;
 }
 
 void
-LteUeRrc::SetLteUeCphySapProvider (LteUeCphySapProvider * s, uint8_t index)
+LteUeRrc::SetMmWaveUeCphySapProvider (LteUeCphySapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_cphySapProvider.at(index) = s;
+  m_mmWaveCphySapProvider = s;
 }
 
 LteUeCphySapUser*
 LteUeRrc::GetLteUeCphySapUser ()
 {
   NS_LOG_FUNCTION (this);
-  return m_cphySapUser.at(0);
-}
-
-LteUeCphySapUser*
-LteUeRrc::GetLteUeCphySapUser (uint8_t index)
-{
-  NS_LOG_FUNCTION (this);
-  return m_cphySapUser.at(index);
+  return m_cphySapUser;
 }
 
 void
 LteUeRrc::SetLteUeCmacSapProvider (LteUeCmacSapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_cmacSapProvider.at (0) = s;
+  m_cmacSapProvider = s;
+  m_lteCmacSapProvider = s;
 }
 
 void
-LteUeRrc::SetLteUeCmacSapProvider (LteUeCmacSapProvider * s, uint8_t index)
+LteUeRrc::SetMmWaveUeCmacSapProvider (LteUeCmacSapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_cmacSapProvider.at (index) = s;
+  m_mmWaveCmacSapProvider = s;
 }
 
 LteUeCmacSapUser*
 LteUeRrc::GetLteUeCmacSapUser ()
 {
   NS_LOG_FUNCTION (this);
-  return m_cmacSapUser.at (0);
-}
-
-LteUeCmacSapUser*
-LteUeRrc::GetLteUeCmacSapUser (uint8_t index)
-{
-  NS_LOG_FUNCTION (this);
-  return m_cmacSapUser.at (index);
+  return m_cmacSapUser;
 }
 
 void
@@ -357,20 +362,14 @@
 {
   NS_LOG_FUNCTION (this << s);
   m_macSapProvider = s;
+  m_lteMacSapProvider = s;
 }
 
 void
-LteUeRrc::SetLteCcmRrcSapProvider (LteUeCcmRrcSapProvider * s)
+LteUeRrc::SetMmWaveMacSapProvider (LteMacSapProvider * s)
 {
   NS_LOG_FUNCTION (this << s);
-  m_ccmRrcSapProvider = s;
-}
-
-LteUeCcmRrcSapUser*
-LteUeRrc::GetLteCcmRrcSapUser ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_ccmRrcSapUser;
+  m_mmWaveMacSapProvider = s;
 }
 
 void
@@ -412,6 +411,80 @@
   return m_cellId;
 }
 
+void 
+LteUeRrc::AddMmWaveCellId(uint16_t cellId)
+{
+  NS_LOG_FUNCTION(this);
+  NS_ASSERT_MSG(m_interRatHoCapable, "Trying to setup unnecessary information on a non interRatHoCapable device");
+  if(m_isMmWaveCellMap.find(cellId) == m_isMmWaveCellMap.end())
+  {
+    m_isMmWaveCellMap.insert(std::pair<uint16_t, bool> (cellId, true));
+  }
+  else // modify
+  {
+    m_isMmWaveCellMap.find(cellId)->second = true;
+  }
+}
+
+void 
+LteUeRrc::AddLteCellId(uint16_t cellId)
+{
+  NS_LOG_FUNCTION(this);
+  NS_ASSERT_MSG(m_interRatHoCapable, "Trying to setup unnecessary information on a non interRatHoCapable device");
+  if(m_isMmWaveCellMap.find(cellId) == m_isMmWaveCellMap.end())
+  {
+    m_isMmWaveCellMap.insert(std::pair<uint16_t, bool> (cellId, false));
+  }
+  else // modify
+  {
+    m_isMmWaveCellMap.find(cellId)->second = false;
+  }
+}
+
+bool
+LteUeRrc::SwitchLowerLayerProviders (uint16_t cellId)
+{
+  if(m_isMmWaveCellMap.find(cellId) != m_isMmWaveCellMap.end())
+  {
+    if(m_isMmWaveCellMap.find(cellId)->second)
+    {
+      NS_LOG_INFO("Switch SAP to MmWave");
+      NS_LOG_LOGIC("Before switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      m_cphySapProvider = m_mmWaveCphySapProvider;
+      m_cmacSapProvider = m_mmWaveCmacSapProvider;
+      m_macSapProvider = m_mmWaveMacSapProvider;
+
+      m_hasReceivedSib2 = false;
+      NS_LOG_LOGIC("After switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      return true;
+    }
+    else
+    {
+      NS_LOG_INFO("Switch SAP to LTE");
+      NS_LOG_LOGIC("Before switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      m_cphySapProvider = m_lteCphySapProvider;
+      m_cmacSapProvider = m_lteCmacSapProvider;
+      m_macSapProvider = m_lteMacSapProvider;
+
+      m_hasReceivedSib2 = false;
+
+      NS_LOG_LOGIC("After switch " << m_cphySapProvider << m_cmacSapProvider << m_macSapProvider);
+      return true;
+    }
+  }
+  else
+  {
+    if(m_interRatHoCapable)
+    {
+      NS_FATAL_ERROR("Unkown cell, set it up in the helper!");
+    }
+    else
+    {
+      // do nothing, always use the ones set at the beginning
+      return false;
+    }
+  }
+}
 
 uint8_t 
 LteUeRrc::GetUlBandwidth () const
@@ -427,13 +500,13 @@
   return m_dlBandwidth;
 }
 
-uint32_t
+uint16_t
 LteUeRrc::GetDlEarfcn () const
 {
   return m_dlEarfcn;
 }
 
-uint32_t 
+uint16_t 
 LteUeRrc::GetUlEarfcn () const
 {
   NS_LOG_FUNCTION (this);
@@ -454,7 +527,6 @@
   m_useRlcSm = val;
 }
 
-
 void
 LteUeRrc::DoInitialize (void)
 {
@@ -482,30 +554,18 @@
   lcConfig.prioritizedBitRateKbps = 65535; // maximum
   lcConfig.bucketSizeDurationMs = 65535; // maximum
   lcConfig.logicalChannelGroup = 0; // all SRBs mapped to LCG 0
-  m_cmacSapProvider.at(0)->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
-}
 
-void
-LteUeRrc::InitializeSap (void)
-{
-  if (m_numberOfComponentCarriers < MIN_NO_CC || m_numberOfComponentCarriers > MAX_NO_CC)
-    {
-      // this check is neede in order to maintain backward compatibility with scripts and tests
-      // if case lte-helper is not used (like in several tests) the m_numberOfComponentCarriers
-      // is not set and then an error is rised
-      // In this case m_numberOfComponentCarriers is set to 1
-      m_numberOfComponentCarriers = MIN_NO_CC;
-    }
-  if (m_numberOfComponentCarriers > MIN_NO_CC )
-    {
-      for ( uint16_t i = 1; i < m_numberOfComponentCarriers; i++)
-        {
-          m_cphySapUser.push_back(new MemberLteUeCphySapUser<LteUeRrc> (this));
-          m_cmacSapUser.push_back(new UeMemberLteUeCmacSapUser (this));
-          m_cphySapProvider.push_back(0);
-          m_cmacSapProvider.push_back(0);
-        }
-    }
+  
+  if(m_interRatHoCapable)
+  {
+    m_mmWaveCmacSapProvider->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+    m_lteCmacSapProvider->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+  }
+  else
+  {
+    m_cmacSapProvider->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+  }
+
 }
 
 
@@ -570,6 +630,15 @@
 }
 
 void
+LteUeRrc::DoNotifySecondaryCellConnected(uint16_t mmWaveRnti, uint16_t mmWaveCellId)
+{
+  m_mmWaveCellId = mmWaveCellId;
+  m_mmWaveRnti = mmWaveRnti;
+  NS_LOG_FUNCTION(this);
+  m_rrcSapUser->SendNotifySecondaryCellConnected(mmWaveRnti, mmWaveCellId);
+}
+
+void
 LteUeRrc::DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params)
 {
   NS_LOG_FUNCTION (this);
@@ -583,7 +652,13 @@
   NS_LOG_FUNCTION (this << rnti);
   m_rnti = rnti;
   m_srb0->m_rlc->SetRnti (m_rnti);
-  m_cphySapProvider.at(0)->SetRnti (m_rnti);
+  m_cphySapProvider->SetRnti (m_rnti);
+}
+
+void
+LteUeRrc::DoNotifyRadioLinkFailure (double lastSinrValue)
+{
+  NS_LOG_DEBUG("Rlf");
 }
 
 void
@@ -601,6 +676,7 @@
         SwitchToState (IDLE_CONNECTING);
         LteRrcSap::RrcConnectionRequest msg;
         msg.ueIdentity = m_imsi;
+        msg.isMc = m_isSecondaryRRC;
         m_rrcSapUser->SendRrcConnectionRequest (msg); 
         m_connectionTimeout = Simulator::Schedule (m_t300,
                                                    &LteUeRrc::ConnectionTimeout,
@@ -614,6 +690,12 @@
         msg.rrcTransactionIdentifier = m_lastRrcTransactionIdentifier;
         m_rrcSapUser->SendRrcConnectionReconfigurationCompleted (msg);
 
+        // The following is not needed
+        //if(m_isSecondaryRRC)
+        //{
+        //  m_asSapUser->NotifyHandoverSuccessful (m_rnti, m_cellId); // this triggers MC reconfiguration         
+        //}
+
         // 3GPP TS 36.331 section 5.5.6.1 Measurements related actions upon handover
         std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator measIdIt;
         for (measIdIt = m_varMeasConfig.measIdList.begin ();
@@ -625,6 +707,12 @@
 
         SwitchToState (CONNECTED_NORMALLY);
         m_handoverEndOkTrace (m_imsi, m_cellId, m_rnti);
+        if(m_isSecondaryRRC) // an handover for secondary cells has happened. 
+        // this trace is used to keep a consistent trace of the cell to which the UE is connected
+        {
+          NS_LOG_UNCOND("DoNotifyRandomAccessSuccessful at time " << Simulator::Now().GetSeconds());
+          m_switchToMmWaveTrace(m_imsi, m_cellId, m_rnti);
+        }
       }
       break;
 
@@ -675,18 +763,18 @@
 }
 
 void 
-LteUeRrc::DoStartCellSelection (uint32_t dlEarfcn)
+LteUeRrc::DoStartCellSelection (uint16_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << m_imsi << dlEarfcn);
   NS_ASSERT_MSG (m_state == IDLE_START,
                  "cannot start cell selection from state " << ToString (m_state));
   m_dlEarfcn = dlEarfcn;
-  m_cphySapProvider.at(0)->StartCellSearch (dlEarfcn);
+  m_cphySapProvider->StartCellSearch (dlEarfcn);
   SwitchToState (IDLE_CELL_SEARCH);
 }
 
 void 
-LteUeRrc::DoForceCampedOnEnb (uint16_t cellId, uint32_t dlEarfcn)
+LteUeRrc::DoForceCampedOnEnb (uint16_t cellId, uint16_t dlEarfcn)
 {
   NS_LOG_FUNCTION (this << m_imsi << cellId << dlEarfcn);
 
@@ -694,8 +782,9 @@
     {
     case IDLE_START:
       m_cellId = cellId;
+      SwitchLowerLayerProviders(m_cellId); // for InterRat HO      
       m_dlEarfcn = dlEarfcn;
-      m_cphySapProvider.at(0)->SynchronizeWithEnb (m_cellId, m_dlEarfcn);
+      m_cphySapProvider->SynchronizeWithEnb (m_cellId, m_dlEarfcn);
       SwitchToState (IDLE_WAIT_MIB);
       break;
 
@@ -777,7 +866,7 @@
                                         LteRrcSap::MasterInformationBlock msg)
 { 
   m_dlBandwidth = msg.dlBandwidth;
-  m_cphySapProvider.at(0)->SetDlBandwidth (msg.dlBandwidth);
+  m_cphySapProvider->SetDlBandwidth (msg.dlBandwidth);
   m_hasReceivedMib = true;
   m_mibReceivedTrace (m_imsi, m_cellId, m_rnti, cellId);
 
@@ -803,7 +892,6 @@
 LteUeRrc::DoRecvSystemInformationBlockType1 (uint16_t cellId,
                                              LteRrcSap::SystemInformationBlockType1 msg)
 {
-  NS_LOG_FUNCTION (this);
   switch (m_state)
     {
     case IDLE_WAIT_SIB1:
@@ -846,25 +934,13 @@
 
   // layer 3 filtering does not apply in IDLE mode
   bool useLayer3Filtering = (m_state == CONNECTED_NORMALLY);
-  bool triggering = true;
+
   std::vector <LteUeCphySapUser::UeMeasurementsElement>::iterator newMeasIt;
   for (newMeasIt = params.m_ueMeasurementsList.begin ();
        newMeasIt != params.m_ueMeasurementsList.end (); ++newMeasIt)
     {
-      if (params.m_componentCarrierId != 0)
-        {
-          triggering = false; // report is triggered only when an event is on the primary carrier
-          // in this case the measurement received is related to secondary carriers
-          // measurements related to secondary carriers are saved on a different portion of memory
-          SaveScellUeMeasurements (newMeasIt->m_cellId, newMeasIt->m_rsrp,
-                                   newMeasIt->m_rsrq, useLayer3Filtering, 
-                                   params.m_componentCarrierId );
-        }
-      else
-        {
-          SaveUeMeasurements (newMeasIt->m_cellId, newMeasIt->m_rsrp,
-                              newMeasIt->m_rsrq, useLayer3Filtering);
-        }
+      SaveUeMeasurements (newMeasIt->m_cellId, newMeasIt->m_rsrp,
+                          newMeasIt->m_rsrq, useLayer3Filtering);
     }
 
   if (m_state == IDLE_CELL_SEARCH)
@@ -874,14 +950,11 @@
     }
   else
     {
-      if (triggering)
+      std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator measIdIt;
+      for (measIdIt = m_varMeasConfig.measIdList.begin ();
+           measIdIt != m_varMeasConfig.measIdList.end (); ++measIdIt)
         {
-          std::map<uint8_t, LteRrcSap::MeasIdToAddMod>::iterator measIdIt;
-          for (measIdIt = m_varMeasConfig.measIdList.begin ();
-               measIdIt != m_varMeasConfig.measIdList.end (); ++measIdIt)
-            {
-              MeasurementReportTriggering (measIdIt->first);
-             }
+          MeasurementReportTriggering (measIdIt->first);
         }
     }
 
@@ -891,7 +964,7 @@
 
 // RRC SAP methods
 
-void
+void 
 LteUeRrc::DoCompleteSetup (LteUeRrcSapProvider::CompleteSetupParameters params)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
@@ -928,14 +1001,20 @@
           rc.numberOfRaPreambles = msg.sib2.radioResourceConfigCommon.rachConfigCommon.preambleInfo.numberOfRaPreambles;
           rc.preambleTransMax = msg.sib2.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.preambleTransMax;
           rc.raResponseWindowSize = msg.sib2.radioResourceConfigCommon.rachConfigCommon.raSupervisionInfo.raResponseWindowSize;
-          m_cmacSapProvider.at (0)->ConfigureRach (rc);
-          m_cphySapProvider.at (0)->ConfigureUplink (m_ulEarfcn, m_ulBandwidth);
-          m_cphySapProvider.at (0)->ConfigureReferenceSignalPower (msg.sib2.radioResourceConfigCommon.pdschConfigCommon.referenceSignalPower);
+          m_cmacSapProvider->ConfigureRach (rc);
+          m_cphySapProvider->ConfigureUplink (m_ulEarfcn, m_ulBandwidth);
+          m_cphySapProvider->ConfigureReferenceSignalPower(msg.sib2.radioResourceConfigCommon.pdschConfigCommon.referenceSignalPower);
           if (m_state == IDLE_WAIT_SIB2)
             {
               NS_ASSERT (m_connectionPending);
               StartConnection ();
             }
+          if (m_state == CONNECTED_HANDOVER && m_interRatHoCapable && !m_ncRaStarted)
+            {
+              m_ncRaStarted = true;
+              NS_LOG_INFO("StartNonContentionBasedRandomAccessProcedure after SIB2 received at time " << Simulator::Now());
+              m_cmacSapProvider->StartNonContentionBasedRandomAccessProcedure (m_rnti, m_rachConfigDedicated.raPreambleIndex, m_rachConfigDedicated.raPrachMaskIndex);  
+            }
           break;
 
         default: // IDLE_START, IDLE_CELL_SEARCH, IDLE_WAIT_MIB, IDLE_WAIT_MIB_SIB1, IDLE_WAIT_SIB1
@@ -961,7 +1040,7 @@
         LteRrcSap::RrcConnectionSetupCompleted msg2;
         msg2.rrcTransactionIdentifier = msg.rrcTransactionIdentifier;
         m_rrcSapUser->SendRrcConnectionSetupCompleted (msg2);
-        m_asSapUser->NotifyConnectionSuccessful ();
+        m_asSapUser->NotifyConnectionSuccessful (m_rnti);
         m_connectionEstablishedTrace (m_imsi, m_cellId, m_rnti);
       }
       break;
@@ -972,33 +1051,48 @@
     }
 }
 
+void 
+LteUeRrc::DoRecvRrcConnectToMmWave (uint16_t mmWaveCellId)
+{
+  m_asSapUser->NotifyConnectToMmWave(mmWaveCellId);
+}
+
 void
 LteUeRrc::DoRecvRrcConnectionReconfiguration (LteRrcSap::RrcConnectionReconfiguration msg)
 {
   NS_LOG_FUNCTION (this << " RNTI " << m_rnti);
-  NS_LOG_INFO ("DoRecvRrcConnectionReconfiguration haveNonCriticalExtension:" << msg.haveNonCriticalExtension );
   switch (m_state)
     {
     case CONNECTED_NORMALLY:
       if (msg.haveMobilityControlInfo)
         {
-          NS_LOG_INFO ("haveMobilityControlInfo == true");
+          NS_LOG_INFO ("UE " << m_rnti << " on cellId " << m_cellId << " haveMobilityControlInfo == true");
           SwitchToState (CONNECTED_HANDOVER);
           const LteRrcSap::MobilityControlInfo& mci = msg.mobilityControlInfo;
           m_handoverStartTrace (m_imsi, m_cellId, m_rnti, mci.targetPhysCellId);
-          m_cmacSapProvider.at(0)->Reset ();
-          m_cphySapProvider.at(0)->Reset ();
+          m_cmacSapProvider->Reset ();
+          m_cphySapProvider->Reset ();
           m_cellId = mci.targetPhysCellId;
+          SwitchLowerLayerProviders(m_cellId); // for InterRat HO
           NS_ASSERT (mci.haveCarrierFreq);
           NS_ASSERT (mci.haveCarrierBandwidth);
-          m_cphySapProvider.at(0)->SynchronizeWithEnb (m_cellId, mci.carrierFreq.dlCarrierFreq);
-          m_cphySapProvider.at(0)->SetDlBandwidth ( mci.carrierBandwidth.dlBandwidth);
-          m_cphySapProvider.at(0)->ConfigureUplink (mci.carrierFreq.ulCarrierFreq, mci.carrierBandwidth.ulBandwidth);
+          m_cphySapProvider->SynchronizeWithEnb (m_cellId, mci.carrierFreq.dlCarrierFreq);
+          m_cphySapProvider->SetDlBandwidth ( mci.carrierBandwidth.dlBandwidth);
+          m_cphySapProvider->ConfigureUplink (mci.carrierFreq.ulCarrierFreq, mci.carrierBandwidth.ulBandwidth); 
+          uint16_t oldRnti = m_rnti;
           m_rnti = msg.mobilityControlInfo.newUeIdentity;
           m_srb0->m_rlc->SetRnti (m_rnti);
           NS_ASSERT_MSG (mci.haveRachConfigDedicated, "handover is only supported with non-contention-based random access procedure");
-          m_cmacSapProvider.at(0)->StartNonContentionBasedRandomAccessProcedure (m_rnti, mci.rachConfigDedicated.raPreambleIndex, mci.rachConfigDedicated.raPrachMaskIndex);
-          m_cphySapProvider.at(0)->SetRnti (m_rnti);
+          if(m_interRatHoCapable)
+          {
+            m_rachConfigDedicated = mci.rachConfigDedicated;
+            m_ncRaStarted = false;
+          }
+          else
+          {
+            m_cmacSapProvider->StartNonContentionBasedRandomAccessProcedure (m_rnti, mci.rachConfigDedicated.raPreambleIndex, mci.rachConfigDedicated.raPrachMaskIndex);
+          }
+          m_cphySapProvider->SetRnti (m_rnti);
           m_lastRrcTransactionIdentifier = msg.rrcTransactionIdentifier;
           NS_ASSERT (msg.haveRadioResourceConfigDedicated);
 
@@ -1010,8 +1104,27 @@
           Simulator::ScheduleNow (&LteUeRrc::DisposeOldSrb1, this);
           m_srb1 = 0; // new instance will be be created within ApplyRadioResourceConfigDedicated
 
+          //TODO find how to clear these maps and forward buffer contents!
+          // clear the RLC maps after having forwarded buffer content 
           m_drbMap.clear (); // dispose all DRBs
-          ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
+          m_rlcMap.clear (); // dispose all MmWave RLCs
+
+          if(!m_isSecondaryRRC)
+          {
+            ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
+          }
+          else
+          {
+            // this is the secondary mmWave RRC. When a secondary HO happens,
+            // the primary LTE RRC must be notified in order to update the RLC instances
+            // Forward this message to EpcUeNas and then to LteUeRrc for LTE RRC
+            m_asSapUser->NotifySecondaryCellHandoverStarted(oldRnti, m_rnti, m_cellId, msg.radioResourceConfigDedicated);
+            msg.radioResourceConfigDedicated.drbToAddModList.clear(); // remove the drb list, since no Data RLC must be setup in this RRC
+            // setup SRB1
+            ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
+          }
+
+
 
           if (msg.haveMeasConfig)
             {
@@ -1022,12 +1135,7 @@
         }
       else
         {
-          NS_LOG_INFO ("haveMobilityControlInfo == false");
-          if (msg.haveNonCriticalExtension)
-            {
-              ApplyRadioResourceConfigDedicatedSecondaryCarrier (msg.nonCriticalExtension);
-              NS_LOG_FUNCTION ( this << "RNTI " << m_rnti << " Configured for CA" );
-            }
+          NS_LOG_INFO ("UE " << m_rnti << " on cellId " << m_cellId << " haveMobilityControlInfo == false");
           if (msg.haveRadioResourceConfigDedicated)
             {
               ApplyRadioResourceConfigDedicated (msg.radioResourceConfigDedicated);
@@ -1108,12 +1216,439 @@
   NS_LOG_FUNCTION (this);
   m_connectionTimeout.Cancel ();
 
-  m_cmacSapProvider.at (0)->Reset ();       // reset the MAC
+  m_cmacSapProvider->Reset ();       // reset the MAC
   m_hasReceivedSib2 = false;         // invalidate the previously received SIB2
   SwitchToState (IDLE_CAMPED_NORMALLY);
   m_asSapUser->NotifyConnectionFailed ();  // inform upper layer
 }
 
+void
+LteUeRrc::DoRecvRrcConnectionSwitch (LteRrcSap::RrcConnectionSwitch msg)
+{
+  NS_LOG_INFO("Recv RRC Connection Switch on rnti " << m_rnti << " of cell " << m_cellId << " m_mmWaveCellId " << m_mmWaveCellId << " in state " << ToString(m_state));
+  std::vector<uint8_t> drbidList = msg.drbidList;
+  for(std::vector<uint8_t>::iterator iter = drbidList.begin(); iter != drbidList.end(); ++iter)
+  {
+    if(m_drbMap.find(*iter) != m_drbMap.end())
+    {
+      Ptr<McUePdcp> pdcp = DynamicCast<McUePdcp>(m_drbMap.find(*iter)->second->m_pdcp);
+      if(pdcp != 0)
+      {
+        pdcp->SwitchConnection(msg.useMmWaveConnection);
+
+        if(msg.useMmWaveConnection) // I was on LTE, now I switch to mmWave
+        {
+          uint8_t lcid = m_drbMap.find(*iter)->second->m_logicalChannelIdentity;
+          m_cmacSapProvider->RemoveLc (lcid);
+
+          // before resetting the RLC, forward the content of the LTE RLC to the mmWave RLC
+          // check if this rlc is already in the map
+          if(m_drbMap.find(*iter) != m_drbMap.end())
+          {
+            // get the RLC buffer content and forward it to the m_rlcMap RLC!
+            CopyRlcBuffers(m_drbMap.find(*iter)->second->m_rlc, pdcp, lcid);
+          } 
+
+          // reset the LTE RLC
+          TypeId rlcTypeId;
+          if (m_useRlcSm)
+            {
+              rlcTypeId = LteRlcSm::GetTypeId ();
+            }
+          else
+            {
+              switch (m_drbMap.find(*iter)->second->m_rlcConfig.choice)
+                {
+                case LteRrcSap::RlcConfig::AM: 
+                  rlcTypeId = LteRlcAm::GetTypeId ();
+                  break;
+          
+                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL: 
+                  rlcTypeId = LteRlcUm::GetTypeId ();
+                  break;
+          
+                default:
+                  NS_FATAL_ERROR ("unsupported RLC configuration");
+                  break;                
+                }
+            }
+  
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_macSapProvider);
+          rlc->SetRnti (m_rnti);
+          rlc->SetLcId (lcid);
+
+          
+          m_drbMap.find(*iter)->second->m_rlc = rlc;
+ 
+          // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
+          // if we are using RLC/SM we don't care of anything above RLC
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+            {
+              pdcp->SetLteRlcSapProvider (rlc->GetLteRlcSapProvider ()); 
+              rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+            }
+
+          struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+          lcConfig.priority = m_drbMap.find(*iter)->second->m_logicalChannelConfig.priority;
+          lcConfig.prioritizedBitRateKbps = m_drbMap.find(*iter)->second->m_logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfig.bucketSizeDurationMs =   m_drbMap.find(*iter)->second->m_logicalChannelConfig.bucketSizeDurationMs;
+          lcConfig.logicalChannelGroup =    m_drbMap.find(*iter)->second->m_logicalChannelConfig.logicalChannelGroup;
+
+          m_cmacSapProvider->AddLc (lcid,
+                                    lcConfig,
+                                    rlc->GetLteMacSapUser ());
+          rlc->Initialize ();
+
+        }
+        else // I was on mmWave, and I switch to LTE
+        {
+          m_mmWaveCmacSapProvider->RemoveLc(m_rlcMap.find(*iter)->second->logicalChannelIdentity);
+
+          // before resetting, forward the content of the RLC in m_rlcMap to the RLC in m_drbMap
+          if(m_rlcMap.find(*iter) != m_rlcMap.end())
+          {
+            // get the RLC buffer content and store it in this RLC
+            CopyRlcBuffers(m_rlcMap.find(*iter)->second->m_rlc, pdcp, m_rlcMap.find(*iter)->second->logicalChannelIdentity);
+          } 
+
+          // create Rlc
+          TypeId rlcTypeId;
+          if (m_useRlcSm)
+            {
+              rlcTypeId = LteRlcSm::GetTypeId ();
+              NS_LOG_INFO("SM");
+            }
+          else
+            {
+              switch (m_rlcMap.find(*iter)->second->rlcConfig.choice)
+                {
+                case LteRrcSap::RlcConfig::AM: 
+                  rlcTypeId = LteRlcAm::GetTypeId ();
+                  NS_LOG_INFO("AM");
+                  break;
+          
+                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL: 
+                  rlcTypeId = LteRlcUm::GetTypeId ();
+                  NS_LOG_INFO("UM");
+                  break;
+          
+                default:
+                  NS_FATAL_ERROR ("unsupported RLC configuration");
+                  break;                
+                }
+            }
+  
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_mmWaveMacSapProvider); 
+          rlc->SetRnti (m_mmWaveRnti);
+          rlc->SetLcId (m_rlcMap.find(*iter)->second->logicalChannelIdentity);
+
+          struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+          lcConfig.priority =               m_rlcMap.find(*iter)->second->logicalChannelConfig.priority;
+          lcConfig.prioritizedBitRateKbps = m_rlcMap.find(*iter)->second->logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfig.bucketSizeDurationMs =   m_rlcMap.find(*iter)->second->logicalChannelConfig.bucketSizeDurationMs;
+          lcConfig.logicalChannelGroup =    m_rlcMap.find(*iter)->second->logicalChannelConfig.logicalChannelGroup;      
+
+          m_mmWaveCmacSapProvider->AddLc (m_rlcMap.find(*iter)->second->logicalChannelIdentity, 
+                                  lcConfig,
+                                  rlc->GetLteMacSapUser ());
+
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+          {
+            pdcp->SetMmWaveRnti (m_mmWaveRnti);
+            pdcp->SetMmWaveRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+          } 
+          rlc->Initialize();
+          m_rlcMap.find(*iter)->second->m_rlc = rlc;
+
+        }
+
+        if(msg.useMmWaveConnection)
+        {
+          NS_LOG_INFO("LteUeRrc SwitchToMmWave " << m_imsi << m_cellId << m_rnti << " at time " << Simulator::Now().GetSeconds());
+          m_switchToMmWaveTrace(m_imsi, m_mmWaveCellId, m_mmWaveRnti);
+        }
+        else if(!msg.useMmWaveConnection)
+        {
+          NS_LOG_INFO("LteUeRrc SwitchToLte " << m_imsi << m_cellId << m_rnti << " at time " << Simulator::Now().GetSeconds());
+          m_switchToLteTrace(m_imsi, m_cellId, m_rnti);          
+        }
+      }
+      else
+      {
+        NS_FATAL_ERROR("Trying to switch a non MC bearer");
+      }
+    }
+  }
+}
+
+
+/*
+ * Merge 2 buffers of RlcAmPdus into 1 vector with increment order of Pdus
+ */
+std::vector < LteRlcAm::RetxPdu >
+LteUeRrc::MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second)
+{
+  LteRlcAmHeader rlcamHeader_1, rlcamHeader_2;
+  std::vector < LteRlcAm::RetxPdu> result;
+  std::vector < LteRlcAm::RetxPdu>::iterator it_1 = first.begin();
+  std::vector < LteRlcAm::RetxPdu>::iterator it_2 = second.begin();
+  bool end_1_reached = false;
+  bool end_2_reached = false;
+  while (it_1 != first.end() && it_2 != second.end()){
+    while ((*it_1).m_pdu == 0){
+      ++it_1;
+      if(it_1 == first.end())
+      {
+        end_1_reached = true;
+        break;
+      }
+    }
+    while ((*it_2).m_pdu == 0){
+      ++it_2;
+      if(it_2 == second.end())
+      {
+        end_2_reached = true;
+        break;
+      }
+    }
+    if(!end_1_reached && !end_2_reached)
+    {
+      (*it_1).m_pdu->PeekHeader(rlcamHeader_1);
+      (*it_2).m_pdu->PeekHeader(rlcamHeader_2);
+      if (rlcamHeader_1.GetSequenceNumber() > rlcamHeader_2.GetSequenceNumber()){
+        result.push_back((*it_2));  
+        ++it_2;       
+      }
+      else if (rlcamHeader_2.GetSequenceNumber() > rlcamHeader_1.GetSequenceNumber()){
+        result.push_back((*it_1));
+        ++it_1;         
+      }
+      else {
+        result.push_back((*it_1));
+        ++it_1;
+        ++it_2;
+      }
+      NS_LOG_DEBUG ("first,second = " << rlcamHeader_1.GetSequenceNumber() << "," << rlcamHeader_2.GetSequenceNumber());
+    }
+    else
+    {
+      break;
+    }
+  }
+  while (it_1 != first.end()){
+    result.push_back((*it_1));
+    it_1++;
+  }
+  while (it_2 != second.end()){
+    result.push_back((*it_2));
+    it_2++;
+  }
+  return result;
+}
+
+// This code from the LL HO implementation is refactored in a function
+// in order to be used also when switching from LTE to MmWave and back
+void
+LteUeRrc::CopyRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint16_t lcid)
+{
+  // RlcBuffers forwarding only for RlcAm bearers.
+  if (0 != rlc->GetObject<LteRlcAm> ())
+  {
+    //Copy lte-rlc-am.m_txOnBuffer to X2 forwarding buffer.
+    Ptr<LteRlcAm> rlcAm = rlc->GetObject<LteRlcAm>();
+    uint32_t txonBufferSize = rlcAm->GetTxBufferSize();
+    std::vector < Ptr<Packet> > txonBuffer = rlcAm->GetTxBuffer();
+    //m_rlcBufferToBeForwardedSize =  drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBufferSize();
+    //m_rlcBufferToBeForwarded = drbIt->second->m_rlc->GetObject<LteRlcAm>()->GetTxBuffer();
+    uint32_t txedBufferSize = rlcAm->GetTxedBufferSize();
+    std::vector < LteRlcAm::RetxPdu > txedBuffer = rlcAm->GetTxedBuffer();
+    uint32_t retxBufferSize = rlcAm->GetRetxBufferSize();
+    std::vector < LteRlcAm::RetxPdu > retxBuffer = rlcAm->GetRetxBuffer();
+    
+    //Translate Pdus in Rlc txed/retx buffer into RLC Sdus
+    //and put these Sdus into rlcAm->m_transmittingRlcSdus.
+    NS_LOG_INFO("UE RRC: retxBuffer size = " << retxBufferSize);
+    NS_LOG_INFO("UE RRC: txedBuffer size = " << txedBufferSize);
+    //Merge txed and retx buffers into a single buffer before doing RlcPdusToRlc.
+    if ( retxBufferSize + txedBufferSize > 0 ){
+      std::vector< LteRlcAm::RetxPdu > sortedTxedRetxBuffer;
+      if (retxBufferSize == 0){
+        sortedTxedRetxBuffer = txedBuffer;
+      }
+      else if (txedBufferSize == 0){
+        sortedTxedRetxBuffer = retxBuffer;
+      }
+      else {
+        sortedTxedRetxBuffer = MergeBuffers(txedBuffer, retxBuffer);
+      }
+      rlcAm->RlcPdusToRlcSdus(sortedTxedRetxBuffer);  
+    }
+
+    //Construct the forwarding buffer
+    //Forwarding buffer = retxBuffer + txedBuffer + txonBuffer.
+    //if ( txonBufferSize > 0 )
+    //{
+      LtePdcpHeader pdcpHeader;
+      uint32_t pos = 0;
+      for (std::vector< Ptr<Packet> >::iterator it = txonBuffer.begin(); it != txonBuffer.end(); ++it)
+      {
+        pos++;
+        if((*it)->GetSize() > 3) 
+        {
+          (*it)->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG("UE RRC: txonBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+        }
+        else
+        {
+          NS_LOG_UNCOND("UE RRC: Fragment too small in txonBuffer, pos " << pos);
+        }
+          
+      }
+
+      // this cycle adds the SDUs given by the merge of txed and retxed buffers
+      if ( rlcAm->GetTransmittingRlcSduBufferSize() > 0 )
+      { //something inside the RLC AM's transmitting buffer 
+        NS_LOG_DEBUG ("UE RRC: ADDING TRANSMITTING SDUS OF RLC AM TO X2FORWARDINGBUFFER... Size = " << rlcAm->GetTransmittingRlcSduBufferSize() );
+        //copy the RlcSdu buffer (map) to forwardingBuffer.
+        std::map < uint32_t, Ptr<Packet> > rlcAmTransmittingBuffer = rlcAm->GetTransmittingRlcSduBuffer();
+        NS_LOG_DEBUG ("UE RRC:  *** SIZE = " << rlcAmTransmittingBuffer.size());
+        for (std::map< uint32_t, Ptr<Packet> >::iterator it = rlcAmTransmittingBuffer.begin(); it != rlcAmTransmittingBuffer.end(); ++it)
+        {
+          if (it->second != 0)
+          {
+            NS_LOG_DEBUG ( this << " add to forwarding buffer SEQ = " << it->first << " Ptr<Packet> = " << it->second );
+            m_rlcBufferToBeForwarded.push_back(it->second);
+          }
+        } 
+        NS_LOG_DEBUG(this << "UE RRC:  ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+
+      
+        Ptr<Packet> segmentedRlcsdu = rlcAm->GetSegmentedRlcsdu();
+        if (segmentedRlcsdu != NULL){
+          segmentedRlcsdu->PeekHeader(pdcpHeader);
+          NS_LOG_DEBUG(this << "UE RRC: SegmentedRlcSdu = " << segmentedRlcsdu->GetSize() << " SEQ = " << pdcpHeader.GetSequenceNumber());
+          //insert the complete version of the fragmented SDU to the front of txonBuffer.
+          txonBuffer.insert(txonBuffer.begin(),segmentedRlcsdu);
+        }
+        m_rlcBufferToBeForwarded.insert(m_rlcBufferToBeForwarded.end(), txonBuffer.begin(), txonBuffer.end());
+        m_rlcBufferToBeForwardedSize += rlcAm->GetTransmittingRlcSduBufferSize() + txonBufferSize;
+
+        //Get the rlcAm
+        std::vector < Ptr <Packet> > rlcAmTxedSduBuffer = rlcAm->GetTxedRlcSduBuffer();
+        LtePdcpHeader pdcpHeader_1;
+        m_rlcBufferToBeForwarded.at(0)->PeekHeader(pdcpHeader_1);
+        uint16_t i = 0;
+        for (std::vector< Ptr<Packet> >::iterator it = rlcAmTxedSduBuffer.begin(); it != rlcAmTxedSduBuffer.end(); ++it)
+        {
+          if ((*it) != NULL)
+          {
+            (*it)->PeekHeader(pdcpHeader);
+            NS_LOG_DEBUG("UE RRC: rlcAmTxedSduBuffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+          
+            //add the previous SDU of the forwarding buffer to the forwarding buffer.
+            if (pdcpHeader.GetSequenceNumber() >= (pdcpHeader_1.GetSequenceNumber() - 2) && pdcpHeader.GetSequenceNumber() <= (pdcpHeader_1.GetSequenceNumber()) )
+            {
+              NS_LOG_DEBUG("UE RRC: Added previous SDU to forwarding buffer SEQ = " << pdcpHeader.GetSequenceNumber() << " Size = " << (*it)->GetSize());
+              m_rlcBufferToBeForwarded.insert(m_rlcBufferToBeForwarded.begin()+i, (*it)->Copy());
+              ++i;
+            }
+          }
+        }
+        
+      }
+      else 
+      { //TransmittingBuffer is empty. Only copy TxonBuffer.
+        NS_LOG_DEBUG(this << " UE RRC: ADDING TXONBUFFER OF RLC AM " << m_rnti << " Size = " << txonBufferSize) ;
+        m_rlcBufferToBeForwarded = txonBuffer;
+        m_rlcBufferToBeForwardedSize += txonBufferSize;
+      }
+    //}
+  }
+  //For RlcUM, no forwarding available as the simulator itself (seamless HO).
+  //However, as the LTE-UMTS book, PDCP txbuffer should be forwarded for seamless 
+  //HO. Enable this code for txbuffer forwarding in seamless HO (which is believe to 
+  //be correct).
+  else if (0 != rlc->GetObject<LteRlcUm> ())
+  {
+    //Copy lte-rlc-um.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " UE RRC: Copying txonBuffer from RLC UM " << m_rnti);
+    m_rlcBufferToBeForwarded = rlc->GetObject<LteRlcUm>()->GetTxBuffer();
+    m_rlcBufferToBeForwardedSize =  rlc->GetObject<LteRlcUm>()->GetTxBufferSize();
+  }
+  else if (0 != rlc->GetObject<LteRlcUmLowLat> ())
+  {
+    //Copy lte-rlc-um-low-lat.m_txOnBuffer to X2 forwarding buffer.
+    NS_LOG_DEBUG(this << " UE RRC: Copying txonBuffer from RLC UM " << m_rnti);
+    m_rlcBufferToBeForwarded = rlc->GetObject<LteRlcUmLowLat>()->GetTxBuffer();
+    m_rlcBufferToBeForwardedSize =  rlc->GetObject<LteRlcUmLowLat>()->GetTxBufferSize();
+  }
+  //LteRlcAm m_txBuffer stores PDCP "PDU".
+  NS_LOG_DEBUG(this << " UE RRC: m_x2forw buffer size = " << m_rlcBufferToBeForwardedSize);
+    //Forwarding the packet inside m_rlcBufferToBeForwarded to target eNB. 
+
+  while (!m_rlcBufferToBeForwarded.empty())
+  {
+    NS_LOG_DEBUG(this << " UE RRC: Forwarding m_rlcBufferToBeForwarded to target eNB, lcid = " << lcid );
+    //Remove tags to get PDCP SDU from PDCP PDU.
+    //Ptr<Packet> rlcSdu =  (*(m_rlcBufferToBeForwarded.begin()))->Copy();
+    Ptr<Packet> rlcSdu =  m_rlcBufferToBeForwarded.at(0);
+    //Tags to be removed from rlcSdu (from outer to inner)
+    //LteRlcSduStatusTag rlcSduStatusTag;
+    //RlcTag  rlcTag; //rlc layer timestamp
+    //PdcpTag pdcpTag;  //pdcp layer timestamp
+    LtePdcpHeader pdcpHeader;
+    
+    
+    NS_LOG_DEBUG ("UE RRC: RlcSdu size = " << rlcSdu->GetSize() );
+    //rlcSdu->RemoveHeader(pdcpHeader); //remove pdcp header
+    
+    //only forward data PDCP PDUs (1-DATA_PDU,0-CTR_PDU)
+    if(rlcSdu->GetSize() >= 3)
+    {
+      rlcSdu->RemoveHeader(pdcpHeader);
+      if (pdcpHeader.GetDcBit() == 1 )
+      { //ignore control SDU.
+        NS_LOG_LOGIC ("UE RRC: SEQ = " << pdcpHeader.GetSequenceNumber());
+        NS_LOG_LOGIC ("UE RRC: removed pdcp header, size = " << rlcSdu->GetSize());
+
+        rlcSdu->RemoveAllPacketTags(); // this does not remove byte tags
+        NS_LOG_LOGIC ("UE RRC: removed tags, size = " << rlcSdu->GetSize() );
+
+        /*
+        rlcSdu->RemovePacketTag(rlcSduStatusTag); //remove Rlc status tag.
+        NS_LOG_DEBUG ("removed rlc status tag, size = " << rlcSdu->GetSize() );
+        rlcSdu->RemovePacketTag(rlcTag);  //remove Rlc timestamp
+        NS_LOG_DEBUG ("removed rlc timestamp, size = " << rlcSdu->GetSize() );
+        //rlcSdu->RemoveByteTag(pdcpTag); //remove pdcp timestamp
+        //NS_LOG_DEBUG ("removed pdcp timestamp, size = " << rlcSdu->GetSize());
+        */
+
+        // re-inject into PDCP
+        LtePdcpSapProvider::TransmitPdcpSduParameters pdcpParams;
+        pdcpParams.pdcpSdu = rlcSdu;
+        pdcpParams.rnti = m_rnti;
+        pdcpParams.lcid = lcid;
+        pdcp->GetLtePdcpSapProvider()->TransmitPdcpSdu(pdcpParams);
+
+      }
+    }
+    else
+    {
+      NS_LOG_UNCOND("UE RRC: Too small, not forwarded");
+    }
+    m_rlcBufferToBeForwardedSize -= (*(m_rlcBufferToBeForwarded.begin()))->GetSize();
+    m_rlcBufferToBeForwarded.erase (m_rlcBufferToBeForwarded.begin());
+    NS_LOG_LOGIC(this << " UE RRC: After forwarding: buffer size = " << m_rlcBufferToBeForwardedSize );
+  }
+}
+
 
 
 void
@@ -1152,7 +1687,7 @@
     {
       NS_LOG_LOGIC (this << " cell " << maxRsrpCellId
                          << " is the strongest untried surrounding cell");
-      m_cphySapProvider.at(0)->SynchronizeWithEnb (maxRsrpCellId, m_dlEarfcn);
+      m_cphySapProvider->SynchronizeWithEnb (maxRsrpCellId, m_dlEarfcn);
       SwitchToState (IDLE_WAIT_MIB_SIB1);
     }
 
@@ -1197,8 +1732,9 @@
   if (isSuitableCell)
     {
       m_cellId = cellId;
-      m_cphySapProvider.at(0)->SynchronizeWithEnb (cellId, m_dlEarfcn);
-      m_cphySapProvider.at(0)->SetDlBandwidth (m_dlBandwidth);
+      SwitchLowerLayerProviders(m_cellId); // for InterRat HO
+      m_cphySapProvider->SynchronizeWithEnb (cellId, m_dlEarfcn);
+      m_cphySapProvider->SetDlBandwidth (m_dlBandwidth);
       m_initialCellSelectionEndOkTrace (m_imsi, cellId);
       SwitchToState (IDLE_CAMPED_NORMALLY);
     }
@@ -1225,38 +1761,112 @@
 
 } // end of void LteUeRrc::EvaluateCellForSelection ()
 
-
 void
-LteUeRrc::ApplyRadioResourceConfigDedicatedSecondaryCarrier (LteRrcSap::NonCriticalExtensionConfiguration nonCec)
+LteUeRrc::DoNotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd)
 {
-  NS_LOG_FUNCTION (this);
-
-  for(std::list<LteRrcSap::SCellToAddMod>::iterator it = nonCec.sCellsToAddModList.begin(); it!=nonCec.sCellsToAddModList.end(); it++)
+  NS_ASSERT_MSG(oldRnti == m_mmWaveRnti, "Wrong RNTI! - unknown device");
+  NS_ASSERT_MSG(!m_isSecondaryRRC, "Trying to modify RLCs in the mmWave RRC (they are instances in the LTE RRC)");
+  m_mmWaveRnti = newRnti;
+  m_mmWaveCellId = mmWaveCellId;
+  std::list<LteRrcSap::DrbToAddMod>::const_iterator dtamIt; // iterate over the 
+  for (dtamIt = rrcd.drbToAddModList.begin ();
+       dtamIt != rrcd.drbToAddModList.end ();
+       ++dtamIt)
     {
-      LteRrcSap::SCellToAddMod scell = *it;
-      uint8_t ccId = scell.sCellIndex;
+      NS_LOG_INFO (this << " IMSI " << m_imsi << " modifying DRBID " << (uint32_t) dtamIt->drbIdentity << " LC " << (uint32_t) dtamIt->logicalChannelIdentity);
+      NS_ASSERT_MSG (dtamIt->logicalChannelIdentity > 2, "LCID value " << dtamIt->logicalChannelIdentity << " is reserved for SRBs");
 
+      std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbMapIt = m_drbMap.find (dtamIt->drbIdentity);
+      NS_ASSERT_MSG (drbMapIt != m_drbMap.end(), "Trying to modify an unknown bearer");
+        
+      Ptr<LteDataRadioBearerInfo> drbInfo = drbMapIt->second;
+      NS_LOG_INFO ("Is MC " << dtamIt->is_mc);
+      if(dtamIt->is_mc == true) // we need to modify the RLC for MmWave communications
+      {
+        Ptr<McUePdcp> pdcp = DynamicCast<McUePdcp> (drbInfo->m_pdcp);
+        if(pdcp !=0)
+        {
+          // create Rlc
+          TypeId rlcTypeId;
+          if (m_useRlcSm)
+            {
+              rlcTypeId = LteRlcSm::GetTypeId ();
+              NS_LOG_INFO("SM");
+            }
+          else
+            {
+              switch (dtamIt->rlcConfig.choice)
+                {
+                case LteRrcSap::RlcConfig::AM: 
+                  rlcTypeId = LteRlcAm::GetTypeId ();
+                  NS_LOG_INFO("AM");
+                  break;
+          
+                case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL: 
+                  rlcTypeId = LteRlcUm::GetTypeId ();
+                  NS_LOG_INFO("UM");
+                  break;
+          
+                default:
+                  NS_FATAL_ERROR ("unsupported RLC configuration");
+                  break;                
+                }
+            }
+  
+          ObjectFactory rlcObjectFactory;
+          rlcObjectFactory.SetTypeId (rlcTypeId);
+          Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+          rlc->SetLteMacSapProvider (m_mmWaveMacSapProvider); 
+          rlc->SetRnti (m_mmWaveRnti);
+          rlc->SetLcId (dtamIt->logicalChannelIdentity);
 
-      uint16_t physCellId = scell.cellIdentification.physCellId;
-      uint8_t ulBand = scell.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulBandwidth;
-      uint32_t ulEarfcn = scell.radioResourceConfigCommonSCell.ulConfiguration.ulFreqInfo.ulCarrierFreq;
-      uint8_t dlBand = scell.radioResourceConfigCommonSCell.nonUlConfiguration.dlBandwidth;
-      uint32_t dlEarfcn = scell.cellIdentification.dlCarrierFreq;
-      uint8_t txMode = scell.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.antennaInfo.transmissionMode;
-      uint8_t srsIndex = scell.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.soundingRsUlConfigDedicated.srsConfigIndex;
+          struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+          lcConfig.priority = dtamIt->logicalChannelConfig.priority;
+          lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+          lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;      
 
-      m_cphySapProvider.at (ccId)->SynchronizeWithEnb (physCellId, dlEarfcn);
-      m_cphySapProvider.at (ccId)->SetDlBandwidth (dlBand);
-      m_cphySapProvider.at (ccId)->ConfigureUplink (ulEarfcn, ulBand);
-      m_cphySapProvider.at (ccId)->ConfigureReferenceSignalPower (scell.radioResourceConfigCommonSCell.nonUlConfiguration.pdschConfigCommon.referenceSignalPower);
-      m_cphySapProvider.at (ccId)->SetTransmissionMode (txMode);
-      m_cphySapProvider.at (ccId)->SetRnti(m_rnti);
-      m_cmacSapProvider.at (ccId)->SetRnti(m_rnti);
-      // update PdschConfigDedicated (i.e. P_A value)
-      LteRrcSap::PdschConfigDedicated pdschConfigDedicated = scell.radioResourceConfigDedicateSCell.physicalConfigDedicatedSCell.pdschConfigDedicated;
-      double paDouble = LteRrcSap::ConvertPdschConfigDedicated2Double (pdschConfigDedicated);
-      m_cphySapProvider.at (ccId)->SetPa (paDouble);
-      m_cphySapProvider.at (ccId)->SetSrsConfigurationIndex (srsIndex);
+
+          m_mmWaveCmacSapProvider->AddLc (dtamIt->logicalChannelIdentity, 
+                                  lcConfig,
+                                  rlc->GetLteMacSapUser ());
+          if (rlcTypeId != LteRlcSm::GetTypeId ())
+          {
+            pdcp->SetMmWaveRnti (m_mmWaveRnti);
+            pdcp->SetMmWaveRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+          } 
+          rlc->Initialize();
+
+          Ptr<RlcBearerInfo> rlcInfo = CreateObject<RlcBearerInfo>();
+          rlcInfo->m_rlc = rlc;
+          rlcInfo->rlcConfig.choice = dtamIt->rlcConfig.choice;
+          rlcInfo->logicalChannelIdentity = dtamIt->logicalChannelIdentity;
+          rlcInfo->mmWaveRnti = m_mmWaveRnti;
+
+          LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+          logicalChannelConfig.priority = dtamIt->logicalChannelConfig.priority;
+          logicalChannelConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+          logicalChannelConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+          logicalChannelConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;  
+
+          rlcInfo->logicalChannelConfig = logicalChannelConfig;
+
+          // check if this rlc is already in the map
+          if(m_rlcMap.find(dtamIt->drbIdentity) != m_rlcMap.end())
+          {
+            // get the RLC buffer content and store it in this RLC
+            CopyRlcBuffers(m_rlcMap.find(dtamIt->drbIdentity)->second->m_rlc, drbInfo->m_pdcp, drbInfo->m_logicalChannelIdentity);
+          } 
+          m_rlcMap[dtamIt->drbIdentity] = rlcInfo;
+          
+          NS_LOG_INFO(this << "LteUeRrc Secondary Cell Handover, created new rlc " << m_imsi << m_mmWaveCellId << m_mmWaveRnti << " at time " << Simulator::Now().GetSeconds());
+        }
+        else
+        {
+          NS_FATAL_ERROR("MC setup on a non MC-capable bearer");
+        }
+      }
     }
 }
 
@@ -1268,11 +1878,11 @@
 
   if (pcd.haveAntennaInfoDedicated)
     {
-      m_cphySapProvider.at(0)->SetTransmissionMode (pcd.antennaInfo.transmissionMode);
+      m_cphySapProvider->SetTransmissionMode (pcd.antennaInfo.transmissionMode);
     }
   if (pcd.haveSoundingRsUlConfigDedicated)
     {
-      m_cphySapProvider.at(0)->SetSrsConfigurationIndex (pcd.soundingRsUlConfigDedicated.srsConfigIndex);
+      m_cphySapProvider->SetSrsConfigurationIndex (pcd.soundingRsUlConfigDedicated.srsConfigIndex);
     }
 
   if (pcd.havePdschConfigDedicated)
@@ -1280,7 +1890,7 @@
       // update PdschConfigDedicated (i.e. P_A value)
       m_pdschConfigDedicated = pcd.pdschConfigDedicated;
       double paDouble = LteRrcSap::ConvertPdschConfigDedicated2Double (m_pdschConfigDedicated);
-      m_cphySapProvider.at(0)->SetPa (paDouble);
+      m_cphySapProvider->SetPa (paDouble);
     }
 
   std::list<LteRrcSap::SrbToAddMod>::const_iterator stamIt = rrcd.srbToAddModList.begin ();
@@ -1288,6 +1898,7 @@
     {
       if (m_srb1 == 0)
         {
+          NS_LOG_INFO("Setup SBR1 for rnti " << m_rnti << " on cell " << m_cellId);
           // SRB1 not setup yet        
           NS_ASSERT_MSG ((m_state == IDLE_CONNECTING) || (m_state == CONNECTED_HANDOVER), 
                          "unexpected state " << ToString (m_state));
@@ -1322,9 +1933,11 @@
           lcConfig.prioritizedBitRateKbps = stamIt->logicalChannelConfig.prioritizedBitRateKbps;
           lcConfig.bucketSizeDurationMs = stamIt->logicalChannelConfig.bucketSizeDurationMs;
           lcConfig.logicalChannelGroup = stamIt->logicalChannelConfig.logicalChannelGroup;
-          m_cmacSapProvider.at (0)->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+      
+          m_cmacSapProvider->AddLc (lcid, lcConfig, rlc->GetLteMacSapUser ());
+      
           ++stamIt;
-          NS_ASSERT_MSG (stamIt == rrcd.srbToAddModList.end (), "at most one SrbToAdd supported");
+          NS_ASSERT_MSG (stamIt == rrcd.srbToAddModList.end (), "at most one SrbToAdd supported");     
           
           LteUeRrcSapUser::SetupParameters ueParams;
           ueParams.srb0SapProvider = m_srb0->m_rlc->GetLteRlcSapProvider ();
@@ -1347,11 +1960,19 @@
       NS_LOG_INFO (this << " IMSI " << m_imsi << " adding/modifying DRBID " << (uint32_t) dtamIt->drbIdentity << " LC " << (uint32_t) dtamIt->logicalChannelIdentity);
       NS_ASSERT_MSG (dtamIt->logicalChannelIdentity > 2, "LCID value " << dtamIt->logicalChannelIdentity << " is reserved for SRBs");
 
-      std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbMapIt = m_drbMap.find (dtamIt->drbIdentity);
+      std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator drbMapIt = m_drbMap.begin();
+      for(; drbMapIt != m_drbMap.end(); ++drbMapIt)
+      {
+        NS_LOG_DEBUG("In m_drbMap " << (uint16_t)drbMapIt->first);
+      }
+
+
+      //std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator 
+      drbMapIt = m_drbMap.find (dtamIt->drbIdentity);
       if (drbMapIt == m_drbMap.end ())
         {
           NS_LOG_INFO ("New Data Radio Bearer");
-        
+
           TypeId rlcTypeId;
           if (m_useRlcSm)
             {
@@ -1374,11 +1995,11 @@
                   break;                
                 }
             }
-  
+
           ObjectFactory rlcObjectFactory;
           rlcObjectFactory.SetTypeId (rlcTypeId);
           Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
-          rlc->SetLteMacSapProvider (m_macSapProvider);
+          rlc->SetLteMacSapProvider (m_macSapProvider); // TODO interRatHoCapable 
           rlc->SetRnti (m_rnti);
           rlc->SetLcId (dtamIt->logicalChannelIdentity);
 
@@ -1387,12 +2008,13 @@
           drbInfo->m_epsBearerIdentity = dtamIt->epsBearerIdentity;
           drbInfo->m_logicalChannelIdentity = dtamIt->logicalChannelIdentity;
           drbInfo->m_drbIdentity = dtamIt->drbIdentity;
+          drbInfo->m_rlcConfig.choice = dtamIt->rlcConfig.choice;
  
           // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
           // if we are using RLC/SM we don't care of anything above RLC
           if (rlcTypeId != LteRlcSm::GetTypeId ())
             {
-              Ptr<LtePdcp> pdcp = CreateObject<LtePdcp> ();
+              Ptr<McUePdcp> pdcp = CreateObject<McUePdcp> (); 
               pdcp->SetRnti (m_rnti);
               pdcp->SetLcId (dtamIt->logicalChannelIdentity);
               pdcp->SetLtePdcpSapUser (m_drbPdcpSapUser);
@@ -1402,6 +2024,13 @@
             }
 
           m_bid2DrbidMap[dtamIt->epsBearerIdentity] = dtamIt->drbIdentity;
+
+          struct LteRrcSap::LogicalChannelConfig lcConfigToStore;
+          lcConfigToStore.priority = dtamIt->logicalChannelConfig.priority;
+          lcConfigToStore.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+          lcConfigToStore.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+          lcConfigToStore.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+          drbInfo->m_logicalChannelConfig = lcConfigToStore;
   
           m_drbMap.insert (std::pair<uint8_t, Ptr<LteDataRadioBearerInfo> > (dtamIt->drbIdentity, drbInfo));
   
@@ -1410,21 +2039,193 @@
           lcConfig.priority = dtamIt->logicalChannelConfig.priority;
           lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
           lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
-          lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;      
+          lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
 
-          for (uint32_t i = 0; i < m_numberOfComponentCarriers; i++)
-          {
-            m_cmacSapProvider.at (i)->AddLc (dtamIt->logicalChannelIdentity,
+          // TODO check which for interRatHoCapable
+          m_cmacSapProvider->AddLc (dtamIt->logicalChannelIdentity,
                                     lcConfig,
                                     rlc->GetLteMacSapUser ());
-          }
           rlc->Initialize ();
         }
       else
         {
           NS_LOG_INFO ("request to modify existing DRBID");
           Ptr<LteDataRadioBearerInfo> drbInfo = drbMapIt->second;
-          /// \todo currently not implemented. Would need to modify drbInfo, and then propagate changes to the MAC
+          NS_LOG_INFO ("Is MC " << dtamIt->is_mc);
+          if(dtamIt->is_mc == true) // we need to setup the RLC for MmWave communications
+          {
+            Ptr<McUePdcp> pdcp = DynamicCast<McUePdcp> (drbInfo->m_pdcp);
+            if(pdcp !=0)
+            {
+              // create Rlc
+              TypeId rlcTypeId;
+              if (m_useRlcSm)
+                {
+                  rlcTypeId = LteRlcSm::GetTypeId ();
+                  NS_LOG_INFO("SM");
+                }
+              else
+                {
+                  switch (dtamIt->rlcConfig.choice)
+                    {
+                    case LteRrcSap::RlcConfig::AM: 
+                      rlcTypeId = LteRlcAm::GetTypeId ();
+                      NS_LOG_INFO("AM");
+                      break;
+              
+                    case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL: 
+                      rlcTypeId = LteRlcUm::GetTypeId ();
+                      NS_LOG_INFO("UM");
+                      break;
+              
+                    default:
+                      NS_FATAL_ERROR ("unsupported RLC configuration");
+                      break;                
+                    }
+                }
+      
+              ObjectFactory rlcObjectFactory;
+              rlcObjectFactory.SetTypeId (rlcTypeId);
+              Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+              rlc->SetLteMacSapProvider (m_mmWaveMacSapProvider); 
+              rlc->SetRnti (m_mmWaveRnti);
+              rlc->SetLcId (dtamIt->logicalChannelIdentity);
+
+              struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+              lcConfig.priority = dtamIt->logicalChannelConfig.priority;
+              lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+              lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+              lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;      
+
+
+              m_mmWaveCmacSapProvider->AddLc (dtamIt->logicalChannelIdentity, 
+                                      lcConfig,
+                                      rlc->GetLteMacSapUser ());
+              if (rlcTypeId != LteRlcSm::GetTypeId ())
+              {
+                pdcp->SetMmWaveRnti (m_mmWaveRnti);
+                pdcp->SetMmWaveRlcSapProvider (rlc->GetLteRlcSapProvider ());
+                rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+              } 
+              rlc->Initialize();
+
+              Ptr<RlcBearerInfo> rlcInfo = CreateObject<RlcBearerInfo>();
+              rlcInfo->m_rlc = rlc;
+              rlcInfo->rlcConfig.choice = dtamIt->rlcConfig.choice;
+              rlcInfo->logicalChannelIdentity = dtamIt->logicalChannelIdentity;
+              rlcInfo->mmWaveRnti = m_mmWaveRnti;
+
+              LteRrcSap::LogicalChannelConfig logicalChannelConfig;
+              logicalChannelConfig.priority = dtamIt->logicalChannelConfig.priority;
+              logicalChannelConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+              logicalChannelConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+              logicalChannelConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;  
+
+              rlcInfo->logicalChannelConfig = logicalChannelConfig;
+
+              // switch to the mmWave RLC
+              bool useMmWaveConnection = true;
+              pdcp->SwitchConnection(useMmWaveConnection);
+              NS_LOG_INFO("LteUeRrc SwitchToMmWave and create new rlc " << m_imsi << m_mmWaveCellId << m_mmWaveRnti << " at time " << Simulator::Now().GetSeconds());
+              m_switchToMmWaveTrace(m_imsi, m_mmWaveCellId, m_mmWaveRnti);
+
+              // check if this rlc is already in the map
+              if(m_rlcMap.find(dtamIt->drbIdentity) != m_rlcMap.end())
+              {
+                // get the RLC buffer content and store it in this RLC
+                CopyRlcBuffers(m_rlcMap.find(dtamIt->drbIdentity)->second->m_rlc, drbInfo->m_pdcp, drbInfo->m_logicalChannelIdentity);
+              } 
+              m_rlcMap[dtamIt->drbIdentity] = rlcInfo;
+            }
+            else
+            {
+              NS_FATAL_ERROR("MC setup on a non MC-capable bearer");
+            }
+
+          }
+          else
+          {
+            NS_LOG_INFO ("Modify Data Radio Bearer : not implemented");
+            // TypeId rlcTypeId;
+            // if (m_useRlcSm)
+            //   {
+            //     rlcTypeId = LteRlcSm::GetTypeId ();
+            //   }
+            // else
+            //   {
+            //     switch (dtamIt->rlcConfig.choice)
+            //       {
+            //       case LteRrcSap::RlcConfig::AM: 
+            //         rlcTypeId = LteRlcAm::GetTypeId ();
+            //         break;
+            
+            //       case LteRrcSap::RlcConfig::UM_BI_DIRECTIONAL: 
+            //         rlcTypeId = LteRlcUm::GetTypeId ();
+            //         break;
+            
+            //       default:
+            //         NS_FATAL_ERROR ("unsupported RLC configuration");
+            //         break;                
+            //       }
+            //   }
+
+            // ObjectFactory rlcObjectFactory;
+            // rlcObjectFactory.SetTypeId (rlcTypeId);
+            // Ptr<LteRlc> rlc = rlcObjectFactory.Create ()->GetObject<LteRlc> ();
+            // rlc->SetLteMacSapProvider (m_macSapProvider);
+            // rlc->SetRnti (m_rnti);
+            // rlc->SetLcId (dtamIt->logicalChannelIdentity);
+
+            // Ptr<LteDataRadioBearerInfo> drbInfo = CreateObject<LteDataRadioBearerInfo> ();
+            // drbInfo->m_rlc = rlc;
+            // drbInfo->m_epsBearerIdentity = dtamIt->epsBearerIdentity;
+            // drbInfo->m_logicalChannelIdentity = dtamIt->logicalChannelIdentity;
+            // drbInfo->m_drbIdentity = dtamIt->drbIdentity;
+            // drbInfo->m_rlcConfig.choice = dtamIt->rlcConfig.choice;
+   
+            // // we need PDCP only for real RLC, i.e., RLC/UM or RLC/AM
+            // // if we are using RLC/SM we don't care of anything above RLC
+            // if (rlcTypeId != LteRlcSm::GetTypeId ())
+            //   {
+            //     Ptr<LtePdcp> pdcp = CreateObject<LtePdcp> (); 
+            //     pdcp->SetRnti (m_rnti);
+            //     pdcp->SetLcId (dtamIt->logicalChannelIdentity);
+            //     pdcp->SetLtePdcpSapUser (m_drbPdcpSapUser);
+            //     pdcp->SetLteRlcSapProvider (rlc->GetLteRlcSapProvider ());
+            //     rlc->SetLteRlcSapUser (pdcp->GetLteRlcSapUser ());
+            //     drbInfo->m_pdcp = pdcp;
+            //   }
+
+            // m_bid2DrbidMap[dtamIt->epsBearerIdentity] = dtamIt->drbIdentity;
+
+            // struct LteRrcSap::LogicalChannelConfig lcConfigToStore;
+            // lcConfigToStore.priority = dtamIt->logicalChannelConfig.priority;
+            // lcConfigToStore.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+            // lcConfigToStore.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+            // lcConfigToStore.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+            // drbInfo->m_logicalChannelConfig = lcConfigToStore;    
+
+            // struct LteUeCmacSapProvider::LogicalChannelConfig lcConfig;
+            // lcConfig.priority = dtamIt->logicalChannelConfig.priority;
+            // lcConfig.prioritizedBitRateKbps = dtamIt->logicalChannelConfig.prioritizedBitRateKbps;
+            // lcConfig.bucketSizeDurationMs = dtamIt->logicalChannelConfig.bucketSizeDurationMs;
+            // lcConfig.logicalChannelGroup = dtamIt->logicalChannelConfig.logicalChannelGroup;
+
+            // rlc->Initialize ();    
+
+            // // check if an RLC for this drbid is already in the map
+            // if(m_drbMap.find(dtamIt->drbIdentity) != m_drbMap.end())
+            // {
+            //   // get the RLC buffer content and store it in this RLC
+            //   CopyRlcBuffers(m_drbMap.find(dtamIt->drbIdentity)->second->m_rlc, drbInfo->m_pdcp, drbInfo->m_logicalChannelIdentity);
+            // } 
+            // m_drbMap[dtamIt->drbIdentity] = drbInfo;
+
+            // m_cmacSapProvider->AddLc (dtamIt->logicalChannelIdentity,
+            //                           lcConfig,
+            //                           rlc->GetLteMacSapUser ());
+
+          }
         }
     }
   
@@ -1440,10 +2241,7 @@
       m_drbMap.erase (it);      
       m_bid2DrbidMap.erase (drbid);
       //Remove LCID
-      for (uint32_t i = 0; i < m_numberOfComponentCarriers; i++)
-       {
-         m_cmacSapProvider.at (i)->RemoveLc (drbid + 2);
-       }
+      m_cmacSapProvider->RemoveLc (drbid + 2);
     }
 }
 
@@ -2754,20 +3552,27 @@
   LteRrcSap::MeasResults& measResults = measurementReport.measResults;
   measResults.measId = measId;
 
-  std::map<uint16_t, MeasValues>::iterator servingMeasIt = m_storedMeasValues.find (m_cellId);
-  NS_ASSERT (servingMeasIt != m_storedMeasValues.end ());
-  measResults.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (servingMeasIt->second.rsrp);
-  measResults.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (servingMeasIt->second.rsrq);
-  NS_LOG_INFO (this << " reporting serving cell "
-               "RSRP " << (uint32_t) measResults.rsrpResult << " (" << servingMeasIt->second.rsrp << " dBm) "
-               "RSRQ " << (uint32_t) measResults.rsrqResult << " (" << servingMeasIt->second.rsrq << " dB)");
-  measResults.haveMeasResultNeighCells = false;
-  std::map<uint8_t, VarMeasReport>::iterator measReportIt = m_varMeasReportList.find (measId);
-  if (measReportIt == m_varMeasReportList.end ())
+  bool cellHasMeasures = true; // measurements are available only for LTE cells
+  if(m_isMmWaveCellMap.find(m_cellId) != m_isMmWaveCellMap.end())
+  {
+    cellHasMeasures = !m_isMmWaveCellMap.find(m_cellId)->second;
+  }
+  if(cellHasMeasures)
+  {
+    std::map<uint16_t, MeasValues>::iterator servingMeasIt = m_storedMeasValues.find (m_cellId);
+    NS_ASSERT (servingMeasIt != m_storedMeasValues.end ());
+    measResults.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (servingMeasIt->second.rsrp);
+    measResults.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (servingMeasIt->second.rsrq);
+    NS_LOG_INFO (this << " reporting serving cell "
+                 "RSRP " << (uint32_t) measResults.rsrpResult << " (" << servingMeasIt->second.rsrp << " dBm) "
+                 "RSRQ " << (uint32_t) measResults.rsrqResult << " (" << servingMeasIt->second.rsrq << " dB)");
+    measResults.haveMeasResultNeighCells = false;
+    std::map<uint8_t, VarMeasReport>::iterator measReportIt = m_varMeasReportList.find (measId);
+    if (measReportIt == m_varMeasReportList.end ())
     {
       NS_LOG_ERROR ("no entry found in m_varMeasReportList for measId " << (uint32_t) measId);
     }
-  else
+    else
     {
       if (!(measReportIt->second.cellsTriggeredList.empty ()))
         {
@@ -2827,28 +3632,6 @@
           NS_LOG_WARN (this << " cellsTriggeredList is empty");
         }
 
-      measResults.haveScellsMeas = false;
-      std::map<uint16_t, MeasValues>::iterator sCellsMeasIt =  m_storedScellMeasValues.begin ();
-      if (sCellsMeasIt != m_storedScellMeasValues.end ())
-        {
-          measResults.haveScellsMeas = true;
-          measResults.measScellResultList.haveMeasurementResultsServingSCells = true;
-          measResults.measScellResultList.haveMeasurementResultsNeighCell = false;
-
-
-          for ( sCellsMeasIt = m_storedScellMeasValues.begin (); 
-                sCellsMeasIt != m_storedScellMeasValues.end (); ++sCellsMeasIt)
-            {
-              LteRrcSap::MeasResultScell measResultScell;
-              measResultScell.servFreqId = sCellsMeasIt->first;
-              measResultScell.haveRsrpResult =  true;
-              measResultScell.haveRsrqResult =  true;
-              measResultScell.rsrpResult = EutranMeasurementMapping::Dbm2RsrpRange (sCellsMeasIt->second.rsrp);
-              measResultScell.rsrqResult = EutranMeasurementMapping::Db2RsrqRange (sCellsMeasIt->second.rsrq); 
-              measResults.measScellResultList.measResultScell.push_back (measResultScell);
-            }
-        }
-
       /*
        * The current LteRrcSap implementation is broken in that it does not
        * allow for infinite values of reportAmount, which is probably the most
@@ -2913,6 +3696,7 @@
       // send the measurement report to eNodeB
       m_rrcSapUser->SendMeasurementReport (measurementReport);
     } 
+  }
 }
 
 void 
@@ -2923,7 +3707,7 @@
   NS_ASSERT (m_hasReceivedSib2);
   m_connectionPending = false; // reset the flag
   SwitchToState (IDLE_RANDOM_ACCESS);
-  m_cmacSapProvider.at (0)->StartContentionBasedRandomAccessProcedure ();
+  m_cmacSapProvider->StartContentionBasedRandomAccessProcedure ();
 }
 
 void 
@@ -2931,11 +3715,11 @@
 {
   NS_LOG_FUNCTION (this << m_imsi);
   m_asSapUser->NotifyConnectionReleased ();
-  m_cmacSapProvider.at (0)->RemoveLc (1);
+  m_cmacSapProvider->RemoveLc (1);
   std::map<uint8_t, Ptr<LteDataRadioBearerInfo> >::iterator it;
   for (it = m_drbMap.begin (); it != m_drbMap.end (); ++it)
     {
-      m_cmacSapProvider.at (0)->RemoveLc (it->second->m_logicalChannelIdentity);
+      m_cmacSapProvider->RemoveLc (it->second->m_logicalChannelIdentity);
     }
   m_drbMap.clear ();
   m_bid2DrbidMap.clear ();
@@ -2947,7 +3731,7 @@
 LteUeRrc::ConnectionTimeout ()
 {
   NS_LOG_FUNCTION (this << m_imsi);
-  m_cmacSapProvider.at (0)->Reset ();       // reset the MAC
+  m_cmacSapProvider->Reset ();       // reset the MAC
   m_hasReceivedSib2 = false;         // invalidate the previously received SIB2
   SwitchToState (IDLE_CAMPED_NORMALLY);
   m_connectionTimeoutTrace (m_imsi, m_cellId, m_rnti);
@@ -2982,7 +3766,7 @@
   NS_LOG_FUNCTION (this << ToString (newState));
   State oldState = m_state;
   m_state = newState;
-  NS_LOG_INFO (this << " IMSI " << m_imsi << " RNTI " << m_rnti << " UeRrc "
+  NS_LOG_INFO (this << " IMSI " << m_imsi << " RNTI " << m_rnti << " CellId " << m_cellId << " UeRrc "
                     << ToString (oldState) << " --> " << ToString (newState));
   m_stateTransitionTrace (m_imsi, m_cellId, m_rnti, oldState, newState);
 
@@ -3026,73 +3810,7 @@
     }
 }
 
-void
-LteUeRrc::DoComponentCarrierEnabling (std::vector<uint8_t> res)
-  {
-    NS_LOG_INFO (this);
-  }
-
-void
-LteUeRrc::SaveScellUeMeasurements (uint16_t sCellId, double rsrp, double rsrq,
-                                   bool useLayer3Filtering, uint16_t componentCarrierId)
-{
-  NS_LOG_FUNCTION (this << sCellId << componentCarrierId << rsrp << rsrq << useLayer3Filtering);
-  if (sCellId == m_cellId)
-    {
-
-      std::map<uint16_t, MeasValues>::iterator storedMeasIt = m_storedScellMeasValues.find (componentCarrierId);
-
-      if (storedMeasIt != m_storedScellMeasValues.end ())
-        {
-          if (useLayer3Filtering)
-            {
-              // F_n = (1-a) F_{n-1} + a M_n
-              storedMeasIt->second.rsrp = (1 - m_varMeasConfig.aRsrp) * storedMeasIt->second.rsrp
-                + m_varMeasConfig.aRsrp * rsrp;
-
-              if (std::isnan (storedMeasIt->second.rsrq))
-                {
-                  // the previous RSRQ measurements provided UE PHY are invalid
-                  storedMeasIt->second.rsrq = rsrq;   // replace it with unfiltered value
-                }
-              else
-                {
-                  storedMeasIt->second.rsrq = (1 - m_varMeasConfig.aRsrq) * storedMeasIt->second.rsrq
-                    + m_varMeasConfig.aRsrq * rsrq;
-                }
-            }
-          else
-            {
-              storedMeasIt->second.rsrp = rsrp;
-              storedMeasIt->second.rsrq = rsrq;
-            }
-        }
-      else
-        {
-          // first value is always unfiltered
-          MeasValues v;
-          v.rsrp = rsrp;
-          v.rsrq = rsrq;
-          std::pair<uint16_t, MeasValues> val (componentCarrierId, v);
-          std::pair<std::map<uint16_t, MeasValues>::iterator, bool>
-            ret = m_storedScellMeasValues.insert (val);
-          NS_ASSERT_MSG (ret.second == true, "element already existed");
-          storedMeasIt = ret.first;
-        }
-
-      NS_LOG_DEBUG (this << " IMSI " << m_imsi << " state " << ToString (m_state)
-                    << ", measured cell " << sCellId
-                    << ", carrier component Id " << componentCarrierId
-                    << ", new RSRP " << rsrp << " stored " << storedMeasIt->second.rsrp
-                    << ", new RSRQ " << rsrq << " stored " << storedMeasIt->second.rsrq);
-      storedMeasIt->second.timestamp = Simulator::Now ();
-    }
-  else 
-    {
-      NS_LOG_DEBUG (this << " IMSI " << m_imsi << "measurement on SCC from not serving cell ");
-    }
 
-}   // end of void SaveUeMeasurements
 
 
 } // namespace ns3
diff -Naru a/model/lte-ue-rrc.h b/model/lte-ue-rrc.h
--- a/model/lte-ue-rrc.h	2017-10-05 11:46:52.218493988 +0200
+++ b/model/lte-ue-rrc.h	2017-10-05 11:47:22.314601784 +0200
@@ -1,6 +1,7 @@
 /* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
 /*
  * Copyright (c) 2011 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -17,9 +18,9 @@
  *
  * Author: Nicola Baldo <nbaldo@cttc.es>
  *         Budiarto Herman <budiarto.herman@magister.fi>
- * Modified by:
- *          Danilo Abrignani <danilo.abrignani@unibo.it> (Carrier Aggregation - GSoC 2015)
- *          Biljana Bojovic <biljana.bojovic@cttc.es> (Carrier Aggregation)
+ *
+ * Modified by: Michele Polese <michele.polese@gmail.com>
+ *          Dual Connectivity functionalities
  */
 
 #ifndef LTE_UE_RRC_H
@@ -33,15 +34,12 @@
 #include <ns3/lte-ue-cphy-sap.h>
 #include <ns3/lte-rrc-sap.h>
 #include <ns3/traced-callback.h>
-#include "ns3/component-carrier-ue.h"
-#include <ns3/lte-ue-ccm-rrc-sap.h>
-#include <vector>
-
+#include <ns3/lte-radio-bearer-info.h>
 #include <map>
 #include <set>
-
-#define MIN_NO_CC 1
-#define MAX_NO_CC 5 // this is the maximum number of carrier components allowed by 3GPP up to R13
+#include <ns3/lte-rlc.h>
+#include <ns3/lte-pdcp.h>
+#include <ns3/lte-rlc-am.h>
 
 namespace ns3 {
 
@@ -79,20 +77,12 @@
 class LteUeRrc : public Object
 {
 
-  /// allow UeMemberLteUeCmacSapUser class friend access
   friend class UeMemberLteUeCmacSapUser;
-  /// allow UeRrcMemberLteEnbCmacSapUser class friend access
   friend class UeRrcMemberLteEnbCmacSapUser;
-  /// allow LtePdcpSpecificLtePdcpSapUser<LteUeRrc> class friend access
   friend class LtePdcpSpecificLtePdcpSapUser<LteUeRrc>;
-  /// allow MemberLteAsSapProvider<LteUeRrc> class friend access
   friend class MemberLteAsSapProvider<LteUeRrc>;
-  /// allow MemberLteUeCphySapUser<LteUeRrc> class friend access
   friend class MemberLteUeCphySapUser<LteUeRrc>;
-  /// allow MemberLteUeRrcSapProvider<LteUeRrc> class friend access
   friend class MemberLteUeRrcSapProvider<LteUeRrc>;
-  /// allow MemberLteUeCcmRrcSapUser<LteUeRrc> class friend access
-  friend class MemberLteUeCcmRrcSapUser<LteUeRrc>;
 
 public:
 
@@ -137,14 +127,8 @@
   virtual void DoInitialize (void);
   virtual void DoDispose (void);
 public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
-  /// Initiaize SAP
-  void InitializeSap (void);
 
   /**
    * set the CPHY SAP this RRC should use to interact with the PHY
@@ -152,52 +136,29 @@
    * \param s the CPHY SAP Provider
    */
   void SetLteUeCphySapProvider (LteUeCphySapProvider * s);
-  /**
-   * set the CPHY SAP this RRC should use to interact with the PHY
-   *
-   * \param s the CPHY SAP Provider
-   * \param index the index
-   */
-  void SetLteUeCphySapProvider (LteUeCphySapProvider * s, uint8_t index);
-
+  void SetMmWaveUeCphySapProvider (LteUeCphySapProvider * s);
+  
   /**
    *
    *
    * \return s the CPHY SAP User interface offered to the PHY by this RRC
    */
   LteUeCphySapUser* GetLteUeCphySapUser ();
-  /**
-   *
-   * \param index the index
-   * \return s the CPHY SAP User interface offered to the PHY by this RRC
-   */
-  LteUeCphySapUser* GetLteUeCphySapUser (uint8_t index);
 
   /**
    * set the CMAC SAP this RRC should interact with
-   * \brief This function is overloaded to maintain backward compatibility 
+   *
    * \param s the CMAC SAP Provider to be used by this RRC
    */
   void SetLteUeCmacSapProvider (LteUeCmacSapProvider * s);
-  /**
-   * set the CMAC SAP this RRC should interact with
-   * \brief This function is overloaded to maintain backward compatibility 
-   * \param s the CMAC SAP Provider to be used by this RRC
-   * \param index the index
-   */
-  void SetLteUeCmacSapProvider (LteUeCmacSapProvider * s, uint8_t index);
+  void SetMmWaveUeCmacSapProvider (LteUeCmacSapProvider * s);
 
   /**
-   * \brief This function is overloaded to maintain backward compatibility 
+   *
+   *
    * \return s the CMAC SAP User interface offered to the MAC by this RRC
    */
   LteUeCmacSapUser* GetLteUeCmacSapUser ();
-  /**
-   * \brief This function is overloaded to maintain backward compatibility
-   * \param index the index  
-   * \return s the CMAC SAP User interface offered to the MAC by this RRC
-   */
-  LteUeCmacSapUser* GetLteUeCmacSapUser (uint8_t index);
 
 
   /**
@@ -222,6 +183,7 @@
    * newly created RLC instances
    */
   void SetLteMacSapProvider (LteMacSapProvider* s);
+  void SetMmWaveMacSapProvider (LteMacSapProvider* s);
 
   /** 
    * Set the AS SAP user to interact with the NAS entity
@@ -237,20 +199,6 @@
    */
   LteAsSapProvider* GetAsSapProvider ();
 
-  /**
-   * set the Component Carrier Management SAP this RRC should interact with
-   *
-   * \param s the Component Carrier Management SAP Provider to be used by this RRC
-   */
-  void SetLteCcmRrcSapProvider (LteUeCcmRrcSapProvider * s);
-
-  /**
-   * Get the Component Carrier Management SAP offered by this RRC
-   * \return s the Component Carrier Management SAP User interface offered to the
-   *           carrier component selection algorithm by this RRC
-   */
-  LteUeCcmRrcSapUser* GetLteCcmRrcSapUser ();
-
   /** 
    * 
    * \param imsi the unique UE identifier
@@ -269,6 +217,19 @@
    */
   uint16_t GetRnti () const;
 
+
+  /**
+   * add an entry to the m_isMmWaveCellMap, respectively
+   * set to 1 or 0
+   */
+  void AddMmWaveCellId (uint16_t cellId);
+  void AddLteCellId (uint16_t cellId);
+
+  /**
+   * Switch lower layers' providers when connecting to a certain CellId
+   */ 
+  bool SwitchLowerLayerProviders (uint16_t cellId);
+
   /**
    *
    * \return the CellId of the attached Enb
@@ -288,12 +249,12 @@
   /**
    * \return the downlink carrier frequency (EARFCN)
    */
-  uint32_t GetDlEarfcn () const;
+  uint16_t GetDlEarfcn () const;
 
   /** 
    * \return the uplink carrier frequency (EARFCN)
    */
-  uint32_t GetUlEarfcn () const;
+  uint16_t GetUlEarfcn () const;
 
   /**
    *
@@ -308,6 +269,7 @@
    */
   void SetUseRlcSm (bool val);
 
+
   /**
    * TracedCallback signature for imsi, cellId and rnti events.
    *
@@ -357,129 +319,53 @@
 
 
   // PDCP SAP methods
-  /**
-   * Receive PDCP SDU function
-   *
-   * \param params LtePdcpSapUser::ReceivePdcpSduParameters
-   */
   void DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params);
 
   // CMAC SAP methods
-  /**
-   * Set temporary cell rnti function
-   *
-   * \param rnti RNTI
-   */
   void DoSetTemporaryCellRnti (uint16_t rnti);
-  /// Notify random access successful function
   void DoNotifyRandomAccessSuccessful ();
-  /// Notify random access failed function
   void DoNotifyRandomAccessFailed ();
  
   // LTE AS SAP methods
-  /**
-   * Set CSG white list function
-   *
-   * \param csgId CSG ID
-   */
   void DoSetCsgWhiteList (uint32_t csgId);
-  /**
-   * Force camped on ENB function
-   *
-   * \param cellId the cell ID
-   * \param dlEarfcn the DL EARFCN
-   */
-  void DoForceCampedOnEnb (uint16_t cellId, uint32_t dlEarfcn);
-  /**
-   * Start cell selection function
-   *
-   * \param dlEarfcn the DL EARFCN
-   */
-  void DoStartCellSelection (uint32_t dlEarfcn);
-  /// Connect function
+  void DoForceCampedOnEnb (uint16_t cellId, uint16_t dlEarfcn);
+  void DoStartCellSelection (uint16_t dlEarfcn);
   void DoConnect ();
-  /**
-   * Send data function
-   *
-   * \param packet the packet
-   * \param bid the BID
-   */
   void DoSendData (Ptr<Packet> packet, uint8_t bid);
-  /// Disconnect function
   void DoDisconnect ();
+  void DoNotifySecondaryCellConnected (uint16_t mmWaveRnti, uint16_t mmWaveCellId);
+  void DoNotifySecondaryCellHandover (uint16_t oldRnti, uint16_t newRnti, uint16_t mmWaveCellId, LteRrcSap::RadioResourceConfigDedicated rrcd);
 
   // CPHY SAP methods
-  /**
-   * Receive master information block function
-   *
-   * \param cellId the cell ID
-   * \param msg LteRrcSap::MasterInformationBlock
-   */
   void DoRecvMasterInformationBlock (uint16_t cellId,
                                      LteRrcSap::MasterInformationBlock msg);
-  /**
-   * Receive system information block type 1 function
-   *
-   * \param cellId the cell ID
-   * \param msg LteRrcSap::SystemInformationBlockType1
-   */
   void DoRecvSystemInformationBlockType1 (uint16_t cellId,
                                           LteRrcSap::SystemInformationBlockType1 msg);
-  /**
-   * Report UE measurements function
-   *
-   * \param params LteUeCphySapUser::UeMeasurementsParameters
-   */
   void DoReportUeMeasurements (LteUeCphySapUser::UeMeasurementsParameters params);
+  void DoNotifyRadioLinkFailure (double lastSinrValue);
 
   // RRC SAP methods
 
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::CompleteSetup interface.
-   * \param params the LteUeRrcSapProvider::CompleteSetupParameters
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::CompleteSetup interface.
   void DoCompleteSetup (LteUeRrcSapProvider::CompleteSetupParameters params);
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvSystemInformation interface.
-   * \param msg the LteRrcSap::SystemInformation
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvSystemInformation interface.
   void DoRecvSystemInformation (LteRrcSap::SystemInformation msg);
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionSetup interface.
-   * \param msg the LteRrcSap::RrcConnectionSetup
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionSetup interface.
   void DoRecvRrcConnectionSetup (LteRrcSap::RrcConnectionSetup msg);
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReconfiguration interface.
-   * \param msg the LteRrcSap::RrcConnectionReconfiguration
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReconfiguration interface.
   void DoRecvRrcConnectionReconfiguration (LteRrcSap::RrcConnectionReconfiguration msg);
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReestablishment interface.
-   * \param msg LteRrcSap::RrcConnectionReestablishment
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReestablishment interface.
   void DoRecvRrcConnectionReestablishment (LteRrcSap::RrcConnectionReestablishment msg);
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReestablishmentReject interface.
-   * \param msg LteRrcSap::RrcConnectionReestablishmentReject
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReestablishmentReject interface.
   void DoRecvRrcConnectionReestablishmentReject (LteRrcSap::RrcConnectionReestablishmentReject msg);
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionRelease interface.
-   * \param msg LteRrcSap::RrcConnectionRelease
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionRelease interface.
   void DoRecvRrcConnectionRelease (LteRrcSap::RrcConnectionRelease msg);
-  /**
-   * Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReject interface.
-   * \param msg the LteRrcSap::RrcConnectionReject
-   */
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectionReject interface.
   void DoRecvRrcConnectionReject (LteRrcSap::RrcConnectionReject msg);
-
-  /**
-   * RRC CCM SAP USER Method
-   * \param res
-   */
-  void DoComponentCarrierEnabling (std::vector<uint8_t> res);
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider::RecvRrcConnectToMmWave interface.
+  void DoRecvRrcConnectToMmWave (uint16_t mmWaveCellId);
+  /// Part of the RRC protocol. Implement the LteUeRrcSapProvider:;RecvRrcConnectionSwitch interface.
+  void DoRecvRrcConnectionSwitch (LteRrcSap::RrcConnectionSwitch msg);
 
  
   // INTERNAL METHODS
@@ -593,24 +479,6 @@
                            bool useLayer3Filtering);
 
   /**
-   * \brief keep the given measurement result as the latest measurement figures,
-   *        to be utilised by UE RRC functions.
-   * \param cellId the cell ID of the measured cell
-   * \param rsrp measured RSRP value to be saved (in dBm)
-   * \param rsrq measured RSRQ value to be saved (in dB)
-   * \param useLayer3Filtering
-   * \param componentCarrierId
-   * \todo Remove the useLayer3Filtering argument
-   *
-   * As for SaveUeMeasurements, this function aims to store the latest measurements
-   * related to the secondary component carriers.
-   * in the current implementation it saves only measurements related on the serving 
-   * secondary carriers while, measurements related to the Neighbor Cell are filtered
-   */
-
-  void SaveScellUeMeasurements (uint16_t cellId, double rsrp, double rsrq,
-                                bool useLayer3Filtering, uint16_t componentCarrierId);
-  /**
    * \brief Evaluate the reporting criteria of a measurement identity and
    *        invoke some reporting actions based on the result.
    * \param measId the measurement identity to be evaluated
@@ -669,27 +537,10 @@
    */
   void SendMeasurementReport (uint8_t measId);
 
-  /**
-   * Apply radio resoure config dedicated.
-   * \param rrcd LteRrcSap::RadioResourceConfigDedicated
-   */
   void ApplyRadioResourceConfigDedicated (LteRrcSap::RadioResourceConfigDedicated rrcd);
-  /**
-   * Apply radio resoure config dedicated secondary carrier.
-   * \param nonCec LteRrcSap::NonCriticalExtensionConfiguration
-   */
-  void ApplyRadioResourceConfigDedicatedSecondaryCarrier (LteRrcSap::NonCriticalExtensionConfiguration nonCec);
-  /// Start connetion function
   void StartConnection ();
-  /// Leave connected mode
   void LeaveConnectedMode ();
-  /// Dispose old SRB1
   void DisposeOldSrb1 ();
-  /**
-   * Bid 2 DR bid.
-   * \param bid the BID
-   * \returns the DR bid
-   */
   uint8_t Bid2Drbid (uint8_t bid);
   /**
    * Switch the UE RRC to the given state.
@@ -697,28 +548,43 @@
    */
   void SwitchToState (State s);
 
-  std::map<uint8_t, uint8_t> m_bid2DrbidMap; ///< bid to DR bid map
-
-  std::vector<LteUeCphySapUser*> m_cphySapUser; ///< UE CPhy SAP user
-  std::vector<LteUeCphySapProvider*> m_cphySapProvider; ///< UE CPhy SAP provider
-
-  std::vector<LteUeCmacSapUser*> m_cmacSapUser; ///< UE CMac SAP user
-  std::vector<LteUeCmacSapProvider*> m_cmacSapProvider; ///< UE CMac SAP provider
-
-  LteUeRrcSapUser* m_rrcSapUser; ///< RRC SAP user
-  LteUeRrcSapProvider* m_rrcSapProvider; ///< RRC SAP provider
-
-  LteMacSapProvider* m_macSapProvider; ///< MAC SAP provider
-  LtePdcpSapUser* m_drbPdcpSapUser; ///< DRB PDCP SAP user
-
-  LteAsSapProvider* m_asSapProvider; ///< AS SAP provider
-  LteAsSapUser* m_asSapUser; ///< AS SAP user
+  /**
+   * Transfer the content of the buffers of RLC back into the PDCP, so
+   * that if a new RLC is available then the buffer content is not lost
+   * @params rlc the old RLC layer instance
+   * @params pdcp the PDCP instance connected to the new RLC instance
+   * @params lcid
+   */
+  void CopyRlcBuffers(Ptr<LteRlc> rlc, Ptr<LtePdcp> pdcp, uint16_t lcid);
+  //Lossless HO: merge 2 buffers into 1 with increment order.
+  std::vector < LteRlcAm::RetxPdu > MergeBuffers(std::vector < LteRlcAm::RetxPdu > first, std::vector < LteRlcAm::RetxPdu > second);
+
+
+  std::map<uint8_t, uint8_t> m_bid2DrbidMap;
+
+  LteUeCphySapUser* m_cphySapUser;
+  LteUeCphySapProvider* m_cphySapProvider;
+  // CphyProviders for InterRat handover between MmWave and LTE
+  LteUeCphySapProvider* m_lteCphySapProvider;
+  LteUeCphySapProvider* m_mmWaveCphySapProvider;
+
+  LteUeCmacSapUser* m_cmacSapUser;
+  LteUeCmacSapProvider* m_cmacSapProvider;
+  // CmacProviders for InterRat handover between MmWave and LTE
+  LteUeCmacSapProvider* m_lteCmacSapProvider;
+  LteUeCmacSapProvider* m_mmWaveCmacSapProvider;
+
+  LteUeRrcSapUser* m_rrcSapUser;
+  LteUeRrcSapProvider* m_rrcSapProvider;
+
+  LteMacSapProvider* m_macSapProvider;
+  // MacProviders for InterRat handover between MmWave and LTE
+  LteMacSapProvider* m_lteMacSapProvider;
+  LteMacSapProvider* m_mmWaveMacSapProvider;
+  LtePdcpSapUser* m_drbPdcpSapUser;
 
-  // Receive API calls from the LteUeComponentCarrierManager  instance.
-  // LteCcmRrcSapUser* m_ccmRrcSapUser;
-  /// Interface to the LteUeComponentCarrierManage instance.
-  LteUeCcmRrcSapProvider* m_ccmRrcSapProvider; ///< CCM RRC SAP provider
-  LteUeCcmRrcSapUser* m_ccmRrcSapUser; ///< CCM RRC SAP user
+  LteAsSapProvider* m_asSapProvider;
+  LteAsSapUser* m_asSapUser;
 
   /// The current UE RRC state.
   State m_state;
@@ -729,6 +595,7 @@
    * The `C-RNTI` attribute. Cell Radio Network Temporary Identifier.
    */
   uint16_t m_rnti;
+  uint16_t m_mmWaveRnti;
   /**
    * The `CellId` attribute. Serving cell identifier.
    */
@@ -752,6 +619,7 @@
    * Radio Bearers by LCID.
    */
   std::map <uint8_t, Ptr<LteDataRadioBearerInfo> > m_drbMap;
+  std::map <uint8_t, Ptr<RlcBearerInfo> > m_rlcMap;
 
   /**
    * True if RLC SM is to be used, false if RLC UM/AM are to be used.
@@ -759,15 +627,15 @@
    */
   bool m_useRlcSm;
 
-  uint8_t m_lastRrcTransactionIdentifier; ///< last RRC transaction identifier
+  uint8_t m_lastRrcTransactionIdentifier;
 
-  LteRrcSap::PdschConfigDedicated m_pdschConfigDedicated; ///< the PDSCH condig dedicated
+  LteRrcSap::PdschConfigDedicated m_pdschConfigDedicated;
 
   uint8_t m_dlBandwidth; /**< Downlink bandwidth in RBs. */
   uint8_t m_ulBandwidth; /**< Uplink bandwidth in RBs. */
 
-  uint32_t m_dlEarfcn;  /**< Downlink carrier frequency. */
-  uint32_t m_ulEarfcn;  /**< Uplink carrier frequency. */
+  uint16_t m_dlEarfcn;  /**< Downlink carrier frequency. */
+  uint16_t m_ulEarfcn;  /**< Uplink carrier frequency. */
 
   /**
    * The `MibReceived` trace source. Fired upon reception of Master Information
@@ -843,6 +711,19 @@
    */
   TracedCallback<uint64_t, uint16_t, uint16_t> m_handoverEndErrorTrace;
 
+  /**
+   * The `SwitchToLte` trace source. Fired upon receiving a command to 
+   * switch to LTE RAT. Exporting IMSI, cellId, RNTI.
+   */
+  TracedCallback<uint64_t, uint16_t, uint16_t> m_switchToLteTrace;
+
+  /**
+   * The `SwitchToMmWave` trace source. Fired upon receiving a command to 
+   * switch to MmWave RAT. Exporting IMSI, cellId, RNTI.
+   */
+  TracedCallback<uint64_t, uint16_t, uint16_t> m_switchToMmWaveTrace;
+
+
   /// True if a connection request by upper layers is pending.
   bool m_connectionPending;
   /// True if MIB was received for the current cell.
@@ -873,12 +754,12 @@
    */
   struct VarMeasConfig
   {
-    std::map<uint8_t, LteRrcSap::MeasIdToAddMod> measIdList; ///< measure ID list
-    std::map<uint8_t, LteRrcSap::MeasObjectToAddMod> measObjectList; ///< measure object list
-    std::map<uint8_t, LteRrcSap::ReportConfigToAddMod> reportConfigList; ///< report config list
-    LteRrcSap::QuantityConfig quantityConfig; ///< quantity config
-    double aRsrp; ///< RSRP
-    double aRsrq; ///< RSRQ
+    std::map<uint8_t, LteRrcSap::MeasIdToAddMod> measIdList;
+    std::map<uint8_t, LteRrcSap::MeasObjectToAddMod> measObjectList;
+    std::map<uint8_t, LteRrcSap::ReportConfigToAddMod> reportConfigList;
+    LteRrcSap::QuantityConfig quantityConfig; 
+    double aRsrp;
+    double aRsrq;
   };
 
   /**
@@ -898,10 +779,10 @@
    */
   struct VarMeasReport
   {
-    uint8_t measId; ///< measure ID
-    std::set<uint16_t> cellsTriggeredList; ///< note: only E-UTRA is supported.
-    uint32_t numberOfReportsSent; ///< number of reports sent
-    EventId periodicReportTimer; ///< periodic report timer
+    uint8_t measId;
+    std::set<uint16_t> cellsTriggeredList; // note: only E-UTRA is supported.
+    uint32_t numberOfReportsSent;
+    EventId periodicReportTimer;
   };
 
   /**
@@ -995,29 +876,6 @@
   std::map<uint16_t, MeasValues> m_storedMeasValues;
 
   /**
-   * \brief Stored measure values per carrier.
-   */
-  std::map<uint16_t, std::map <uint8_t, MeasValues> > m_storedMeasValuesPerCarrier;
-
-  /**
-   * \brief Internal storage of the latest measurement results from all detected
-   *        detected Secondary carrier component, indexed by the carrier component ID 
-   *        where the measurement was taken from.
-   *
-   * Each *measurement result* comprises of RSRP (in dBm) and RSRQ (in dB).
-   *
-   * In IDLE mode, the measurement results are used by the *initial cell
-   * selection* procedure. While in CONNECTED mode, *layer-3 filtering* is
-   * applied to the measurement results and they are used by *UE measurements*
-   * function:
-   * - LteUeRrc::MeasurementReportTriggering: in this case it is not set any
-   *   measurment related to seconday carrier components since the 
-   *   A6 event is not implemented
-   * - LteUeRrc::SendMeasurementReport: in this case the report are sent.
-   */
-  std::map<uint16_t, MeasValues> m_storedScellMeasValues;
-
-  /**
    * \brief Represents a single triggered event from a measurement identity
    *        which reporting criteria have been fulfilled, but delayed by
    *        time-to-trigger.
@@ -1150,12 +1008,17 @@
    *        connection establishment procedure has failed.
    */
   void ConnectionTimeout ();
+  bool m_isSecondaryRRC;
+  uint16_t m_mmWaveCellId;
 
-public:
-  /** 
-   * The number of component carriers.
-   */
-  uint16_t m_numberOfComponentCarriers;
+  std::map<uint16_t, bool> m_isMmWaveCellMap;
+  bool m_interRatHoCapable;
+  LteRrcSap::RachConfigDedicated m_rachConfigDedicated;
+  bool m_ncRaStarted;
+
+  // lossless HO
+  std::vector < Ptr<Packet> > m_rlcBufferToBeForwarded;
+  uint32_t m_rlcBufferToBeForwardedSize;
 
 }; // end of class LteUeRrc
 
diff -Naru a/model/mc-enb-pdcp.cc b/model/mc-enb-pdcp.cc
--- a/model/mc-enb-pdcp.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-enb-pdcp.cc	2017-10-05 11:47:22.314601784 +0200
@@ -0,0 +1,315 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+
+#include "ns3/mc-enb-pdcp.h"
+#include "ns3/lte-pdcp-header.h"
+#include "ns3/lte-pdcp-sap.h"
+#include "ns3/lte-pdcp-tag.h"
+#include "ns3/epc-x2-sap.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("McEnbPdcp");
+
+class McPdcpSpecificLteRlcSapUser : public LteRlcSapUser
+{
+public:
+  McPdcpSpecificLteRlcSapUser (McEnbPdcp* pdcp);
+
+  // Interface provided to lower RLC entity (implemented from LteRlcSapUser)
+  virtual void ReceivePdcpPdu (Ptr<Packet> p);
+
+private:
+  McPdcpSpecificLteRlcSapUser ();
+  McEnbPdcp* m_pdcp;
+};
+
+McPdcpSpecificLteRlcSapUser::McPdcpSpecificLteRlcSapUser (McEnbPdcp* pdcp)
+  : m_pdcp (pdcp)
+{
+}
+
+McPdcpSpecificLteRlcSapUser::McPdcpSpecificLteRlcSapUser ()
+{
+}
+
+void
+McPdcpSpecificLteRlcSapUser::ReceivePdcpPdu (Ptr<Packet> p)
+{
+  m_pdcp->DoReceivePdu (p);
+}
+
+///////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (McEnbPdcp);
+
+McEnbPdcp::McEnbPdcp ()
+  : m_pdcpSapUser (0),
+    m_rlcSapProvider (0),
+    m_rnti (0),
+    m_lcid (0),
+    m_epcX2PdcpProvider (0),
+    m_txSequenceNumber (0),
+    m_rxSequenceNumber (0),
+    m_useMmWaveConnection (false)
+{
+  NS_LOG_FUNCTION (this);
+  m_pdcpSapProvider = new LtePdcpSpecificLtePdcpSapProvider<McEnbPdcp> (this);
+  m_rlcSapUser = new McPdcpSpecificLteRlcSapUser (this);
+  m_epcX2PdcpUser = new EpcX2PdcpSpecificUser<McEnbPdcp> (this);
+}
+
+McEnbPdcp::~McEnbPdcp ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+McEnbPdcp::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::McEnbPdcp")
+    .SetParent<Object> ()
+    .AddTraceSource ("TxPDU",
+                     "PDU transmission notified to the RLC.",
+                     MakeTraceSourceAccessor (&McEnbPdcp::m_txPdu),
+                     "ns3::McEnbPdcp::PduTxTracedCallback")
+    .AddTraceSource ("RxPDU",
+                     "PDU received.",
+                     MakeTraceSourceAccessor (&McEnbPdcp::m_rxPdu),
+                     "ns3::McEnbPdcp::PduRxTracedCallback")
+    ;
+  return tid;
+}
+
+void
+McEnbPdcp::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  delete (m_pdcpSapProvider);
+  delete (m_rlcSapUser);
+  delete (m_epcX2PdcpUser);
+}
+
+void
+McEnbPdcp::SetEpcX2PdcpProvider (EpcX2PdcpProvider * s)
+{
+  NS_LOG_FUNCTION(this);
+  m_epcX2PdcpProvider = s;
+}
+
+  
+EpcX2PdcpUser* 
+McEnbPdcp::GetEpcX2PdcpUser ()
+{
+  NS_LOG_FUNCTION(this);
+  return m_epcX2PdcpUser;
+}
+
+void
+McEnbPdcp::SetMmWaveRnti (uint16_t rnti)
+{
+  m_mmWaveRnti = rnti;
+}
+
+void
+McEnbPdcp::SetRnti (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) rnti);
+  m_rnti = rnti;
+}
+
+void
+McEnbPdcp::SetLcId (uint8_t lcId)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) lcId);
+  m_lcid = lcId;
+}
+
+void
+McEnbPdcp::SetLtePdcpSapUser (LtePdcpSapUser * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_pdcpSapUser = s;
+}
+
+LtePdcpSapProvider*
+McEnbPdcp::GetLtePdcpSapProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_pdcpSapProvider;
+}
+
+void
+McEnbPdcp::SetLteRlcSapProvider (LteRlcSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  NS_LOG_INFO("Change LteRlcSapProvider");
+  m_rlcSapProvider = s;
+}
+
+LteRlcSapUser*
+McEnbPdcp::GetLteRlcSapUser ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_rlcSapUser;
+}
+
+McEnbPdcp::Status 
+McEnbPdcp::GetStatus ()
+{
+  Status s;
+  s.txSn = m_txSequenceNumber;
+  s.rxSn = m_rxSequenceNumber;
+  return s;
+}
+
+void 
+McEnbPdcp::SetStatus (Status s)
+{
+  m_txSequenceNumber = s.txSn;
+  m_rxSequenceNumber = s.rxSn;
+}
+
+void 
+McEnbPdcp::SetUeDataParams(EpcX2Sap::UeDataParams params)
+{
+  m_ueDataParams = params;
+}
+
+
+////////////////////////////////////////
+
+void
+McEnbPdcp::DoTransmitPdcpSdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  LtePdcpHeader pdcpHeader;
+  pdcpHeader.SetSequenceNumber (m_txSequenceNumber);
+
+  m_txSequenceNumber++;
+  if (m_txSequenceNumber > m_maxPdcpSn)
+    {
+      m_txSequenceNumber = 0;
+    }
+
+  pdcpHeader.SetDcBit (LtePdcpHeader::DATA_PDU);
+
+  NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+  p->AddHeader (pdcpHeader);
+
+  LteRlcSapProvider::TransmitPdcpPduParameters params;
+  params.rnti = m_rnti;
+  params.lcid = m_lcid;
+
+  if(m_epcX2PdcpProvider == 0 || (!m_useMmWaveConnection)) 
+  {
+    NS_LOG_INFO(this << " McEnbPdcp: Tx packet to downlink local stack");
+
+    // Sender timestamp. We will use this to measure the delay on top of RLC
+    PdcpTag pdcpTag (Simulator::Now ());
+    p->AddByteTag (pdcpTag);
+    // m_txPdu (m_rnti, m_lcid, p->GetSize ());
+    params.pdcpPdu = p;
+
+    NS_LOG_LOGIC("Params.rnti " << params.rnti);
+    NS_LOG_LOGIC("Params.m_lcid " << params.lcid);
+    NS_LOG_LOGIC("Params.pdcpPdu " << params.pdcpPdu);
+
+    m_rlcSapProvider->TransmitPdcpPdu (params);
+  } 
+  else if (m_useMmWaveConnection) 
+  {
+    // Do not add sender time stamp: we are not interested in adding X2 delay for MC connections
+    NS_LOG_INFO(this << " McEnbPdcp: Tx packet to downlink MmWave stack on remote cell " << m_ueDataParams.targetCellId);
+    m_ueDataParams.ueData = p;
+    m_epcX2PdcpProvider->SendMcPdcpPdu (m_ueDataParams);
+  } 
+  else 
+  {
+    NS_FATAL_ERROR("Invalid combination");
+  }
+}
+
+void
+McEnbPdcp::DoReceivePdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  NS_LOG_INFO(this << " McEnbPdcp received uplink Pdu");
+  // Receiver timestamp
+  PdcpTag pdcpTag;
+  Time delay;
+  if (p->FindFirstMatchingByteTag (pdcpTag))
+    {
+      delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+    }
+  m_rxPdu(m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
+
+  p->RemoveAllByteTags();
+  NS_LOG_LOGIC("ALL BYTE TAGS REMOVED. NetAmin and FlowMonitor won't work");
+  
+  LtePdcpHeader pdcpHeader;
+  p->RemoveHeader (pdcpHeader);
+  NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+
+  m_rxSequenceNumber = pdcpHeader.GetSequenceNumber () + 1;
+  if (m_rxSequenceNumber > m_maxPdcpSn)
+    {
+      m_rxSequenceNumber = 0;
+    }
+  if(p->GetSize() > 20 + 8 + 12)
+  {
+    LtePdcpSapUser::ReceivePdcpSduParameters params;
+    params.pdcpSdu = p;
+    params.rnti = m_rnti;
+    params.lcid = m_lcid;
+    m_pdcpSapUser->ReceivePdcpSdu (params);
+  }
+}
+
+void
+McEnbPdcp::DoReceiveMcPdcpPdu (EpcX2Sap::UeDataParams params)
+{
+  NS_LOG_FUNCTION(this << m_mmWaveRnti << (uint32_t) m_lcid);
+  DoReceivePdu(params.ueData);
+}
+
+void
+McEnbPdcp::SwitchConnection (bool useMmWaveConnection)
+{
+  m_useMmWaveConnection = useMmWaveConnection;
+}
+
+bool
+McEnbPdcp::GetUseMmWaveConnection() const
+{
+  return m_useMmWaveConnection && (m_epcX2PdcpProvider != 0);
+}
+
+
+
+} // namespace ns3
diff -Naru a/model/mc-enb-pdcp.h b/model/mc-enb-pdcp.h
--- a/model/mc-enb-pdcp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-enb-pdcp.h	2017-10-05 11:47:22.314601784 +0200
@@ -0,0 +1,243 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef MC_ENB_PDCP_H
+#define MC_ENB_PDCP_H
+
+#include "ns3/traced-value.h"
+#include "ns3/trace-source-accessor.h"
+
+#include "ns3/object.h"
+
+#include <ns3/epc-x2-sap.h>
+#include <ns3/epc-x2.h>
+#include <ns3/lte-pdcp-sap.h>
+#include <ns3/lte-rlc-sap.h>
+#include <ns3/lte-pdcp.h>
+
+namespace ns3 {
+
+/**
+ * MC eNB PDCP entity. It has 2 interfaces to the 2 RLC layers,
+ * the local and the remote one. The interface to the local is a
+ * Rlc Sap, while the interface to the remote is offered by the 
+ * EpcX2Sap.
+ * Note: there is a single IMSI and lcid (no problem in having the same
+ * in the 2 eNBs), but 2 rnti.
+ */
+class McEnbPdcp : public LtePdcp 
+{
+  friend class McPdcpSpecificLteRlcSapUser;
+  friend class LtePdcpSpecificLtePdcpSapProvider<McEnbPdcp>;
+  friend class EpcX2PdcpSpecificProvider <EpcX2>;
+  friend class EpcX2PdcpSpecificUser <McEnbPdcp>;
+public:
+  McEnbPdcp ();
+  virtual ~McEnbPdcp ();
+  static TypeId GetTypeId (void);
+  virtual void DoDispose ();
+
+  /**
+   * Set the RNTI of the UE in the MmWave eNB
+   *
+   * \param rnti
+   */
+  void SetMmWaveRnti (uint16_t rnti);
+
+  /**
+   * Set the RNTI of the UE in the LTE eNB
+   *
+   * \param rnti
+   */
+  void SetRnti (uint16_t rnti);
+
+  /**
+   * Set the ldid
+   *
+   * \param lcId
+   */
+  void SetLcId (uint8_t lcId);
+
+  /**
+   *
+   *
+   * \param s the EpcX2PDCP Provider to the Epc X2 interface
+   */
+  void SetEpcX2PdcpProvider (EpcX2PdcpProvider * s);
+
+  /**
+   *
+   *
+   * \return the EpcX2PDCP User, given to X2 to access PDCP Receive method
+   */
+  EpcX2PdcpUser* GetEpcX2PdcpUser ();
+
+  /**
+   *
+   *
+   * \param s the PDCP SAP user to be used by this LTE_PDCP
+   */
+  void SetLtePdcpSapUser (LtePdcpSapUser * s);
+
+  /**
+   *
+   *
+   * \return the PDCP SAP Provider interface offered to the RRC by this LTE_PDCP
+   */
+  LtePdcpSapProvider* GetLtePdcpSapProvider ();
+
+  /**
+   *
+   *
+   * \param s the RLC SAP Provider to be used by this LTE_PDCP
+   */
+  void SetLteRlcSapProvider (LteRlcSapProvider * s);
+
+  /**
+   *
+   *
+   * \return the RLC SAP User interface offered to the RLC by this LTE_PDCP
+   */
+  LteRlcSapUser* GetLteRlcSapUser ();
+
+  static const uint16_t MAX_PDCP_SN = 4096;
+
+  /**
+   * Status variables of the PDCP
+   * 
+   */
+  struct Status
+  {
+    uint16_t txSn; ///< TX sequence number
+    uint16_t rxSn; ///< RX sequence number
+  };
+
+  /** 
+   * 
+   * \return the current status of the PDCP
+   */
+  Status GetStatus ();
+
+  /**
+   * Set the status of the PDCP
+   * 
+   * \param s 
+   */
+  void SetStatus (Status s);
+
+  /**
+   * Set the param needed for X2 tunneling
+   * \param the UeDataParams defined in RRC
+   */
+  void SetUeDataParams(EpcX2Sap::UeDataParams params);
+
+  /**
+   * TracedCallback for PDU transmission event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   */
+  typedef void (* PduTxTracedCallback)
+    (uint16_t rnti, uint8_t lcid, uint32_t size);
+
+  /**
+   * TracedCallback signature for PDU receive event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   * \param [in] delay Delay since packet sent, in ns..
+   */
+  typedef void (* PduRxTracedCallback)
+    (const uint16_t rnti, const uint8_t lcid,
+     const uint32_t size, const uint64_t delay);
+
+  /**
+   * Switch between LTE and MmWave
+   */
+  void SwitchConnection(bool useMmWaveConnection);
+
+  /**
+   * Return true if this PDCP is configured to forward data to the mmWave eNB
+   */
+  bool GetUseMmWaveConnection() const;
+
+protected:
+  // Interface provided to upper RRC entity
+  virtual void DoTransmitPdcpSdu (Ptr<Packet> p);
+
+  LtePdcpSapUser* m_pdcpSapUser;
+  LtePdcpSapProvider* m_pdcpSapProvider;
+
+  // Interface provided to lower RLC entity
+  virtual void DoReceivePdu (Ptr<Packet> p);
+
+  LteRlcSapUser* m_rlcSapUser;
+  LteRlcSapProvider* m_rlcSapProvider;
+
+  uint16_t m_rnti;
+  uint8_t m_lcid;
+  uint16_t m_mmWaveRnti;
+
+  /**
+   * Used to inform of a PDU delivery to the RLC SAP provider.
+   * The parameters are RNTI, LCID and bytes delivered
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t> m_txPdu;
+  /**
+   * Used to inform of a PDU reception from the RLC SAP user.
+   * The parameters are RNTI, LCID, bytes delivered and delivery delay in nanoseconds. 
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t, uint64_t> m_rxPdu;
+
+  // Interface provided to EpcX2 entity
+  virtual void DoReceiveMcPdcpPdu(EpcX2Sap::UeDataParams params);
+
+  EpcX2PdcpProvider* m_epcX2PdcpProvider;
+  EpcX2PdcpUser* m_epcX2PdcpUser;
+
+private:
+  /**
+   * State variables. See section 7.1 in TS 36.323
+   */
+  uint16_t m_txSequenceNumber;
+  uint16_t m_rxSequenceNumber;
+
+  // UeDataParams needed to forward data to MmWave
+  EpcX2Sap::UeDataParams m_ueDataParams;
+
+  /**
+   * Constants. See section 7.2 in TS 36.323
+   */
+  static const uint16_t m_maxPdcpSn = 4095;
+
+  bool m_useMmWaveConnection;
+
+};
+
+
+} // namespace ns3
+
+#endif // MC_ENB_PDCP_H
diff -Naru a/model/mc-ue-pdcp.cc b/model/mc-ue-pdcp.cc
--- a/model/mc-ue-pdcp.cc	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-ue-pdcp.cc	2017-10-05 11:47:22.314601784 +0200
@@ -0,0 +1,297 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#include "ns3/log.h"
+#include "ns3/simulator.h"
+
+#include "ns3/mc-ue-pdcp.h"
+#include "ns3/lte-pdcp-header.h"
+#include "ns3/lte-pdcp-sap.h"
+#include "ns3/lte-pdcp-tag.h"
+#include "ns3/seq-ts-header.h"
+
+
+namespace ns3 {
+
+NS_LOG_COMPONENT_DEFINE ("McUePdcp");
+
+class McUePdcpSpecificLteRlcSapUser : public LteRlcSapUser
+{
+public:
+  McUePdcpSpecificLteRlcSapUser (McUePdcp* pdcp);
+
+  // Interface provided to lower RLC entity (implemented from LteRlcSapUser)
+  virtual void ReceivePdcpPdu (Ptr<Packet> p);
+
+private:
+  McUePdcpSpecificLteRlcSapUser ();
+  McUePdcp* m_pdcp;
+};
+
+McUePdcpSpecificLteRlcSapUser::McUePdcpSpecificLteRlcSapUser (McUePdcp* pdcp)
+  : m_pdcp (pdcp)
+{
+}
+
+McUePdcpSpecificLteRlcSapUser::McUePdcpSpecificLteRlcSapUser ()
+{
+}
+
+void
+McUePdcpSpecificLteRlcSapUser::ReceivePdcpPdu (Ptr<Packet> p)
+{
+  m_pdcp->DoReceivePdu (p);
+}
+
+///////////////////////////////////////
+
+NS_OBJECT_ENSURE_REGISTERED (McUePdcp);
+
+McUePdcp::McUePdcp ()
+  : m_pdcpSapUser (0),
+    m_rlcSapProvider (0),
+    m_rnti (0),
+    m_lcid (0),
+    m_txSequenceNumber (0),
+    m_rxSequenceNumber (0),
+    m_useMmWaveConnection (false)
+{
+  NS_LOG_FUNCTION (this);
+  m_pdcpSapProvider = new LtePdcpSpecificLtePdcpSapProvider<McUePdcp> (this);
+  m_rlcSapUser = new McUePdcpSpecificLteRlcSapUser (this);
+}
+
+McUePdcp::~McUePdcp ()
+{
+  NS_LOG_FUNCTION (this);
+}
+
+TypeId
+McUePdcp::GetTypeId (void)
+{
+  static TypeId tid = TypeId ("ns3::McUePdcp")
+    .SetParent<Object> ()
+    .SetGroupName("Lte")
+    .AddTraceSource ("TxPDU",
+                     "PDU transmission notified to the RLC.",
+                     MakeTraceSourceAccessor (&McUePdcp::m_txPdu),
+                     "ns3::McUePdcp::PduTxTracedCallback")
+    .AddTraceSource ("RxPDU",
+                     "PDU received.",
+                     MakeTraceSourceAccessor (&McUePdcp::m_rxPdu),
+                     "ns3::McUePdcp::PduRxTracedCallback")
+    .AddAttribute ("LteUplink",
+                    "Use LTE for uplink",
+                    BooleanValue (false),
+                    MakeBooleanAccessor (&McUePdcp::m_alwaysLteUplink),
+                    MakeBooleanChecker ())
+    ;
+  return tid;
+}
+
+void
+McUePdcp::DoDispose ()
+{
+  NS_LOG_FUNCTION (this);
+  delete (m_pdcpSapProvider);
+  delete (m_rlcSapUser);
+}
+
+
+void
+McUePdcp::SetRnti (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) rnti);
+  m_rnti = rnti;
+}
+
+void
+McUePdcp::SetMmWaveRnti (uint16_t rnti)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) rnti);
+  m_mmWaveRnti = rnti;
+}
+
+void
+McUePdcp::SetLcId (uint8_t lcId)
+{
+  NS_LOG_FUNCTION (this << (uint32_t) lcId);
+  m_lcid = lcId;
+}
+
+void
+McUePdcp::SetLtePdcpSapUser (LtePdcpSapUser * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_pdcpSapUser = s;
+}
+
+LtePdcpSapProvider*
+McUePdcp::GetLtePdcpSapProvider ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_pdcpSapProvider;
+}
+
+void
+McUePdcp::SetLteRlcSapProvider (LteRlcSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_rlcSapProvider = s;
+}
+
+void
+McUePdcp::SetMmWaveRlcSapProvider (LteRlcSapProvider * s)
+{
+  NS_LOG_FUNCTION (this << s);
+  m_mmWaveRlcSapProvider = s;
+}
+
+LteRlcSapUser*
+McUePdcp::GetLteRlcSapUser ()
+{
+  NS_LOG_FUNCTION (this);
+  return m_rlcSapUser;
+}
+
+McUePdcp::Status 
+McUePdcp::GetStatus ()
+{
+  Status s;
+  s.txSn = m_txSequenceNumber;
+  s.rxSn = m_rxSequenceNumber;
+  return s;
+}
+
+void 
+McUePdcp::SetStatus (Status s)
+{
+  m_txSequenceNumber = s.txSn;
+  m_rxSequenceNumber = s.rxSn;
+}
+
+////////////////////////////////////////
+
+void
+McUePdcp::DoTransmitPdcpSdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  LtePdcpHeader pdcpHeader;
+  pdcpHeader.SetSequenceNumber (m_txSequenceNumber);
+
+  m_txSequenceNumber++;
+  if (m_txSequenceNumber > m_maxPdcpSn)
+    {
+      m_txSequenceNumber = 0;
+    }
+
+  pdcpHeader.SetDcBit (LtePdcpHeader::DATA_PDU);
+
+  NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+  p->AddHeader (pdcpHeader);
+
+  // Sender timestamp
+  PdcpTag pdcpTag (Simulator::Now ());
+  p->AddByteTag (pdcpTag);
+  //m_txPdu (m_rnti, m_lcid, p->GetSize ());
+
+  LteRlcSapProvider::TransmitPdcpPduParameters params;
+  params.rnti = m_rnti;
+  params.lcid = m_lcid;
+  params.pdcpPdu = p;
+
+  // WARN TODO hack: always use LTE for uplink (i.e. TCP acks)
+  if(m_mmWaveRlcSapProvider == 0 || (!m_useMmWaveConnection) || m_alwaysLteUplink)
+  {
+    NS_LOG_INFO(this << " McUePdcp: Tx packet to uplink primary stack");
+    m_rlcSapProvider->TransmitPdcpPdu (params);
+  }
+  else if (m_useMmWaveConnection)
+  {
+    NS_LOG_INFO(this << " McUePdcp: Tx packet to uplink secondary stack");
+    m_mmWaveRlcSapProvider->TransmitPdcpPdu (params);
+  }
+  else
+  {
+    NS_FATAL_ERROR ("Invalid combination");
+  }
+}
+
+void
+McUePdcp::DoReceivePdu (Ptr<Packet> p)
+{
+  NS_LOG_FUNCTION (this << m_rnti << (uint32_t) m_lcid << p->GetSize ());
+
+  NS_LOG_INFO(this << " McUePdcp received dowlink Pdu");
+  // Receiver timestamp
+  PdcpTag pdcpTag;
+  Time delay;
+  if (p->FindFirstMatchingByteTag (pdcpTag))
+    {
+      delay = Simulator::Now() - pdcpTag.GetSenderTimestamp ();
+    }
+  m_rxPdu(m_rnti, m_lcid, p->GetSize (), delay.GetNanoSeconds ());
+
+  p->RemoveAllByteTags();
+  NS_LOG_LOGIC("ALL BYTE TAGS REMOVED. NetAmin and FlowMonitor won't work");
+
+  if(p->GetSize() > 3)
+  {
+    LtePdcpHeader pdcpHeader;
+    p->RemoveHeader (pdcpHeader);
+    NS_LOG_LOGIC ("PDCP header: " << pdcpHeader);
+
+    // SeqTsHeader seqTs;
+    // p->PeekHeader (seqTs);
+    // NS_LOG_UNCOND("Carrying UDP packet " << (uint32_t)seqTs.GetSeq());
+
+
+    m_rxSequenceNumber = pdcpHeader.GetSequenceNumber () + 1;
+    if (m_rxSequenceNumber > m_maxPdcpSn)
+      {
+        m_rxSequenceNumber = 0;
+      }
+
+    if(p->GetSize() > 20 + 8 + 12)
+    {
+      LtePdcpSapUser::ReceivePdcpSduParameters params;
+      params.pdcpSdu = p;
+      params.rnti = m_rnti;
+      params.lcid = m_lcid;
+      m_pdcpSapUser->ReceivePdcpSdu (params);
+    }
+  }
+  else
+  {
+    NS_LOG_INFO("Packet fragmented, too small!");
+  }
+}
+
+void
+McUePdcp::SwitchConnection (bool useMmWaveConnection)
+{
+  m_useMmWaveConnection = useMmWaveConnection;
+}
+
+
+} // namespace ns3
diff -Naru a/model/mc-ue-pdcp.h b/model/mc-ue-pdcp.h
--- a/model/mc-ue-pdcp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/model/mc-ue-pdcp.h	2017-10-05 11:47:22.314601784 +0200
@@ -0,0 +1,214 @@
+/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
+/*
+ * Copyright (c) 2011-2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
+ * Copyright (c) 2016, University of Padova, Dep. of Information Engineering, SIGNET lab. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Author of base class: Manuel Requena <manuel.requena@cttc.es>
+ * Extension to DC devices by Michele Polese <michele.polese@gmail.com>
+ */
+
+#ifndef MC_UE_PDCP_H
+#define MC_UE_PDCP_H
+
+#include "ns3/traced-value.h"
+#include "ns3/trace-source-accessor.h"
+
+#include "ns3/object.h"
+
+#include <ns3/lte-pdcp-sap.h>
+#include <ns3/lte-rlc-sap.h>
+#include <ns3/lte-pdcp.h>
+
+namespace ns3 {
+
+/**
+ * MC UE PDCP entity. It has 2 interfaces to the 2 RLC layers
+ * Note: there is a single IMSI and lcid (no problem in having the same
+ * in the 2 eNBs), but 2 rnti.
+ */
+class McUePdcp : public LtePdcp 
+{
+  friend class McUePdcpSpecificLteRlcSapUser;
+  friend class LtePdcpSpecificLtePdcpSapProvider<McUePdcp>;
+
+public:
+  McUePdcp ();
+  virtual ~McUePdcp ();
+  static TypeId GetTypeId (void);
+  virtual void DoDispose ();
+
+  /**
+   * Set the RNTI of the UE in the MmWave eNB
+   *
+   * \param rnti
+   */
+  void SetMmWaveRnti (uint16_t rnti);
+
+  /**
+   * Set the RNTI of the UE in the LTE eNB
+   *
+   * \param rnti
+   */
+  void SetRnti (uint16_t rnti);
+
+  /**
+   * Set the ldid
+   *
+   * \param lcId
+   */
+  void SetLcId (uint8_t lcId);
+
+  /**
+   *
+   *
+   * \param s the PDCP SAP user to be used by this MC_PDCP
+   */
+  void SetLtePdcpSapUser (LtePdcpSapUser * s);
+
+  /**
+   *
+   *
+   * \return the PDCP SAP Provider interface offered to the RRC by this MC_PDCP
+   */
+  LtePdcpSapProvider* GetLtePdcpSapProvider ();
+
+  /**
+   *
+   *
+   * \param s the Lte RLC SAP Provider to be used by this MC_PDCP
+   */
+  void SetLteRlcSapProvider (LteRlcSapProvider * s);
+
+  /**
+   *
+   *
+   * \return the RLC SAP User interface offered to the RLC by this MC_PDCP
+   */
+  LteRlcSapUser* GetLteRlcSapUser ();
+
+  /**
+   *
+   *
+   * \param s the MmWave RLC SAP Provider to be used by this MC_PDCP
+   */
+  void SetMmWaveRlcSapProvider (LteRlcSapProvider * s);
+
+  static const uint16_t MAX_PDCP_SN = 4096;
+
+  /**
+   * Status variables of the PDCP
+   * 
+   */
+  struct Status
+  {
+    uint16_t txSn; ///< TX sequence number
+    uint16_t rxSn; ///< RX sequence number
+  };
+
+  /** 
+   * 
+   * \return the current status of the PDCP
+   */
+  Status GetStatus ();
+
+  /**
+   * Set the status of the PDCP
+   * 
+   * \param s 
+   */
+  void SetStatus (Status s);
+
+  /**
+   * TracedCallback for PDU transmission event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   */
+  typedef void (* PduTxTracedCallback)
+    (uint16_t rnti, uint8_t lcid, uint32_t size);
+
+  /**
+   * TracedCallback signature for PDU receive event.
+   *
+   * \param [in] rnti The C-RNTI identifying the UE.
+   * \param [in] lcid The logical channel id corresponding to
+   *             the sending RLC instance.
+   * \param [in] size Packet size.
+   * \param [in] delay Delay since packet sent, in ns..
+   */
+  typedef void (* PduRxTracedCallback)
+    (const uint16_t rnti, const uint8_t lcid,
+     const uint32_t size, const uint64_t delay);
+
+  /**
+   * Switch between LTE and MmWave
+   */
+  void SwitchConnection(bool useMmWaveConnection);
+
+
+
+protected:
+  // Interface provided to upper RRC entity
+  virtual void DoTransmitPdcpSdu (Ptr<Packet> p);
+
+  LtePdcpSapUser* m_pdcpSapUser;
+  LtePdcpSapProvider* m_pdcpSapProvider;
+
+  // Interface provided to lower RLC entity
+  virtual void DoReceivePdu (Ptr<Packet> p);
+
+  LteRlcSapUser* m_rlcSapUser;
+  LteRlcSapProvider* m_rlcSapProvider;
+  LteRlcSapProvider* m_mmWaveRlcSapProvider;
+
+  uint16_t m_rnti;
+  uint8_t m_lcid;
+  uint16_t m_mmWaveRnti;
+
+  /**
+   * Used to inform of a PDU delivery to the RLC SAP provider.
+   * The parameters are RNTI, LCID and bytes delivered
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t> m_txPdu;
+  /**
+   * Used to inform of a PDU reception from the RLC SAP user.
+   * The parameters are RNTI, LCID, bytes delivered and delivery delay in nanoseconds. 
+   */
+  TracedCallback<uint16_t, uint8_t, uint32_t, uint64_t> m_rxPdu;
+
+private:
+  /**
+   * State variables. See section 7.1 in TS 36.323
+   */
+  uint16_t m_txSequenceNumber;
+  uint16_t m_rxSequenceNumber;
+
+  /**
+   * Constants. See section 7.2 in TS 36.323
+   */
+  static const uint16_t m_maxPdcpSn = 4095;
+
+  bool m_useMmWaveConnection;
+  bool m_alwaysLteUplink;
+
+};
+
+
+} // namespace ns3
+
+#endif // MC_UE_PDCP_H
diff -Naru a/model/no-op-component-carrier-manager.cc b/model/no-op-component-carrier-manager.cc
--- a/model/no-op-component-carrier-manager.cc	2017-10-05 11:46:52.218493988 +0200
+++ b/model/no-op-component-carrier-manager.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,518 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- * Copyright (c) 2016 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Authors: Danilo Abrignani <danilo.abrignani@unibo.it>
- *          Biljana Bojovic <biljana.bojovic@cttc.es>
- *
- */
-
-#include "no-op-component-carrier-manager.h"
-#include <ns3/log.h>
-#include <ns3/random-variable-stream.h>
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("NoOpComponentCarrierManager");
-NS_OBJECT_ENSURE_REGISTERED (NoOpComponentCarrierManager);
-  
-NoOpComponentCarrierManager::NoOpComponentCarrierManager ()
-{
-  NS_LOG_FUNCTION (this);
-  m_ccmRrcSapProvider = new MemberLteCcmRrcSapProvider<NoOpComponentCarrierManager> (this);
-  m_ccmMacSapUser = new MemberLteCcmMacSapUser<NoOpComponentCarrierManager> (this);
-  m_macSapProvider = new EnbMacMemberLteMacSapProvider <NoOpComponentCarrierManager> (this);
-  m_ccmRrcSapUser  = 0;
-}
-
-NoOpComponentCarrierManager::~NoOpComponentCarrierManager ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-void
-NoOpComponentCarrierManager::DoDispose ()
-{
-  NS_LOG_FUNCTION (this);
-  delete m_ccmRrcSapProvider;
-  delete m_ccmMacSapUser;
-  delete m_macSapProvider;
-}
-
-
-TypeId
-NoOpComponentCarrierManager::GetTypeId ()
-{
-  static TypeId tid = TypeId ("ns3::NoOpComponentCarrierManager")
-          .SetParent<LteEnbComponentCarrierManager> ()
-          .SetGroupName("Lte")
-          .AddConstructor<NoOpComponentCarrierManager> ()
-          ;
-  return tid;
-}
-
-
-void
-NoOpComponentCarrierManager::DoInitialize ()
-{
-  NS_LOG_FUNCTION (this);
-  LteEnbComponentCarrierManager::DoInitialize ();
-}
-
-//////////////////////////////////////////////
-// MAC SAP
-/////////////////////////////////////////////
-
-
-void
-NoOpComponentCarrierManager::DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params)
-{
-  NS_LOG_FUNCTION (this);
-  std::map <uint8_t, LteMacSapProvider*>::iterator it =  m_macSapProvidersMap.find (params.componentCarrierId);
-  NS_ASSERT_MSG (it != m_macSapProvidersMap.end (), "could not find Sap for ComponentCarrier " << params.componentCarrierId);
-  // with this algorithm all traffic is on Primary Carrier
-  it->second->TransmitPdu (params);
-}
-
-void
-NoOpComponentCarrierManager::DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params)
-{
-  NS_LOG_FUNCTION (this);
-  auto ueManager = m_ccmRrcSapUser->GetUeManager (params.rnti);
-  std::map <uint8_t, LteMacSapProvider*>::iterator it = m_macSapProvidersMap.find (ueManager->GetComponentCarrierId ());
-  NS_ASSERT_MSG (it != m_macSapProvidersMap.end (), "could not find Sap for ComponentCarrier ");
-  it->second->ReportBufferStatus (params);
-}
-
-void
-NoOpComponentCarrierManager::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
-{
-  NS_LOG_FUNCTION (this);
-  std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator rntiIt = m_ueAttached.find (rnti);
-  NS_ASSERT_MSG (rntiIt != m_ueAttached.end (), "could not find RNTI" << rnti);
-  std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = rntiIt->second.find (lcid);
-  NS_ASSERT_MSG (lcidIt != rntiIt->second.end (), "could not find LCID " << (uint16_t) lcid);
-  NS_LOG_DEBUG (this << " rnti= " << rnti << " lcid= " << (uint32_t) lcid << " layer= " << (uint32_t)layer<<" ccId="<< (uint32_t)componentCarrierId);
-  (*lcidIt).second->NotifyTxOpportunity (bytes, layer, harqId, componentCarrierId, rnti, lcid);
-
-}
-
-void
-NoOpComponentCarrierManager::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
-{
-  NS_LOG_FUNCTION (this);
-  std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator rntiIt = m_ueAttached.find (rnti);
-  NS_ASSERT_MSG (rntiIt != m_ueAttached.end (), "could not find RNTI" << rnti);
-  std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = rntiIt->second.find (lcid);
-  if (lcidIt != rntiIt->second.end ())
-    {
-      (*lcidIt).second->ReceivePdu (p, rnti, lcid);
-    }
-}
-
-void
-NoOpComponentCarrierManager::DoNotifyHarqDeliveryFailure ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-void
-NoOpComponentCarrierManager::DoReportUeMeas (uint16_t rnti,
-                                             LteRrcSap::MeasResults measResults)
-{
-  NS_LOG_FUNCTION (this << rnti << (uint16_t) measResults.measId);
-}
-
-void
-NoOpComponentCarrierManager::DoAddUe (uint16_t rnti, uint8_t state)
-{
-  NS_LOG_FUNCTION (this << rnti << (uint16_t) state);
-  std::map<uint16_t, uint8_t>::iterator stateIt;
-  std::map<uint16_t, uint8_t>::iterator eccIt; // m_enabledComponentCarrier iterator
-  stateIt = m_ueState.find (rnti);
-  if (stateIt == m_ueState.end ())
-    {
-      //      NS_ASSERT_MSG ((stateIt == m_ueState.end () && state == 3), " ERROR: Ue was not indexed and current state is CONNECTED_NORMALLY" << (uint16_t) state);
-      NS_LOG_DEBUG (this << " UE " << rnti << " was not found, now it is added in the map");
-      m_ueState.insert (std::pair<uint16_t, uint8_t> (rnti, state));
-      eccIt = m_enabledComponentCarrier.find (rnti);
-      //if ((state == 7 || state == 0) && eccIt == m_enabledComponentCarrier.end ())
-      if (eccIt == m_enabledComponentCarrier.end ())
-        {
-          // the Primary carrier (PC) is enabled by default
-          // on the PC the SRB0 and SRB1 are enabled when the Ue is connected
-          // these are hard-coded and the configuration not pass through the
-          // Component Carrier Manager which is responsible of configure
-          // only DataRadioBearer on the different Component Carrier
-          m_enabledComponentCarrier.insert (std::pair<uint16_t, uint8_t> (rnti, 1));
-        }
-      else
-        {
-          NS_FATAL_ERROR (this << " Ue " << rnti << " had Component Carrier enabled before join the network" << (uint16_t) state);
-        }
-      // preparing the rnti,lcid,LteMacSapUser map
-      std::map<uint8_t, LteMacSapUser*> empty;
-      std::pair <std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator, bool>
-      ret = m_ueAttached.insert (std::pair <uint16_t,  std::map<uint8_t, LteMacSapUser*> >
-      (rnti, empty));
-      NS_LOG_DEBUG (this << "AddUe: UE Pointer LteMacSapUser Map " << rnti << " added " << (uint16_t) ret.second);
-      NS_ASSERT_MSG (ret.second, "element already present, RNTI already existed");
-
-      //add new rnti in the map
-      std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> emptyA;
-      std::pair <std::map <uint16_t, std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> >::iterator, bool>
-      retA = m_rlcLcInstantiated.insert (std::pair <uint16_t,  std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> >
-      (rnti, emptyA));
-      NS_ASSERT_MSG (retA.second, "element already present, RNTI already existed");
-      NS_LOG_DEBUG (this << "AddUe: UE " << rnti << " added " << (uint16_t) retA.second);
-
-    }
-  else
-    {
-      NS_LOG_DEBUG (this << " UE " << rnti << "found, updating the state from " << (uint16_t) stateIt->second << " to " << (uint16_t) state);
-      stateIt->second = state;
-    }
-
-
-}
-
-void
-NoOpComponentCarrierManager::DoAddLc (LteEnbCmacSapProvider::LcInfo lcInfo, LteMacSapUser* msu)
-{
-  NS_LOG_FUNCTION (this);
-  NS_ASSERT_MSG( m_rlcLcInstantiated.find(lcInfo.rnti) != m_rlcLcInstantiated.end(), "Adding lc for a user that was not yet added to component carrier manager list.");
-  m_rlcLcInstantiated.find(lcInfo.rnti)->second.insert(std::pair <uint8_t, LteEnbCmacSapProvider::LcInfo> (lcInfo.lcId, lcInfo));
-}
-
-
-void
-NoOpComponentCarrierManager::DoRemoveUe (uint16_t rnti)
-{
-  NS_LOG_FUNCTION (this);
-  std::map<uint16_t, uint8_t>::iterator stateIt;
-  std::map<uint16_t, uint8_t>::iterator eccIt; // m_enabledComponentCarrier iterator
-  stateIt = m_ueState.find (rnti);
-  eccIt = m_enabledComponentCarrier.find (rnti);
-  NS_ASSERT_MSG (stateIt != m_ueState.end (), "request to remove UE info with unknown rnti ");
-  NS_ASSERT_MSG (eccIt != m_enabledComponentCarrier.end (), "request to remove UE info with unknown rnti ");
-
-}
-
-std::vector<LteCcmRrcSapProvider::LcsConfig>
-NoOpComponentCarrierManager::DoSetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, LteMacSapUser *msu)
-{
-  NS_LOG_FUNCTION (this << rnti);
-  std::map<uint16_t, uint8_t>::iterator eccIt; // m_enabledComponentCarrier iterator
-  eccIt = m_enabledComponentCarrier.find (rnti);
-  NS_ASSERT_MSG (eccIt != m_enabledComponentCarrier.end (), "SetupDataRadioBearer on unknown rnti ");
-
-  // enable by default all carriers
-  eccIt->second = m_noOfComponentCarriers;
-
-  std::vector<LteCcmRrcSapProvider::LcsConfig> res;
-  LteCcmRrcSapProvider::LcsConfig entry;
-  LteEnbCmacSapProvider::LcInfo lcinfo;
-  // NS_LOG_DEBUG (this << " componentCarrierEnabled " << (uint16_t) eccIt->second);
-  for (uint16_t ncc = 0; ncc < m_noOfComponentCarriers; ncc++)
-    {
-      // NS_LOG_DEBUG (this << " res size " << (uint16_t) res.size ());
-      LteEnbCmacSapProvider::LcInfo lci;
-      lci.rnti = rnti;
-      lci.lcId = lcid;
-      lci.lcGroup = lcGroup;
-      lci.qci = bearer.qci;
-      if (ncc == 0)
-        {
-          lci.isGbr = bearer.IsGbr ();
-          lci.mbrUl = bearer.gbrQosInfo.mbrUl;
-          lci.mbrDl = bearer.gbrQosInfo.mbrDl;
-          lci.gbrUl = bearer.gbrQosInfo.gbrUl;
-          lci.gbrDl = bearer.gbrQosInfo.gbrDl;
-        }
-      else
-        {
-          lci.isGbr = 0;
-          lci.mbrUl = 0;
-          lci.mbrDl = 0;
-          lci.gbrUl = 0;
-          lci.gbrDl = 0;
-        } // data flows only on PC
-      NS_LOG_DEBUG (this << " RNTI " << lci.rnti << "Lcid " << (uint16_t) lci.lcId << " lcGroup " << (uint16_t) lci.lcGroup);
-      entry.componentCarrierId = ncc;
-      entry.lc = lci;
-      entry.msu = m_ccmMacSapUser;
-      res.push_back (entry);
-    } // end for
-
-
-  // preparing the rnti,lcid,LcInfo map
-  std::map <uint16_t, std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> >::iterator rntiIter = m_rlcLcInstantiated.find (rnti);
-  rntiIter = m_rlcLcInstantiated.begin ();
-  // while (rntiIter != m_rlcLcInstantiated.end ())
-  //   {
-  //     ++rntiIter;
-  //   }
-  // if (rntiIt == m_rlcLcInstantiated.end ())
-  //   {
-  //     //add new rnti in the map
-  //     std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> empty;
-  //     std::pair <std::map <uint16_t, std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> >::iterator, bool>
-  //       ret = m_rlcLcInstantiated.insert (std::pair <uint16_t,  std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> >
-  //                                         (rnti, empty));
-  //     NS_LOG_DEBUG (this << " UE " << rnti << " added " << (uint16_t) ret.second);
-  //   }
-
-  std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator sapIt =  m_ueAttached.find (rnti);
-  NS_ASSERT_MSG (sapIt != m_ueAttached.end (), "RNTI not found");
-  rntiIter = m_rlcLcInstantiated.find (rnti);
-  std::map<uint8_t, LteEnbCmacSapProvider::LcInfo>::iterator lcidIt = rntiIter->second.find (lcid);
-  //std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = sapIt->second.find (lcinfo.lcId);
-  NS_ASSERT_MSG (rntiIter != m_rlcLcInstantiated.end (), "RNTI not found");
-  if (lcidIt == rntiIter->second.end ())
-    {
-      lcinfo.rnti = rnti;
-      lcinfo.lcId = lcid;
-      lcinfo.lcGroup = lcGroup;
-      lcinfo.qci = bearer.qci;
-      lcinfo.isGbr = bearer.IsGbr ();
-      lcinfo.mbrUl = bearer.gbrQosInfo.mbrUl;
-      lcinfo.mbrDl = bearer.gbrQosInfo.mbrDl;
-      lcinfo.gbrUl = bearer.gbrQosInfo.gbrUl;
-      lcinfo.gbrDl = bearer.gbrQosInfo.gbrDl;
-      rntiIter->second.insert (std::pair<uint8_t, LteEnbCmacSapProvider::LcInfo> (lcinfo.lcId, lcinfo));
-      sapIt->second.insert (std::pair<uint8_t, LteMacSapUser*> (lcinfo.lcId, msu));
-    }
-  else
-    {
-      NS_LOG_ERROR ("LC already exists");
-    }
-  return res;
-
-}
-
-std::vector<uint8_t>
-NoOpComponentCarrierManager::DoReleaseDataRadioBearer (uint16_t rnti, uint8_t lcid)
-{
-  NS_LOG_FUNCTION (this);
-  // here we receive directly the rnti and the lcid, instead of only drbid
-  // drbid are mapped as drbid = lcid + 2
-  std::map<uint16_t, uint8_t>::iterator eccIt; // m_enabledComponentCarrier iterator
-  eccIt= m_enabledComponentCarrier.find (rnti);
-  NS_ASSERT_MSG (eccIt != m_enabledComponentCarrier.end (), "request to Release Data Radio Bearer on Ue without Component Carrier Enabled");
-  std::map <uint16_t, std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> >::iterator lcsIt;
-  lcsIt = m_rlcLcInstantiated.find (rnti);
-  NS_ASSERT_MSG (lcsIt != m_rlcLcInstantiated.end (), "request to Release Data Radio Bearer on Ue without Logical Channels enabled");
-  std::map<uint8_t, LteEnbCmacSapProvider::LcInfo>::iterator lcIt;
-  NS_LOG_DEBUG (this << " remove lcid " << (uint16_t) lcid << " for rnti " << rnti);
-  lcIt = lcsIt->second.find (lcid);
-  NS_ASSERT_MSG (lcIt != lcsIt->second.end (), " Logical Channel not found");
-  std::vector<uint8_t> res;
-  for (uint16_t i = 0; i < eccIt->second; i++)
-    {
-      res.insert (res.end (), i);
-    }
-  //Find user based on rnti and then erase lcid stored against the same
-  std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator rntiIt = m_ueAttached.find (rnti);
-  rntiIt->second.erase (lcid);
-  std::map <uint16_t, std::map<uint8_t, LteEnbCmacSapProvider::LcInfo> >::iterator rlcInstancesIt = m_rlcLcInstantiated.find (rnti);
-  std::map<uint8_t, LteEnbCmacSapProvider::LcInfo>::iterator rclLcIt;
-  lcIt = rlcInstancesIt->second.find (lcid);
-  NS_ASSERT_MSG (lcIt != lcsIt->second.end (), " Erasing: Logical Channel not found");
-  lcsIt->second.erase (lcid);
-  return res;
-}
-
-LteMacSapUser*
-NoOpComponentCarrierManager::DoConfigureSignalBearer(LteEnbCmacSapProvider::LcInfo lcinfo,  LteMacSapUser* msu)
-{
-  NS_LOG_FUNCTION (this);
-  std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator itSapUserAtCcm;
-  itSapUserAtCcm = m_ueAttached.find (lcinfo.rnti);
-  NS_ASSERT_MSG (itSapUserAtCcm != m_ueAttached.end (), "request to Add a SignalBearer to unknown rnti");
-  std::map <uint16_t, std::map<uint8_t, LteMacSapUser*> >::iterator rntiIt = m_ueAttached.find (lcinfo.rnti);
-  NS_ASSERT_MSG (rntiIt != m_ueAttached.end (), "RNTI not found");
-  std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = rntiIt->second.find (lcinfo.lcId);
-  if (lcidIt == rntiIt->second.end ())
-    {
-      rntiIt->second.insert (std::pair<uint8_t, LteMacSapUser*> (lcinfo.lcId, msu));
-    }
-  else
-    {
-      NS_LOG_ERROR ("LC already exists");
-    }
-
-  return m_ccmMacSapUser;
-}
-
-void
-NoOpComponentCarrierManager::DoNotifyPrbOccupancy (double prbOccupancy, uint8_t componentCarrierId)
-{
-  NS_LOG_FUNCTION (this);
-  NS_LOG_DEBUG ("Update PRB occupancy:"<<prbOccupancy<<" at carrier:"<< (uint32_t) componentCarrierId);
-  m_ccPrbOccupancy.insert(std::pair<uint8_t, double> (componentCarrierId, prbOccupancy));
-}
-
-void
-NoOpComponentCarrierManager::DoUlReceiveMacCe (MacCeListElement_s bsr, uint8_t componentCarrierId)
-{
-  NS_LOG_FUNCTION (this);
-  NS_ASSERT_MSG (bsr.m_macCeType == MacCeListElement_s::BSR, "Received a Control Message not allowed " << bsr.m_macCeType);
-  if ( bsr.m_macCeType == MacCeListElement_s::BSR)
-    {
-      MacCeListElement_s newBsr;
-      newBsr.m_rnti = bsr.m_rnti;
-      newBsr.m_macCeType = bsr.m_macCeType;
-      newBsr.m_macCeValue.m_phr = bsr.m_macCeValue.m_phr;
-      newBsr.m_macCeValue.m_crnti = bsr.m_macCeValue.m_crnti;
-      newBsr.m_macCeValue.m_bufferStatus.resize (4);
-      for (uint16_t i = 0; i < 4; i++)
-        {
-          uint8_t bsrId = bsr.m_macCeValue.m_bufferStatus.at (i);
-          uint32_t buffer = BufferSizeLevelBsr::BsrId2BufferSize (bsrId);
-          // here the buffer should be divide among the different sap
-          // since the buffer status report are compressed information
-          // it is needed to use BsrId2BufferSize to uncompress
-          // after the split over all component carriers is is needed to
-          // compress again the information to fit MacCeListEkement_s structure
-          // verify how many Component Carrier are enabled per UE
-          // in this simple code the BufferStatus will be notify only
-          // to the primary carrier component
-          newBsr.m_macCeValue.m_bufferStatus.at (i) = BufferSizeLevelBsr::BufferSize2BsrId (buffer);
-        }
-      auto sapIt = m_ccmMacSapProviderMap.find (componentCarrierId);
-      if (sapIt == m_ccmMacSapProviderMap.end ())
-        {
-          NS_FATAL_ERROR ("Sap not found in the CcmMacSapProviderMap");
-        }
-      else
-        {
-          // in the current implementation bsr in uplink is forwarded only to the primary carrier.
-          // above code demonstrates how to resize buffer status if more carriers are being used in future
-          sapIt->second->ReportMacCeToScheduler (newBsr);
-        }
-    }
-  else
-    {
-      NS_FATAL_ERROR ("Expected BSR type of message.");
-    }
-}
-
-
-//////////////////////////////////////////
-
-NS_OBJECT_ENSURE_REGISTERED (RrComponentCarrierManager);
-
-RrComponentCarrierManager::RrComponentCarrierManager ()
-{
-  NS_LOG_FUNCTION (this);
-
-}
-
-RrComponentCarrierManager::~RrComponentCarrierManager ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-TypeId
-RrComponentCarrierManager::GetTypeId ()
-{
-  static TypeId tid = TypeId ("ns3::RrComponentCarrierManager")
-                .SetParent<NoOpComponentCarrierManager> ()
-                .SetGroupName("Lte")
-                .AddConstructor<RrComponentCarrierManager> ()
-                ;
-  return tid;
-}
-
-
-void
-RrComponentCarrierManager::DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params)
-{
-  NS_LOG_FUNCTION (this);
-
-  NS_ASSERT_MSG( m_enabledComponentCarrier.find(params.rnti)!=m_enabledComponentCarrier.end(), " UE with provided RNTI not found. RNTI:"<<params.rnti);
-
-  uint32_t numberOfCarriersForUe = m_enabledComponentCarrier.find (params.rnti)->second;
-  if (params.lcid == 0 || params.lcid == 1 || numberOfCarriersForUe == 1)
-    {
-      NS_LOG_INFO("Buffer status forwarded to the primary carrier.");
-      auto ueManager = m_ccmRrcSapUser->GetUeManager (params.rnti);
-      m_macSapProvidersMap.at (ueManager->GetComponentCarrierId ())->ReportBufferStatus (params);
-    }
-  else
-    {
-      params.retxQueueSize /= numberOfCarriersForUe;
-      params.txQueueSize /= numberOfCarriersForUe;
-      for ( uint16_t i = 0;  i < numberOfCarriersForUe ; i++)
-        {
-          NS_ASSERT_MSG (m_macSapProvidersMap.find(i)!=m_macSapProvidersMap.end(), "Mac sap provider does not exist.");
-          m_macSapProvidersMap.find(i)->second->ReportBufferStatus(params);
-        }
-    }
-}
-
-
-void
-RrComponentCarrierManager::DoUlReceiveMacCe (MacCeListElement_s bsr, uint8_t componentCarrierId)
-{
-  NS_LOG_FUNCTION (this);
-  NS_ASSERT_MSG (componentCarrierId == 0, "Received BSR from a ComponentCarrier not allowed, ComponentCarrierId = " << componentCarrierId);
-  NS_ASSERT_MSG (bsr.m_macCeType == MacCeListElement_s::BSR, "Received a Control Message not allowed " << bsr.m_macCeType);
-
-  // split traffic in uplink equally among carriers
-  uint32_t numberOfCarriersForUe = m_enabledComponentCarrier.find(bsr.m_rnti)->second;
-
-  if ( bsr.m_macCeType == MacCeListElement_s::BSR)
-    {
-      MacCeListElement_s newBsr;
-      newBsr.m_rnti = bsr.m_rnti;
-      // mac control element type, values can be BSR, PHR, CRNTI
-      newBsr.m_macCeType = bsr.m_macCeType;
-      // the power headroom, 64 means no valid phr is available
-      newBsr.m_macCeValue.m_phr = bsr.m_macCeValue.m_phr;
-      // indicates that the CRNTI MAC CE was received. The value is not used.
-      newBsr.m_macCeValue.m_crnti = bsr.m_macCeValue.m_crnti;
-      // and value 64 means that the buffer status should not be updated
-      newBsr.m_macCeValue.m_bufferStatus.resize (4);
-      // always all 4 LCGs are present see 6.1.3.1 of 3GPP TS 36.321.
-      for (uint16_t i = 0; i < 4; i++)
-        {
-          uint8_t bsrStatusId = bsr.m_macCeValue.m_bufferStatus.at (i);
-          uint32_t bufferSize = BufferSizeLevelBsr::BsrId2BufferSize (bsrStatusId);
-          // here the buffer should be divide among the different sap
-          // since the buffer status report are compressed information
-          // it is needed to use BsrId2BufferSize to uncompress
-          // after the split over all component carriers is is needed to
-          // compress again the information to fit MacCeListElement_s structure
-          // verify how many Component Carrier are enabled per UE
-          newBsr.m_macCeValue.m_bufferStatus.at(i) = BufferSizeLevelBsr::BufferSize2BsrId (bufferSize/numberOfCarriersForUe);
-        }
-      // notify MAC of each component carrier that is enabled for this UE
-      for ( uint16_t i = 0;  i < numberOfCarriersForUe ; i++)
-        {
-          NS_ASSERT_MSG (m_ccmMacSapProviderMap.find(i)!=m_ccmMacSapProviderMap.end(), "Mac sap provider does not exist.");
-          m_ccmMacSapProviderMap.find(i)->second->ReportMacCeToScheduler(newBsr);
-        }
-    }
-  else
-    {
-      auto ueManager = m_ccmRrcSapUser->GetUeManager (bsr.m_rnti);
-      m_ccmMacSapProviderMap.at (ueManager->GetComponentCarrierId ())->ReportMacCeToScheduler (bsr);
-    }
-}
-
-} // end of namespace ns3
diff -Naru a/model/no-op-component-carrier-manager.h b/model/no-op-component-carrier-manager.h
--- a/model/no-op-component-carrier-manager.h	2017-10-05 11:46:52.218493988 +0200
+++ b/model/no-op-component-carrier-manager.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,187 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- * Copyright (c) 2016 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Authors: Danilo Abrignani <danilo.abrignani@unibo.it>
- *          Biljana Bojovic <biljana.bojovic@cttc.es>
- */
-
-#ifndef NO_OP_COMPONENT_CARRIER_MANAGER_H
-#define NO_OP_COMPONENT_CARRIER_MANAGER_H
-
-#include <ns3/lte-enb-component-carrier-manager.h>
-#include <ns3/lte-ccm-rrc-sap.h>
-#include <ns3/lte-rrc-sap.h>
-#include <map>
-
-namespace ns3 {
-
-class UeManager;
-class LteCcmRrcSapProvider;
-
-/**
- * \brief The default component carrier manager that forwards all traffic, the uplink and the downlink,
- *  over the primary carrier, and will not use secondary carriers. To enable carrier aggregation
- *  feature, select another component carrier manager class, i.e., some of child classes of
- *  LteEnbComponentCarrierManager of NoOpComponentCarrierManager.
- */
-
-class NoOpComponentCarrierManager : public LteEnbComponentCarrierManager
-{
-  /// allow EnbMacMemberLteMacSapProvider<NoOpComponentCarrierManager> class friend access
-  friend class EnbMacMemberLteMacSapProvider<NoOpComponentCarrierManager>;
-  /// allow MemberLteCcmRrcSapProvider<NoOpComponentCarrierManager> class friend access
-  friend class MemberLteCcmRrcSapProvider<NoOpComponentCarrierManager>;
-  /// allow MemberLteCcmRrcSapUser<NoOpComponentCarrierManager> class friend access
-  friend class MemberLteCcmRrcSapUser<NoOpComponentCarrierManager>;
-  /// allow MemberLteCcmMacSapUser<NoOpComponentCarrierManager> class friend access
-  friend class MemberLteCcmMacSapUser<NoOpComponentCarrierManager>;
-
-public:
-
-  NoOpComponentCarrierManager ();
-  virtual ~NoOpComponentCarrierManager ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId ();
-
-protected:
-  // Inherited methods
-  virtual void DoInitialize ();
-  virtual void DoDispose ();
-  virtual void DoReportUeMeas (uint16_t rnti, LteRrcSap::MeasResults measResults);
-  /**
-   * \brief Add UE.
-   * \param rnti the RNTI
-   * \param state the state
-   */
-  virtual void DoAddUe (uint16_t rnti, uint8_t state);
-  /**
-   * \brief Add LC.
-   * \param lcInfo the LC info
-   * \param msu the MSU
-   */
-  virtual void DoAddLc (LteEnbCmacSapProvider::LcInfo lcInfo, LteMacSapUser* msu);
-  /**
-   * \brief Setup data radio bearer.
-   * \param bearer the radio bearer
-   * \param bearerId the bearerID
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   * \param lcGroup the LC group
-   * \param msu the MSU
-   * \returns std::vector<LteCcmRrcSapProvider::LcsConfig> 
-   */
-  virtual std::vector<LteCcmRrcSapProvider::LcsConfig> DoSetupDataRadioBearer (EpsBearer bearer, uint8_t bearerId, uint16_t rnti, uint8_t lcid, uint8_t lcGroup, LteMacSapUser* msu);
-  /**
-   * \brief Transmit PDU.
-   * \param params the transmit PDU parameters
-   */
-  virtual void DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params);
-  /**
-   * \brief Report buffer status.
-   * \param params the report buffer status parameters
-   */
-  virtual void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params);
-  /**
-   * \brief Notify transmit opportunity.
-   * \param bytes the number of bytes
-   * \param layer the layer
-   * \param harqId the HARQ ID
-   * \param componentCarrierId the component carrier ID
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */
-  virtual void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
-  /**
-   * \brief Receive PDU.
-   * \param p the packet
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */
-  virtual void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
-  /// Notify HARQ delivery failure
-  virtual void DoNotifyHarqDeliveryFailure ();
-  /**
-   * \brief Remove UE.
-   * \param rnti the RNTI
-   */
-  virtual void DoRemoveUe (uint16_t rnti);
-  /**
-   * \brief Release data radio bearer.
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   * \returns updated data radio bearer list
-   */
-  virtual std::vector<uint8_t> DoReleaseDataRadioBearer (uint16_t rnti, uint8_t lcid);
-  /**
-   * \brief Configure the signal bearer.
-   * \param lcinfo the LteEnbCmacSapProvider::LcInfo
-   * \param msu the MSU
-   * \returns updated data radio bearer list
-   */
-  virtual LteMacSapUser* DoConfigureSignalBearer(LteEnbCmacSapProvider::LcInfo lcinfo,  LteMacSapUser* msu);
-  /**
-   * \brief Forwards uplink BSR to CCM, called by MAC through CCM SAP interface.
-   * \param bsr the BSR
-   * \param componentCarrierId the component carrier ID
-   */
-  virtual void DoUlReceiveMacCe (MacCeListElement_s bsr, uint8_t componentCarrierId);
-  /**
-   * \brief Function implements the function of the SAP interface of CCM instance which is used by MAC
-   * to notify the PRB occupancy reported by scheduler.
-   * \param prbOccupancy the PRB occupancy
-   * \param componentCarrierId the component carrier ID
-   */
-  virtual void DoNotifyPrbOccupancy (double prbOccupancy, uint8_t componentCarrierId);
-
-protected:
-
-  std::map <uint8_t, double > m_ccPrbOccupancy;//!< The physical resource block occupancy per carrier.
-
-}; // end of class NoOpComponentCarrierManager
-
-
-/*
- * \brief Component carrier manager implementation that splits traffic equally among carriers.
- */
-class RrComponentCarrierManager : public NoOpComponentCarrierManager
-{
-public:
-
-  RrComponentCarrierManager ();
-  virtual ~RrComponentCarrierManager ();
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId ();
-
-protected:
-
-  // Inherited methods
-  virtual void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params);
-  virtual void DoUlReceiveMacCe (MacCeListElement_s bsr, uint8_t componentCarrierId);
-
-}; // end of class RrComponentCarrierManager
-
-} // end of namespace ns3
-
-
-#endif /* NO_OP_COMPONENT_CARRIER_MANAGER_H */
diff -Naru a/model/simple-ue-component-carrier-manager.cc b/model/simple-ue-component-carrier-manager.cc
--- a/model/simple-ue-component-carrier-manager.cc	2017-10-05 11:46:52.218493988 +0200
+++ b/model/simple-ue-component-carrier-manager.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,354 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
-* Copyright (c) 2015 Danilo Abrignani
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License version 2 as
-* published by the Free Software Foundation;
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*
-* Author: Danilo Abrignani <danilo.abrignani@unibo.it>
-*
-*/
-
-#include "simple-ue-component-carrier-manager.h"
-#include <ns3/log.h>
-#include <ns3/lte-ue-mac.h>
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("SimpleUeComponentCarrierManager");
-
-NS_OBJECT_ENSURE_REGISTERED (SimpleUeComponentCarrierManager);
-
-///////////////////////////////////////////////////////////
-// SAP forwarders
-///////////////////////////////////////////////////////////
-
-///////////////////////////////////////////////////////////
-// MAC SAP PROVIDER SAP forwarders
-///////////////////////////////////////////////////////////
-
-/// SimpleUeCcmMacSapProvider class
-class SimpleUeCcmMacSapProvider : public LteMacSapProvider
-{ 
-public:
-  /**
-   * Constructor
-   *
-   * \param mac the component carrier manager
-   */
-  SimpleUeCcmMacSapProvider (SimpleUeComponentCarrierManager* mac);
-
-  // inherited from LteMacSapProvider
-  virtual void TransmitPdu (LteMacSapProvider::TransmitPduParameters params);
-  virtual void ReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params);
-
-private:
-  SimpleUeComponentCarrierManager* m_mac; ///< the component carrier manager
-};
-
-SimpleUeCcmMacSapProvider::SimpleUeCcmMacSapProvider (SimpleUeComponentCarrierManager* mac)
-  : m_mac (mac)
-{
-}
-
-void
-SimpleUeCcmMacSapProvider::TransmitPdu (TransmitPduParameters params)
-{
-  m_mac->DoTransmitPdu (params);
-}
-
-
-void
-SimpleUeCcmMacSapProvider::ReportBufferStatus (ReportBufferStatusParameters params)
-{
-  m_mac->DoReportBufferStatus (params);
-}
-
-///////////////////////////////////////////////////////////
-// MAC SAP USER SAP forwarders
-/////////////// ////////////////////////////////////////////
-
-/// SimpleUeCcmMacSapUser class
-class SimpleUeCcmMacSapUser : public LteMacSapUser
-{ 
-public:
-  /**
-   * Constructor
-   *
-   * \param mac the component carrier manager
-   */
-  SimpleUeCcmMacSapUser  (SimpleUeComponentCarrierManager* mac);
-
-  // inherited from LteMacSapUser
-  virtual void NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
-  virtual void ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
-  virtual void NotifyHarqDeliveryFailure ();
-
-
-private:
-  SimpleUeComponentCarrierManager* m_mac; ///< the component carrier manager
-};
-
-SimpleUeCcmMacSapUser::SimpleUeCcmMacSapUser (SimpleUeComponentCarrierManager* mac)
-  : m_mac (mac)
-{
-}
-
-void
-SimpleUeCcmMacSapUser::NotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
-{
-  NS_LOG_INFO ("SimpleUeCcmMacSapUser::NotifyTxOpportunity for ccId:"<<(uint32_t)componentCarrierId);
-  m_mac->DoNotifyTxOpportunity (bytes, layer, harqId, componentCarrierId, rnti, lcid);
-}
-
-
-void
-SimpleUeCcmMacSapUser::ReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
-{
-  m_mac->DoReceivePdu (p, rnti, lcid);
-}
-
-void
-SimpleUeCcmMacSapUser::NotifyHarqDeliveryFailure ()
-{
-  m_mac->DoNotifyHarqDeliveryFailure ();
-}
-
-//////////////////////////////////////////////////////////
-// SimpleUeComponentCarrierManager methods
-///////////////////////////////////////////////////////////
-
-SimpleUeComponentCarrierManager::SimpleUeComponentCarrierManager ()
-: m_ccmRrcSapUser (0)
-{
-  NS_LOG_FUNCTION (this);
-  m_ccmRrcSapProvider = new MemberLteUeCcmRrcSapProvider<SimpleUeComponentCarrierManager> (this);
-  m_noOfComponentCarriersEnabled = 1;
-  m_ccmMacSapUser = new SimpleUeCcmMacSapUser (this);
-  m_ccmMacSapProvider = new SimpleUeCcmMacSapProvider (this);
-}
-
-
-SimpleUeComponentCarrierManager::~SimpleUeComponentCarrierManager ()
-{
-  NS_LOG_FUNCTION (this);
-
-}
-
-
-void
-SimpleUeComponentCarrierManager::DoDispose ()
-{
-  NS_LOG_FUNCTION (this);
-  delete m_ccmMacSapUser;
-  delete m_ccmMacSapProvider;
-  delete m_ccmRrcSapProvider;
-}
-
-
-TypeId
-SimpleUeComponentCarrierManager::GetTypeId ()
-{
-  static TypeId tid = TypeId ("ns3::SimpleUeComponentCarrierManager")
-    .SetParent<LteUeComponentCarrierManager> ()
-    .SetGroupName("Lte")
-    .AddConstructor<SimpleUeComponentCarrierManager> ()
-    ;
-  return tid;
-}
-
-LteMacSapProvider*
-SimpleUeComponentCarrierManager::GetLteMacSapProvider ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_ccmMacSapProvider;
-}
-
-void
-SimpleUeComponentCarrierManager::SetLteCcmRrcSapUser (LteUeCcmRrcSapUser* s)
-{
-  NS_LOG_FUNCTION (this << s);
-  m_ccmRrcSapUser = s;
-}
-
-
-LteUeCcmRrcSapProvider*
-SimpleUeComponentCarrierManager::GetLteCcmRrcSapProvider ()
-{
-  NS_LOG_FUNCTION (this);
-  return m_ccmRrcSapProvider;
-}
-
-
-void
-SimpleUeComponentCarrierManager::DoInitialize ()
-{
-  NS_LOG_FUNCTION (this);
-  LteUeComponentCarrierManager::DoInitialize ();
-}
-
-
-void
-SimpleUeComponentCarrierManager::DoReportUeMeas (uint16_t rnti,
-                                                 LteRrcSap::MeasResults measResults)
-{
-  NS_LOG_FUNCTION (this << rnti << (uint16_t) measResults.measId);
-}
-
-
-void
-SimpleUeComponentCarrierManager::DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params)
-{
-  NS_LOG_FUNCTION (this);
-   std::map <uint8_t, LteMacSapProvider*>::iterator it =  m_macSapProvidersMap.find (params.componentCarrierId);
-  NS_ASSERT_MSG (it != m_macSapProvidersMap.end (), "could not find Sap for ComponentCarrier " << (uint16_t) params.componentCarrierId);
-  // with this algorithm all traffic is on Primary Carrier
-  it->second->TransmitPdu (params);
-}
-
-void
-SimpleUeComponentCarrierManager::DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params)
-{
-  NS_LOG_FUNCTION (this);
-  std::map <uint8_t, LteMacSapProvider*>::iterator it =  m_macSapProvidersMap.find (0);
-  NS_ASSERT_MSG (it != m_macSapProvidersMap.end (), "could not find Sap for ComponentCarrier ");
-  it->second->ReportBufferStatus (params);
-}
-
-void 
-SimpleUeComponentCarrierManager::DoNotifyHarqDeliveryFailure ()
-{
- NS_LOG_FUNCTION (this);
-}
-
-
-void 
-SimpleUeComponentCarrierManager::DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid)
-{
-  NS_LOG_FUNCTION (this);
-  std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = m_lcAttached.find (lcid);
-  NS_ASSERT_MSG (lcidIt != m_lcAttached.end (), "could not find LCID" << lcid);
-  NS_LOG_DEBUG (this << " lcid= " << (uint32_t) lcid << " layer= " << (uint16_t) layer << " componentCarierId " << (uint16_t) componentCarrierId << " rnti " << rnti);
-  (*lcidIt).second->NotifyTxOpportunity (bytes, layer, harqId, componentCarrierId, rnti, lcid);
-}
-void
-SimpleUeComponentCarrierManager::DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid)
-{
-  NS_LOG_FUNCTION (this);
-  std::map<uint8_t, LteMacSapUser*>::iterator lcidIt = m_lcAttached.find (lcid);
-  if (lcidIt != m_lcAttached.end ())
-    {
-      (*lcidIt).second->ReceivePdu (p, rnti, lcid);
-    }
-}
-
-///////////////////////////////////////////////////////////
-// Ue CCM RRC SAP PROVIDER SAP forwarders
-///////////////////////////////////////////////////////////
-std::vector<uint16_t>
-SimpleUeComponentCarrierManager::DoRemoveLc (uint8_t lcid)
-{
-  NS_LOG_FUNCTION (this << " lcId" << lcid);
-  std::vector<uint16_t> res;
-  NS_ASSERT_MSG (m_lcAttached.find (lcid) != m_lcAttached.end (), "could not find LCID " << lcid);
-  m_lcAttached.erase (lcid);
-  // send back all the configuration to the componentCarrier where we want to remove the Lc
-  std::map<uint8_t, std::map<uint8_t, LteMacSapProvider*> >::iterator it =  m_componentCarrierLcMap.begin ();
-  while (it != m_componentCarrierLcMap.end ())
-    {
-      std::map<uint8_t, LteMacSapProvider*>::iterator lcToRemove = it->second.find (lcid);
-      if (lcToRemove != it->second.end ())
-        {
-          res.insert (res.end (), it->first);
-        }
-      it++;
-    }
-  NS_ASSERT_MSG (res.size () != 0, "Not found in the ComponentCarrierManager maps the LCID " << lcid);
-
-  return res; 
-
-}
-
-std::vector<LteUeCcmRrcSapProvider::LcsConfig>
-SimpleUeComponentCarrierManager::DoAddLc (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu)
-{
-  NS_LOG_FUNCTION (this);
-  std::vector<LteUeCcmRrcSapProvider::LcsConfig> res;
-  std::map<uint8_t, LteMacSapUser*>::iterator it = m_lcAttached.find (lcId);
-  NS_ASSERT_MSG (it == m_lcAttached.end (), "Warning, LCID " << lcId << " already exist");
-  m_lcAttached.insert (std::pair<uint8_t, LteMacSapUser*> (lcId, msu));
-  LteUeCcmRrcSapProvider::LcsConfig elem;
-  std::map <uint8_t, std::map<uint8_t, LteMacSapProvider*> >::iterator ccLcMapIt;
-  for (uint8_t ncc = 0; ncc < m_noOfComponentCarriersEnabled; ncc++)
-    {
-      elem.componentCarrierId = ncc;
-      elem.lcConfig = &lcConfig;
-      elem.msu = m_ccmMacSapUser;
-      res.insert (res.end (), elem);
-      
-      ccLcMapIt = m_componentCarrierLcMap.find (ncc);
-      if (ccLcMapIt != m_componentCarrierLcMap.end ())
-        {
-          ccLcMapIt->second.insert (std::pair <uint8_t, LteMacSapProvider*> (lcId, m_macSapProvidersMap.at (ncc)));
-        }
-      else
-        {
-          std::map<uint8_t, LteMacSapProvider*> empty;
-          std::pair <std::map <uint8_t, std::map<uint8_t, LteMacSapProvider*> >::iterator, bool>
-            ret = m_componentCarrierLcMap.insert (std::pair <uint8_t,  std::map<uint8_t, LteMacSapProvider*> >
-                                                  (ncc, empty));
-          NS_ASSERT_MSG (ret.second, "element already present, ComponentCarrierId already existed");
-          ccLcMapIt = m_componentCarrierLcMap.find (ncc);
-          ccLcMapIt->second.insert (std::pair <uint8_t, LteMacSapProvider*> (lcId, m_macSapProvidersMap.at (ncc)));
-        }
-    }
-  
-  return res;  
-}
-
-void
-SimpleUeComponentCarrierManager::DoNotifyConnectionReconfigurationMsg ()
-{
-  NS_LOG_FUNCTION (this);
-  // this method need to be extended, now support only up to 2 ComponentCarrier Simulations
-
-  if (m_noOfComponentCarriersEnabled < m_noOfComponentCarriers)
-   {
-     // new ComponentCarrierConfiguration Requested
-     m_noOfComponentCarriersEnabled++;
-     std::vector<uint8_t> res;
-     res.insert (res.end (), m_noOfComponentCarriersEnabled);
-     //here the code to update all the Lc, since now  those should be mapped on all ComponentCarriers
-     m_ccmRrcSapUser->ComponentCarrierEnabling (res);
-   }
-  
-}
-LteMacSapUser*
-SimpleUeComponentCarrierManager::DoConfigureSignalBearer (uint8_t lcid,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu)
-{
-  NS_LOG_FUNCTION (this);
-  std::map<uint8_t, LteMacSapUser*>::iterator it = m_lcAttached.find (lcid);
-  //NS_ASSERT_MSG (it == m_lcAttached.end (), "Warning, LCID " << (uint8_t) lcid << " already exist");
-  if (it != m_lcAttached.end ())
-    {
-      // This line will remove the former SignalBearer. It is needed in case of handover
-      // since an update of the signal bearer performed.
-      // Now it points on the right LteMacSapUser
-      m_lcAttached.erase (it); 
-    }
-  m_lcAttached.insert (std::pair<uint8_t, LteMacSapUser*> (lcid, msu));
-
-  return m_ccmMacSapUser;
- } 
-
-} // end of namespace ns3
diff -Naru a/model/simple-ue-component-carrier-manager.h b/model/simple-ue-component-carrier-manager.h
--- a/model/simple-ue-component-carrier-manager.h	2017-10-05 11:46:52.218493988 +0200
+++ b/model/simple-ue-component-carrier-manager.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Danilo Abrignani
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Danilo Abrignani <danilo.abrignani@unibo.it>
- *
- */
-
-#ifndef SIMPLE_UE_COMPONENT_CARRIER_MANAGER_H
-#define SIMPLE_UE_COMPONENT_CARRIER_MANAGER_H
-
-#include <ns3/lte-ue-component-carrier-manager.h>
-#include <ns3/lte-ue-ccm-rrc-sap.h>
-#include <ns3/lte-rrc-sap.h>
-#include <map>
-
-namespace ns3 {
-  class LteUeCcmRrcSapProvider;
-
-/**
- * \brief Component carrier manager implementation which simply does nothing.
- *
- * Selecting this component carrier selection algorithm is equivalent to disabling automatic
- * triggering of component carrier selection. This is the default choice.
- *
- */
-class SimpleUeComponentCarrierManager : public LteUeComponentCarrierManager
-{
-public:
-  /// Creates a No-op CCS algorithm instance.
-  SimpleUeComponentCarrierManager ();
-
-  virtual ~SimpleUeComponentCarrierManager ();
-
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId ();
-
-  // inherited from LteComponentCarrierManager
-  virtual void SetLteCcmRrcSapUser (LteUeCcmRrcSapUser* s);
-  virtual LteUeCcmRrcSapProvider* GetLteCcmRrcSapProvider ();
-  virtual LteMacSapProvider* GetLteMacSapProvider ();
-
-
-
-  /// let the forwarder class access the protected and private members
-  friend class MemberLteUeCcmRrcSapProvider<SimpleUeComponentCarrierManager>;
-  //friend class MemberLteUeCcmRrcSapUser<SimpleUeComponentCarrierManager>;
-  
-  /// allow SimpleUeCcmMacSapProvider class friend access
-  friend class SimpleUeCcmMacSapProvider;
-  /// allow SimpleUeCcmMacSapUser class friend access
-  friend class SimpleUeCcmMacSapUser;
-
-protected:
-
-  // inherited from Object
-  virtual void DoInitialize ();
-  virtual void DoDispose ();
-  // inherited from LteCcsAlgorithm as a Component Carrier Management SAP implementation
-  /**
-   * \brief Report Ue Measure function
-   * \param rnti the RNTI
-   * \param measResults the measure results
-   */
-  void DoReportUeMeas (uint16_t rnti, LteRrcSap::MeasResults measResults);
-  // forwarded from LteMacSapProvider
-  /**
-   * \brief Transmit PDU function
-   * \param params LteMacSapProvider::TransmitPduParameters
-   */
-  void DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params);
-  /**
-   * \brief Report buffer status function
-   * \param params LteMacSapProvider::ReportBufferStatusParameters
-   */
-  void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params);
-  /// Notify HARQ deliver failure
-  void DoNotifyHarqDeliveryFailure ();
-  // forwarded from LteMacSapUser
-  /**
-   * \brief Notify TX opportunity function
-   * \param bytes the number of bytes
-   * \param layer the layer
-   * \param harqId the HARQ ID
-   * \param componentCarrierId the component carrier ID
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */
-  void DoNotifyTxOpportunity (uint32_t bytes, uint8_t layer, uint8_t harqId, uint8_t componentCarrierId, uint16_t rnti, uint8_t lcid);
-  /**
-   * \brief Receive PDU function
-   * \param p the packet
-   * \param rnti the RNTI
-   * \param lcid the LCID
-   */
-  void DoReceivePdu (Ptr<Packet> p, uint16_t rnti, uint8_t lcid);
-  //forwarded from LteUeCcmRrcSapProvider
-  /**
-   * \brief Add LC function
-   * \param lcId the LCID
-   * \param lcConfig the logical channel config
-   * \param msu the MSU
-   * \returns updated LC config list
-   */
-  std::vector<LteUeCcmRrcSapProvider::LcsConfig> DoAddLc (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu);
-  /**
-   * \brief Remove LC function
-   * \param lcid the LCID
-   * \returns updated LC list
-   */
-  std::vector<uint16_t> DoRemoveLc (uint8_t lcid);
-  /// Notify connection reconfiguration message
-  void DoNotifyConnectionReconfigurationMsg ();
-  /**
-   * \brief Configure signal bearer function
-   * \param lcId the LCID
-   * \param lcConfig the logical channel config
-   * \param msu the MSU
-   * \returns LteMacSapUser *
-   */
-  LteMacSapUser* DoConfigureSignalBearer (uint8_t lcId,  LteUeCmacSapProvider::LogicalChannelConfig lcConfig, LteMacSapUser* msu);
-  
-private:
-  
-  LteUeCcmRrcSapUser* m_ccmRrcSapUser;//!< Interface to the eNodeB RRC instance.
-  LteUeCcmRrcSapProvider* m_ccmRrcSapProvider; //!< Receive API calls from the eNodeB RRC instance.
-  LteMacSapUser* m_ccmMacSapUser;//!< Interface to the eNodeB RLC instance.
-  LteMacSapProvider* m_ccmMacSapProvider; //!< Receive API calls from the eNodeB RLC instance
-
-}; // end of class SimpleUeComponentCarrierManager
-
-
-} // end of namespace ns3
-
-
-#endif /* SIMPLE_UE_COMPONENT_CARRIER_MANAGER_H */
diff -Naru a/test/lte-test-aggregation-throughput-scale.cc b/test/lte-test-aggregation-throughput-scale.cc
--- a/test/lte-test-aggregation-throughput-scale.cc	2017-10-05 11:46:52.222494002 +0200
+++ b/test/lte-test-aggregation-throughput-scale.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,169 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2017 Alexander Krotov
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Alexander Krotov <krotov@iitp.ru>
- *
- */
-
-#include "lte-test-aggregation-throughput-scale.h"
-
-#include <algorithm>
-#include <numeric>
-
-#include <ns3/application-container.h>
-#include <ns3/friis-spectrum-propagation-loss.h>
-#include <ns3/internet-stack-helper.h>
-#include <ns3/ipv4-address-helper.h>
-#include <ns3/ipv4-interface-container.h>
-#include <ns3/ipv4-static-routing-helper.h>
-#include <ns3/log.h>
-#include <ns3/lte-enb-net-device.h>
-#include <ns3/lte-helper.h>
-#include <ns3/lte-ue-net-device.h>
-#include <ns3/lte-ue-rrc.h>
-#include <ns3/mobility-helper.h>
-#include <ns3/net-device-container.h>
-#include <ns3/node-container.h>
-#include <ns3/packet-sink.h>
-#include <ns3/point-to-point-epc-helper.h>
-#include <ns3/point-to-point-helper.h>
-#include <ns3/simulator.h>
-#include <ns3/udp-client.h>
-
-using namespace ns3;
-
-NS_LOG_COMPONENT_DEFINE ("LteAggregationThroughputScaleTest");
-
-LteAggregationThroughputScaleTestSuite::LteAggregationThroughputScaleTestSuite ()
-  : TestSuite ("lte-aggregation-throughput-scale", SYSTEM)
-{
-  AddTestCase (new LteAggregationThroughputScaleTestCase ("Carrier aggregation throughput scale"), TestCase::QUICK);
-}
-
-static LteAggregationThroughputScaleTestSuite g_lteAggregationThroughputScaleTestSuite;
-
-LteAggregationThroughputScaleTestCase::LteAggregationThroughputScaleTestCase (std::string name)
-  : TestCase (name)
-{
-  NS_LOG_FUNCTION (this << GetName ());
-}
-
-
-LteAggregationThroughputScaleTestCase::~LteAggregationThroughputScaleTestCase ()
-{
-  NS_LOG_FUNCTION (this << GetName ());
-}
-
-double
-LteAggregationThroughputScaleTestCase::GetThroughput (uint8_t numberOfComponentCarriers)
-{
-  NS_LOG_FUNCTION (this << GetName ());
-
-  auto lteHelper = CreateObject<LteHelper> ();
-  lteHelper->SetAttribute ("PathlossModel", TypeIdValue (ns3::FriisSpectrumPropagationLossModel::GetTypeId ()));
-  lteHelper->SetAttribute ("NumberOfComponentCarriers", UintegerValue (numberOfComponentCarriers));
-  lteHelper->SetAttribute ("EnbComponentCarrierManager", StringValue ("ns3::RrComponentCarrierManager"));
-
-  auto epcHelper = CreateObject<PointToPointEpcHelper> ();
-  lteHelper->SetEpcHelper (epcHelper);
-
-  auto cch = CreateObject<CcHelper> ();
-  cch->SetUlEarfcn (100 + 18000);
-  cch->SetDlEarfcn (100);
-  cch->SetUlBandwidth (25);
-  cch->SetDlBandwidth (25);
-  cch->SetNumberOfComponentCarriers (numberOfComponentCarriers);
-
-  const auto ccm = cch->EquallySpacedCcs ();
-  lteHelper->SetCcPhyParams (ccm);
-
-  auto enbNode = CreateObject<Node> ();
-  auto ueNode = CreateObject<Node> ();
-  auto pgwNode = epcHelper->GetPgwNode ();
-
-  MobilityHelper mobility;
-  mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-  mobility.Install (enbNode);
-  mobility.Install (ueNode);
-
-  InternetStackHelper internet;
-  internet.Install (ueNode);
-
-  Ipv4AddressHelper ipv4h;
-  ipv4h.SetBase ("1.0.0.0", "255.0.0.0");
-
-  Ipv4StaticRoutingHelper ipv4RoutingHelper;
-  auto ueStaticRouting = ipv4RoutingHelper.GetStaticRouting (ueNode->GetObject<Ipv4> ());
-  ueStaticRouting->SetDefaultRoute (epcHelper->GetUeDefaultGatewayAddress (), 1);
-
-  auto enbDev = DynamicCast<LteEnbNetDevice> (lteHelper->InstallEnbDevice (enbNode).Get (0));
-  auto ueDevs = lteHelper->InstallUeDevice (ueNode);
-  auto ueDev = DynamicCast<LteUeNetDevice> (ueDevs.Get (0));
-
-  Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address (ueDevs);
-
-  // Attach to last CC as primary
-  ueDev->SetDlEarfcn (ccm.at (numberOfComponentCarriers - 1).GetDlEarfcn ());
-  lteHelper->Attach (ueDevs);
-  m_expectedCellId = enbDev->GetCcMap ().at (numberOfComponentCarriers - 1)->GetCellId ();
-
-  // Applications
-  const uint16_t port = 21;
-
-  ApplicationContainer apps;
-
-  auto sink = CreateObject<PacketSink> ();
-  sink->SetAttribute ("Protocol", StringValue ("ns3::UdpSocketFactory"));
-  sink->SetAttribute ("Local", AddressValue (InetSocketAddress (ueIpIface.GetAddress (0), port)));
-  ueNode->AddApplication (sink);
-  apps.Add (sink);
-
-  auto client = CreateObject<UdpClient> ();
-  client->SetAttribute ("RemotePort", UintegerValue (port));
-  client->SetAttribute ("MaxPackets", UintegerValue (1000000));
-  client->SetAttribute ("Interval", TimeValue (Seconds (0.0001)));
-  client->SetAttribute ("PacketSize", UintegerValue (1000));
-  client->SetAttribute ("RemoteAddress", AddressValue (ueIpIface.GetAddress (0)));
-  pgwNode->AddApplication (client);
-
-  apps.Add (client);
-  apps.Start (Seconds (1.0));
-
-  Simulator::Stop (Seconds (2.0));
-  Simulator::Run ();
-
-  m_actualCellId = ueDev->GetRrc ()->GetCellId ();
-
-  Simulator::Destroy ();
-  return 8e-6 * sink->GetTotalRx ();
-}
-
-void
-LteAggregationThroughputScaleTestCase::DoRun ()
-{
-  std::vector<double> throughputs;
-  for (uint8_t i = 1; i <= 4; i++)
-    {
-      throughputs.push_back (GetThroughput (i) / i);
-      NS_TEST_ASSERT_MSG_EQ (m_expectedCellId, m_actualCellId, "UE has attached to an unexpected cell");
-    }
-  double average = std::accumulate(begin (throughputs), end (throughputs), 0.0) / throughputs.size ();
-  for (double throughput: throughputs)
-    {
-      NS_TEST_ASSERT_MSG_EQ_TOL (throughput, average, average * 0.01, "Throughput does not scale with number of component carriers");
-    }
-}
diff -Naru a/test/lte-test-aggregation-throughput-scale.h b/test/lte-test-aggregation-throughput-scale.h
--- a/test/lte-test-aggregation-throughput-scale.h	2017-10-05 11:46:52.222494002 +0200
+++ b/test/lte-test-aggregation-throughput-scale.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2017 Alexander Krotov
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Alexander Krotov <krotov@iitp.ru>
- *
- */
-
-#ifndef LTE_AGGREGATION_THROUGHPUT_SCALE_H
-#define LTE_AGGREGATION_THROUGHPUT_SCALE_H
-
-#include <ns3/test.h>
-
-using namespace ns3;
-
-/**
- * \brief Test suite for executing carrier aggregation throughput scaling test case.
- *
- * \sa ns3::LteAggregationThroughputScaleTestCase
- */
-class LteAggregationThroughputScaleTestSuite : public TestSuite
-{
-public:
-  LteAggregationThroughputScaleTestSuite ();
-};
-
-/**
- * \ingroup lte
- *
- * \brief Testing that UE throughput scales linearly with number of component carriers.
- *        Also attaches UE to last component carrier to make sure no code assumes
- *        that primary carrier is first.
- */
-class LteAggregationThroughputScaleTestCase : public TestCase
-{
-public:
-  /**
-   * \brief Creates an instance of the carrier aggregation throughput scaling test case.
-   * \param name name of this test
-   */
-  LteAggregationThroughputScaleTestCase (std::string name);
-
-  virtual ~LteAggregationThroughputScaleTestCase ();
-
-private:
-  /**
-   * \brief Setup the simulation, run it, and verify the result.
-   */
-  virtual void DoRun ();
-
-  double GetThroughput (uint8_t numberOfComponentCarriers);
-
-  uint16_t m_expectedCellId; //< Cell ID UE is expected to attach to
-  uint16_t m_actualCellId; //< Cell ID UE has attached to
-};
-
-#endif /* LTE_AGGREGATION_THROUGHPUT_SCALE_H */
diff -Naru a/test/lte-test-carrier-aggregation.cc b/test/lte-test-carrier-aggregation.cc
--- a/test/lte-test-carrier-aggregation.cc	2017-10-05 11:46:52.222494002 +0200
+++ b/test/lte-test-carrier-aggregation.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,486 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2016 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Biljana Bojovic <bbojovic@cttc.es>
- *
- */
-
-#include <ns3/object.h>
-#include <ns3/spectrum-interference.h>
-#include <ns3/spectrum-error-model.h>
-#include <ns3/log.h>
-#include <ns3/test.h>
-#include <ns3/simulator.h>
-#include <ns3/packet.h>
-#include <ns3/ptr.h>
-#include <iostream>
-#include "ns3/radio-bearer-stats-calculator.h"
-#include <ns3/constant-position-mobility-model.h>
-#include <ns3/eps-bearer.h>
-#include <ns3/node-container.h>
-#include <ns3/mobility-helper.h>
-#include <ns3/net-device-container.h>
-#include <ns3/lte-ue-net-device.h>
-#include <ns3/lte-enb-net-device.h>
-#include <ns3/lte-ue-rrc.h>
-#include <ns3/lte-helper.h>
-#include "ns3/string.h"
-#include "ns3/double.h"
-#include <ns3/lte-enb-phy.h>
-#include <ns3/lte-ue-phy.h>
-#include <ns3/boolean.h>
-#include <ns3/enum.h>
-#include <ns3/config-store-module.h>
-#include <errno.h>
-
-#include "lte-test-carrier-aggregation.h"
-
-using namespace ns3;
-
-NS_LOG_COMPONENT_DEFINE ("TestCarrierAggregation");
-
-bool CarrierAggregationTestCase::s_writeResults = false; // set to true to write response vectors
-const std::string dlResultsFileName = "carrier_aggregation_results_dl.txt";
-const std::string ulResultsFileName = "carrier_aggregation_results_ul.txt";
-
-
-void
-LteTestDlSchedulingCallback (CarrierAggregationTestCase *testcase, std::string path, DlSchedulingCallbackInfo dlInfo)
-{
-  testcase->DlScheduling (dlInfo);
-}
-
-void
-LteTestUlSchedulingCallback (CarrierAggregationTestCase *testcase, std::string path,
-                             uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
-                             uint8_t mcs, uint16_t sizeTb, uint8_t ccId)
-{
-  testcase->UlScheduling (frameNo, subframeNo, rnti, mcs, sizeTb, ccId);
-}
-
-
-TestCarrierAggregationSuite::TestCarrierAggregationSuite ()
-  : TestSuite ("lte-carrier-aggregation", SYSTEM)
-{
-  NS_LOG_INFO ("creating CarrierAggregationTestCase");
-
-  if (CarrierAggregationTestCase::s_writeResults) // write result vectors to file
-    {
-      std::cout<<"\n Running TestCarrierAggregationSuite with activated option to write results to files."
-          "Dl results will be written to "<<dlResultsFileName<<" and uplink results to "<<ulResultsFileName<<std::endl;
-
-      bool abort = false;
-
-      if (fopen(dlResultsFileName.c_str(), "r"))
-        {
-          std::cout<<"\nResults file "<<dlResultsFileName<<" already exists. Move it out of the way or specify another downlink results file name."<<std::endl;
-          abort = true;
-        }
-      if (fopen(ulResultsFileName.c_str(), "r"))
-        {
-          std::cout<<"\nResults file "<<ulResultsFileName<<" already exists. Move it out of the way or specify another uplink results file name."<<std::endl;
-          abort = true;
-        }
-
-      if (abort)
-        return;
-
-      AddTestCase (new CarrierAggregationTestCase (1,0, 100, 100, 1), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (3,0, 100, 100, 1), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (6,0, 100, 100, 1), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (9,0, 100, 100, 1), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (12,0, 100, 100, 1), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (15,0, 100, 100, 1), TestCase::QUICK);
-
-      AddTestCase (new CarrierAggregationTestCase (1,0, 100, 100, 2), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (3,0, 100, 100, 2), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (6,0, 100, 100, 2), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (9,0, 100, 100, 2), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (12,0, 100, 100, 2), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (15,0, 100, 100, 2), TestCase::QUICK);
-
-      AddTestCase (new CarrierAggregationTestCase (1,0, 100, 100, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (3,0, 100, 100, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (6,0, 100, 100, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (9,0, 100, 100, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (12,0, 100, 100, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (15,0, 100, 100, 3), TestCase::QUICK);
-    }
-  else
-    {
-      // bandwidth is 25 and there are 2 carriers
-      AddTestCase (new CarrierAggregationTestCase (1,0, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,0, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,0, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,0, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,0, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,0, 25, 25, 2), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,4800, 25, 25, 2), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (3,4800, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,4800, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,4800, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,4800, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,4800, 25, 25, 2), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,6000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,6000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,6000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,6000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,6000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,6000, 25, 25, 2), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,20000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,20000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,20000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,20000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,20000, 25, 25, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,20000, 25, 25, 2), TestCase::QUICK);
-
-
-      // bandwidth is 25 and there are 3 carriers
-      AddTestCase (new CarrierAggregationTestCase (1,0, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,0, 25, 25, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (6,0, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,0, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,0, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,0, 25, 25, 3), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,4800, 25, 25, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (3,4800, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,4800, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,4800, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,4800, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,4800, 25, 25, 3), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,6000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,6000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,6000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,6000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,6000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,6000, 25, 25, 3), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,20000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,20000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,20000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,20000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,20000, 25, 25, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,20000, 25, 25, 3), TestCase::EXTENSIVE);
-
-
-      // bandwidth = 6 RB and there are 3 carriers
-      AddTestCase (new CarrierAggregationTestCase (1,0, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,0, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,0, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,0, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,0, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,0, 6, 6, 3), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,4800, 6, 6, 3), TestCase::QUICK);
-      AddTestCase (new CarrierAggregationTestCase (3,4800, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,4800, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,4800, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,4800, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,4800, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (1,6000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,6000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,6000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,6000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,6000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,6000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (1,20000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,20000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,20000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,20000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,20000, 6, 6, 3), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,20000, 6, 6, 3), TestCase::EXTENSIVE);
-
-      // bandwidth = 6 RB and there are 2 carriers
-      AddTestCase (new CarrierAggregationTestCase (1,0, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,0, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,0, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,0, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,0, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,0, 6, 6, 2), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,4800, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,4800, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,4800, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,4800, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,4800, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,4800, 6, 6, 2), TestCase::EXTENSIVE);
-
-      AddTestCase (new CarrierAggregationTestCase (1,6000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,6000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,6000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,6000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,6000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,6000, 6, 6, 2), TestCase::QUICK);
-
-      AddTestCase (new CarrierAggregationTestCase (1,20000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (3,20000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (6,20000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (9,20000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (12,20000, 6, 6, 2), TestCase::EXTENSIVE);
-      AddTestCase (new CarrierAggregationTestCase (15,20000, 6, 6, 2), TestCase::EXTENSIVE);
-    }
-}
-
-
-static TestCarrierAggregationSuite lenaTestRrFfMacSchedulerSuite;
-
-std::string 
-CarrierAggregationTestCase::BuildNameString (uint16_t nUser, uint16_t dist, uint32_t dlBandwidth, uint32_t ulBandwidth, uint32_t numberOfComponentCarriers)
-{
-  std::ostringstream oss;
-  oss << nUser << " UEs, distance " << dist << " m"<< " dlBandwidth "<< dlBandwidth <<" ulBandwidth "<< ulBandwidth <<" number of carriers "<<numberOfComponentCarriers;
-  return oss.str ();
-}
-
-CarrierAggregationTestCase::CarrierAggregationTestCase (uint16_t nUser, uint16_t dist, uint32_t dlbandwidth, uint32_t ulBandwidth, uint32_t numberOfComponentCarriers)
-  : TestCase (BuildNameString (nUser, dist, dlbandwidth, ulBandwidth, numberOfComponentCarriers)),
-    m_nUser (nUser),
-    m_dist (dist),
-    m_dlBandwidth (dlbandwidth),
-    m_ulBandwidth (ulBandwidth),
-    m_numberOfComponentCarriers(numberOfComponentCarriers)
-{
-   m_dlThroughput = 0;
-   m_statsDuration = 0.6;
-}
-
-CarrierAggregationTestCase::~CarrierAggregationTestCase ()
-{
-}
-
-void
-CarrierAggregationTestCase::DoRun (void)
-{
-  NS_LOG_FUNCTION (this << m_nUser << m_dist << m_dlBandwidth << m_ulBandwidth << m_numberOfComponentCarriers);
-
-  Config::SetDefault ("ns3::LteEnbNetDevice::DlBandwidth", UintegerValue (m_dlBandwidth));
-  Config::SetDefault ("ns3::LteEnbNetDevice::UlBandwidth", UintegerValue (m_ulBandwidth));
-  Config::SetDefault ("ns3::LteHelper::UseCa", BooleanValue (true));
-  Config::SetDefault ("ns3::LteHelper::NumberOfComponentCarriers", UintegerValue (m_numberOfComponentCarriers));
-  Config::SetDefault ("ns3::LteHelper::EnbComponentCarrierManager", StringValue ("ns3::RrComponentCarrierManager"));
-  Config::SetDefault ("ns3::LteSpectrumPhy::CtrlErrorModelEnabled", BooleanValue (false));
-  Config::SetDefault ("ns3::LteSpectrumPhy::DataErrorModelEnabled", BooleanValue (false));
-  Config::SetDefault ("ns3::LteHelper::UseIdealRrc", BooleanValue (true));
-
-  /**
-   * Initialize Simulation Scenario: 1 eNB and m_nUser UEs
-   */
-
-  Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
-  
-  lteHelper->SetAttribute ("PathlossModel", StringValue ("ns3::FriisSpectrumPropagationLossModel"));
-
-  auto cch = CreateObject<CcHelper> ();
-  cch->SetDlEarfcn (100); // Same as default value for LteEnbNetDevice
-  cch->SetUlEarfcn (100 + 18000); // Same as default value for LteEnbNetDevice
-  cch->SetDlBandwidth (m_dlBandwidth);
-  cch->SetUlBandwidth (m_ulBandwidth);
-  cch->SetNumberOfComponentCarriers (m_numberOfComponentCarriers);
-  lteHelper->SetCcPhyParams (cch->EquallySpacedCcs ());
-
-  // Create Nodes: eNodeB and UE
-  NodeContainer enbNodes;
-  NodeContainer ueNodes;
-  enbNodes.Create (1);
-  ueNodes.Create (m_nUser);
-
-  // Install Mobility Model
-  MobilityHelper mobility;
-  mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-  mobility.Install (enbNodes);
-  mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-  mobility.Install (ueNodes);
-
-  // Create Devices and install them in the Nodes (eNB and UE)
-  NetDeviceContainer enbDevs;
-  NetDeviceContainer ueDevs;
-  lteHelper->SetSchedulerType ("ns3::PfFfMacScheduler");
-  enbDevs = lteHelper->InstallEnbDevice (enbNodes);
-  ueDevs = lteHelper->InstallUeDevice (ueNodes);
-
-  // Attach a UE to a eNB
-  lteHelper->Attach (ueDevs, enbDevs.Get (0));
-
-  // Activate an EPS bearer
-  enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;
-  EpsBearer bearer (q);
-  lteHelper->ActivateDataRadioBearer (ueDevs, bearer);
-  
- 
-  Ptr<LteEnbNetDevice> lteEnbDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
-  Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy ();
-  enbPhy->SetAttribute ("TxPower", DoubleValue (30.0));
-  enbPhy->SetAttribute ("NoiseFigure", DoubleValue (5.0));
-
-  // Set UEs' position and power
-  for (int i = 0; i < m_nUser; i++)
-    {
-      Ptr<ConstantPositionMobilityModel> mm = ueNodes.Get (i)->GetObject<ConstantPositionMobilityModel> ();
-      mm->SetPosition (Vector (m_dist, 0.0, 0.0));
-      Ptr<LteUeNetDevice> lteUeDev = ueDevs.Get (i)->GetObject<LteUeNetDevice> ();
-      Ptr<LteUePhy> uePhy = lteUeDev->GetPhy ();
-      uePhy->SetAttribute ("TxPower", DoubleValue (23.0));
-      uePhy->SetAttribute ("NoiseFigure", DoubleValue (9.0));
-    }
-
-
-  double statsStartTime = 0.300; // need to allow for RRC connection establishment + SRS
-
-  Simulator::Stop (Seconds (statsStartTime + m_statsDuration - 0.0001));
-
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbMac/DlScheduling",
-                    MakeBoundCallback (&LteTestDlSchedulingCallback, this));
-
-  Config::Connect ("/NodeList/*/DeviceList/*/ComponentCarrierMap/*/LteEnbMac/UlScheduling",
-                    MakeBoundCallback (&LteTestUlSchedulingCallback, this));
-
-  lteHelper->EnableTraces();
-
-  Simulator::Run ();
-
-  /**
-   * Check that the assignation is done in a RR fashion
-   */
-  NS_LOG_INFO ("DL - Test with " << m_nUser << " user(s) at distance " << m_dist);
-  std::vector <uint64_t> dlDataRxed;
-
-  // tolerance increases with the number of users because the lc 0 and lc 1 will go always over primary carrier, so as the number of users increases the difference between primary and secondary
-  //carrier will increase
-
-  bool testDownlinkShare = true;
-
-  for (std::map <uint8_t, uint32_t>::iterator itDownlink = m_ccDownlinkTraffic.begin(); itDownlink!=m_ccDownlinkTraffic.end(); itDownlink++)
-   {
-
-      if (itDownlink == m_ccDownlinkTraffic.begin())
-        {
-           NS_LOG_INFO ("Downlink traffic per carrier:"<<itDownlink->second);
-        }
-      else
-        {
-          if (itDownlink->second != m_ccDownlinkTraffic.begin()->second)
-           {
-             testDownlinkShare = false;
-             break;
-           }
-        }
-   }
-
-  bool testUplinkShare = true;
-
-  for (std::map <uint8_t, uint32_t>::iterator itUplink = m_ccUplinkTraffic.begin(); itUplink!=m_ccUplinkTraffic.end(); itUplink++)
-   {
-      if (itUplink == m_ccUplinkTraffic.begin())
-       {
-          NS_LOG_INFO ("Uplink traffic per carrier:"<<itUplink->second);
-       }
-      else
-        {
-          if (itUplink->second != m_ccUplinkTraffic.begin()->second)
-            {
-              testUplinkShare = false;
-              break;
-            }
-        }
-   }
-
-  NS_TEST_ASSERT_MSG_EQ (m_ccUplinkTraffic.size(), m_numberOfComponentCarriers, "Number of carriers in uplink does not correspond to number of carriers being configured in test.");
-  NS_TEST_ASSERT_MSG_EQ (m_ccDownlinkTraffic.size(), m_numberOfComponentCarriers, "Number of carriers in downlink does not correspond to number of carriers being configured in test.");
-
-  NS_TEST_ASSERT_MSG_EQ (testDownlinkShare, true, " Downlink traffic not split equally between carriers!");
-  NS_TEST_ASSERT_MSG_EQ (testUplinkShare, true , " Uplink traffic not split equally between carriers");
-
-  if (s_writeResults)
-     WriteResultToFile ();
-
-  Simulator::Destroy ();
-}
-
-void
-CarrierAggregationTestCase::DlScheduling (DlSchedulingCallbackInfo dlInfo)
-{
-  //NS_LOG_FUNCTION (dlInfo.frameNo << dlInfo.subframeNo << dlInfo.rnti << (uint32_t) dlInfo.mcsTb1 << dlInfo.sizeTb1 << (uint32_t) dlInfo.mcsTb2 << dlInfo.sizeTb2<<(uint16_t)dlInfo.componentCarrierId);
-  // need to allow for RRC connection establishment + CQI feedback reception + persistent data transmission
-  if (Simulator::Now () > MilliSeconds (300))
-    {
-      if (m_ccDownlinkTraffic.find(dlInfo.componentCarrierId) == m_ccDownlinkTraffic.end())
-        {
-          m_ccDownlinkTraffic.insert (std::pair<uint8_t, uint32_t> (dlInfo.componentCarrierId, dlInfo.sizeTb1 + dlInfo.sizeTb2));
-        }
-      else
-        {
-          m_ccDownlinkTraffic[dlInfo.componentCarrierId]+= (dlInfo.sizeTb1 + dlInfo.sizeTb2);
-        }
-
-      m_dlThroughput += dlInfo.sizeTb1 + dlInfo.sizeTb2;
-    }
-}
-
-void
-CarrierAggregationTestCase::UlScheduling (uint32_t frameNo, uint32_t subframeNo, uint16_t rnti,
-                                       uint8_t mcs, uint16_t sizeTb, uint8_t componentCarrierId)
-{
-  //NS_LOG_FUNCTION (frameNo << subframeNo << rnti << (uint32_t) mcs << sizeTb);
-  // need to allow for RRC connection establishment + SRS transmission
-  if (Simulator::Now () > MilliSeconds (300))
-    {
-      if (m_ccUplinkTraffic.find(componentCarrierId) == m_ccUplinkTraffic.end())
-        {
-          m_ccUplinkTraffic.insert (std::pair<uint8_t, uint32_t> (componentCarrierId, sizeTb));
-        }
-      else
-        {
-          m_ccUplinkTraffic[componentCarrierId] += sizeTb;
-        }
-
-      m_ulThroughput += sizeTb;
-    }
-}
-
-void
-CarrierAggregationTestCase::WriteResultToFile ()
-{
-  std::ofstream dlOutFile;
-  dlOutFile.open (dlResultsFileName.c_str(), std::ofstream::out | std::ofstream::app);
-  dlOutFile.setf (std::ios_base::fixed);
-
-  if (!dlOutFile.is_open ())
-    {
-      NS_LOG_ERROR ("Can't open file "<<dlResultsFileName);
-      return;
-    }
-  dlOutFile << m_nUser <<" "<<m_numberOfComponentCarriers <<" "<< ((m_dlThroughput*8)/m_statsDuration)/m_nUser<<std::endl;
-  dlOutFile.close ();
-
-  std::ofstream ulOutFile;
-  ulOutFile.open (ulResultsFileName.c_str(), std::ofstream::out | std::ofstream::app);
-  ulOutFile.setf (std::ios_base::fixed);
-
-  if (!ulOutFile.is_open ())
-    {
-      NS_LOG_ERROR ("Can't open file "<<ulResultsFileName);
-      return;
-    }
-  ulOutFile << m_nUser <<" "<<m_numberOfComponentCarriers <<" "<< ((m_ulThroughput*8)/m_statsDuration)/m_nUser<<std::endl;
-  ulOutFile.close ();
-}
-
diff -Naru a/test/lte-test-carrier-aggregation.h b/test/lte-test-carrier-aggregation.h
--- a/test/lte-test-carrier-aggregation.h	2017-10-05 11:46:52.222494002 +0200
+++ b/test/lte-test-carrier-aggregation.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2016 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Biljana Bojovic <biljana.bojovic@cttc.es>
- *
- */
-
-#ifndef TEST_CARRIER_AGGREGATION_H
-#define TEST_CARRIER_AGGREGATION_H
-
-#include "ns3/simulator.h"
-#include "ns3/test.h"
-#include "fcntl.h"
-
-
-using namespace ns3;
-
-/**
- * \ingroup wifi-test
- * \ingroup tests wifi-test wifi module tests
- *
- * \brief This system test program creates different test cases with a single eNB and 
- * several UEs, all having the same Radio Bearer specification. In each test 
- * case, the UEs see the same SINR from the eNB; different test cases are 
- * implemented obtained by using different SINR values and different numbers of 
- * UEs. eNb and UEs are configured to use the secondary carrier and the component
- * carrier manager is configured to split the data equally between primary and
- * secondary carrier. The test consists of checking that the throughput
- * obtained over different carriers are equal within a given tolerance.
- */
-class CarrierAggregationTestCase : public TestCase
-{
-public:
-
-  static bool s_writeResults; ///< write results flag, determines whether to write results to outoput files
-
-  /**
-   * Constructor of test case
-   *
-   * \param nUser number of users
-   * \param dist the distance
-   * \param dlbandwidth the DL bandwidth
-   * \param ulBandwidth the UL badnwidth
-   * \param numberOfComponentCarriers number of component carriers to be used in test configuration
-   */
-  CarrierAggregationTestCase (uint16_t nUser, uint16_t dist, uint32_t dlbandwidth, uint32_t ulBandwidth, uint32_t numberOfComponentCarriers);
-  virtual ~CarrierAggregationTestCase ();
-  /**
-   * DL Scheduling function that is used in this test as callback function of DL scheduling trace
-   * \param dlInfo the DL scheduling callback info
-   */
-  void DlScheduling (DlSchedulingCallbackInfo dlInfo);
-  /**
-   * UL Scheduling function that is used in this test as callback function of UL sceduling trace
-   * \param frameNo the frame number
-   * \param subframeNo the subframe number
-   * \param rnti the RNTI
-   * \param mcs the MCS
-   * \param sizeTb
-   * \param componentCarrierId the component carrier ID
-   */
-  void UlScheduling (uint32_t frameNo, uint32_t subframeNo, uint16_t rnti, uint8_t mcs, uint16_t sizeTb, uint8_t componentCarrierId);
-  /// Write result to file function
-  void WriteResultToFile ();
-
-
-private:
-
-  virtual void DoRun (void);
-  /**
-   * Builds the test name string based on provided parameter values
-   * \param nUser number of users
-   * \param dist the distance
-   * \param dlBandwidth the DL bandwidth
-   * \param ulBandwidth the UL badnwidth
-   * \param numberOfComponentCarriers number of component carriers
-   * \returns the test name
-   */   
-  static std::string BuildNameString  (uint16_t nUser, uint16_t dist, uint32_t dlBandwidth, uint32_t ulBandwidth, uint32_t numberOfComponentCarriers);
-
-  uint16_t m_nUser; ///< the number of users
-  uint16_t m_dist; ///< the distance
-  uint32_t m_dlBandwidth; ///< DL bandwidth
-  uint32_t m_ulBandwidth; ///< UL bandwidth
-  uint32_t m_numberOfComponentCarriers; ///< number of component carriers
-
-  std::map <uint8_t, uint32_t> m_ccDownlinkTraffic; ///< CC DL traffic
-  std::map <uint8_t, uint32_t> m_ccUplinkTraffic; ///< CC UL traffic
-  uint64_t m_dlThroughput; ///< DL throughput
-  uint64_t m_ulThroughput; ///< UL throughput
-  double m_statsDuration; ///< stats duration
-};
-
-
-
-/**
- * \ingroup wifi-test
- * \ingroup tests
- *
- * \brief Test Carrier Aggregation Suite
- */
-class TestCarrierAggregationSuite : public TestSuite
-{
-public:
-  TestCarrierAggregationSuite ();
-};
-
-#endif /* TEST_CARRIER_AGGREGATION_H */
diff -Naru a/test/lte-test-earfcn.cc b/test/lte-test-earfcn.cc
--- a/test/lte-test-earfcn.cc	2017-10-05 11:46:52.222494002 +0200
+++ b/test/lte-test-earfcn.cc	2017-10-05 11:47:22.314601784 +0200
@@ -29,36 +29,21 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteTestEarfcn");
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Test case that is testing if the frequency is properly generated 
- * from provided EARFCN frequency.
- */
-
 class LteEarfcnTestCase : public TestCase
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param str referene name
-   * \param earfcn EARFCN
-   * \param f frequency
-   */
-  LteEarfcnTestCase (const char* str, uint32_t earfcn, double f);
+  LteEarfcnTestCase (const char* str, uint16_t earfcn, double f);
   virtual ~LteEarfcnTestCase ();
 
 protected:
-  uint32_t m_earfcn; ///< the EARFCN
-  double m_f; ///< the frequency
+  uint16_t m_earfcn;
+  double m_f;
 
 private:
   virtual void DoRun (void);
 };
 
-LteEarfcnTestCase::LteEarfcnTestCase (const char* str, uint32_t earfcn, double f)
+LteEarfcnTestCase::LteEarfcnTestCase (const char* str, uint16_t earfcn, double f)
   :   TestCase (str),
     m_earfcn (earfcn),
     m_f (f)
@@ -77,32 +62,16 @@
   NS_TEST_ASSERT_MSG_EQ_TOL (f, m_f, 0.0000001, "wrong frequency");
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief 
- * Test case that is testing if the downlink frequency is properly 
- * converted from provided downlink EARFCN frequency value.
- */
-
 class LteEarfcnDlTestCase : public LteEarfcnTestCase
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param str referene name
-   * \param earfcn EARFCN
-   * \param f frequency
-   */
-  LteEarfcnDlTestCase (const char* str, uint32_t earfcn, double f);
+  LteEarfcnDlTestCase (const char* str, uint16_t earfcn, double f);
 
 private:
   virtual void DoRun (void);
 };
 
-LteEarfcnDlTestCase::LteEarfcnDlTestCase (const char* str, uint32_t earfcn, double f)
+LteEarfcnDlTestCase::LteEarfcnDlTestCase (const char* str, uint16_t earfcn, double f)
   : LteEarfcnTestCase (str, earfcn, f)
 {
 }
@@ -119,31 +88,16 @@
 }
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief  Test case that is testing if the uplink frequency is properly 
- * converted from provided uplink EARFCN frequency value.
- */
-
 class LteEarfcnUlTestCase : public LteEarfcnTestCase
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param str referene name
-   * \param earfcn EARFCN
-   * \param f frequency
-   */
-  LteEarfcnUlTestCase (const char* str, uint32_t earfcn, double f);
+  LteEarfcnUlTestCase (const char* str, uint16_t earfcn, double f);
 
 private:
   virtual void DoRun (void);
 };
 
-LteEarfcnUlTestCase::LteEarfcnUlTestCase (const char* str, uint32_t earfcn, double f)
+LteEarfcnUlTestCase::LteEarfcnUlTestCase (const char* str, uint16_t earfcn, double f)
   : LteEarfcnTestCase (str, earfcn, f)
 {
 }
@@ -157,11 +111,7 @@
 
 
 /**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Test suite for testing correct conversion of frequencies in
- * the downlink and the uplink, and general EARFCN frequencies.
+ * Test the calculation of carrier frequency based on EARFCN
  */
 class LteEarfcnTestSuite : public TestSuite
 {
diff -Naru a/test/lte-test-entities.cc b/test/lte-test-entities.cc
--- a/test/lte-test-entities.cc	2017-10-05 11:46:52.222494002 +0200
+++ b/test/lte-test-entities.cc	2017-10-05 11:47:22.314601784 +0200
@@ -486,11 +486,11 @@
     }
   if (haveContext)
     {
-      Simulator::ScheduleWithContext (node->GetId (), time, &LteMacSapUser::NotifyTxOpportunity, m_macSapUser, bytes, 0, 0, 0, 0, 0);
+      Simulator::ScheduleWithContext (node->GetId (), time, &LteMacSapUser::NotifyTxOpportunity, m_macSapUser, bytes, 0, 0);
     }
   else
     {
-      Simulator::Schedule (time, &LteMacSapUser::NotifyTxOpportunity, m_macSapUser, bytes, 0, 0, 0, 0, 0);
+      Simulator::Schedule (time, &LteMacSapUser::NotifyTxOpportunity, m_macSapUser, bytes, 0, 0);
     }
     
   if (m_txOpportunityMode == RANDOM_MODE)
@@ -565,7 +565,7 @@
   else if (m_macLoopback)
     {
       Simulator::Schedule (Seconds (0.1), &LteMacSapUser::ReceivePdu,
-                           m_macLoopback->m_macSapUser, params.pdu, params.rnti, params.lcid);
+                           m_macLoopback->m_macSapUser, params.pdu);
     }
   else
     {
@@ -626,7 +626,7 @@
         {
           EventId e = Simulator::Schedule (time, 
                                            &LteMacSapUser::NotifyTxOpportunity,
-                                           m_macSapUser, m_txOppSize, 0, 0, 0, params.rnti, params.lcid);
+                                           m_macSapUser, m_txOppSize, 0, 0);
           m_nextTxOppList.push_back (e);
           size -= m_txOppSize;
           time += m_txOppTime;
@@ -644,7 +644,7 @@
   m_rxBytes += p->GetSize ();
 
   Ptr<Packet> packet = p->Copy ();
-  m_macSapUser->ReceivePdu (packet, 0, 0);
+  m_macSapUser->ReceivePdu (packet);
   return true;
 }
 
diff -Naru a/test/lte-test-entities.h b/test/lte-test-entities.h
--- a/test/lte-test-entities.h	2017-10-05 11:46:52.222494002 +0200
+++ b/test/lte-test-entities.h	2017-10-05 11:47:22.314601784 +0200
@@ -34,14 +34,10 @@
 namespace ns3 {
 
 /**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief This class implements a testing RRC entity
+ * This class implements a testing RRC entity
  */
 class LteTestRrc : public Object
 {
-    /// allow LtePdcpSpecificLtePdcpSapUser<LteTestRrc> class friend access
     friend class LtePdcpSpecificLtePdcpSapUser<LteTestRrc>;
 //   friend class EnbMacMemberLteEnbCmacSapProvider;
 //   friend class EnbMacMemberLteMacSapProvider<LteTestMac>;
@@ -50,10 +46,6 @@
 //   friend class EnbMacMemberLteEnbPhySapUser;
 
   public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
     static TypeId GetTypeId (void);
 
     LteTestRrc (void);
@@ -72,117 +64,59 @@
     */
     LtePdcpSapUser* GetLtePdcpSapUser (void);
 
-    /// Start function
     void Start ();
-    /// Stop function
     void Stop ();
 
-    /**
-    * \brief Send data function
-    * \param at the time to send
-    * \param dataToSend the data to send
-    */
     void SendData (Time at, std::string dataToSend);
-    /**
-    * \brief Get data received function
-    * \returns the received data string
-    */
     std::string GetDataReceived (void);
 
     // Stats
-    /**
-    * \brief Get the transmit PDUs
-    * \return the number of transmit PDUS
-    */
     uint32_t GetTxPdus (void);
-    /**
-    * \brief Get the transmit bytes
-    * \return the number of bytes transmitted
-    */
     uint32_t GetTxBytes (void);
-    /**
-    * \brief Get the receive PDUs
-    * \return the number of receive PDUS
-    */
     uint32_t GetRxPdus (void);
-    /**
-    * \brief Get the receive bytes
-    * \return the number of bytes received
-    */
     uint32_t GetRxBytes (void);
 
-    /**
-    * \brief Get the last transmit time
-    * \return the time of the last transmit
-    */
     Time GetTxLastTime (void);
-    /**
-    * \brief Get the last receive time
-    * \return the time of the last receive
-    */
     Time GetRxLastTime (void);
 
-    /**
-    * \brief Set the arrival time
-    * \param arrivalTime the arrival time
-    */
     void SetArrivalTime (Time arrivalTime);
-    /**
-    * \brief Set the PDU size
-    * \param pduSize the PDU size
-    */
     void SetPduSize (uint32_t pduSize);
 
-    /**
-    * \brief Set the device
-    * \param device the device
-    */
-    void SetDevice (Ptr<NetDevice> device);
+  void SetDevice (Ptr<NetDevice> device);
 
   private:
-    /**
-     * Interface forwarded by LtePdcpSapUser
-     * \param params the LtePdcpSapUser::ReceivePdcpSduParameters
-     */
+    // Interface forwarded by LtePdcpSapUser
     virtual void DoReceivePdcpSdu (LtePdcpSapUser::ReceivePdcpSduParameters params);
 
-    LtePdcpSapUser* m_pdcpSapUser; ///< PDCP SAP user
-    LtePdcpSapProvider* m_pdcpSapProvider; ///< PDCP SAP provider
+    LtePdcpSapUser* m_pdcpSapUser;
+    LtePdcpSapProvider* m_pdcpSapProvider;
 
-    std::string m_receivedData; ///< the received data
+    std::string m_receivedData;
 
-    uint32_t m_txPdus; ///< number of transmit PDUs
-    uint32_t m_txBytes; ///< number of transmit bytes
-    uint32_t m_rxPdus; ///< number of receive PDUs
-    uint32_t m_rxBytes; ///< number of receive bytes
-    Time     m_txLastTime; ///< last transmit time
-    Time     m_rxLastTime; ///< last reeive time
-
-    EventId m_nextPdu; ///< next PDU event
-    Time m_arrivalTime; ///< next arrival time
-    uint32_t m_pduSize; ///< PDU size
+    uint32_t m_txPdus;
+    uint32_t m_txBytes;
+    uint32_t m_rxPdus;
+    uint32_t m_rxBytes;
+    Time     m_txLastTime;
+    Time     m_rxLastTime;
+
+    EventId m_nextPdu;
+    Time m_arrivalTime;
+    uint32_t m_pduSize;
 
-    Ptr<NetDevice> m_device; ///< the device
+    Ptr<NetDevice> m_device;
 };
 
 /////////////////////////////////////////////////////////////////////
 
 /**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief This class implements a testing PDCP entity
+ * This class implements a testing PDCP entity
  */
 class LteTestPdcp : public Object
 {
-  /// allow LteRlcSpecificLteRlcSapUser<LteTestPdcp> class friend access
   friend class LteRlcSpecificLteRlcSapUser<LteTestPdcp>;
   
   public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
     static TypeId GetTypeId (void);
 
     LteTestPdcp (void);
@@ -201,88 +135,46 @@
     */
     LteRlcSapUser* GetLteRlcSapUser (void);
 
-    /// Start function
     void Start ();
 
-    /**
-    * \brief Send data function
-    * \param time the time to send
-    * \param dataToSend the data to send
-    */
     void SendData (Time time, std::string dataToSend);
-    /**
-    * \brief Get data received function
-    * \returns the received data string
-    */
     std::string GetDataReceived (void);
 
   private:
-    /**
-     * Interface forwarded by LteRlcSapUser
-     * \param p the PDCP PDU packet received
-     */
-    virtual void DoReceivePdcpPdu (Ptr<Packet> p);
+    // Interface forwarded by LteRlcSapUser
+  virtual void DoReceivePdcpPdu (Ptr<Packet> p);
 
-    LteRlcSapUser* m_rlcSapUser; ///< RLC SAP user
-    LteRlcSapProvider* m_rlcSapProvider; ///< RLC SAP provider
+    LteRlcSapUser* m_rlcSapUser;
+    LteRlcSapProvider* m_rlcSapProvider;
 
-    std::string m_receivedData; ///< the received data 
+    std::string m_receivedData;
 };
 
 /////////////////////////////////////////////////////////////////////
 
 /**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief This class implements a testing loopback MAC layer
+ * This class implements a testing loopback MAC layer
  */
 class LteTestMac : public Object
 {
 //   friend class EnbMacMemberLteEnbCmacSapProvider;
-    /// allow EnbMacMemberLteMacSapProvider<LteTestMac> class friend access
     friend class EnbMacMemberLteMacSapProvider<LteTestMac>;
 //   friend class EnbMacMemberFfMacSchedSapUser;
 //   friend class EnbMacMemberFfMacCschedSapUser;
 //   friend class EnbMacMemberLteEnbPhySapUser;
 
   public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
     static TypeId GetTypeId (void);
 
     LteTestMac (void);
     virtual ~LteTestMac (void);
     virtual void DoDispose (void);
 
-    /**
-    * \brief Set the device function
-    * \param device the device
-    */
     void SetDevice (Ptr<NetDevice> device);
 
-    /**
-    * \brief Send transmit opportunity function
-    * \param time the time
-    * \param bytes the number of bytes
-    */
-    void SendTxOpportunity (Time time, uint32_t bytes);
-    /**
-    * \brief Get data received function
-    * \returns the received data string
-    */
+    void SendTxOpportunity (Time, uint32_t);
     std::string GetDataReceived (void);
 
-    /**
-    * \brief the Receive function
-    * \param nd the device
-    * \param p the packet
-    * \param protocol the protocol
-    * \param addr the address
-    * \returns true if successful
-    */
     bool Receive (Ptr<NetDevice> nd, Ptr<const Packet> p, uint16_t protocol, const Address& addr);
 
     /**
@@ -303,119 +195,79 @@
     void SetLteMacLoopback (Ptr<LteTestMac> s);
 
     /**
-     * \brief Set PDCP header present function
-     * \param present true iif PDCP header present
+     *
      */
     void SetPdcpHeaderPresent (bool present);
 
     /**
-     * \brief Set RLC header type
-     * \param rlcHeaderType the RLC header type
+     *
      */
     void SetRlcHeaderType (uint8_t rlcHeaderType);
 
-    /// RCL Header Type enumeration
     typedef enum {
       UM_RLC_HEADER = 0,
       AM_RLC_HEADER = 1,
-    } RlcHeaderType_t; ///< the RLC header type
+    } RlcHeaderType_t;
 
     /**
-     * Set transmit opportunity mode
-     * \param mode the transmit opportunity mode
+     *
      */
     void SetTxOpportunityMode (uint8_t mode);
 
-    /// Transmit opportunity mode enumeration
     typedef enum {
       MANUAL_MODE     = 0,
       AUTOMATIC_MODE  = 1,
       RANDOM_MODE     = 2
-    } TxOpportunityMode_t; ///< transmit opportunity mode
+    } TxOpportunityMode_t;
 
-    /**
-     * Set transmit opportunity time
-     * \param txOppTime the transmit opportunity time
-     */
     void SetTxOppTime (Time txOppTime);
-    /**
-     * Set transmit opportunity time
-     * \param txOppSize the transmit opportunity size
-     */
     void SetTxOppSize (uint32_t txOppSize);
 
     // Stats
-    /**
-    * \brief Get the transmit PDUs
-    * \return the number of transmit PDUS
-    */
     uint32_t GetTxPdus (void);
-    /**
-    * \brief Get the transmit bytes
-    * \return the number of bytes transmitted
-    */
     uint32_t GetTxBytes (void);
-    /**
-    * \brief Get the receive PDUs
-    * \return the number of receive PDUS
-    */
     uint32_t GetRxPdus (void);
-    /**
-    * \brief Get the receive bytes
-    * \return the number of bytes received
-    */
     uint32_t GetRxBytes (void);
 
   private:
     // forwarded from LteMacSapProvider
-    /**
-     * Transmit PDU
-     * \param params LteMacSapProvider::TransmitPduParameters
-     */
-    void DoTransmitPdu (LteMacSapProvider::TransmitPduParameters params);
-    /**
-     * Report buffer status function
-     * \param params LteMacSapProvider::ReportBufferStatusParameters
-     */
-    void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters params);
+    void DoTransmitPdu (LteMacSapProvider::TransmitPduParameters);
+    void DoReportBufferStatus (LteMacSapProvider::ReportBufferStatusParameters);
 
-    LteMacSapProvider* m_macSapProvider; ///< MAC SAP provider
-    LteMacSapUser* m_macSapUser; ///< MAC SAP user
-    Ptr<LteTestMac> m_macLoopback; ///< MAC loopback
+    LteMacSapProvider* m_macSapProvider;
+    LteMacSapUser* m_macSapUser;
+    Ptr<LteTestMac> m_macLoopback;
 
-    std::string m_receivedData; ///< the received data string
+    std::string m_receivedData;
 
-    uint8_t m_rlcHeaderType; ///< RLC header type
-    bool m_pdcpHeaderPresent; ///< PDCP header present?
-    uint8_t m_txOpportunityMode; ///< transmit opportunity mode
+    uint8_t m_rlcHeaderType;
+    bool m_pdcpHeaderPresent;
+    uint8_t m_txOpportunityMode;
 
-    Ptr<NetDevice> m_device; ///< the device
+    Ptr<NetDevice> m_device;
 
     // TxOpportunity configuration
-    EventId m_nextTxOpp; ///< next transmit opportunity event
-    Time m_txOppTime; ///< transmit opportunity time
-    uint32_t m_txOppSize; ///< transmit opportunity size
-    std::list<EventId> m_nextTxOppList; ///< next transmit opportunity list
+    EventId m_nextTxOpp;
+    Time m_txOppTime;
+    uint32_t m_txOppSize;
+    std::list<EventId> m_nextTxOppList;
 
     // Stats
-    uint32_t m_txPdus; ///< the number of transmit PDUs
-    uint32_t m_txBytes; ///< the number of transmit bytes
-    uint32_t m_rxPdus; ///< the number of receive PDUs
-    uint32_t m_rxBytes; ///< the number of receive bytes
+    uint32_t m_txPdus;
+    uint32_t m_txBytes;
+    uint32_t m_rxPdus;
+    uint32_t m_rxBytes;
 
 };
 
 
 
 /**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief RRC stub providing a testing S1 SAP user to be used with the EpcEnbApplication
+ * RRC stub providing a testing S1 SAP user to be used with the EpcEnbApplication
+ * 
  */
 class EpcTestRrc : public Object
 {
-  /// allow MemberEpcEnbS1SapUser<EpcTestRrc> class friend access
   friend class MemberEpcEnbS1SapUser<EpcTestRrc>;
 
 public:
@@ -424,10 +276,6 @@
 
   // inherited from Object
   virtual void DoDispose (void);
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
   static TypeId GetTypeId (void);
 
   /** 
@@ -446,19 +294,11 @@
 private:
 
   // S1 SAP methods
-  /**
-   * Data radio bearer setup request
-   * \param params EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters
-   */
   void DoDataRadioBearerSetupRequest (EpcEnbS1SapUser::DataRadioBearerSetupRequestParameters params);
-  /**
-   * Path switch request acknowledge function
-   * \param params EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters
-   */
   void DoPathSwitchRequestAcknowledge (EpcEnbS1SapUser::PathSwitchRequestAcknowledgeParameters params);  
   
-  EpcEnbS1SapProvider* m_s1SapProvider; ///< S1 SAP provider
-  EpcEnbS1SapUser* m_s1SapUser; ///< S1 SAP user
+  EpcEnbS1SapProvider* m_s1SapProvider;
+  EpcEnbS1SapUser* m_s1SapUser;
   
 
 };
diff -Naru a/test/lte-test-mimo.cc b/test/lte-test-mimo.cc
--- a/test/lte-test-mimo.cc	2017-10-05 11:46:52.226494017 +0200
+++ b/test/lte-test-mimo.cc	2017-10-05 11:47:22.314601784 +0200
@@ -198,7 +198,7 @@
   Ptr<LteEnbNetDevice> enbNetDev = enbDevs.Get (0)->GetObject<LteEnbNetDevice> ();
   
   PointerValue ptrval;
-  enbNetDev->GetCcMap()[0]->GetAttribute ("FfMacScheduler", ptrval);
+  enbNetDev->GetAttribute ("FfMacScheduler", ptrval);
   Ptr<PfFfMacScheduler> pfsched;
   Ptr<RrFfMacScheduler> rrsched;
   if (m_schedulerType.compare ("ns3::RrFfMacScheduler") == 0)
diff -Naru a/test/lte-test-mimo.h b/test/lte-test-mimo.h
--- a/test/lte-test-mimo.h	2017-10-05 11:46:52.226494017 +0200
+++ b/test/lte-test-mimo.h	2017-10-05 11:47:22.314601784 +0200
@@ -29,63 +29,30 @@
 
 
 /**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief This system test program creates different test cases with a 
- * single eNB and single UE. The traffic is configured to be in saturation 
- * mode. It is checked if the throughput reaches the expected values 
- * when MIMO is used.
+ * This system test program creates different test cases with a single eNB...
  */
 class LenaMimoTestCase : public TestCase
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param dist the distance
-   * \param estThrDl the estimated throughput DL
-   * \param schedulerType the scheduler type
-   * \param useIdealRrc true if use ideal RRC
-   */
   LenaMimoTestCase (uint16_t dist, std::vector<uint32_t> estThrDl, std::string schedulerType, bool useIdealRrc);
   virtual ~LenaMimoTestCase ();
 
 private:
   virtual void DoRun (void);
   
-  /**
-   * Get RLC buffer sample
-   * \param rlcStats Ptr<RadioBearerStatsCalculator>
-   * \param imsi the IMSI
-   * \param rnti the RNTI
-   */
   void GetRlcBufferSample (Ptr<RadioBearerStatsCalculator> rlcStats, uint64_t imsi, uint8_t rnti);
   
-  /**
-   * Builds the test name string based on provided parameter values
-   * \param dist the distance
-   * \param schedulerType the scheduler type
-   * \param useIdealRrc if true use the ideal RRC
-   * \returns the name string
-   */
   static std::string BuildNameString (uint16_t dist, std::string schedulerType, bool useIdealRrc);
-  uint16_t m_dist; ///< the distance
-  std::vector<uint32_t> m_estThrDl; ///< estimated throughput DL
-  std::string m_schedulerType; ///< the scheduler type
-  bool m_useIdealRrc; ///< whether to use the ideal RRC
+  uint16_t m_dist;
+  std::vector<uint32_t> m_estThrDl;
+  std::string m_schedulerType;
+  bool m_useIdealRrc;
   
-  std::vector <uint64_t> m_dlDataRxed; ///< DL data received
+  std::vector <uint64_t> m_dlDataRxed;
 
 };
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Lena Test Mimo Suite
- */
 
 class LenaTestMimoSuite : public TestSuite
 {
diff -Naru a/test/lte-test-secondary-cell-selection.cc b/test/lte-test-secondary-cell-selection.cc
--- a/test/lte-test-secondary-cell-selection.cc	2017-10-05 11:46:52.226494017 +0200
+++ b/test/lte-test-secondary-cell-selection.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,199 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2017 Alexander Krotov
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Alexander Krotov <krotov@iitp.ru>
- *
- */
-
-#include "lte-test-secondary-cell-selection.h"
-
-#include <ns3/boolean.h>
-#include <ns3/double.h>
-#include <ns3/integer.h>
-#include <ns3/log.h>
-#include <ns3/simulator.h>
-
-#include <ns3/internet-stack-helper.h>
-#include <ns3/ipv4-address-helper.h>
-#include <ns3/ipv4-interface-container.h>
-#include <ns3/friis-spectrum-propagation-loss.h>
-#include <ns3/ipv4-static-routing-helper.h>
-#include <ns3/lte-enb-net-device.h>
-#include <ns3/lte-helper.h>
-#include <ns3/lte-ue-net-device.h>
-#include <ns3/lte-ue-rrc.h>
-#include <ns3/mobility-helper.h>
-#include <ns3/net-device-container.h>
-#include <ns3/node-container.h>
-#include <ns3/point-to-point-epc-helper.h>
-#include <ns3/point-to-point-helper.h>
-
-using namespace ns3;
-
-NS_LOG_COMPONENT_DEFINE ("LteSecondaryCellSelectionTest");
-
-/*
- * Test Suite
- */
-
-LteSecondaryCellSelectionTestSuite::LteSecondaryCellSelectionTestSuite ()
-  : TestSuite ("lte-secondary-cell-selection", SYSTEM)
-{
-  // REAL RRC PROTOCOL
-
-  AddTestCase (new LteSecondaryCellSelectionTestCase ("EPC, real RRC, RngRun=1", false, 1, 2), TestCase::QUICK);
-  AddTestCase (new LteSecondaryCellSelectionTestCase ("EPC, real RRC, RngRun=1", false, 1, 4), TestCase::QUICK);
-
-  // IDEAL RRC PROTOCOL
-
-  AddTestCase (new LteSecondaryCellSelectionTestCase ("EPC, ideal RRC, RngRun=1", true, 1, 2), TestCase::QUICK);
-  AddTestCase (new LteSecondaryCellSelectionTestCase ("EPC, ideal RRC, RngRun=1", true, 1, 4), TestCase::QUICK);
-
-} // end of LteSecondaryCellSelectionTestSuite::LteSecondaryCellSelectionTestSuite ()
-
-static LteSecondaryCellSelectionTestSuite g_lteSecondaryCellSelectionTestSuite;
-
-/*
- * Test Case
- */
-
-LteSecondaryCellSelectionTestCase::LteSecondaryCellSelectionTestCase (
-  std::string name, bool isIdealRrc, int64_t rngRun, uint8_t numberOfComponentCarriers)
-  : TestCase (name),
-    m_isIdealRrc (isIdealRrc),
-    m_rngRun (rngRun),
-    m_numberOfComponentCarriers (numberOfComponentCarriers)
-{
-  NS_LOG_FUNCTION (this << GetName ());
-}
-
-
-LteSecondaryCellSelectionTestCase::~LteSecondaryCellSelectionTestCase ()
-{
-  NS_LOG_FUNCTION (this << GetName ());
-}
-
-void
-LteSecondaryCellSelectionTestCase::DoRun ()
-{
-  NS_LOG_FUNCTION (this << GetName ());
-
-  Config::SetGlobal ("RngRun", IntegerValue (m_rngRun));
-
-  // Create helpers.
-  auto lteHelper = CreateObject<LteHelper> ();
-  lteHelper->SetAttribute ("PathlossModel", TypeIdValue (ns3::FriisSpectrumPropagationLossModel::GetTypeId ()));
-  lteHelper->SetAttribute ("UseIdealRrc", BooleanValue (m_isIdealRrc));
-  lteHelper->SetAttribute ("NumberOfComponentCarriers", UintegerValue (m_numberOfComponentCarriers));
-
-  auto epcHelper = CreateObject<PointToPointEpcHelper> ();
-  lteHelper->SetEpcHelper (epcHelper);
-
-  auto cch = CreateObject<CcHelper> ();
-  cch->SetUlEarfcn (100 + 18000);
-  cch->SetDlEarfcn (100);
-  cch->SetUlBandwidth (25);
-  cch->SetDlBandwidth (25);
-  cch->SetNumberOfComponentCarriers (m_numberOfComponentCarriers);
-
-  const auto ccm = cch->EquallySpacedCcs ();
-  lteHelper->SetCcPhyParams (ccm);
-  
-  // Create nodes.
-  auto enbNode = CreateObject<Node> ();
-  NodeContainer ueNodes;
-  ueNodes.Create (m_numberOfComponentCarriers);
-
-  MobilityHelper mobility;
-  mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
-  mobility.Install (enbNode);
-  mobility.Install (ueNodes);
-
-  // Physical layer.
-  auto enbDev = DynamicCast<LteEnbNetDevice> (lteHelper->InstallEnbDevice (enbNode).Get (0));
-  auto ueDevs = lteHelper->InstallUeDevice (ueNodes);
-
-  // Network layer.
-  InternetStackHelper internet;
-  internet.Install (ueNodes);
-  epcHelper->AssignUeIpv4Address (ueDevs);
-
-  for (auto &it: ccm)
-    {
-      std::cerr << "Assign " << it.second.GetDlEarfcn () << std::endl;
-      DynamicCast<LteUeNetDevice> (ueDevs.Get (it.first))->SetDlEarfcn (it.second.GetDlEarfcn ());
-    }
-
-  // Enable Idle mode cell selection.
-  lteHelper->Attach (ueDevs);
-
-  // Connect to trace sources in UEs
-  Config::Connect ("/NodeList/*/DeviceList/*/LteUeRrc/StateTransition",
-                   MakeCallback (&LteSecondaryCellSelectionTestCase::StateTransitionCallback,
-                                 this));
-  Config::Connect ("/NodeList/*/DeviceList/*/LteUeRrc/InitialSecondaryCellSelectionEndOk",
-                   MakeCallback (&LteSecondaryCellSelectionTestCase::InitialSecondaryCellSelectionEndOkCallback,
-                                 this));
-  Config::Connect ("/NodeList/*/DeviceList/*/LteUeRrc/ConnectionEstablished",
-                   MakeCallback (&LteSecondaryCellSelectionTestCase::ConnectionEstablishedCallback,
-                                 this));
-
-  // Run simulation.
-  Simulator::Stop (Seconds (2.0));
-  Simulator::Run ();
-
-  for (auto &it: enbDev->GetCcMap ())
-    {
-      auto ueDev = DynamicCast<LteUeNetDevice> (ueDevs.Get (it.first));
-      uint16_t expectedCellId = it.second->GetCellId ();
-      uint16_t actualCellId = ueDev->GetRrc ()->GetCellId ();
-      NS_TEST_ASSERT_MSG_EQ (expectedCellId, actualCellId, "IMSI " << ueDev->GetImsi () << " has attached to an unexpected cell");
-
-      NS_TEST_ASSERT_MSG_EQ (m_lastState.at (ueDev->GetImsi ()),
-                             LteUeRrc::CONNECTED_NORMALLY,
-                             "UE " << ueDev->GetImsi ()
-                                   << " is not at CONNECTED_NORMALLY state");
-    }
-
-  // Destroy simulator.
-  Simulator::Destroy ();
-} // end of void LteSecondaryCellSelectionTestCase::DoRun ()
-
-
-void
-LteSecondaryCellSelectionTestCase::StateTransitionCallback (
-  std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti,
-  LteUeRrc::State oldState, LteUeRrc::State newState)
-{
-  NS_LOG_FUNCTION (this << imsi << cellId << rnti << oldState << newState);
-  m_lastState[imsi] = newState;
-}
-
-
-void
-LteSecondaryCellSelectionTestCase::InitialSecondaryCellSelectionEndOkCallback (
-  std::string context, uint64_t imsi, uint16_t cellId)
-{
-  NS_LOG_FUNCTION (this << imsi << cellId);
-}
-
-void
-LteSecondaryCellSelectionTestCase::ConnectionEstablishedCallback (
-  std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)
-{
-  NS_LOG_FUNCTION (this << imsi << cellId << rnti);
-}
diff -Naru a/test/lte-test-secondary-cell-selection.h b/test/lte-test-secondary-cell-selection.h
--- a/test/lte-test-secondary-cell-selection.h	2017-10-05 11:46:52.226494017 +0200
+++ b/test/lte-test-secondary-cell-selection.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2017 Alexander Krotov
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Alexander Krotov <krotov@iitp.ru>
- *
- */
-
-#ifndef LTE_TEST_SECONDARY_CELL_SELECTION_H
-#define LTE_TEST_SECONDARY_CELL_SELECTION_H
-
-#include <ns3/test.h>
-#include <ns3/nstime.h>
-#include <ns3/node-container.h>
-#include <ns3/vector.h>
-#include <ns3/lte-ue-rrc.h>
-#include <vector>
-
-using namespace ns3;
-
-/**
- * \brief Test suite for executing the secondary cell selection test cases.
- *
- * \sa ns3::LteSecondaryCellSelectionTestCase
- */
-class LteSecondaryCellSelectionTestSuite : public TestSuite
-{
-public:
-  LteSecondaryCellSelectionTestSuite ();
-};
-
-
-
-
-/**
- * \ingroup lte
- *
- * \brief Testing the initial cell selection procedure by UE at IDLE state in
- *        the beginning of simulation with multiple component carriers.
- */
-class LteSecondaryCellSelectionTestCase : public TestCase
-{
-public:
-  /**
-   * \brief Creates an instance of the initial cell selection test case.
-   * \param name name of this test
-   * \param isIdealRrc if true, simulation uses Ideal RRC protocol, otherwise
-   *                   simulation uses Real RRC protocol
-   * \param rngRun the number of run to be used by the random number generator
-   * \param numberOfComponentCarriers number of component carriers
-   */
-  LteSecondaryCellSelectionTestCase (std::string name, bool isIdealRrc, int64_t rngRun, uint8_t numberOfComponentCarriers);
-
-  virtual ~LteSecondaryCellSelectionTestCase ();
-
-private:
-  /**
-   * \brief Setup the simulation according to the configuration set by the
-   *        class constructor, run it, and verify the result.
-   */
-  virtual void DoRun ();
-
-  /**
-   * \brief State transition callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellId the cell ID
-   * \param rnti the RNTI
-   * \param oldState the old state
-   * \param newState the new state
-   */
-  void StateTransitionCallback (std::string context, uint64_t imsi,
-                                uint16_t cellId, uint16_t rnti,
-                                LteUeRrc::State oldState, LteUeRrc::State newState);
-  /**
-   * \brief Initial cell selection end ok callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellId the cell ID
-   */
-  void InitialSecondaryCellSelectionEndOkCallback (std::string context, uint64_t imsi,
-                                          uint16_t cellId);
-  /**
-   * \brief Connection established callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellId the cell ID
-   * \param rnti the RNTI
-   */
-  void ConnectionEstablishedCallback (std::string context, uint64_t imsi,
-                                      uint16_t cellId, uint16_t rnti);
-
-  bool m_isIdealRrc; ///< whether the LTE is configured to use ideal RRC
-  int64_t m_rngRun; ///< rng run
-  uint8_t m_numberOfComponentCarriers; ///< number of component carriers
-
-  /// The current UE RRC state.
-  std::map<uint64_t, LteUeRrc::State> m_lastState;
-
-}; // end of class LteSecondaryCellSelectionTestCase
-
-#endif /* LTE_TEST_SECONDARY_CELL_SELECTION_H */
diff -Naru a/test/test-asn1-encoding.cc b/test/test-asn1-encoding.cc
--- a/test/test-asn1-encoding.cc	2017-10-05 11:46:52.230494031 +0200
+++ b/test/test-asn1-encoding.cc	2017-10-05 11:47:22.314601784 +0200
@@ -34,20 +34,10 @@
 
 NS_LOG_COMPONENT_DEFINE ("Asn1EncodingTest");
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Contains ASN encoding test utility functions.
- */
 class TestUtils
 {
 public:
-  /**
-   * Function to convert packet contents in hex format
-   * \param pkt the packet
-   * \returns the text string
-   */
+  // Function to convert packet contents in hex format
   static std::string sprintPacketContentsHex (Ptr<Packet> pkt)
   {
     uint32_t psize = pkt->GetSize ();
@@ -61,11 +51,7 @@
     return std::string (sbuffer);
   }
 
-  /**
-   * Function to convert packet contents in binary format
-   * \param pkt the packet
-   * \returns the text string
-   */
+  // Function to convert packet contents in binary format
   static std::string sprintPacketContentsBin (Ptr<Packet> pkt)
   {
     uint32_t psize = pkt->GetSize ();
@@ -79,10 +65,7 @@
     return std::string (oss.str () + "\n");
   }
 
-  /**
-   * Function to log packet contents
-   * \param pkt the packet
-   */
+  // Function to log packet contents
   static void LogPacketContents (Ptr<Packet> pkt)
   {
     NS_LOG_DEBUG ("---- SERIALIZED PACKET CONTENTS (HEX): -------");
@@ -90,11 +73,6 @@
     NS_LOG_DEBUG ("Bin: " << TestUtils::sprintPacketContentsBin (pkt));
   }
 
-  /**
-   * Function to log packet info
-   * \param source T
-   * \param s the string
-   */
   template <class T>
   static void LogPacketInfo (T source,std::string s)
   {
@@ -107,35 +85,19 @@
 
 // --------------------------- CLASS RrcHeaderTestCase -----------------------------
 /**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief This class provides common functions to be inherited
+ * This class provides common functions to be inherited
  * by the children TestCases
  */
 class RrcHeaderTestCase : public TestCase
 {
 public:
-  /**
-   * Constructor
-   * \param s the reference name
-   */
   RrcHeaderTestCase (std::string s);
   virtual void DoRun (void) = 0;
-  /**
-   * \brief Create radio resoure config dedicated
-   * \returns LteRrcSap::RadioResourceConfigDedicated
-   */
   LteRrcSap::RadioResourceConfigDedicated CreateRadioResourceConfigDedicated ();
-  /**
-   * \brief Assert equal radio resource config dedicated
-   * \param rrcd1 LteRrcSap::RadioResourceConfigDedicated # 1
-   * \param rrcd2 LteRrcSap::RadioResourceConfigDedicated # 2
-   */
   void AssertEqualRadioResourceConfigDedicated (LteRrcSap::RadioResourceConfigDedicated rrcd1, LteRrcSap::RadioResourceConfigDedicated rrcd2);
 
 protected:
-  Ptr<Packet> packet; ///< the packet
+  Ptr<Packet> packet;
 };
 
 RrcHeaderTestCase::RrcHeaderTestCase (std::string s) : TestCase (s)
@@ -291,12 +253,7 @@
     }
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Request Test Case
- */
+// --------------------------- CLASS RrcConnectionRequestTestCase -----------------------------
 class RrcConnectionRequestTestCase : public RrcHeaderTestCase
 {
 public:
@@ -343,12 +300,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Setup Test Case
- */
+// --------------------------- CLASS RrcConnectionSetupTestCase -----------------------------
 class RrcConnectionSetupTestCase : public RrcHeaderTestCase
 {
 public:
@@ -397,12 +349,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Setup Complete Test Case
- */
+// --------------------------- CLASS RrcConnectionSetupCompleteTestCase -----------------------------
 class RrcConnectionSetupCompleteTestCase : public RrcHeaderTestCase
 {
 public:
@@ -448,12 +395,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Reconfiguration Complete Test Case
- */
+// --------------------------- CLASS RrcConnectionReconfigurationCompleteTestCase -----------------------------
 class RrcConnectionReconfigurationCompleteTestCase : public RrcHeaderTestCase
 {
 public:
@@ -500,12 +442,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Reconfiguration Test Case
- */
+// --------------------------- CLASS RrcConnectionReconfigurationTestCase -----------------------------
 class RrcConnectionReconfigurationTestCase : public RrcHeaderTestCase
 {
 public:
@@ -637,7 +574,6 @@
 
   msg.radioResourceConfigDedicated = CreateRadioResourceConfigDedicated ();
 
-  msg.haveNonCriticalExtension = false; //Danilo
   RrcConnectionReconfigurationHeader source;
   source.SetMessage (msg);
 
@@ -710,12 +646,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Handover Preparation Info Test Case
- */
+// --------------------------- CLASS HandoverPreparationInfoTestCase -----------------------------
 class HandoverPreparationInfoTestCase : public RrcHeaderTestCase
 {
 public:
@@ -789,12 +720,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Reestablishment Request Test Case
- */
+// --------------------------- CLASS RrcConnectionReestablishmentRequestTestCase -----------------------------
 class RrcConnectionReestablishmentRequestTestCase : public RrcHeaderTestCase
 {
 public:
@@ -844,12 +770,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Reestablishment Test Case
- */
+// --------------------------- CLASS RrcConnectionReestablishmentTestCase -----------------------------
 class RrcConnectionReestablishmentTestCase : public RrcHeaderTestCase
 {
 public:
@@ -897,12 +818,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Reestablishment Complete Test Case
- */
+// --------------------------- CLASS RrcConnectionReestablishmentCompleteTestCase -----------------------------
 class RrcConnectionReestablishmentCompleteTestCase : public RrcHeaderTestCase
 {
 public:
@@ -948,12 +864,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Rrc Connection Reject Test Case
- */
+// --------------------------- CLASS RrcConnectionRejectTestCase -----------------------------
 class RrcConnectionRejectTestCase : public RrcHeaderTestCase
 {
 public:
@@ -999,12 +910,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Measurement Report Test Case
- */
+// --------------------------- CLASS MeasurementReportTestCase -----------------------------
 class MeasurementReportTestCase : public RrcHeaderTestCase
 {
 public:
@@ -1040,7 +946,6 @@
   mResEutra.cgiInfo.trackingAreaCode = 5;
   msg.measResults.measResultListEutra.push_back (mResEutra);
 
-  msg.measResults.haveScellsMeas = false;
 
   MeasurementReportHeader source;
   source.SetMessage (msg);
@@ -1115,12 +1020,7 @@
   packet = 0;
 }
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Asn1Encoding Test Suite
- */
+// --------------------------- CLASS Asn1EncodingSuite -----------------------------
 class Asn1EncodingSuite : public TestSuite
 {
 public:
diff -Naru a/test/test-lte-handover-delay.cc b/test/test-lte-handover-delay.cc
--- a/test/test-lte-handover-delay.cc	2017-10-05 11:46:52.230494031 +0200
+++ b/test/test-lte-handover-delay.cc	2017-10-05 11:47:22.314601784 +0200
@@ -16,7 +16,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  * Author: Budiarto Herman <budiarto.herman@magister.fi>
- *         Alexander Krotov <krotov@iitp.ru>
  */
 
 #include <ns3/test.h>
@@ -49,29 +48,16 @@
 
 NS_LOG_COMPONENT_DEFINE("LteHandoverDelayTest");
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Verifying that the time needed for handover is under a 
- * specified threshold.
+/*
+ * HANDOVER DELAY TEST CASE
  */
 
 class LteHandoverDelayTestCase : public TestCase
 {
 public:
-  /**
-   * Constructor
-   *
-   * \param useIdealRrc if true, use the ideal RRC
-   * \param handoverTime the time of handover
-   * \param delayThreshold the delay threshold
-   * \param simulationDuration duration of the simulation
-   */
-  LteHandoverDelayTestCase (uint8_t numberOfComponentCarriers, bool useIdealRrc, Time handoverTime,
+  LteHandoverDelayTestCase (bool useIdealRrc, Time handoverTime,
       Time delayThreshold, Time simulationDuration)
       : TestCase ("Verifying that the time needed for handover is under a specified threshold"),
-        m_numberOfComponentCarriers (numberOfComponentCarriers),
         m_useIdealRrc (useIdealRrc),
         m_handoverTime (handoverTime),
         m_delayThreshold (delayThreshold),
@@ -83,53 +69,22 @@
 private:
   virtual void DoRun (void);
 
-  /**
-   * UE handover start callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellid the cell ID
-   * \param rnti the RNTI
-   * \param targetCellId the target cell ID
-   */
   void UeHandoverStartCallback (std::string context, uint64_t imsi,
       uint16_t cellid, uint16_t rnti, uint16_t targetCellId);
-  /**
-   * UE handover end OK callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellid the cell ID
-   * \param rnti the RNTI
-   */
   void UeHandoverEndOkCallback (std::string context, uint64_t imsi,
       uint16_t cellid, uint16_t rnti);
-  /**
-   * ENB handover start callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellid the cell ID
-   * \param rnti the RNTI
-   * \param targetCellId the target cell ID
-   */
   void EnbHandoverStartCallback (std::string context, uint64_t imsi,
       uint16_t cellid, uint16_t rnti, uint16_t targetCellId);
-  /**
-   * ENB handover end OK callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellid the cell ID
-   * \param rnti the RNTI
-   */
   void EnbHandoverEndOkCallback (std::string context, uint64_t imsi,
       uint16_t cellid, uint16_t rnti);
 
-  uint8_t m_numberOfComponentCarriers;
-  bool m_useIdealRrc; ///< use ideal RRC?
-  Time m_handoverTime; ///< handover time
-  Time m_delayThreshold; ///< the delay threshold
-  Time m_simulationDuration; ///< the simulation duration
+  bool m_useIdealRrc;
+  Time m_handoverTime;
+  Time m_delayThreshold;
+  Time m_simulationDuration;
 
-  Time m_ueHandoverStart; ///< UE handover start time
-  Time m_enbHandoverStart; ///< ENB handover start time
+  Time m_ueHandoverStart;
+  Time m_enbHandoverStart;
 };
 
 
@@ -139,38 +94,59 @@
   NS_LOG_INFO ("-----test case: ideal RRC = " << m_useIdealRrc
       << " handover time = " << m_handoverTime.GetSeconds () << "-----");
 
-  /*
-   * Helpers.
-   */
-  auto epcHelper = CreateObject<PointToPointEpcHelper> ();
-
-  auto lteHelper = CreateObject<LteHelper> ();
+  Ptr<LteHelper> lteHelper = CreateObject<LteHelper> ();
+  Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper> ();
   lteHelper->SetEpcHelper (epcHelper);
-  lteHelper->SetAttribute ("UseIdealRrc", BooleanValue (m_useIdealRrc));
-  lteHelper->SetAttribute ("NumberOfComponentCarriers", UintegerValue (m_numberOfComponentCarriers));
+  lteHelper->SetAttribute ("UseIdealRrc", BooleanValue(m_useIdealRrc));
 
-  auto ccHelper = CreateObject<CcHelper> ();
-  ccHelper->SetUlEarfcn (100 + 18000);
-  ccHelper->SetDlEarfcn (100);
-  ccHelper->SetUlBandwidth (25);
-  ccHelper->SetDlBandwidth (25);
-  ccHelper->SetNumberOfComponentCarriers (m_numberOfComponentCarriers);
+  // SETUP A REMOTE HOST
 
-  /*
-   * Physical layer.
-   *
+  NodeContainer remoteHosts;
+  remoteHosts.Create (1);
+  InternetStackHelper inetStackHelper;
+  inetStackHelper.Install (remoteHosts);
+
+  // SETUP POINT-TO-POINT CONNECTION BETWEEN REMOTE HOST AND EPC
+
+  PointToPointHelper p2pHelper;
+  p2pHelper.SetDeviceAttribute ("DataRate",
+      DataRateValue (DataRate ("100Gb/s")));
+  p2pHelper.SetDeviceAttribute ("Mtu", UintegerValue (1500));
+  p2pHelper.SetChannelAttribute ("Delay", TimeValue (Seconds (0.010)));
+
+  NetDeviceContainer inetDevs = p2pHelper.Install (epcHelper->GetPgwNode (),
+      remoteHosts.Get (0));
+
+  Ipv4AddressHelper addrHelper;
+  addrHelper.SetBase ("10.1.1.0", "255.255.255.0");
+  Ipv4InterfaceContainer inetIfs;
+  inetIfs = addrHelper.Assign (inetDevs);
+
+  // SETUP ROUTING
+
+  Ipv4StaticRoutingHelper ipRoutingHelper;
+  Ptr<Ipv4StaticRouting> remoteHostRouting =
+      ipRoutingHelper.GetStaticRouting (remoteHosts.Get (0)->GetObject<Ipv4> ());
+  remoteHostRouting->AddNetworkRouteTo (Ipv4Address ("7.0.0.0"),
+      Ipv4Mask ("255.0.0.0"), 1);
+
+  // CREATE NODES
+
+  NodeContainer enbNodes;
+  NodeContainer ueNodes;
+  enbNodes.Create (2);
+  ueNodes.Create (1);
+
+  /**
    * eNodeB 0                    UE                      eNodeB 1
    *
    *    x ----------------------- x ----------------------- x
    *              500 m                      500 m
    */
-  // Create nodes.
-  NodeContainer enbNodes;
-  enbNodes.Create (2);
-  auto ueNode = CreateObject<Node> ();
 
-  // Setup mobility
-  auto posAlloc = CreateObject<ListPositionAllocator> ();
+  // SETUP MOBILITY
+
+  Ptr<ListPositionAllocator> posAlloc = CreateObject<ListPositionAllocator> ();
   posAlloc->Add (Vector (0, 0, 0));
   posAlloc->Add (Vector (1000, 0, 0));
   posAlloc->Add (Vector (500, 0, 0));
@@ -179,23 +155,30 @@
   mobilityHelper.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
   mobilityHelper.SetPositionAllocator (posAlloc);
   mobilityHelper.Install (enbNodes);
-  mobilityHelper.Install (ueNode);
+  mobilityHelper.Install (ueNodes);
 
-  /*
-   * Link layer.
-   */
-  auto enbDevs = lteHelper->InstallEnbDevice (enbNodes);
-  auto ueDev = lteHelper->InstallUeDevice (ueNode).Get (0);
+  // SETUP LTE DEVICES
 
-  /*
-   * Network layer.
-   */
-  InternetStackHelper inetStackHelper;
-  inetStackHelper.Install (ueNode);
+  NetDeviceContainer enbDevs;
+  NetDeviceContainer ueDevs;
+  enbDevs = lteHelper->InstallEnbDevice (enbNodes);
+  ueDevs = lteHelper->InstallUeDevice (ueNodes);
+
+  // SETUP INTERNET IN UE
+
+  inetStackHelper.Install(ueNodes);
   Ipv4InterfaceContainer ueIfs;
-  ueIfs = epcHelper->AssignUeIpv4Address (ueDev);
+  ueIfs = epcHelper->AssignUeIpv4Address (ueDevs);
+
+  // SETUP DEFAULT GATEWAY FOR UE
+
+  Ptr<Ipv4StaticRouting> ueStaticRouting =
+      ipRoutingHelper.GetStaticRouting (ueNodes.Get (0)->GetObject<Ipv4> ());
+  ueStaticRouting->SetDefaultRoute (epcHelper->GetUeDefaultGatewayAddress (),
+      1);
+
+  // INSTALLING TRACES
 
-  // Setup traces.
   Config::Connect ("/NodeList/*/DeviceList/*/LteUeRrc/HandoverStart",
       MakeCallback (&LteHandoverDelayTestCase::UeHandoverStartCallback, this));
   Config::Connect ("/NodeList/*/DeviceList/*/LteUeRrc/HandoverEndOk",
@@ -206,12 +189,15 @@
   Config::Connect ("/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk",
       MakeCallback (&LteHandoverDelayTestCase::EnbHandoverEndOkCallback, this));
 
-  // Prepare handover.
-  lteHelper->AddX2Interface (enbNodes);
-  lteHelper->Attach (ueDev, enbDevs.Get(0));
-  lteHelper->HandoverRequest (m_handoverTime, ueDev, enbDevs.Get (0), enbDevs.Get (1));
+  // SIMULATION
 
-  // Run simulation.
+  lteHelper->AddX2Interface (enbNodes);
+  lteHelper->Attach (ueDevs.Get(0), enbDevs.Get(0));
+  lteHelper->HandoverRequest (m_handoverTime, ueDevs.Get (0), enbDevs.Get (0),
+      enbDevs.Get (1));
+  // disable error model in dl ctrl channel
+  //Config::Set ("/NodeList/*/DeviceList/*/LteUePhy/DlSpectrumPhy/CtrlErrorModelEnabled",
+  //    BooleanValue (false));
   Simulator::Stop (m_simulationDuration);
   Simulator::Run ();
   Simulator::Destroy ();
@@ -266,11 +252,8 @@
 
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Lte Handover Delay Test Suite
+/*
+ * TEST SUITE
  */
 
 static class LteHandoverDelayTestSuite : public TestSuite
@@ -290,7 +273,7 @@
       {
         // arguments: useIdealRrc, handoverTime, delayThreshold, simulationDuration
         AddTestCase (
-            new LteHandoverDelayTestCase (1, true, handoverTime, Seconds (0.005),
+            new LteHandoverDelayTestCase (true, handoverTime, Seconds (0.005),
                 Seconds (0.200)), TestCase::QUICK);
       }
 
@@ -301,8 +284,8 @@
       {
         // arguments: useIdealRrc, handoverTime, delayThreshold, simulationDuration
         AddTestCase (
-            new LteHandoverDelayTestCase (1, false, handoverTime, Seconds (0.020),
+            new LteHandoverDelayTestCase (false, handoverTime, Seconds (0.020),
                 Seconds (0.200)), TestCase::QUICK);
       }
   }
-} g_lteHandoverDelayTestSuite; ///< the test suite
+} g_lteHandoverDelayTestSuite;
diff -Naru a/test/test-lte-rrc.cc b/test/test-lte-rrc.cc
--- a/test/test-lte-rrc.cc	2017-10-05 11:46:52.230494031 +0200
+++ b/test/test-lte-rrc.cc	2017-10-05 11:47:22.314601784 +0200
@@ -30,12 +30,6 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteRrcTest");
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Test rrc connection establishment.
- */ 
 class LteRrcConnectionEstablishmentTestCase : public TestCase
 {
 public:
@@ -65,21 +59,8 @@
 protected:
 
   virtual void DoRun (void);
-  uint32_t m_nUes; ///< number of UEs in the test
+  uint32_t m_nUes; // number of UEs in the test
 
-  /**
-   * Build name string function
-   * 
-   * \param nUes number of UEs in the test
-   * \param nBearers number of bearers to be setup in each connection
-   * \param tConnBase connection time base value for all UEs in ms
-   * \param tConnIncrPerUe additional connection time increment for each UE index (0...nUes-1) in ms
-   * \param delayDiscStart expected duration to perform connection establishment in ms
-   * \param useIdealRrc If set to false, real RRC protocol model will be used
-   * \param admitRrcConnectionRequest If set to false, eNb will not allow UE connections
-   * \param description additional description of the test case
-   * \returns the name string
-   */
   static std::string BuildNameString (uint32_t nUes,
                                       uint32_t nBearers,
                                       uint32_t tConnBase,
@@ -88,55 +69,26 @@
                                       bool useIdealRrc,
                                       bool admitRrcConnectionRequest,
                                       std::string description = "");
-  /**
-   * Connect function
-   * \param ueDevice the UE device
-   * \param enbDevice the ENB device
-   */
   void Connect (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice);
-  /**
-   * Check connected function
-   * \param ueDevice the UE device
-   * \param enbDevice the ENB device
-   */
   void CheckConnected (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice);
-  /**
-   * Check not connected function
-   * \param ueDevice the UE device
-   * \param enbDevice the ENB device
-   */
   void CheckNotConnected (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice);
-  /**
-   * Connection established callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellId the cell ID
-   * \param rnti the RNTI
-   */
   void ConnectionEstablishedCallback (std::string context, uint64_t imsi,
                                       uint16_t cellId, uint16_t rnti);
-  /**
-   * Connection timeout callback function
-   * \param context the context string
-   * \param imsi the IMSI
-   * \param cellId the cell ID
-   * \param rnti the RNTI
-   */
   void ConnectionTimeoutCallback (std::string context, uint64_t imsi,
                                   uint16_t cellId, uint16_t rnti);
 
-  uint32_t m_nBearers; ///< number of bearers to be setup in each connection
-  uint32_t m_tConnBase;  ///< connection time base value for all UEs in ms
-  uint32_t m_tConnIncrPerUe; ///< additional connection time increment for each UE index (0...nUes-1) in ms
-  uint32_t m_delayConnEnd;  ///< expected duration to perform connection establishment in ms
-  uint32_t m_delayDiscStart;  ///< delay between connection completed and disconnection request in ms
-  uint32_t m_delayDiscEnd; ///< expected duration to complete disconnection in ms
-  bool     m_useIdealRrc; ///< If set to false, real RRC protocol model will be used
-  bool     m_admitRrcConnectionRequest; ///< If set to false, eNb will not allow UE connections
-  Ptr<LteHelper> m_lteHelper; ///< LTE helper
+  uint32_t m_nBearers; // number of bearers to be setup in each connection
+  uint32_t m_tConnBase;  // connection time base value for all UEs in ms
+  uint32_t m_tConnIncrPerUe; // additional connection time increment for each UE index (0...nUes-1) in ms
+  uint32_t m_delayConnEnd;  // expected duration to perform connection establishment in ms
+  uint32_t m_delayDiscStart;  // delay between connection completed and disconnection request in ms
+  uint32_t m_delayDiscEnd; // expected duration to complete disconnection in ms
+  bool     m_useIdealRrc; // If set to false, real RRC protocol model will be used
+  bool     m_admitRrcConnectionRequest; // If set to false, eNb will not allow UE connections
+  Ptr<LteHelper> m_lteHelper;
 
-  /// key: IMSI
-  std::map<uint64_t, bool> m_isConnectionEstablished; 
+  // key: IMSI
+  std::map<uint64_t, bool> m_isConnectionEstablished;
 };
 
 
@@ -541,12 +493,6 @@
 
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Lte Rrc Connection Establishment Error Test Case
- */ 
 class LteRrcConnectionEstablishmentErrorTestCase
   : public LteRrcConnectionEstablishmentTestCase
 {
@@ -564,13 +510,11 @@
   virtual void DoRun (void);
 
 private:
-  /// Jump away function
   void JumpAway ();
-  /// Jump back function
   void JumpBack ();
 
-  Time m_jumpAwayTime; ///< jump away time
-  Ptr<MobilityModel> m_ueMobility; ///< UE mobility model
+  Time m_jumpAwayTime;
+  Ptr<MobilityModel> m_ueMobility;
 };
 
 
@@ -728,12 +672,7 @@
 }
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Lte Rrc Test Suite
- */ 
+
 class LteRrcTestSuite : public TestSuite
 {
 public:
diff -Naru a/test/test-lte-x2-handover.cc b/test/test-lte-x2-handover.cc
--- a/test/test-lte-x2-handover.cc	2017-10-05 11:46:52.230494031 +0200
+++ b/test/test-lte-x2-handover.cc	2017-10-05 11:47:22.314601784 +0200
@@ -31,28 +31,15 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteX2HandoverTest");
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief HandoverEvent structure
- */ 
 struct HandoverEvent
 {
-  Time startTime; ///< start time
-  uint32_t ueDeviceIndex; ///< UE device index
-  uint32_t sourceEnbDeviceIndex; ///< source ENB device index
-  uint32_t targetEnbDeviceIndex; ///< target ENB device index
+  Time startTime;
+  uint32_t ueDeviceIndex;
+  uint32_t sourceEnbDeviceIndex;
+  uint32_t targetEnbDeviceIndex;
 };
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Test X2 Handover. In this test is used NoOpHandoverAlgorithm and 
- * the request for handover is generated mannually, and it is not based on measurements.
- */ 
 class LteX2HandoverTestCase : public TestCase
 {
 public:
@@ -65,89 +52,52 @@
    * \param handoverEventList 
    * \param handoverEventListName 
    * \param useUdp true if UDP is to be used, false if TCP is to be used
-   * \param schedulerType the scheduler type
-   * \param admitHo
-   * \param useIdealRrc true if the ideal RRC should be used 
+   * 
+   * \return 
    */
   LteX2HandoverTestCase (uint32_t nUes, uint32_t nDedicatedBearers, std::list<HandoverEvent> handoverEventList, std::string handoverEventListName, bool useUdp, std::string schedulerType, bool admitHo, bool useIdealRrc);
   
 private:
-  /**
-   * Build name string
-   * \param nUes number of UEs in the test
-   * \param nDedicatedBearers number of bearers to be activated per UE
-   * \param handoverEventListName 
-   * \param useUdp true if UDP is to be used, false if TCP is to be used
-   * \param schedulerType the scheduler type
-   * \param admitHo
-   * \param useIdealRrc true if the ideal RRC should be used 
-   * \returns the name string
-   */
   static std::string BuildNameString (uint32_t nUes, uint32_t nDedicatedBearers, std::string handoverEventListName, bool useUdp, std::string schedulerType, bool admitHo, bool useIdealRrc);
   virtual void DoRun (void);
-  /**
-   * Check connected function
-   * \param ueDevice the UE device
-   * \param enbDevice the ENB device
-   */
   void CheckConnected (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice);
 
-  uint32_t m_nUes; ///< number of UEs in the test
-  uint32_t m_nDedicatedBearers; ///< number of UEs in the test
-  std::list<HandoverEvent> m_handoverEventList; ///< handover event list
-  std::string m_handoverEventListName; ///< handover event list name
-  bool m_epc; ///< whether to use EPC
-  bool m_useUdp; ///< whether to use UDP traffic
-  std::string m_schedulerType; ///< scheduler type
-  bool m_admitHo; ///< whether to admit the handover request
-  bool     m_useIdealRrc; ///< whether to use the ideal RRC
-  Ptr<LteHelper> m_lteHelper; ///< LTE helper
-  Ptr<PointToPointEpcHelper> m_epcHelper; ///< EPC helper
+  uint32_t m_nUes; // number of UEs in the test
+  uint32_t m_nDedicatedBearers; // number of UEs in the test
+  std::list<HandoverEvent> m_handoverEventList;
+  std::string m_handoverEventListName;
+  bool m_epc;
+  bool m_useUdp;
+  std::string m_schedulerType;
+  bool m_admitHo;
+  bool     m_useIdealRrc;
+  Ptr<LteHelper> m_lteHelper;
+  Ptr<PointToPointEpcHelper> m_epcHelper;
   
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief BearerData structure
- */ 
   struct BearerData
   {
-    uint32_t bid; ///< BID
-    Ptr<PacketSink> dlSink; ///< DL sink
-    Ptr<PacketSink> ulSink; ///< UL sink
-    uint32_t dlOldTotalRx; ///< DL old total receive
-    uint32_t ulOldTotalRx; ///< UL old total receive
+    uint32_t bid;
+    Ptr<PacketSink> dlSink;
+    Ptr<PacketSink> ulSink;
+    uint32_t dlOldTotalRx;
+    uint32_t ulOldTotalRx;
   };
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief UeData structure
- */ 
   struct UeData
   {
-    uint32_t id; ///< ID
-    std::list<BearerData> bearerDataList; ///< bearer ID list
+    uint32_t id;
+    std::list<BearerData> bearerDataList;
   };
 
-/**
- * \brief Save stats after handover function
- * \param ueIndex the index of the UE
- */ 
   void SaveStatsAfterHandover (uint32_t ueIndex);
-/**
- * \brief Check stats a while after handover function
- * \param ueIndex the index of the UE
- */ 
   void CheckStatsAWhileAfterHandover (uint32_t ueIndex);
 
-  std::vector<UeData> m_ueDataVector; ///< UE data vector
+  std::vector<UeData> m_ueDataVector;
 
-  const Time m_maxHoDuration; ///< maximum HO duration
-  const Time m_statsDuration; ///< stats duration
-  const Time m_udpClientInterval; ///< UDP client interval
-  const uint32_t m_udpClientPktSize; ///< UDP client packet size
+  const Time m_maxHoDuration; 
+  const Time m_statsDuration;
+  const Time m_udpClientInterval;
+  const uint32_t m_udpClientPktSize;
 
 };
 
@@ -584,12 +534,6 @@
 }
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Lte X2 Handover Test Suite
- */ 
 class LteX2HandoverTestSuite : public TestSuite
 {
 public:
diff -Naru a/test/test-lte-x2-handover-measures.cc b/test/test-lte-x2-handover-measures.cc
--- a/test/test-lte-x2-handover-measures.cc	2017-10-05 11:46:52.230494031 +0200
+++ b/test/test-lte-x2-handover-measures.cc	2017-10-05 11:47:22.314601784 +0200
@@ -31,29 +31,14 @@
 
 NS_LOG_COMPONENT_DEFINE ("LteX2HandoverMeasuresTest");
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief CheckPointEvent structure
- */
 struct CheckPointEvent
 {
-  Time checkStartTime; ///< check start time
-  Time checkStopTime; ///< check stop time
-  Time checkInterval; ///< check interval
-  uint32_t ueDeviceIndex; ///< UE device index
-  uint32_t enbDeviceIndex; ///< ENB device index
+  Time checkStartTime;
+  Time checkStopTime;
+  Time checkInterval;
+  uint32_t ueDeviceIndex;
+  uint32_t enbDeviceIndex;
 
-  /**
-   *  Constructor
-   *
-   * \param start the start time
-   * \param stop the stop time
-   * \param interval the interval time
-   * \param ueIndex the UE index
-   * \param enbIndex the ENB index
-   */ 
   CheckPointEvent (Time start, Time stop, Time interval, uint32_t ueIndex, uint32_t enbIndex)
     : checkStartTime (start),
       checkStopTime (stop),
@@ -65,13 +50,6 @@
 };
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Test different X2 handover measures and algorithms, e.g. A2A4RsrqHandoverAlgorithm and 
- * A3RsrpHandoverAlgorithm. Test defines different handover parameters and scenario configurations.
- */
 class LteX2HandoverMeasuresTestCase : public TestCase
 {
 public:
@@ -99,90 +77,52 @@
                                  bool useIdealRrc);
 
 private:
-  /**
-   * Build name string
-   * \param nEnbs number of eNBs in the test
-   * \param nUes number of UEs in the test
-   * \param nDedicatedBearers number of bearers to be activated per UE
-   * \param checkPointEventListName 
-   * \param useUdp true if UDP is to be used, false if TCP is to be used
-   * \param schedulerType the scheduler type
-   * \param handoverAlgorithmType type of handover algorithm to be used (e.g. "ns3::A3RsrpHandoverAlgorithm")
-   * \param admitHo
-   * \param useIdealRrc true if the ideal RRC should be used 
-   * \returns the name string
-   */
   static std::string BuildNameString (uint32_t nEnbs, uint32_t nUes, uint32_t nDedicatedBearers,
                                       std::string checkPointEventListName,
                                       bool useUdp, std::string schedulerType,
                                       std::string handoverAlgorithmType, bool admitHo,
                                       bool useIdealRrc);
   virtual void DoRun (void);
-  /**
-   * Check connected function
-   * \param ueDevice the UE device
-   * \param enbDevice the ENB device
-   */
   void CheckConnected (Ptr<NetDevice> ueDevice, Ptr<NetDevice> enbDevice);
 
-  uint32_t m_nEnbs; ///< number of eNBs in the test
-  uint32_t m_nUes; ///< number of UEs in the test
-  uint32_t m_nDedicatedBearers; ///< number of UEs in the test
-  std::list<CheckPointEvent> m_checkPointEventList; ///< check point event list
-  std::string m_checkPointEventListName; ///< check point event list name
-  bool m_epc; ///< whether to use EPC
-  bool m_useUdp; ///<  whether to use UDP traffic
-  std::string m_schedulerType; ///< scheduler type
-  std::string m_handoverAlgorithmType; ///< handover algorithm type
-  bool m_admitHo; ///< whether to configure to admit handover
-  bool m_useIdealRrc; ///< whether to use ideal RRC
-  Ptr<LteHelper> m_lteHelper; ///< LTE helper
-  Ptr<PointToPointEpcHelper> m_epcHelper; ///< EPC helper
-
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief BearerData structure
- */ 
+  uint32_t m_nEnbs; // number of eNBs in the test
+  uint32_t m_nUes; // number of UEs in the test
+  uint32_t m_nDedicatedBearers; // number of UEs in the test
+  std::list<CheckPointEvent> m_checkPointEventList;
+  std::string m_checkPointEventListName;
+  bool m_epc;
+  bool m_useUdp;
+  std::string m_schedulerType;
+  std::string m_handoverAlgorithmType;
+  bool m_admitHo;
+  bool m_useIdealRrc;
+  Ptr<LteHelper> m_lteHelper;
+  Ptr<PointToPointEpcHelper> m_epcHelper;
+
   struct BearerData
   {
-    uint32_t bid; ///< BID
-    Ptr<PacketSink> dlSink; ///< DL sink
-    Ptr<PacketSink> ulSink; ///< UL sink
-    uint32_t dlOldTotalRx; ///< DL old total receive
-    uint32_t ulOldTotalRx; ///< UL old total receive
+    uint32_t bid;
+    Ptr<PacketSink> dlSink;
+    Ptr<PacketSink> ulSink;
+    uint32_t dlOldTotalRx;
+    uint32_t ulOldTotalRx;
   };
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief UeData structure
- */ 
   struct UeData
   {
-    uint32_t id; ///< ID
-    std::list<BearerData> bearerDataList; ///< bearer ID list
+    uint32_t id;
+    std::list<BearerData> bearerDataList;
   };
 
-  /**
-   * \brief Save stats  function
-   * \param ueIndex the index of the UE
-   */ 
   void SaveStats (uint32_t ueIndex);
-  /**
-   * \brief Check stats  function
-   * \param ueIndex the index of the UE
-   */ 
   void CheckStats (uint32_t ueIndex);
 
-  std::vector<UeData> m_ueDataVector; ///< UE data vector
+  std::vector<UeData> m_ueDataVector;
 
-  const Time m_maxHoDuration; ///< maximum HO duration
-  const Time m_statsDuration; ///< stats duration
-  const Time m_udpClientInterval; ///< UDP client interval
-  const uint32_t m_udpClientPktSize; ///< UDP client packet size
+  const Time m_maxHoDuration;
+  const Time m_statsDuration;
+  const Time m_udpClientInterval;
+  const uint32_t m_udpClientPktSize;
 };
 
 
@@ -691,12 +631,6 @@
 }
 
 
-/**
- * \ingroup lte-test
- * \ingroup tests
- *
- * \brief Lte X2 Handover Measures Test Suite
- */
 class LteX2HandoverMeasuresTestSuite : public TestSuite
 {
 public:
diff -Naru a/wscript b/wscript
--- a/wscript	2017-10-05 11:46:52.230494031 +0200
+++ b/wscript	2017-10-05 11:47:22.314601784 +0200
@@ -90,6 +90,7 @@
         'model/epc-x2-sap.cc',
         'model/epc-x2-header.cc',
         'model/epc-x2.cc',
+        'model/epc-x2-tag.cc',
         'model/epc-tft.cc',
         'model/epc-tft-classifier.cc',
         'model/lte-mi-error-model.cc',
@@ -97,6 +98,7 @@
         'model/epc-enb-s1-sap.cc',
         'model/epc-s1ap-sap.cc',
         'model/epc-s11-sap.cc',
+        'model/epc-s1ap.cc',
         'model/lte-as-sap.cc',
         'model/epc-ue-nas.cc',
         'model/lte-harq-phy.cc',
@@ -121,17 +123,13 @@
         'model/lte-ffr-enhanced-algorithm.cc',
         'model/lte-ffr-distributed-algorithm.cc',
         'model/lte-ue-power-control.cc',
-        'model/lte-ccm-rrc-sap.cc',
-        'model/lte-ue-ccm-rrc-sap.cc', 
-        'model/lte-ccm-mac-sap.cc', 
-        'model/lte-enb-component-carrier-manager.cc',
-        'model/lte-ue-component-carrier-manager.cc',
-        'model/no-op-component-carrier-manager.cc',
-        'model/simple-ue-component-carrier-manager.cc',
-        'model/component-carrier.cc',
-        'helper/cc-helper.cc',
-        'model/component-carrier-ue.cc',
-        'model/component-carrier-enb.cc'
+        'model/lte-rlc-um-lowlat.cc',
+        'model/epc-mme-application.cc',
+        'model/epc-s1ap-header.cc',
+        'model/mc-enb-pdcp.cc',
+        'model/mc-ue-pdcp.cc', 
+        'helper/retx-stats-calculator.cc',
+        'helper/mac-tx-stats-calculator.cc'
         ]
 
     module_test = bld.create_ns3_module_test_library('lte')
@@ -178,7 +176,6 @@
         'test/test-asn1-encoding.cc',
         'test/lte-test-ue-measurements.cc',
         'test/lte-test-cell-selection.cc',
-        'test/lte-test-secondary-cell-selection.cc',
         'test/test-lte-handover-delay.cc',
         'test/test-lte-handover-target.cc',
         'test/lte-test-deactivate-bearer.cc',
@@ -189,8 +186,6 @@
         'test/lte-test-interference-fr.cc',
         'test/lte-test-cqi-generation.cc',
         'test/lte-simple-spectrum-phy.cc',
-        'test/lte-test-carrier-aggregation.cc',
-        'test/lte-test-aggregation-throughput-scale.cc',
         ]
 
     headers = bld(features='ns3header')
@@ -280,12 +275,15 @@
         'model/epc-x2-sap.h',
         'model/epc-x2-header.h',
         'model/epc-x2.h',
+        'model/epc-x2-tag.h',
         'model/epc-tft.h',
         'model/epc-tft-classifier.h',
         'model/lte-mi-error-model.h',
         'model/epc-enb-s1-sap.h',
         'model/epc-s1ap-sap.h',
         'model/epc-s11-sap.h',
+        'model/epc-s1ap.h',
+        'model/epc-mme-application.h',
         'model/lte-as-sap.h',
         'model/epc-ue-nas.h',
         'model/lte-harq-phy.h',
@@ -308,19 +306,14 @@
         'model/lte-fr-soft-algorithm.h',
         'model/lte-ffr-soft-algorithm.h',
         'model/lte-ffr-enhanced-algorithm.h',
-        'model/lte-ffr-distributed-algorithm.h',
-        'model/lte-ue-power-control.h',
-        'model/lte-ccm-rrc-sap.h',
-        'model/lte-ue-ccm-rrc-sap.h', 
-        'model/lte-ccm-mac-sap.h', 
-        'model/lte-enb-component-carrier-manager.h',
-        'model/lte-ue-component-carrier-manager.h',
-        'model/no-op-component-carrier-manager.h',
-        'model/simple-ue-component-carrier-manager.h',
-        'helper/cc-helper.h',
-        'model/component-carrier.h',
-        'model/component-carrier-ue.h',
-        'model/component-carrier-enb.h'
+        'model/lte-ffr-distributed-algorithm.h',     
+		'model/lte-ue-power-control.h',     
+		'model/lte-rlc-um-lowlat.h', 
+        'model/epc-s1ap-header.h',
+        'model/mc-enb-pdcp.h',
+        'model/mc-ue-pdcp.h',     
+        'helper/retx-stats-calculator.h',
+        'helper/mac-tx-stats-calculator.h'
         ]
 
     if (bld.env['ENABLE_EMU']):
